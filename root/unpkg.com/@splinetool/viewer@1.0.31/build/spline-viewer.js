var Lw = Object.defineProperty;
var xO = Object.getOwnPropertyDescriptor;
var Ml = ((e) =>
  typeof require < "u"
    ? require
    : typeof Proxy < "u"
    ? new Proxy(e, { get: (t, i) => (typeof require < "u" ? require : t)[i] })
    : e)(function (e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var bO = (e, t) => () => (e && (t = e((e = 0))), t);
var wO = (e, t) => {
  for (var i in t) Lw(e, i, { get: t[i], enumerable: !0 });
};
var la = (e, t, i, r) => {
  for (
    var s = r > 1 ? void 0 : r ? xO(t, i) : t, a = e.length - 1, n;
    a >= 0;
    a--
  )
    (n = e[a]) && (s = (r ? n(t, i, s) : n(s)) || s);
  return r && s && Lw(t, i, s), s;
};
var zw = {};
wO(zw, { default: () => AO });
var Bw,
  _O,
  SO,
  AO,
  Fw = bO(() => {
    "use strict";
    (Bw = ((e) =>
      typeof Ml < "u"
        ? Ml
        : typeof Proxy < "u"
        ? new Proxy(e, { get: (t, i) => (typeof Ml < "u" ? Ml : t)[i] })
        : e)(function (e) {
      if (typeof Ml < "u") return Ml.apply(this, arguments);
      throw new Error('Dynamic require of "' + e + '" is not supported');
    })),
      (_O = (e, t) => () => (
        t || e((t = { exports: {} }).exports, t), t.exports
      )),
      (SO = _O((e, t) => {
        var i = (() => {
          var r =
            typeof document < "u" && document.currentScript
              ? document.currentScript.src
              : void 0;
          return (
            typeof __filename < "u" && (r = r || __filename),
            function (s = {}) {
              var a = s,
                n,
                o;
              (a.ready = new Promise((v, w) => {
                (n = v), (o = w);
              })),
                (function (v) {
                  (v.Id = v.Id || []),
                    v.Id.push(function () {
                      (v.MakeSWCanvasSurface = function (w) {
                        var E = w,
                          O =
                            typeof OffscreenCanvas < "u" &&
                            E instanceof OffscreenCanvas;
                        if (
                          !(
                            (typeof HTMLCanvasElement < "u" &&
                              E instanceof HTMLCanvasElement) ||
                            O ||
                            ((E = document.getElementById(w)), E)
                          )
                        )
                          throw "Canvas with id " + w + " was not found";
                        return (
                          (w = v.MakeSurface(E.width, E.height)) && (w.ie = E),
                          w
                        );
                      }),
                        v.MakeCanvasSurface ||
                          (v.MakeCanvasSurface = v.MakeSWCanvasSurface),
                        (v.MakeSurface = function (w, E) {
                          var O = {
                              width: w,
                              height: E,
                              colorType: v.ColorType.RGBA_8888,
                              alphaType: v.AlphaType.Unpremul,
                              colorSpace: v.ColorSpace.SRGB,
                            },
                            B = w * E * 4,
                            j = v._malloc(B);
                          return (
                            (O = v.Surface._makeRasterDirect(O, j, 4 * w)) &&
                              ((O.ie = null),
                              (O.Pe = w),
                              (O.Me = E),
                              (O.Ne = B),
                              (O.re = j),
                              O.getCanvas().clear(v.TRANSPARENT)),
                            O
                          );
                        }),
                        (v.MakeRasterDirectSurface = function (w, E, O) {
                          return v.Surface._makeRasterDirect(
                            w,
                            E.byteOffset,
                            O
                          );
                        }),
                        (v.Surface.prototype.flush = function (w) {
                          if ((v.Fd(this.Ed), this._flush(), this.ie)) {
                            var E = new Uint8ClampedArray(
                              v.HEAPU8.buffer,
                              this.re,
                              this.Ne
                            );
                            (E = new ImageData(E, this.Pe, this.Me)),
                              w
                                ? this.ie
                                    .getContext("2d")
                                    .putImageData(
                                      E,
                                      0,
                                      0,
                                      w[0],
                                      w[1],
                                      w[2] - w[0],
                                      w[3] - w[1]
                                    )
                                : this.ie
                                    .getContext("2d")
                                    .putImageData(E, 0, 0);
                          }
                        }),
                        (v.Surface.prototype.dispose = function () {
                          this.re && v._free(this.re), this.delete();
                        }),
                        (v.Fd = v.Fd || function () {}),
                        (v.je =
                          v.je ||
                          function () {
                            return null;
                          });
                    });
                })(a),
                (function (v) {
                  (v.Id = v.Id || []),
                    v.Id.push(function () {
                      function w(K, le, Ie) {
                        return K && K.hasOwnProperty(le) ? K[le] : Ie;
                      }
                      function E(K) {
                        var le = Dh(sa);
                        return (sa[le] = K), le;
                      }
                      function O(K) {
                        return (
                          K.naturalHeight ||
                          K.videoHeight ||
                          K.displayHeight ||
                          K.height
                        );
                      }
                      function B(K) {
                        return (
                          K.naturalWidth ||
                          K.videoWidth ||
                          K.displayWidth ||
                          K.width
                        );
                      }
                      function j(K, le, Ie, Ne) {
                        return (
                          K.bindTexture(K.TEXTURE_2D, le),
                          Ne ||
                            Ie.alphaType !== v.AlphaType.Premul ||
                            K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                          le
                        );
                      }
                      function Q(K, le, Ie) {
                        Ie ||
                          le.alphaType !== v.AlphaType.Premul ||
                          K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                          K.bindTexture(K.TEXTURE_2D, null);
                      }
                      (v.GetWebGLContext = function (K, le) {
                        if (!K)
                          throw "null canvas passed into makeWebGLContext";
                        var Ie = {
                          alpha: w(le, "alpha", 1),
                          depth: w(le, "depth", 1),
                          stencil: w(le, "stencil", 8),
                          antialias: w(le, "antialias", 0),
                          premultipliedAlpha: w(le, "premultipliedAlpha", 1),
                          preserveDrawingBuffer: w(
                            le,
                            "preserveDrawingBuffer",
                            0
                          ),
                          preferLowPowerToHighPerformance: w(
                            le,
                            "preferLowPowerToHighPerformance",
                            0
                          ),
                          failIfMajorPerformanceCaveat: w(
                            le,
                            "failIfMajorPerformanceCaveat",
                            0
                          ),
                          enableExtensionsByDefault: w(
                            le,
                            "enableExtensionsByDefault",
                            1
                          ),
                          explicitSwapControl: w(le, "explicitSwapControl", 0),
                          renderViaOffscreenBackBuffer: w(
                            le,
                            "renderViaOffscreenBackBuffer",
                            0
                          ),
                        };
                        if (
                          ((Ie.majorVersion =
                            le && le.majorVersion
                              ? le.majorVersion
                              : typeof WebGL2RenderingContext < "u"
                              ? 2
                              : 1),
                          Ie.explicitSwapControl)
                        )
                          throw "explicitSwapControl is not supported";
                        return (
                          (K = JD(K, Ie)),
                          K
                            ? (fw(K),
                              Kt.Qd.getExtension("WEBGL_debug_renderer_info"),
                              K)
                            : 0
                        );
                      }),
                        (v.deleteContext = function (K) {
                          Kt === rn[K] && (Kt = null),
                            typeof JSEvents == "object" &&
                              JSEvents.tf(rn[K].Qd.canvas),
                            rn[K] &&
                              rn[K].Qd.canvas &&
                              (rn[K].Qd.canvas.Ke = void 0),
                            (rn[K] = null);
                        }),
                        v._setTextureCleanup({
                          deleteTexture: function (K, le) {
                            var Ie = sa[le];
                            Ie && rn[K].Qd.deleteTexture(Ie), (sa[le] = null);
                          },
                        }),
                        (v.MakeWebGLContext = function (K) {
                          if (!this.Fd(K)) return null;
                          var le = this._MakeGrContext();
                          if (!le) return null;
                          le.Ed = K;
                          var Ie = le.delete.bind(le);
                          return (
                            (le.delete = function () {
                              v.Fd(this.Ed), Ie();
                            }.bind(le)),
                            (Kt.te = le)
                          );
                        }),
                        (v.MakeGrContext = v.MakeWebGLContext),
                        (v.GrDirectContext.prototype.getResourceCacheLimitBytes =
                          function () {
                            v.Fd(this.Ed), this._getResourceCacheLimitBytes();
                          }),
                        (v.GrDirectContext.prototype.getResourceCacheUsageBytes =
                          function () {
                            v.Fd(this.Ed), this._getResourceCacheUsageBytes();
                          }),
                        (v.GrDirectContext.prototype.releaseResourcesAndAbandonContext =
                          function () {
                            v.Fd(this.Ed),
                              this._releaseResourcesAndAbandonContext();
                          }),
                        (v.GrDirectContext.prototype.setResourceCacheLimitBytes =
                          function (K) {
                            v.Fd(this.Ed), this._setResourceCacheLimitBytes(K);
                          }),
                        (v.MakeOnScreenGLSurface = function (
                          K,
                          le,
                          Ie,
                          Ne,
                          $e,
                          ft
                        ) {
                          return !this.Fd(K.Ed) ||
                            ((le =
                              $e === void 0 || ft === void 0
                                ? this._MakeOnScreenGLSurface(K, le, Ie, Ne)
                                : this._MakeOnScreenGLSurface(
                                    K,
                                    le,
                                    Ie,
                                    Ne,
                                    $e,
                                    ft
                                  )),
                            !le)
                            ? null
                            : ((le.Ed = K.Ed), le);
                        }),
                        (v.MakeRenderTarget = function () {
                          var K = arguments[0];
                          if (!this.Fd(K.Ed)) return null;
                          if (arguments.length === 3) {
                            var le = this._MakeRenderTargetWH(
                              K,
                              arguments[1],
                              arguments[2]
                            );
                            if (!le) return null;
                          } else if (arguments.length === 2) {
                            if (
                              ((le = this._MakeRenderTargetII(K, arguments[1])),
                              !le)
                            )
                              return null;
                          } else return null;
                          return (le.Ed = K.Ed), le;
                        }),
                        (v.MakeWebGLCanvasSurface = function (K, le, Ie) {
                          le = le || null;
                          var Ne = K,
                            $e =
                              typeof OffscreenCanvas < "u" &&
                              Ne instanceof OffscreenCanvas;
                          if (
                            !(
                              (typeof HTMLCanvasElement < "u" &&
                                Ne instanceof HTMLCanvasElement) ||
                              $e ||
                              ((Ne = document.getElementById(K)), Ne)
                            )
                          )
                            throw "Canvas with id " + K + " was not found";
                          if (((K = this.GetWebGLContext(Ne, Ie)), !K || 0 > K))
                            throw "failed to create webgl context: err " + K;
                          return (
                            (K = this.MakeWebGLContext(K)),
                            (le = this.MakeOnScreenGLSurface(
                              K,
                              Ne.width,
                              Ne.height,
                              le
                            )),
                            le ||
                              ((le = Ne.cloneNode(!0)),
                              Ne.parentNode.replaceChild(le, Ne),
                              le.classList.add("ck-replaced"),
                              v.MakeSWCanvasSurface(le))
                          );
                        }),
                        (v.MakeCanvasSurface = v.MakeWebGLCanvasSurface),
                        (v.Surface.prototype.makeImageFromTexture = function (
                          K,
                          le
                        ) {
                          return (
                            v.Fd(this.Ed),
                            (K = E(K)),
                            (le = this._makeImageFromTexture(this.Ed, K, le)) &&
                              (le.de = K),
                            le
                          );
                        }),
                        (v.Surface.prototype.makeImageFromTextureSource =
                          function (K, le, Ie) {
                            le ||
                              (le = {
                                height: O(K),
                                width: B(K),
                                colorType: v.ColorType.RGBA_8888,
                                alphaType: Ie
                                  ? v.AlphaType.Premul
                                  : v.AlphaType.Unpremul,
                              }),
                              le.colorSpace ||
                                (le.colorSpace = v.ColorSpace.SRGB),
                              v.Fd(this.Ed);
                            var Ne = Kt.Qd;
                            return (
                              (Ie = j(Ne, Ne.createTexture(), le, Ie)),
                              Kt.version === 2
                                ? Ne.texImage2D(
                                    Ne.TEXTURE_2D,
                                    0,
                                    Ne.RGBA,
                                    le.width,
                                    le.height,
                                    0,
                                    Ne.RGBA,
                                    Ne.UNSIGNED_BYTE,
                                    K
                                  )
                                : Ne.texImage2D(
                                    Ne.TEXTURE_2D,
                                    0,
                                    Ne.RGBA,
                                    Ne.RGBA,
                                    Ne.UNSIGNED_BYTE,
                                    K
                                  ),
                              Q(Ne, le),
                              this._resetContext(),
                              this.makeImageFromTexture(Ie, le)
                            );
                          }),
                        (v.Surface.prototype.updateTextureFromSource =
                          function (K, le, Ie) {
                            if (K.de) {
                              v.Fd(this.Ed);
                              var Ne = K.getImageInfo(),
                                $e = Kt.Qd,
                                ft = j($e, sa[K.de], Ne, Ie);
                              Kt.version === 2
                                ? $e.texImage2D(
                                    $e.TEXTURE_2D,
                                    0,
                                    $e.RGBA,
                                    B(le),
                                    O(le),
                                    0,
                                    $e.RGBA,
                                    $e.UNSIGNED_BYTE,
                                    le
                                  )
                                : $e.texImage2D(
                                    $e.TEXTURE_2D,
                                    0,
                                    $e.RGBA,
                                    $e.RGBA,
                                    $e.UNSIGNED_BYTE,
                                    le
                                  ),
                                Q($e, Ne, Ie),
                                this._resetContext(),
                                (sa[K.de] = null),
                                (K.de = E(ft)),
                                (Ne.colorSpace = K.getColorSpace()),
                                (le = this._makeImageFromTexture(
                                  this.Ed,
                                  K.de,
                                  Ne
                                )),
                                (Ie = K.Dd.Hd),
                                ($e = K.Dd.Ld),
                                (K.Dd.Hd = le.Dd.Hd),
                                (K.Dd.Ld = le.Dd.Ld),
                                (le.Dd.Hd = Ie),
                                (le.Dd.Ld = $e),
                                le.delete(),
                                Ne.colorSpace.delete();
                            }
                          }),
                        (v.MakeLazyImageFromTextureSource = function (
                          K,
                          le,
                          Ie
                        ) {
                          le ||
                            (le = {
                              height: O(K),
                              width: B(K),
                              colorType: v.ColorType.RGBA_8888,
                              alphaType: Ie
                                ? v.AlphaType.Premul
                                : v.AlphaType.Unpremul,
                            }),
                            le.colorSpace ||
                              (le.colorSpace = v.ColorSpace.SRGB);
                          var Ne = {
                            makeTexture: function () {
                              var $e = Kt,
                                ft = $e.Qd,
                                xe = j(ft, ft.createTexture(), le, Ie);
                              return (
                                $e.version === 2
                                  ? ft.texImage2D(
                                      ft.TEXTURE_2D,
                                      0,
                                      ft.RGBA,
                                      le.width,
                                      le.height,
                                      0,
                                      ft.RGBA,
                                      ft.UNSIGNED_BYTE,
                                      K
                                    )
                                  : ft.texImage2D(
                                      ft.TEXTURE_2D,
                                      0,
                                      ft.RGBA,
                                      ft.RGBA,
                                      ft.UNSIGNED_BYTE,
                                      K
                                    ),
                                Q(ft, le, Ie),
                                E(xe)
                              );
                            },
                            freeSrc: function () {},
                          };
                          return (
                            K.constructor.name === "VideoFrame" &&
                              (Ne.freeSrc = function () {
                                K.close();
                              }),
                            v.Image._makeFromGenerator(le, Ne)
                          );
                        }),
                        (v.Fd = function (K) {
                          return K ? fw(K) : !1;
                        }),
                        (v.je = function () {
                          return Kt && Kt.te && !Kt.te.isDeleted()
                            ? Kt.te
                            : null;
                        });
                    });
                })(a),
                (function (v) {
                  function w(F) {
                    return (
                      ((B(255 * F[3]) << 24) |
                        (B(255 * F[0]) << 16) |
                        (B(255 * F[1]) << 8) |
                        (B(255 * F[2]) << 0)) >>>
                      0
                    );
                  }
                  function E(F) {
                    if (F && F._ck) return F;
                    if (F instanceof Float32Array) {
                      for (
                        var D = Math.floor(F.length / 4),
                          U = new Uint32Array(D),
                          J = 0;
                        J < D;
                        J++
                      )
                        U[J] = w(F.slice(4 * J, 4 * (J + 1)));
                      return U;
                    }
                    if (F instanceof Uint32Array) return F;
                    if (F instanceof Array && F[0] instanceof Float32Array)
                      return F.map(w);
                  }
                  function O(F) {
                    if (F === void 0) return 1;
                    var D = parseFloat(F);
                    return F && F.indexOf("%") !== -1 ? D / 100 : D;
                  }
                  function B(F) {
                    return Math.round(Math.max(0, Math.min(F || 0, 255)));
                  }
                  function j(F, D) {
                    (D && D._ck) || v._free(F);
                  }
                  function Q(F, D, U) {
                    if (!F || !F.length) return ai;
                    if (F && F._ck) return F.byteOffset;
                    var J = v[D].BYTES_PER_ELEMENT;
                    return (
                      U || (U = v._malloc(F.length * J)), v[D].set(F, U / J), U
                    );
                  }
                  function K(F) {
                    var D = {
                      Nd: ai,
                      count: F.length,
                      colorType: v.ColorType.RGBA_F32,
                    };
                    if (F instanceof Float32Array)
                      (D.Nd = Q(F, "HEAPF32")), (D.count = F.length / 4);
                    else if (F instanceof Uint32Array)
                      (D.Nd = Q(F, "HEAPU32")),
                        (D.colorType = v.ColorType.RGBA_8888);
                    else if (F instanceof Array) {
                      if (F && F.length) {
                        for (
                          var U = v._malloc(16 * F.length),
                            J = 0,
                            fe = U / 4,
                            Pe = 0;
                          Pe < F.length;
                          Pe++
                        )
                          for (var He = 0; 4 > He; He++)
                            (v.HEAPF32[fe + J] = F[Pe][He]), J++;
                        F = U;
                      } else F = ai;
                      D.Nd = F;
                    } else
                      throw (
                        "Invalid argument to copyFlexibleColorArray, Not a color array " +
                        typeof F
                      );
                    return D;
                  }
                  function le(F) {
                    if (!F) return ai;
                    var D = Hi.toTypedArray();
                    if (F.length) {
                      if (F.length === 6 || F.length === 9)
                        return (
                          Q(F, "HEAPF32", Ut),
                          F.length === 6 && v.HEAPF32.set(yO, 6 + Ut / 4),
                          Ut
                        );
                      if (F.length === 16)
                        return (
                          (D[0] = F[0]),
                          (D[1] = F[1]),
                          (D[2] = F[3]),
                          (D[3] = F[4]),
                          (D[4] = F[5]),
                          (D[5] = F[7]),
                          (D[6] = F[12]),
                          (D[7] = F[13]),
                          (D[8] = F[15]),
                          Ut
                        );
                      throw "invalid matrix size";
                    }
                    if (F.m11 === void 0) throw "invalid matrix argument";
                    return (
                      (D[0] = F.m11),
                      (D[1] = F.m21),
                      (D[2] = F.m41),
                      (D[3] = F.m12),
                      (D[4] = F.m22),
                      (D[5] = F.m42),
                      (D[6] = F.m14),
                      (D[7] = F.m24),
                      (D[8] = F.m44),
                      Ut
                    );
                  }
                  function Ie(F) {
                    if (!F) return ai;
                    var D = Fr.toTypedArray();
                    if (F.length) {
                      if (F.length !== 16 && F.length !== 6 && F.length !== 9)
                        throw "invalid matrix size";
                      return F.length === 16
                        ? Q(F, "HEAPF32", bs)
                        : (D.fill(0),
                          (D[0] = F[0]),
                          (D[1] = F[1]),
                          (D[3] = F[2]),
                          (D[4] = F[3]),
                          (D[5] = F[4]),
                          (D[7] = F[5]),
                          (D[10] = 1),
                          (D[12] = F[6]),
                          (D[13] = F[7]),
                          (D[15] = F[8]),
                          F.length === 6 &&
                            ((D[12] = 0), (D[13] = 0), (D[15] = 1)),
                          bs);
                    }
                    if (F.m11 === void 0) throw "invalid matrix argument";
                    return (
                      (D[0] = F.m11),
                      (D[1] = F.m21),
                      (D[2] = F.m31),
                      (D[3] = F.m41),
                      (D[4] = F.m12),
                      (D[5] = F.m22),
                      (D[6] = F.m32),
                      (D[7] = F.m42),
                      (D[8] = F.m13),
                      (D[9] = F.m23),
                      (D[10] = F.m33),
                      (D[11] = F.m43),
                      (D[12] = F.m14),
                      (D[13] = F.m24),
                      (D[14] = F.m34),
                      (D[15] = F.m44),
                      bs
                    );
                  }
                  function Ne(F, D) {
                    return Q(F, "HEAPF32", D || sn);
                  }
                  function $e(F, D, U, J) {
                    var fe = Ih.toTypedArray();
                    return (
                      (fe[0] = F), (fe[1] = D), (fe[2] = U), (fe[3] = J), sn
                    );
                  }
                  function ft(F) {
                    for (var D = new Float32Array(4), U = 0; 4 > U; U++)
                      D[U] = v.HEAPF32[F / 4 + U];
                    return D;
                  }
                  function xe(F, D) {
                    return Q(F, "HEAPF32", D || Cr);
                  }
                  function vt(F, D) {
                    return Q(F, "HEAPF32", D || iv);
                  }
                  (v.Color = function (F, D, U, J) {
                    return (
                      J === void 0 && (J = 1),
                      v.Color4f(B(F) / 255, B(D) / 255, B(U) / 255, J)
                    );
                  }),
                    (v.ColorAsInt = function (F, D, U, J) {
                      return (
                        J === void 0 && (J = 255),
                        ((B(J) << 24) |
                          (B(F) << 16) |
                          (B(D) << 8) |
                          ((B(U) << 0) & 268435455)) >>>
                          0
                      );
                    }),
                    (v.Color4f = function (F, D, U, J) {
                      return (
                        J === void 0 && (J = 1), Float32Array.of(F, D, U, J)
                      );
                    }),
                    Object.defineProperty(v, "TRANSPARENT", {
                      get: function () {
                        return v.Color4f(0, 0, 0, 0);
                      },
                    }),
                    Object.defineProperty(v, "BLACK", {
                      get: function () {
                        return v.Color4f(0, 0, 0, 1);
                      },
                    }),
                    Object.defineProperty(v, "WHITE", {
                      get: function () {
                        return v.Color4f(1, 1, 1, 1);
                      },
                    }),
                    Object.defineProperty(v, "RED", {
                      get: function () {
                        return v.Color4f(1, 0, 0, 1);
                      },
                    }),
                    Object.defineProperty(v, "GREEN", {
                      get: function () {
                        return v.Color4f(0, 1, 0, 1);
                      },
                    }),
                    Object.defineProperty(v, "BLUE", {
                      get: function () {
                        return v.Color4f(0, 0, 1, 1);
                      },
                    }),
                    Object.defineProperty(v, "YELLOW", {
                      get: function () {
                        return v.Color4f(1, 1, 0, 1);
                      },
                    }),
                    Object.defineProperty(v, "CYAN", {
                      get: function () {
                        return v.Color4f(0, 1, 1, 1);
                      },
                    }),
                    Object.defineProperty(v, "MAGENTA", {
                      get: function () {
                        return v.Color4f(1, 0, 1, 1);
                      },
                    }),
                    (v.getColorComponents = function (F) {
                      return [
                        Math.floor(255 * F[0]),
                        Math.floor(255 * F[1]),
                        Math.floor(255 * F[2]),
                        F[3],
                      ];
                    }),
                    (v.parseColorString = function (F, D) {
                      if (((F = F.toLowerCase()), F.startsWith("#"))) {
                        switch (((D = 255), F.length)) {
                          case 9:
                            D = parseInt(F.slice(7, 9), 16);
                          case 7:
                            var U = parseInt(F.slice(1, 3), 16),
                              J = parseInt(F.slice(3, 5), 16),
                              fe = parseInt(F.slice(5, 7), 16);
                            break;
                          case 5:
                            D = 17 * parseInt(F.slice(4, 5), 16);
                          case 4:
                            (U = 17 * parseInt(F.slice(1, 2), 16)),
                              (J = 17 * parseInt(F.slice(2, 3), 16)),
                              (fe = 17 * parseInt(F.slice(3, 4), 16));
                        }
                        return v.Color(U, J, fe, D / 255);
                      }
                      return F.startsWith("rgba")
                        ? ((F = F.slice(5, -1)),
                          (F = F.split(",")),
                          v.Color(+F[0], +F[1], +F[2], O(F[3])))
                        : F.startsWith("rgb")
                        ? ((F = F.slice(4, -1)),
                          (F = F.split(",")),
                          v.Color(+F[0], +F[1], +F[2], O(F[3])))
                        : F.startsWith("gray(") ||
                          F.startsWith("hsl") ||
                          !D ||
                          ((F = D[F]), F === void 0)
                        ? v.BLACK
                        : F;
                    }),
                    (v.multiplyByAlpha = function (F, D) {
                      return (
                        (F = F.slice()),
                        (F[3] = Math.max(0, Math.min(F[3] * D, 1))),
                        F
                      );
                    }),
                    (v.Malloc = function (F, D) {
                      var U = v._malloc(D * F.BYTES_PER_ELEMENT);
                      return {
                        _ck: !0,
                        length: D,
                        byteOffset: U,
                        Xd: null,
                        subarray: function (J, fe) {
                          return (
                            (J = this.toTypedArray().subarray(J, fe)),
                            (J._ck = !0),
                            J
                          );
                        },
                        toTypedArray: function () {
                          return this.Xd && this.Xd.length
                            ? this.Xd
                            : ((this.Xd = new F(v.HEAPU8.buffer, U, D)),
                              (this.Xd._ck = !0),
                              this.Xd);
                        },
                      };
                    }),
                    (v.Free = function (F) {
                      v._free(F.byteOffset),
                        (F.byteOffset = ai),
                        (F.toTypedArray = null),
                        (F.Xd = null);
                    });
                  var Ut = ai,
                    Hi,
                    bs = ai,
                    Fr,
                    sn = ai,
                    Ih,
                    Oa,
                    Cr = ai,
                    Cw,
                    Io = ai,
                    Tw,
                    ev = ai,
                    Pw,
                    tv = ai,
                    Ip,
                    Ou = ai,
                    Dw,
                    iv = ai,
                    Ow,
                    Iw = ai,
                    yO = Float32Array.of(0, 0, 1),
                    ai = 0;
                  (v.onRuntimeInitialized = function () {
                    function F(D, U, J, fe, Pe, He, mt) {
                      He ||
                        ((He = 4 * fe.width),
                        fe.colorType === v.ColorType.RGBA_F16
                          ? (He *= 2)
                          : fe.colorType === v.ColorType.RGBA_F32 && (He *= 4));
                      var Xt = He * fe.height,
                        Ht = Pe ? Pe.byteOffset : v._malloc(Xt);
                      if (
                        mt
                          ? !D._readPixels(fe, Ht, He, U, J, mt)
                          : !D._readPixels(fe, Ht, He, U, J)
                      )
                        return Pe || v._free(Ht), null;
                      if (Pe) return Pe.toTypedArray();
                      switch (fe.colorType) {
                        case v.ColorType.RGBA_8888:
                        case v.ColorType.RGBA_F16:
                          D = new Uint8Array(v.HEAPU8.buffer, Ht, Xt).slice();
                          break;
                        case v.ColorType.RGBA_F32:
                          D = new Float32Array(v.HEAPU8.buffer, Ht, Xt).slice();
                          break;
                        default:
                          return null;
                      }
                      return v._free(Ht), D;
                    }
                    (Ih = v.Malloc(Float32Array, 4)),
                      (sn = Ih.byteOffset),
                      (Fr = v.Malloc(Float32Array, 16)),
                      (bs = Fr.byteOffset),
                      (Hi = v.Malloc(Float32Array, 9)),
                      (Ut = Hi.byteOffset),
                      (Dw = v.Malloc(Float32Array, 12)),
                      (iv = Dw.byteOffset),
                      (Ow = v.Malloc(Float32Array, 12)),
                      (Iw = Ow.byteOffset),
                      (Oa = v.Malloc(Float32Array, 4)),
                      (Cr = Oa.byteOffset),
                      (Cw = v.Malloc(Float32Array, 4)),
                      (Io = Cw.byteOffset),
                      (Tw = v.Malloc(Float32Array, 3)),
                      (ev = Tw.byteOffset),
                      (Pw = v.Malloc(Float32Array, 3)),
                      (tv = Pw.byteOffset),
                      (Ip = v.Malloc(Int32Array, 4)),
                      (Ou = Ip.byteOffset),
                      (v.ColorSpace.SRGB = v.ColorSpace._MakeSRGB()),
                      (v.ColorSpace.DISPLAY_P3 = v.ColorSpace._MakeDisplayP3()),
                      (v.ColorSpace.ADOBE_RGB = v.ColorSpace._MakeAdobeRGB()),
                      (v.GlyphRunFlags = {
                        IsWhiteSpace: v._GlyphRunFlags_isWhiteSpace,
                      }),
                      (v.Path.MakeFromCmds = function (D) {
                        var U = Q(D, "HEAPF32"),
                          J = v.Path._MakeFromCmds(U, D.length);
                        return j(U, D), J;
                      }),
                      (v.Path.MakeFromVerbsPointsWeights = function (D, U, J) {
                        var fe = Q(D, "HEAPU8"),
                          Pe = Q(U, "HEAPF32"),
                          He = Q(J, "HEAPF32"),
                          mt = v.Path._MakeFromVerbsPointsWeights(
                            fe,
                            D.length,
                            Pe,
                            U.length,
                            He,
                            (J && J.length) || 0
                          );
                        return j(fe, D), j(Pe, U), j(He, J), mt;
                      }),
                      (v.Path.prototype.addArc = function (D, U, J) {
                        return (D = xe(D)), this._addArc(D, U, J), this;
                      }),
                      (v.Path.prototype.addCircle = function (D, U, J, fe) {
                        return this._addCircle(D, U, J, !!fe), this;
                      }),
                      (v.Path.prototype.addOval = function (D, U, J) {
                        return (
                          J === void 0 && (J = 1),
                          (D = xe(D)),
                          this._addOval(D, !!U, J),
                          this
                        );
                      }),
                      (v.Path.prototype.addPath = function () {
                        var D = Array.prototype.slice.call(arguments),
                          U = D[0],
                          J = !1;
                        if (
                          (typeof D[D.length - 1] == "boolean" && (J = D.pop()),
                          D.length === 1)
                        )
                          this._addPath(U, 1, 0, 0, 0, 1, 0, 0, 0, 1, J);
                        else if (D.length === 2)
                          (D = D[1]),
                            this._addPath(
                              U,
                              D[0],
                              D[1],
                              D[2],
                              D[3],
                              D[4],
                              D[5],
                              D[6] || 0,
                              D[7] || 0,
                              D[8] || 1,
                              J
                            );
                        else if (D.length === 7 || D.length === 10)
                          this._addPath(
                            U,
                            D[1],
                            D[2],
                            D[3],
                            D[4],
                            D[5],
                            D[6],
                            D[7] || 0,
                            D[8] || 0,
                            D[9] || 1,
                            J
                          );
                        else return null;
                        return this;
                      }),
                      (v.Path.prototype.addPoly = function (D, U) {
                        var J = Q(D, "HEAPF32");
                        return this._addPoly(J, D.length / 2, U), j(J, D), this;
                      }),
                      (v.Path.prototype.addRect = function (D, U) {
                        return (D = xe(D)), this._addRect(D, !!U), this;
                      }),
                      (v.Path.prototype.addRRect = function (D, U) {
                        return (D = vt(D)), this._addRRect(D, !!U), this;
                      }),
                      (v.Path.prototype.addVerbsPointsWeights = function (
                        D,
                        U,
                        J
                      ) {
                        var fe = Q(D, "HEAPU8"),
                          Pe = Q(U, "HEAPF32"),
                          He = Q(J, "HEAPF32");
                        this._addVerbsPointsWeights(
                          fe,
                          D.length,
                          Pe,
                          U.length,
                          He,
                          (J && J.length) || 0
                        ),
                          j(fe, D),
                          j(Pe, U),
                          j(He, J);
                      }),
                      (v.Path.prototype.arc = function (D, U, J, fe, Pe, He) {
                        return (
                          (D = v.LTRBRect(D - J, U - J, D + J, U + J)),
                          (Pe = ((Pe - fe) / Math.PI) * 180 - 360 * !!He),
                          (He = new v.Path()),
                          He.addArc(D, (fe / Math.PI) * 180, Pe),
                          this.addPath(He, !0),
                          He.delete(),
                          this
                        );
                      }),
                      (v.Path.prototype.arcToOval = function (D, U, J, fe) {
                        return (D = xe(D)), this._arcToOval(D, U, J, fe), this;
                      }),
                      (v.Path.prototype.arcToRotated = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt
                      ) {
                        return (
                          this._arcToRotated(D, U, J, !!fe, !!Pe, He, mt), this
                        );
                      }),
                      (v.Path.prototype.arcToTangent = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        return this._arcToTangent(D, U, J, fe, Pe), this;
                      }),
                      (v.Path.prototype.close = function () {
                        return this._close(), this;
                      }),
                      (v.Path.prototype.conicTo = function (D, U, J, fe, Pe) {
                        return this._conicTo(D, U, J, fe, Pe), this;
                      }),
                      (v.Path.prototype.computeTightBounds = function (D) {
                        this._computeTightBounds(Cr);
                        var U = Oa.toTypedArray();
                        return D ? (D.set(U), D) : U.slice();
                      }),
                      (v.Path.prototype.cubicTo = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        return this._cubicTo(D, U, J, fe, Pe, He), this;
                      }),
                      (v.Path.prototype.dash = function (D, U, J) {
                        return this._dash(D, U, J) ? this : null;
                      }),
                      (v.Path.prototype.getBounds = function (D) {
                        this._getBounds(Cr);
                        var U = Oa.toTypedArray();
                        return D ? (D.set(U), D) : U.slice();
                      }),
                      (v.Path.prototype.lineTo = function (D, U) {
                        return this._lineTo(D, U), this;
                      }),
                      (v.Path.prototype.moveTo = function (D, U) {
                        return this._moveTo(D, U), this;
                      }),
                      (v.Path.prototype.offset = function (D, U) {
                        return this._transform(1, 0, D, 0, 1, U, 0, 0, 1), this;
                      }),
                      (v.Path.prototype.quadTo = function (D, U, J, fe) {
                        return this._quadTo(D, U, J, fe), this;
                      }),
                      (v.Path.prototype.rArcTo = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt
                      ) {
                        return this._rArcTo(D, U, J, fe, Pe, He, mt), this;
                      }),
                      (v.Path.prototype.rConicTo = function (D, U, J, fe, Pe) {
                        return this._rConicTo(D, U, J, fe, Pe), this;
                      }),
                      (v.Path.prototype.rCubicTo = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        return this._rCubicTo(D, U, J, fe, Pe, He), this;
                      }),
                      (v.Path.prototype.rLineTo = function (D, U) {
                        return this._rLineTo(D, U), this;
                      }),
                      (v.Path.prototype.rMoveTo = function (D, U) {
                        return this._rMoveTo(D, U), this;
                      }),
                      (v.Path.prototype.rQuadTo = function (D, U, J, fe) {
                        return this._rQuadTo(D, U, J, fe), this;
                      }),
                      (v.Path.prototype.stroke = function (D) {
                        return (
                          (D = D || {}),
                          (D.width = D.width || 1),
                          (D.miter_limit = D.miter_limit || 4),
                          (D.cap = D.cap || v.StrokeCap.Butt),
                          (D.join = D.join || v.StrokeJoin.Miter),
                          (D.precision = D.precision || 1),
                          this._stroke(D) ? this : null
                        );
                      }),
                      (v.Path.prototype.transform = function () {
                        if (arguments.length === 1) {
                          var D = arguments[0];
                          this._transform(
                            D[0],
                            D[1],
                            D[2],
                            D[3],
                            D[4],
                            D[5],
                            D[6] || 0,
                            D[7] || 0,
                            D[8] || 1
                          );
                        } else if (
                          arguments.length === 6 ||
                          arguments.length === 9
                        )
                          (D = arguments),
                            this._transform(
                              D[0],
                              D[1],
                              D[2],
                              D[3],
                              D[4],
                              D[5],
                              D[6] || 0,
                              D[7] || 0,
                              D[8] || 1
                            );
                        else
                          throw (
                            "transform expected to take 1 or 9 arguments. Got " +
                            arguments.length
                          );
                        return this;
                      }),
                      (v.Path.prototype.trim = function (D, U, J) {
                        return this._trim(D, U, !!J) ? this : null;
                      }),
                      (v.Image.prototype.encodeToBytes = function (D, U) {
                        var J = v.je();
                        return (
                          (D = D || v.ImageFormat.PNG),
                          (U = U || 100),
                          J
                            ? this._encodeToBytes(D, U, J)
                            : this._encodeToBytes(D, U)
                        );
                      }),
                      (v.Image.prototype.makeShaderCubic = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        return (
                          (Pe = le(Pe)), this._makeShaderCubic(D, U, J, fe, Pe)
                        );
                      }),
                      (v.Image.prototype.makeShaderOptions = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        return (
                          (Pe = le(Pe)),
                          this._makeShaderOptions(D, U, J, fe, Pe)
                        );
                      }),
                      (v.Image.prototype.readPixels = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        var He = v.je();
                        return F(this, D, U, J, fe, Pe, He);
                      }),
                      (v.Canvas.prototype.clear = function (D) {
                        v.Fd(this.Ed), (D = Ne(D)), this._clear(D);
                      }),
                      (v.Canvas.prototype.clipRRect = function (D, U, J) {
                        v.Fd(this.Ed), (D = vt(D)), this._clipRRect(D, U, J);
                      }),
                      (v.Canvas.prototype.clipRect = function (D, U, J) {
                        v.Fd(this.Ed), (D = xe(D)), this._clipRect(D, U, J);
                      }),
                      (v.Canvas.prototype.concat = function (D) {
                        v.Fd(this.Ed), (D = Ie(D)), this._concat(D);
                      }),
                      (v.Canvas.prototype.drawArc = function (D, U, J, fe, Pe) {
                        v.Fd(this.Ed),
                          (D = xe(D)),
                          this._drawArc(D, U, J, fe, Pe);
                      }),
                      (v.Canvas.prototype.drawAtlas = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt
                      ) {
                        if (D && fe && U && J && U.length === J.length) {
                          v.Fd(this.Ed), Pe || (Pe = v.BlendMode.SrcOver);
                          var Xt = Q(U, "HEAPF32"),
                            Ht = Q(J, "HEAPF32"),
                            Gi = J.length / 4,
                            rr = Q(E(He), "HEAPU32");
                          if (mt && "B" in mt && "C" in mt)
                            this._drawAtlasCubic(
                              D,
                              Ht,
                              Xt,
                              rr,
                              Gi,
                              Pe,
                              mt.B,
                              mt.C,
                              fe
                            );
                          else {
                            let se = v.FilterMode.Linear,
                              qe = v.MipmapMode.None;
                            mt &&
                              ((se = mt.filter),
                              "mipmap" in mt && (qe = mt.mipmap)),
                              this._drawAtlasOptions(
                                D,
                                Ht,
                                Xt,
                                rr,
                                Gi,
                                Pe,
                                se,
                                qe,
                                fe
                              );
                          }
                          j(Xt, U), j(Ht, J), j(rr, He);
                        }
                      }),
                      (v.Canvas.prototype.drawCircle = function (D, U, J, fe) {
                        v.Fd(this.Ed), this._drawCircle(D, U, J, fe);
                      }),
                      (v.Canvas.prototype.drawColor = function (D, U) {
                        v.Fd(this.Ed),
                          (D = Ne(D)),
                          U !== void 0
                            ? this._drawColor(D, U)
                            : this._drawColor(D);
                      }),
                      (v.Canvas.prototype.drawColorInt = function (D, U) {
                        v.Fd(this.Ed),
                          this._drawColorInt(D, U || v.BlendMode.SrcOver);
                      }),
                      (v.Canvas.prototype.drawColorComponents = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        v.Fd(this.Ed),
                          (D = $e(D, U, J, fe)),
                          Pe !== void 0
                            ? this._drawColor(D, Pe)
                            : this._drawColor(D);
                      }),
                      (v.Canvas.prototype.drawDRRect = function (D, U, J) {
                        v.Fd(this.Ed),
                          (D = vt(D, iv)),
                          (U = vt(U, Iw)),
                          this._drawDRRect(D, U, J);
                      }),
                      (v.Canvas.prototype.drawImage = function (D, U, J, fe) {
                        v.Fd(this.Ed), this._drawImage(D, U, J, fe || null);
                      }),
                      (v.Canvas.prototype.drawImageCubic = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        v.Fd(this.Ed),
                          this._drawImageCubic(D, U, J, fe, Pe, He || null);
                      }),
                      (v.Canvas.prototype.drawImageOptions = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        v.Fd(this.Ed),
                          this._drawImageOptions(D, U, J, fe, Pe, He || null);
                      }),
                      (v.Canvas.prototype.drawImageNine = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        v.Fd(this.Ed),
                          (U = Q(U, "HEAP32", Ou)),
                          (J = xe(J)),
                          this._drawImageNine(D, U, J, fe, Pe || null);
                      }),
                      (v.Canvas.prototype.drawImageRect = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        v.Fd(this.Ed),
                          xe(U, Cr),
                          xe(J, Io),
                          this._drawImageRect(D, Cr, Io, fe, !!Pe);
                      }),
                      (v.Canvas.prototype.drawImageRectCubic = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        v.Fd(this.Ed),
                          xe(U, Cr),
                          xe(J, Io),
                          this._drawImageRectCubic(
                            D,
                            Cr,
                            Io,
                            fe,
                            Pe,
                            He || null
                          );
                      }),
                      (v.Canvas.prototype.drawImageRectOptions = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        v.Fd(this.Ed),
                          xe(U, Cr),
                          xe(J, Io),
                          this._drawImageRectOptions(
                            D,
                            Cr,
                            Io,
                            fe,
                            Pe,
                            He || null
                          );
                      }),
                      (v.Canvas.prototype.drawLine = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        v.Fd(this.Ed), this._drawLine(D, U, J, fe, Pe);
                      }),
                      (v.Canvas.prototype.drawOval = function (D, U) {
                        v.Fd(this.Ed), (D = xe(D)), this._drawOval(D, U);
                      }),
                      (v.Canvas.prototype.drawPaint = function (D) {
                        v.Fd(this.Ed), this._drawPaint(D);
                      }),
                      (v.Canvas.prototype.drawParagraph = function (D, U, J) {
                        v.Fd(this.Ed), this._drawParagraph(D, U, J);
                      }),
                      (v.Canvas.prototype.drawPatch = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        if (24 > D.length) throw "Need 12 cubic points";
                        if (U && 4 > U.length) throw "Need 4 colors";
                        if (J && 8 > J.length)
                          throw "Need 4 shader coordinates";
                        v.Fd(this.Ed);
                        let He = Q(D, "HEAPF32"),
                          mt = U ? Q(E(U), "HEAPU32") : ai,
                          Xt = J ? Q(J, "HEAPF32") : ai;
                        fe || (fe = v.BlendMode.Modulate),
                          this._drawPatch(He, mt, Xt, fe, Pe),
                          j(Xt, J),
                          j(mt, U),
                          j(He, D);
                      }),
                      (v.Canvas.prototype.drawPath = function (D, U) {
                        v.Fd(this.Ed), this._drawPath(D, U);
                      }),
                      (v.Canvas.prototype.drawPicture = function (D) {
                        v.Fd(this.Ed), this._drawPicture(D);
                      }),
                      (v.Canvas.prototype.drawPoints = function (D, U, J) {
                        v.Fd(this.Ed);
                        var fe = Q(U, "HEAPF32");
                        this._drawPoints(D, fe, U.length / 2, J), j(fe, U);
                      }),
                      (v.Canvas.prototype.drawRRect = function (D, U) {
                        v.Fd(this.Ed), (D = vt(D)), this._drawRRect(D, U);
                      }),
                      (v.Canvas.prototype.drawRect = function (D, U) {
                        v.Fd(this.Ed), (D = xe(D)), this._drawRect(D, U);
                      }),
                      (v.Canvas.prototype.drawRect4f = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        v.Fd(this.Ed), this._drawRect4f(D, U, J, fe, Pe);
                      }),
                      (v.Canvas.prototype.drawShadow = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt
                      ) {
                        v.Fd(this.Ed);
                        var Xt = Q(Pe, "HEAPF32"),
                          Ht = Q(He, "HEAPF32");
                        (U = Q(U, "HEAPF32", ev)),
                          (J = Q(J, "HEAPF32", tv)),
                          this._drawShadow(D, U, J, fe, Xt, Ht, mt),
                          j(Xt, Pe),
                          j(Ht, He);
                      }),
                      (v.getShadowLocalBounds = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt
                      ) {
                        return (
                          (D = le(D)),
                          (J = Q(J, "HEAPF32", ev)),
                          (fe = Q(fe, "HEAPF32", tv)),
                          this._getShadowLocalBounds(D, U, J, fe, Pe, He, Cr)
                            ? ((U = Oa.toTypedArray()),
                              mt ? (mt.set(U), mt) : U.slice())
                            : null
                        );
                      }),
                      (v.Canvas.prototype.drawTextBlob = function (
                        D,
                        U,
                        J,
                        fe
                      ) {
                        v.Fd(this.Ed), this._drawTextBlob(D, U, J, fe);
                      }),
                      (v.Canvas.prototype.drawVertices = function (D, U, J) {
                        v.Fd(this.Ed), this._drawVertices(D, U, J);
                      }),
                      (v.Canvas.prototype.getDeviceClipBounds = function (D) {
                        this._getDeviceClipBounds(Ou);
                        var U = Ip.toTypedArray();
                        return D ? D.set(U) : (D = U.slice()), D;
                      }),
                      (v.Canvas.prototype.getLocalToDevice = function () {
                        this._getLocalToDevice(bs);
                        for (var D = bs, U = Array(16), J = 0; 16 > J; J++)
                          U[J] = v.HEAPF32[D / 4 + J];
                        return U;
                      }),
                      (v.Canvas.prototype.getTotalMatrix = function () {
                        this._getTotalMatrix(Ut);
                        for (var D = Array(9), U = 0; 9 > U; U++)
                          D[U] = v.HEAPF32[Ut / 4 + U];
                        return D;
                      }),
                      (v.Canvas.prototype.makeSurface = function (D) {
                        return (D = this._makeSurface(D)), (D.Ed = this.Ed), D;
                      }),
                      (v.Canvas.prototype.readPixels = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        return v.Fd(this.Ed), F(this, D, U, J, fe, Pe);
                      }),
                      (v.Canvas.prototype.saveLayer = function (D, U, J, fe) {
                        return (
                          (U = xe(U)),
                          this._saveLayer(D || null, U, J || null, fe || 0)
                        );
                      }),
                      (v.Canvas.prototype.writePixels = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt,
                        Xt
                      ) {
                        if (D.byteLength % (U * J))
                          throw "pixels length must be a multiple of the srcWidth * srcHeight";
                        v.Fd(this.Ed);
                        var Ht = D.byteLength / (U * J);
                        (He = He || v.AlphaType.Unpremul),
                          (mt = mt || v.ColorType.RGBA_8888),
                          (Xt = Xt || v.ColorSpace.SRGB);
                        var Gi = Ht * U;
                        return (
                          (Ht = Q(D, "HEAPU8")),
                          (U = this._writePixels(
                            {
                              width: U,
                              height: J,
                              colorType: mt,
                              alphaType: He,
                              colorSpace: Xt,
                            },
                            Ht,
                            Gi,
                            fe,
                            Pe
                          )),
                          j(Ht, D),
                          U
                        );
                      }),
                      (v.ColorFilter.MakeBlend = function (D, U, J) {
                        return (
                          (D = Ne(D)),
                          (J = J || v.ColorSpace.SRGB),
                          v.ColorFilter._MakeBlend(D, U, J)
                        );
                      }),
                      (v.ColorFilter.MakeMatrix = function (D) {
                        if (!D || D.length !== 20) throw "invalid color matrix";
                        var U = Q(D, "HEAPF32"),
                          J = v.ColorFilter._makeMatrix(U);
                        return j(U, D), J;
                      }),
                      (v.ContourMeasure.prototype.getPosTan = function (D, U) {
                        return (
                          this._getPosTan(D, Cr),
                          (D = Oa.toTypedArray()),
                          U ? (U.set(D), U) : D.slice()
                        );
                      }),
                      (v.ImageFilter.prototype.getOutputBounds = function (
                        D,
                        U,
                        J
                      ) {
                        return (
                          (D = xe(D, Cr)),
                          (U = le(U)),
                          this._getOutputBounds(D, U, Ou),
                          (U = Ip.toTypedArray()),
                          J ? (J.set(U), J) : U.slice()
                        );
                      }),
                      (v.ImageFilter.MakeDropShadow = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        return (
                          (Pe = Ne(Pe, sn)),
                          v.ImageFilter._MakeDropShadow(D, U, J, fe, Pe, He)
                        );
                      }),
                      (v.ImageFilter.MakeDropShadowOnly = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He
                      ) {
                        return (
                          (Pe = Ne(Pe, sn)),
                          v.ImageFilter._MakeDropShadowOnly(D, U, J, fe, Pe, He)
                        );
                      }),
                      (v.ImageFilter.MakeImage = function (D, U, J, fe) {
                        if (
                          ((J = xe(J, Cr)),
                          (fe = xe(fe, Io)),
                          "B" in U && "C" in U)
                        )
                          return v.ImageFilter._MakeImageCubic(
                            D,
                            U.B,
                            U.C,
                            J,
                            fe
                          );
                        let Pe = U.filter,
                          He = v.MipmapMode.None;
                        return (
                          "mipmap" in U && (He = U.mipmap),
                          v.ImageFilter._MakeImageOptions(D, Pe, He, J, fe)
                        );
                      }),
                      (v.ImageFilter.MakeMatrixTransform = function (D, U, J) {
                        if (((D = le(D)), "B" in U && "C" in U))
                          return v.ImageFilter._MakeMatrixTransformCubic(
                            D,
                            U.B,
                            U.C,
                            J
                          );
                        let fe = U.filter,
                          Pe = v.MipmapMode.None;
                        return (
                          "mipmap" in U && (Pe = U.mipmap),
                          v.ImageFilter._MakeMatrixTransformOptions(
                            D,
                            fe,
                            Pe,
                            J
                          )
                        );
                      }),
                      (v.Paint.prototype.getColor = function () {
                        return this._getColor(sn), ft(sn);
                      }),
                      (v.Paint.prototype.setColor = function (D, U) {
                        (U = U || null), (D = Ne(D)), this._setColor(D, U);
                      }),
                      (v.Paint.prototype.setColorComponents = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        (Pe = Pe || null),
                          (D = $e(D, U, J, fe)),
                          this._setColor(D, Pe);
                      }),
                      (v.Path.prototype.getPoint = function (D, U) {
                        return (
                          this._getPoint(D, Cr),
                          (D = Oa.toTypedArray()),
                          U ? ((U[0] = D[0]), (U[1] = D[1]), U) : D.slice(0, 2)
                        );
                      }),
                      (v.Picture.prototype.makeShader = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe
                      ) {
                        return (
                          (fe = le(fe)),
                          (Pe = xe(Pe)),
                          this._makeShader(D, U, J, fe, Pe)
                        );
                      }),
                      (v.Picture.prototype.cullRect = function (D) {
                        this._cullRect(Cr);
                        var U = Oa.toTypedArray();
                        return D ? (D.set(U), D) : U.slice();
                      }),
                      (v.PictureRecorder.prototype.beginRecording = function (
                        D,
                        U
                      ) {
                        return (D = xe(D)), this._beginRecording(D, !!U);
                      }),
                      (v.Surface.prototype.getCanvas = function () {
                        var D = this._getCanvas();
                        return (D.Ed = this.Ed), D;
                      }),
                      (v.Surface.prototype.makeImageSnapshot = function (D) {
                        return (
                          v.Fd(this.Ed),
                          (D = Q(D, "HEAP32", Ou)),
                          this._makeImageSnapshot(D)
                        );
                      }),
                      (v.Surface.prototype.makeSurface = function (D) {
                        return (
                          v.Fd(this.Ed),
                          (D = this._makeSurface(D)),
                          (D.Ed = this.Ed),
                          D
                        );
                      }),
                      (v.Surface.prototype.Oe = function (D, U) {
                        return (
                          this.ce || (this.ce = this.getCanvas()),
                          requestAnimationFrame(
                            function () {
                              v.Fd(this.Ed), D(this.ce), this.flush(U);
                            }.bind(this)
                          )
                        );
                      }),
                      v.Surface.prototype.requestAnimationFrame ||
                        (v.Surface.prototype.requestAnimationFrame =
                          v.Surface.prototype.Oe),
                      (v.Surface.prototype.Le = function (D, U) {
                        this.ce || (this.ce = this.getCanvas()),
                          requestAnimationFrame(
                            function () {
                              v.Fd(this.Ed),
                                D(this.ce),
                                this.flush(U),
                                this.dispose();
                            }.bind(this)
                          );
                      }),
                      v.Surface.prototype.drawOnce ||
                        (v.Surface.prototype.drawOnce = v.Surface.prototype.Le),
                      (v.PathEffect.MakeDash = function (D, U) {
                        if ((U || (U = 0), !D.length || D.length % 2 === 1))
                          throw "Intervals array must have even length";
                        var J = Q(D, "HEAPF32");
                        return (
                          (U = v.PathEffect._MakeDash(J, D.length, U)),
                          j(J, D),
                          U
                        );
                      }),
                      (v.PathEffect.MakeLine2D = function (D, U) {
                        return (U = le(U)), v.PathEffect._MakeLine2D(D, U);
                      }),
                      (v.PathEffect.MakePath2D = function (D, U) {
                        return (D = le(D)), v.PathEffect._MakePath2D(D, U);
                      }),
                      (v.Shader.MakeColor = function (D, U) {
                        return (
                          (U = U || null),
                          (D = Ne(D)),
                          v.Shader._MakeColor(D, U)
                        );
                      }),
                      (v.Shader.Blend = v.Shader.MakeBlend),
                      (v.Shader.Color = v.Shader.MakeColor),
                      (v.Shader.MakeLinearGradient = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt,
                        Xt
                      ) {
                        Xt = Xt || null;
                        var Ht = K(J),
                          Gi = Q(fe, "HEAPF32");
                        (mt = mt || 0), (He = le(He));
                        var rr = Oa.toTypedArray();
                        return (
                          rr.set(D),
                          rr.set(U, 2),
                          (D = v.Shader._MakeLinearGradient(
                            Cr,
                            Ht.Nd,
                            Ht.colorType,
                            Gi,
                            Ht.count,
                            Pe,
                            mt,
                            He,
                            Xt
                          )),
                          j(Ht.Nd, J),
                          fe && j(Gi, fe),
                          D
                        );
                      }),
                      (v.Shader.MakeRadialGradient = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt,
                        Xt
                      ) {
                        Xt = Xt || null;
                        var Ht = K(J),
                          Gi = Q(fe, "HEAPF32");
                        return (
                          (mt = mt || 0),
                          (He = le(He)),
                          (D = v.Shader._MakeRadialGradient(
                            D[0],
                            D[1],
                            U,
                            Ht.Nd,
                            Ht.colorType,
                            Gi,
                            Ht.count,
                            Pe,
                            mt,
                            He,
                            Xt
                          )),
                          j(Ht.Nd, J),
                          fe && j(Gi, fe),
                          D
                        );
                      }),
                      (v.Shader.MakeSweepGradient = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt,
                        Xt,
                        Ht,
                        Gi
                      ) {
                        Gi = Gi || null;
                        var rr = K(J),
                          se = Q(fe, "HEAPF32");
                        return (
                          (mt = mt || 0),
                          (Xt = Xt || 0),
                          (Ht = Ht || 360),
                          (He = le(He)),
                          (D = v.Shader._MakeSweepGradient(
                            D,
                            U,
                            rr.Nd,
                            rr.colorType,
                            se,
                            rr.count,
                            Pe,
                            Xt,
                            Ht,
                            mt,
                            He,
                            Gi
                          )),
                          j(rr.Nd, J),
                          fe && j(se, fe),
                          D
                        );
                      }),
                      (v.Shader.MakeTwoPointConicalGradient = function (
                        D,
                        U,
                        J,
                        fe,
                        Pe,
                        He,
                        mt,
                        Xt,
                        Ht,
                        Gi
                      ) {
                        Gi = Gi || null;
                        var rr = K(Pe),
                          se = Q(He, "HEAPF32");
                        (Ht = Ht || 0), (Xt = le(Xt));
                        var qe = Oa.toTypedArray();
                        return (
                          qe.set(D),
                          qe.set(J, 2),
                          (D = v.Shader._MakeTwoPointConicalGradient(
                            Cr,
                            U,
                            fe,
                            rr.Nd,
                            rr.colorType,
                            se,
                            rr.count,
                            mt,
                            Ht,
                            Xt,
                            Gi
                          )),
                          j(rr.Nd, Pe),
                          He && j(se, He),
                          D
                        );
                      }),
                      (v.Vertices.prototype.bounds = function (D) {
                        this._bounds(Cr);
                        var U = Oa.toTypedArray();
                        return D ? (D.set(U), D) : U.slice();
                      }),
                      v.Id &&
                        v.Id.forEach(function (D) {
                          D();
                        });
                  }),
                    (v.computeTonalColors = function (F) {
                      var D = Q(F.ambient, "HEAPF32"),
                        U = Q(F.spot, "HEAPF32");
                      this._computeTonalColors(D, U);
                      var J = { ambient: ft(D), spot: ft(U) };
                      return j(D, F.ambient), j(U, F.spot), J;
                    }),
                    (v.LTRBRect = function (F, D, U, J) {
                      return Float32Array.of(F, D, U, J);
                    }),
                    (v.XYWHRect = function (F, D, U, J) {
                      return Float32Array.of(F, D, F + U, D + J);
                    }),
                    (v.LTRBiRect = function (F, D, U, J) {
                      return Int32Array.of(F, D, U, J);
                    }),
                    (v.XYWHiRect = function (F, D, U, J) {
                      return Int32Array.of(F, D, F + U, D + J);
                    }),
                    (v.RRectXY = function (F, D, U) {
                      return Float32Array.of(
                        F[0],
                        F[1],
                        F[2],
                        F[3],
                        D,
                        U,
                        D,
                        U,
                        D,
                        U,
                        D,
                        U
                      );
                    }),
                    (v.MakeAnimatedImageFromEncoded = function (F) {
                      F = new Uint8Array(F);
                      var D = v._malloc(F.byteLength);
                      return (
                        v.HEAPU8.set(F, D),
                        (F = v._decodeAnimatedImage(D, F.byteLength)) ? F : null
                      );
                    }),
                    (v.MakeImageFromEncoded = function (F) {
                      F = new Uint8Array(F);
                      var D = v._malloc(F.byteLength);
                      return (
                        v.HEAPU8.set(F, D),
                        (F = v._decodeImage(D, F.byteLength)) ? F : null
                      );
                    });
                  var Iu = null;
                  (v.MakeImageFromCanvasImageSource = function (F) {
                    var D = F.width,
                      U = F.height;
                    Iu || (Iu = document.createElement("canvas")),
                      (Iu.width = D),
                      (Iu.height = U);
                    var J = Iu.getContext("2d", { willReadFrequently: !0 });
                    return (
                      J.drawImage(F, 0, 0),
                      (F = J.getImageData(0, 0, D, U)),
                      v.MakeImage(
                        {
                          width: D,
                          height: U,
                          alphaType: v.AlphaType.Unpremul,
                          colorType: v.ColorType.RGBA_8888,
                          colorSpace: v.ColorSpace.SRGB,
                        },
                        F.data,
                        4 * D
                      )
                    );
                  }),
                    (v.MakeImage = function (F, D, U) {
                      var J = v._malloc(D.length);
                      return (
                        v.HEAPU8.set(D, J), v._MakeImage(F, J, D.length, U)
                      );
                    }),
                    (v.MakeVertices = function (F, D, U, J, fe, Pe) {
                      var He = (fe && fe.length) || 0,
                        mt = 0;
                      return (
                        U && U.length && (mt |= 1),
                        J && J.length && (mt |= 2),
                        Pe === void 0 || Pe || (mt |= 4),
                        (F = new v._VerticesBuilder(F, D.length / 2, He, mt)),
                        Q(D, "HEAPF32", F.positions()),
                        F.texCoords() && Q(U, "HEAPF32", F.texCoords()),
                        F.colors() && Q(E(J), "HEAPU32", F.colors()),
                        F.indices() && Q(fe, "HEAPU16", F.indices()),
                        F.detach()
                      );
                    }),
                    (function (F) {
                      (F.Id = F.Id || []),
                        F.Id.push(function () {
                          function D(se) {
                            return (
                              se &&
                                (se.dir =
                                  se.dir === 0
                                    ? F.TextDirection.RTL
                                    : F.TextDirection.LTR),
                              se
                            );
                          }
                          function U(se) {
                            if (!se || !se.length) return [];
                            for (var qe = [], bi = 0; bi < se.length; bi += 5) {
                              var kr = F.LTRBRect(
                                  se[bi],
                                  se[bi + 1],
                                  se[bi + 2],
                                  se[bi + 3]
                                ),
                                Gn = F.TextDirection.LTR;
                              se[bi + 4] === 0 && (Gn = F.TextDirection.RTL),
                                qe.push({ rect: kr, dir: Gn });
                            }
                            return F._free(se.byteOffset), qe;
                          }
                          function J(se) {
                            return (
                              (se = se || {}),
                              se.weight === void 0 &&
                                (se.weight = F.FontWeight.Normal),
                              (se.width = se.width || F.FontWidth.Normal),
                              (se.slant = se.slant || F.FontSlant.Upright),
                              se
                            );
                          }
                          function fe(se) {
                            if (!se || !se.length) return ai;
                            for (var qe = [], bi = 0; bi < se.length; bi++) {
                              var kr = Pe(se[bi]);
                              qe.push(kr);
                            }
                            return Q(qe, "HEAPU32");
                          }
                          function Pe(se) {
                            if (Xt[se]) return Xt[se];
                            var qe = pr(se) + 1,
                              bi = F._malloc(qe);
                            return Jt(se, R, bi, qe), (Xt[se] = bi);
                          }
                          function He(se) {
                            if (
                              ((se._colorPtr = Ne(se.color)),
                              (se._foregroundColorPtr = ai),
                              (se._backgroundColorPtr = ai),
                              (se._decorationColorPtr = ai),
                              se.foregroundColor &&
                                (se._foregroundColorPtr = Ne(
                                  se.foregroundColor,
                                  Ht
                                )),
                              se.backgroundColor &&
                                (se._backgroundColorPtr = Ne(
                                  se.backgroundColor,
                                  Gi
                                )),
                              se.decorationColor &&
                                (se._decorationColorPtr = Ne(
                                  se.decorationColor,
                                  rr
                                )),
                              Array.isArray(se.fontFamilies) &&
                              se.fontFamilies.length
                                ? ((se._fontFamiliesPtr = fe(se.fontFamilies)),
                                  (se._fontFamiliesLen =
                                    se.fontFamilies.length))
                                : ((se._fontFamiliesPtr = ai),
                                  (se._fontFamiliesLen = 0)),
                              se.locale)
                            ) {
                              var qe = se.locale;
                              (se._localePtr = Pe(qe)),
                                (se._localeLen = pr(qe) + 1);
                            } else (se._localePtr = ai), (se._localeLen = 0);
                            if (
                              Array.isArray(se.shadows) &&
                              se.shadows.length
                            ) {
                              qe = se.shadows;
                              var bi = qe.map(function (Ia) {
                                  return Ia.color || F.BLACK;
                                }),
                                kr = qe.map(function (Ia) {
                                  return Ia.blurRadius || 0;
                                });
                              se._shadowLen = qe.length;
                              for (
                                var Gn = F._malloc(8 * qe.length),
                                  rv = Gn / 4,
                                  sv = 0;
                                sv < qe.length;
                                sv++
                              ) {
                                var Rw = qe[sv].offset || [0, 0];
                                (F.HEAPF32[rv] = Rw[0]),
                                  (F.HEAPF32[rv + 1] = Rw[1]),
                                  (rv += 2);
                              }
                              (se._shadowColorsPtr = K(bi).Nd),
                                (se._shadowOffsetsPtr = Gn),
                                (se._shadowBlurRadiiPtr = Q(kr, "HEAPF32"));
                            } else (se._shadowLen = 0), (se._shadowColorsPtr = ai), (se._shadowOffsetsPtr = ai), (se._shadowBlurRadiiPtr = ai);
                            Array.isArray(se.fontFeatures) &&
                            se.fontFeatures.length
                              ? ((qe = se.fontFeatures),
                                (bi = qe.map(function (Ia) {
                                  return Ia.name;
                                })),
                                (kr = qe.map(function (Ia) {
                                  return Ia.value;
                                })),
                                (se._fontFeatureLen = qe.length),
                                (se._fontFeatureNamesPtr = fe(bi)),
                                (se._fontFeatureValuesPtr = Q(kr, "HEAPU32")))
                              : ((se._fontFeatureLen = 0),
                                (se._fontFeatureNamesPtr = ai),
                                (se._fontFeatureValuesPtr = ai)),
                              Array.isArray(se.fontVariations) &&
                              se.fontVariations.length
                                ? ((qe = se.fontVariations),
                                  (bi = qe.map(function (Ia) {
                                    return Ia.axis;
                                  })),
                                  (kr = qe.map(function (Ia) {
                                    return Ia.value;
                                  })),
                                  (se._fontVariationLen = qe.length),
                                  (se._fontVariationAxesPtr = fe(bi)),
                                  (se._fontVariationValuesPtr = Q(
                                    kr,
                                    "HEAPF32"
                                  )))
                                : ((se._fontVariationLen = 0),
                                  (se._fontVariationAxesPtr = ai),
                                  (se._fontVariationValuesPtr = ai));
                          }
                          function mt(se) {
                            F._free(se._fontFamiliesPtr),
                              F._free(se._shadowColorsPtr),
                              F._free(se._shadowOffsetsPtr),
                              F._free(se._shadowBlurRadiiPtr),
                              F._free(se._fontFeatureNamesPtr),
                              F._free(se._fontFeatureValuesPtr),
                              F._free(se._fontVariationAxesPtr),
                              F._free(se._fontVariationValuesPtr);
                          }
                          (F.Paragraph.prototype.getRectsForRange = function (
                            se,
                            qe,
                            bi,
                            kr
                          ) {
                            return (
                              (se = this._getRectsForRange(se, qe, bi, kr)),
                              U(se)
                            );
                          }),
                            (F.Paragraph.prototype.getRectsForPlaceholders =
                              function () {
                                var se = this._getRectsForPlaceholders();
                                return U(se);
                              }),
                            (F.Paragraph.prototype.getGlyphInfoAt = function (
                              se
                            ) {
                              return D(this._getGlyphInfoAt(se));
                            }),
                            (F.Paragraph.prototype.getClosestGlyphInfoAtCoordinate =
                              function (se, qe) {
                                return D(
                                  this._getClosestGlyphInfoAtCoordinate(se, qe)
                                );
                              }),
                            (F.TypefaceFontProvider.prototype.registerFont =
                              function (se, qe) {
                                if (
                                  ((se =
                                    F.Typeface.MakeFreeTypeFaceFromData(se)),
                                  !se)
                                )
                                  return null;
                                (qe = Pe(qe)), this._registerFont(se, qe);
                              }),
                            (F.ParagraphStyle = function (se) {
                              if (
                                ((se.disableHinting = se.disableHinting || !1),
                                se.ellipsis)
                              ) {
                                var qe = se.ellipsis;
                                (se._ellipsisPtr = Pe(qe)),
                                  (se._ellipsisLen = pr(qe) + 1);
                              } else
                                (se._ellipsisPtr = ai), (se._ellipsisLen = 0);
                              return (
                                se.heightMultiplier == null &&
                                  (se.heightMultiplier = -1),
                                (se.maxLines = se.maxLines || 0),
                                (se.replaceTabCharacters =
                                  se.replaceTabCharacters || !1),
                                (qe = (qe = se.strutStyle) || {}),
                                (qe.strutEnabled = qe.strutEnabled || !1),
                                qe.strutEnabled &&
                                Array.isArray(qe.fontFamilies) &&
                                qe.fontFamilies.length
                                  ? ((qe._fontFamiliesPtr = fe(
                                      qe.fontFamilies
                                    )),
                                    (qe._fontFamiliesLen =
                                      qe.fontFamilies.length))
                                  : ((qe._fontFamiliesPtr = ai),
                                    (qe._fontFamiliesLen = 0)),
                                (qe.fontStyle = J(qe.fontStyle)),
                                qe.fontSize == null && (qe.fontSize = -1),
                                qe.heightMultiplier == null &&
                                  (qe.heightMultiplier = -1),
                                (qe.halfLeading = qe.halfLeading || !1),
                                (qe.leading = qe.leading || 0),
                                (qe.forceStrutHeight =
                                  qe.forceStrutHeight || !1),
                                (se.strutStyle = qe),
                                (se.textAlign =
                                  se.textAlign || F.TextAlign.Start),
                                (se.textDirection =
                                  se.textDirection || F.TextDirection.LTR),
                                (se.textHeightBehavior =
                                  se.textHeightBehavior ||
                                  F.TextHeightBehavior.All),
                                (se.textStyle = F.TextStyle(se.textStyle)),
                                (se.applyRoundingHack =
                                  se.applyRoundingHack !== !1),
                                se
                              );
                            }),
                            (F.TextStyle = function (se) {
                              return (
                                se.color || (se.color = F.BLACK),
                                (se.decoration = se.decoration || 0),
                                (se.decorationThickness =
                                  se.decorationThickness || 0),
                                (se.decorationStyle =
                                  se.decorationStyle ||
                                  F.DecorationStyle.Solid),
                                (se.textBaseline =
                                  se.textBaseline || F.TextBaseline.Alphabetic),
                                se.fontSize == null && (se.fontSize = -1),
                                (se.letterSpacing = se.letterSpacing || 0),
                                (se.wordSpacing = se.wordSpacing || 0),
                                se.heightMultiplier == null &&
                                  (se.heightMultiplier = -1),
                                (se.halfLeading = se.halfLeading || !1),
                                (se.fontStyle = J(se.fontStyle)),
                                se
                              );
                            });
                          var Xt = {},
                            Ht = F._malloc(16),
                            Gi = F._malloc(16),
                            rr = F._malloc(16);
                          (F.ParagraphBuilder.Make = function (se, qe) {
                            return (
                              He(se.textStyle),
                              (qe = F.ParagraphBuilder._Make(se, qe)),
                              mt(se.textStyle),
                              qe
                            );
                          }),
                            (F.ParagraphBuilder.MakeFromFontProvider =
                              function (se, qe) {
                                return (
                                  He(se.textStyle),
                                  (qe =
                                    F.ParagraphBuilder._MakeFromFontProvider(
                                      se,
                                      qe
                                    )),
                                  mt(se.textStyle),
                                  qe
                                );
                              }),
                            (F.ParagraphBuilder.MakeFromFontCollection =
                              function (se, qe) {
                                return (
                                  He(se.textStyle),
                                  (qe =
                                    F.ParagraphBuilder._MakeFromFontCollection(
                                      se,
                                      qe
                                    )),
                                  mt(se.textStyle),
                                  qe
                                );
                              }),
                            (F.ParagraphBuilder.ShapeText = function (
                              se,
                              qe,
                              bi
                            ) {
                              let kr = 0;
                              for (let Gn of qe) kr += Gn.length;
                              if (kr !== se.length)
                                throw "Accumulated block lengths must equal text.length";
                              return F.ParagraphBuilder._ShapeText(se, qe, bi);
                            }),
                            (F.ParagraphBuilder.prototype.pushStyle = function (
                              se
                            ) {
                              He(se), this._pushStyle(se), mt(se);
                            }),
                            (F.ParagraphBuilder.prototype.pushPaintStyle =
                              function (se, qe, bi) {
                                He(se),
                                  this._pushPaintStyle(se, qe, bi),
                                  mt(se);
                              }),
                            (F.ParagraphBuilder.prototype.addPlaceholder =
                              function (se, qe, bi, kr, Gn) {
                                (bi = bi || F.PlaceholderAlignment.Baseline),
                                  (kr = kr || F.TextBaseline.Alphabetic),
                                  this._addPlaceholder(
                                    se || 0,
                                    qe || 0,
                                    bi,
                                    kr,
                                    Gn || 0
                                  );
                              }),
                            (F.ParagraphBuilder.prototype.setWordsUtf8 =
                              function (se) {
                                var qe = Q(se, "HEAPU32");
                                this._setWordsUtf8(qe, (se && se.length) || 0),
                                  j(qe, se);
                              }),
                            (F.ParagraphBuilder.prototype.setWordsUtf16 =
                              function (se) {
                                var qe = Q(se, "HEAPU32");
                                this._setWordsUtf16(qe, (se && se.length) || 0),
                                  j(qe, se);
                              }),
                            (F.ParagraphBuilder.prototype.setGraphemeBreaksUtf8 =
                              function (se) {
                                var qe = Q(se, "HEAPU32");
                                this._setGraphemeBreaksUtf8(
                                  qe,
                                  (se && se.length) || 0
                                ),
                                  j(qe, se);
                              }),
                            (F.ParagraphBuilder.prototype.setGraphemeBreaksUtf16 =
                              function (se) {
                                var qe = Q(se, "HEAPU32");
                                this._setGraphemeBreaksUtf16(
                                  qe,
                                  (se && se.length) || 0
                                ),
                                  j(qe, se);
                              }),
                            (F.ParagraphBuilder.prototype.setLineBreaksUtf8 =
                              function (se) {
                                var qe = Q(se, "HEAPU32");
                                this._setLineBreaksUtf8(
                                  qe,
                                  (se && se.length) || 0
                                ),
                                  j(qe, se);
                              }),
                            (F.ParagraphBuilder.prototype.setLineBreaksUtf16 =
                              function (se) {
                                var qe = Q(se, "HEAPU32");
                                this._setLineBreaksUtf16(
                                  qe,
                                  (se && se.length) || 0
                                ),
                                  j(qe, se);
                              });
                        });
                    })(a),
                    (v.Id = v.Id || []),
                    v.Id.push(function () {
                      (v.Path.prototype.op = function (F, D) {
                        return this._op(F, D) ? this : null;
                      }),
                        (v.Path.prototype.simplify = function () {
                          return this._simplify() ? this : null;
                        });
                    }),
                    (v.Id = v.Id || []),
                    v.Id.push(function () {
                      (v.Canvas.prototype.drawText = function (F, D, U, J, fe) {
                        var Pe = pr(F),
                          He = v._malloc(Pe + 1);
                        Jt(F, R, He, Pe + 1),
                          this._drawSimpleText(He, Pe, D, U, fe, J),
                          v._free(He);
                      }),
                        (v.Canvas.prototype.drawGlyphs = function (
                          F,
                          D,
                          U,
                          J,
                          fe,
                          Pe
                        ) {
                          if (!(2 * F.length <= D.length))
                            throw "Not enough positions for the array of gyphs";
                          v.Fd(this.Ed);
                          let He = Q(F, "HEAPU16"),
                            mt = Q(D, "HEAPF32");
                          this._drawGlyphs(F.length, He, mt, U, J, fe, Pe),
                            j(mt, D),
                            j(He, F);
                        }),
                        (v.Font.prototype.getGlyphBounds = function (F, D, U) {
                          var J = Q(F, "HEAPU16"),
                            fe = v._malloc(16 * F.length);
                          return (
                            this._getGlyphWidthBounds(
                              J,
                              F.length,
                              ai,
                              fe,
                              D || null
                            ),
                            (D = new Float32Array(
                              v.HEAPU8.buffer,
                              fe,
                              4 * F.length
                            )),
                            j(J, F),
                            U
                              ? (U.set(D), v._free(fe), U)
                              : ((F = Float32Array.from(D)), v._free(fe), F)
                          );
                        }),
                        (v.Font.prototype.getGlyphIDs = function (F, D, U) {
                          D || (D = F.length);
                          var J = pr(F) + 1,
                            fe = v._malloc(J);
                          return (
                            Jt(F, R, fe, J),
                            (F = v._malloc(2 * D)),
                            (D = this._getGlyphIDs(fe, J - 1, D, F)),
                            v._free(fe),
                            0 > D
                              ? (v._free(F), null)
                              : ((fe = new Uint16Array(v.HEAPU8.buffer, F, D)),
                                U
                                  ? (U.set(fe), v._free(F), U)
                                  : ((U = Uint16Array.from(fe)), v._free(F), U))
                          );
                        }),
                        (v.Font.prototype.getGlyphIntercepts = function (
                          F,
                          D,
                          U,
                          J
                        ) {
                          var fe = Q(F, "HEAPU16"),
                            Pe = Q(D, "HEAPF32");
                          return this._getGlyphIntercepts(
                            fe,
                            F.length,
                            !(F && F._ck),
                            Pe,
                            D.length,
                            !(D && D._ck),
                            U,
                            J
                          );
                        }),
                        (v.Font.prototype.getGlyphWidths = function (F, D, U) {
                          var J = Q(F, "HEAPU16"),
                            fe = v._malloc(4 * F.length);
                          return (
                            this._getGlyphWidthBounds(
                              J,
                              F.length,
                              fe,
                              ai,
                              D || null
                            ),
                            (D = new Float32Array(
                              v.HEAPU8.buffer,
                              fe,
                              F.length
                            )),
                            j(J, F),
                            U
                              ? (U.set(D), v._free(fe), U)
                              : ((F = Float32Array.from(D)), v._free(fe), F)
                          );
                        }),
                        (v.FontMgr.FromData = function () {
                          if (!arguments.length) return null;
                          var F = arguments;
                          if (
                            (F.length === 1 &&
                              Array.isArray(F[0]) &&
                              (F = arguments[0]),
                            !F.length)
                          )
                            return null;
                          for (var D = [], U = [], J = 0; J < F.length; J++) {
                            var fe = new Uint8Array(F[J]),
                              Pe = Q(fe, "HEAPU8");
                            D.push(Pe), U.push(fe.byteLength);
                          }
                          return (
                            (D = Q(D, "HEAPU32")),
                            (U = Q(U, "HEAPU32")),
                            (F = v.FontMgr._fromData(D, U, F.length)),
                            v._free(D),
                            v._free(U),
                            F
                          );
                        }),
                        (v.Typeface.MakeFreeTypeFaceFromData = function (F) {
                          F = new Uint8Array(F);
                          var D = Q(F, "HEAPU8");
                          return (F = v.Typeface._MakeFreeTypeFaceFromData(
                            D,
                            F.byteLength
                          ))
                            ? F
                            : null;
                        }),
                        (v.Typeface.prototype.getGlyphIDs = function (F, D, U) {
                          D || (D = F.length);
                          var J = pr(F) + 1,
                            fe = v._malloc(J);
                          return (
                            Jt(F, R, fe, J),
                            (F = v._malloc(2 * D)),
                            (D = this._getGlyphIDs(fe, J - 1, D, F)),
                            v._free(fe),
                            0 > D
                              ? (v._free(F), null)
                              : ((fe = new Uint16Array(v.HEAPU8.buffer, F, D)),
                                U
                                  ? (U.set(fe), v._free(F), U)
                                  : ((U = Uint16Array.from(fe)), v._free(F), U))
                          );
                        }),
                        (v.TextBlob.MakeOnPath = function (F, D, U, J) {
                          if (F && F.length && D && D.countPoints()) {
                            if (D.countPoints() === 1)
                              return this.MakeFromText(F, U);
                            J || (J = 0);
                            var fe = U.getGlyphIDs(F);
                            fe = U.getGlyphWidths(fe);
                            var Pe = [];
                            D = new v.ContourMeasureIter(D, !1, 1);
                            for (
                              var He = D.next(),
                                mt = new Float32Array(4),
                                Xt = 0;
                              Xt < F.length && He;
                              Xt++
                            ) {
                              var Ht = fe[Xt];
                              if (((J += Ht / 2), J > He.length())) {
                                if ((He.delete(), (He = D.next()), !He)) {
                                  F = F.substring(0, Xt);
                                  break;
                                }
                                J = Ht / 2;
                              }
                              He.getPosTan(J, mt);
                              var Gi = mt[2],
                                rr = mt[3];
                              Pe.push(
                                Gi,
                                rr,
                                mt[0] - (Ht / 2) * Gi,
                                mt[1] - (Ht / 2) * rr
                              ),
                                (J += Ht / 2);
                            }
                            return (
                              (F = this.MakeFromRSXform(F, Pe, U)),
                              He && He.delete(),
                              D.delete(),
                              F
                            );
                          }
                        }),
                        (v.TextBlob.MakeFromRSXform = function (F, D, U) {
                          var J = pr(F) + 1,
                            fe = v._malloc(J);
                          return (
                            Jt(F, R, fe, J),
                            (F = Q(D, "HEAPF32")),
                            (U = v.TextBlob._MakeFromRSXform(fe, J - 1, F, U)),
                            v._free(fe),
                            U || null
                          );
                        }),
                        (v.TextBlob.MakeFromRSXformGlyphs = function (F, D, U) {
                          var J = Q(F, "HEAPU16");
                          return (
                            (D = Q(D, "HEAPF32")),
                            (U = v.TextBlob._MakeFromRSXformGlyphs(
                              J,
                              2 * F.length,
                              D,
                              U
                            )),
                            j(J, F),
                            U || null
                          );
                        }),
                        (v.TextBlob.MakeFromGlyphs = function (F, D) {
                          var U = Q(F, "HEAPU16");
                          return (
                            (D = v.TextBlob._MakeFromGlyphs(
                              U,
                              2 * F.length,
                              D
                            )),
                            j(U, F),
                            D || null
                          );
                        }),
                        (v.TextBlob.MakeFromText = function (F, D) {
                          var U = pr(F) + 1,
                            J = v._malloc(U);
                          return (
                            Jt(F, R, J, U),
                            (F = v.TextBlob._MakeFromText(J, U - 1, D)),
                            v._free(J),
                            F || null
                          );
                        }),
                        (v.MallocGlyphIDs = function (F) {
                          return v.Malloc(Uint16Array, F);
                        });
                    }),
                    (v.Id = v.Id || []),
                    v.Id.push(function () {
                      v.MakePicture = function (F) {
                        F = new Uint8Array(F);
                        var D = v._malloc(F.byteLength);
                        return (
                          v.HEAPU8.set(F, D),
                          (F = v._MakePicture(D, F.byteLength)) ? F : null
                        );
                      };
                    }),
                    (v.Id = v.Id || []),
                    v.Id.push(function () {
                      (v.RuntimeEffect.Make = function (F, D) {
                        return v.RuntimeEffect._Make(F, {
                          onError:
                            D ||
                            function (U) {
                              console.log("RuntimeEffect error", U);
                            },
                        });
                      }),
                        (v.RuntimeEffect.MakeForBlender = function (F, D) {
                          return v.RuntimeEffect._MakeForBlender(F, {
                            onError:
                              D ||
                              function (U) {
                                console.log("RuntimeEffect error", U);
                              },
                          });
                        }),
                        (v.RuntimeEffect.prototype.makeShader = function (
                          F,
                          D
                        ) {
                          var U = !F._ck,
                            J = Q(F, "HEAPF32");
                          return (
                            (D = le(D)), this._makeShader(J, 4 * F.length, U, D)
                          );
                        }),
                        (v.RuntimeEffect.prototype.makeShaderWithChildren =
                          function (F, D, U) {
                            var J = !F._ck,
                              fe = Q(F, "HEAPF32");
                            U = le(U);
                            for (var Pe = [], He = 0; He < D.length; He++)
                              Pe.push(D[He].Dd.Hd);
                            return (
                              (D = Q(Pe, "HEAPU32")),
                              this._makeShaderWithChildren(
                                fe,
                                4 * F.length,
                                J,
                                D,
                                Pe.length,
                                U
                              )
                            );
                          }),
                        (v.RuntimeEffect.prototype.makeBlender = function (F) {
                          var D = !F._ck,
                            U = Q(F, "HEAPF32");
                          return this._makeBlender(U, 4 * F.length, D);
                        });
                    });
                })(a);
              var l = Object.assign({}, a),
                h = "./this.program",
                u = typeof window == "object",
                c = typeof importScripts == "function",
                d =
                  typeof process == "object" &&
                  typeof process.versions == "object" &&
                  typeof process.versions.node == "string",
                p = "",
                f,
                m,
                g;
              if (d) {
                var y = Bw("fs"),
                  x = Bw("path");
                (p = c ? x.dirname(p) + "/" : __dirname + "/"),
                  (f = (v, w) => (
                    (v = v.startsWith("file://") ? new URL(v) : x.normalize(v)),
                    y.readFileSync(v, w ? void 0 : "utf8")
                  )),
                  (g = (v) => (
                    (v = f(v, !0)), v.buffer || (v = new Uint8Array(v)), v
                  )),
                  (m = (v, w, E, O = !0) => {
                    (v = v.startsWith("file://") ? new URL(v) : x.normalize(v)),
                      y.readFile(v, O ? void 0 : "utf8", (B, j) => {
                        B ? E(B) : w(O ? j.buffer : j);
                      });
                  }),
                  !a.thisProgram &&
                    1 < process.argv.length &&
                    (h = process.argv[1].replace(/\\/g, "/")),
                  process.argv.slice(2),
                  (a.inspect = () => "[Emscripten Module object]");
              } else
                (u || c) &&
                  (c
                    ? (p = self.location.href)
                    : typeof document < "u" &&
                      document.currentScript &&
                      (p = document.currentScript.src),
                  r && (p = r),
                  p.indexOf("blob:") !== 0
                    ? (p = p.substr(
                        0,
                        p.replace(/[?#].*/, "").lastIndexOf("/") + 1
                      ))
                    : (p = ""),
                  (f = (v) => {
                    var w = new XMLHttpRequest();
                    return w.open("GET", v, !1), w.send(null), w.responseText;
                  }),
                  c &&
                    (g = (v) => {
                      var w = new XMLHttpRequest();
                      return (
                        w.open("GET", v, !1),
                        (w.responseType = "arraybuffer"),
                        w.send(null),
                        new Uint8Array(w.response)
                      );
                    }),
                  (m = (v, w, E) => {
                    var O = new XMLHttpRequest();
                    O.open("GET", v, !0),
                      (O.responseType = "arraybuffer"),
                      (O.onload = () => {
                        O.status == 200 || (O.status == 0 && O.response)
                          ? w(O.response)
                          : E();
                      }),
                      (O.onerror = E),
                      O.send(null);
                  }));
              var b = a.print || console.log.bind(console),
                _ = a.printErr || console.error.bind(console);
              Object.assign(a, l),
                (l = null),
                a.thisProgram && (h = a.thisProgram);
              var S;
              a.wasmBinary && (S = a.wasmBinary);
              var M = a.noExitRuntime || !0;
              typeof WebAssembly != "object" &&
                Ee("no native wasm support detected");
              var C,
                A,
                T = !1,
                P,
                R,
                z,
                N,
                L,
                G,
                Y,
                Z;
              function q() {
                var v = C.buffer;
                (a.HEAP8 = P = new Int8Array(v)),
                  (a.HEAP16 = z = new Int16Array(v)),
                  (a.HEAP32 = L = new Int32Array(v)),
                  (a.HEAPU8 = R = new Uint8Array(v)),
                  (a.HEAPU16 = N = new Uint16Array(v)),
                  (a.HEAPU32 = G = new Uint32Array(v)),
                  (a.HEAPF32 = Y = new Float32Array(v)),
                  (a.HEAPF64 = Z = new Float64Array(v));
              }
              var oe,
                ce = [],
                ie = [],
                te = [];
              function ue() {
                var v = a.preRun.shift();
                ce.unshift(v);
              }
              var ae = 0,
                de = null,
                ne = null;
              function Ee(v) {
                throw (
                  (a.onAbort && a.onAbort(v),
                  (v = "Aborted(" + v + ")"),
                  _(v),
                  (T = !0),
                  (v = new WebAssembly.RuntimeError(
                    v + ". Build with -sASSERTIONS for more info."
                  )),
                  o(v),
                  v)
                );
              }
              function me(v) {
                return v.startsWith("data:application/octet-stream;base64,");
              }
              var Ae;
              if (((Ae = "canvaskit.wasm"), !me(Ae))) {
                var ye = Ae;
                Ae = a.locateFile ? a.locateFile(ye, p) : p + ye;
              }
              function Ue(v) {
                if (v == Ae && S) return new Uint8Array(S);
                if (g) return g(v);
                throw "both async and sync fetching of the wasm failed";
              }
              function Le(v) {
                if (!S && (u || c)) {
                  if (typeof fetch == "function" && !v.startsWith("file://"))
                    return fetch(v, { credentials: "same-origin" })
                      .then((w) => {
                        if (!w.ok)
                          throw (
                            "failed to load wasm binary file at '" + v + "'"
                          );
                        return w.arrayBuffer();
                      })
                      .catch(() => Ue(v));
                  if (m)
                    return new Promise((w, E) => {
                      m(v, (O) => w(new Uint8Array(O)), E);
                    });
                }
                return Promise.resolve().then(() => Ue(v));
              }
              function Te(v, w, E) {
                return Le(v)
                  .then((O) => WebAssembly.instantiate(O, w))
                  .then((O) => O)
                  .then(E, (O) => {
                    _("failed to asynchronously prepare wasm: " + O), Ee(O);
                  });
              }
              function tt(v, w) {
                var E = Ae;
                return S ||
                  typeof WebAssembly.instantiateStreaming != "function" ||
                  me(E) ||
                  E.startsWith("file://") ||
                  d ||
                  typeof fetch != "function"
                  ? Te(E, v, w)
                  : fetch(E, { credentials: "same-origin" }).then((O) =>
                      WebAssembly.instantiateStreaming(O, v).then(
                        w,
                        function (B) {
                          return (
                            _("wasm streaming compile failed: " + B),
                            _("falling back to ArrayBuffer instantiation"),
                            Te(E, v, w)
                          );
                        }
                      )
                    );
              }
              var Je = (v) => {
                  for (; 0 < v.length; ) v.shift()(a);
                },
                rt =
                  typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
                st = (v, w, E) => {
                  var O = w + E;
                  for (E = w; v[E] && !(E >= O); ) ++E;
                  if (16 < E - w && v.buffer && rt)
                    return rt.decode(v.subarray(w, E));
                  for (O = ""; w < E; ) {
                    var B = v[w++];
                    if (B & 128) {
                      var j = v[w++] & 63;
                      if ((B & 224) == 192)
                        O += String.fromCharCode(((B & 31) << 6) | j);
                      else {
                        var Q = v[w++] & 63;
                        (B =
                          (B & 240) == 224
                            ? ((B & 15) << 12) | (j << 6) | Q
                            : ((B & 7) << 18) |
                              (j << 12) |
                              (Q << 6) |
                              (v[w++] & 63)),
                          65536 > B
                            ? (O += String.fromCharCode(B))
                            : ((B -= 65536),
                              (O += String.fromCharCode(
                                55296 | (B >> 10),
                                56320 | (B & 1023)
                              )));
                      }
                    } else O += String.fromCharCode(B);
                  }
                  return O;
                },
                Ze = {};
              function Qe(v) {
                for (; v.length; ) {
                  var w = v.pop();
                  v.pop()(w);
                }
              }
              function pt(v) {
                return this.fromWireType(L[v >> 2]);
              }
              var bt = {},
                $ = {},
                W = {},
                _e = void 0;
              function Ge(v) {
                throw new _e(v);
              }
              function V(v, w, E) {
                function O(K) {
                  (K = E(K)),
                    K.length !== v.length &&
                      Ge("Mismatched type converter count");
                  for (var le = 0; le < v.length; ++le) at(v[le], K[le]);
                }
                v.forEach(function (K) {
                  W[K] = w;
                });
                var B = Array(w.length),
                  j = [],
                  Q = 0;
                w.forEach((K, le) => {
                  $.hasOwnProperty(K)
                    ? (B[le] = $[K])
                    : (j.push(K),
                      bt.hasOwnProperty(K) || (bt[K] = []),
                      bt[K].push(() => {
                        (B[le] = $[K]), ++Q, Q === j.length && O(B);
                      }));
                }),
                  j.length === 0 && O(B);
              }
              function De(v) {
                switch (v) {
                  case 1:
                    return 0;
                  case 2:
                    return 1;
                  case 4:
                    return 2;
                  case 8:
                    return 3;
                  default:
                    throw new TypeError(`Unknown type size: ${v}`);
                }
              }
              var ct = void 0;
              function We(v) {
                for (var w = ""; R[v]; ) w += ct[R[v++]];
                return w;
              }
              var Be = void 0;
              function Fe(v) {
                throw new Be(v);
              }
              function ut(v, w, E = {}) {
                var O = w.name;
                if (
                  (v ||
                    Fe(
                      `type "${O}" must have a positive integer typeid pointer`
                    ),
                  $.hasOwnProperty(v))
                ) {
                  if (E.af) return;
                  Fe(`Cannot register type '${O}' twice`);
                }
                ($[v] = w),
                  delete W[v],
                  bt.hasOwnProperty(v) &&
                    ((w = bt[v]), delete bt[v], w.forEach((B) => B()));
              }
              function at(v, w, E = {}) {
                if (!("argPackAdvance" in w))
                  throw new TypeError(
                    "registerType registeredInstance requires argPackAdvance"
                  );
                ut(v, w, E);
              }
              function wt(v) {
                Fe(v.Dd.Jd.Gd.name + " instance already deleted");
              }
              var xt = !1;
              function ii() {}
              function ui(v) {
                --v.count.value,
                  v.count.value === 0 &&
                    (v.Ld ? v.Pd.Td(v.Ld) : v.Jd.Gd.Td(v.Hd));
              }
              function ei(v, w, E) {
                return w === E
                  ? v
                  : E.Md === void 0
                  ? null
                  : ((v = ei(v, w, E.Md)), v === null ? null : E.Te(v));
              }
              var ge = {},
                Ce = [];
              function Ye() {
                for (; Ce.length; ) {
                  var v = Ce.pop();
                  (v.Dd.$d = !1), v.delete();
                }
              }
              var Ke = void 0,
                gt = {};
              function Mt(v, w) {
                for (w === void 0 && Fe("ptr should not be undefined"); v.Md; )
                  (w = v.ge(w)), (v = v.Md);
                return gt[w];
              }
              function yi(v, w) {
                return (
                  (w.Jd && w.Hd) ||
                    Ge("makeClassHandle requires ptr and ptrType"),
                  !!w.Pd != !!w.Ld &&
                    Ge("Both smartPtrType and smartPtr must be specified"),
                  (w.count = { value: 1 }),
                  ki(Object.create(v, { Dd: { value: w } }))
                );
              }
              function ki(v) {
                return typeof FinalizationRegistry > "u"
                  ? ((ki = (w) => w), v)
                  : ((xt = new FinalizationRegistry((w) => {
                      ui(w.Dd);
                    })),
                    (ki = (w) => {
                      var E = w.Dd;
                      return E.Ld && xt.register(w, { Dd: E }, w), w;
                    }),
                    (ii = (w) => {
                      xt.unregister(w);
                    }),
                    ki(v));
              }
              function Ar() {}
              function Si(v) {
                if (v === void 0) return "_unknown";
                v = v.replace(/[^a-zA-Z0-9_]/g, "$");
                var w = v.charCodeAt(0);
                return 48 <= w && 57 >= w ? `_${v}` : v;
              }
              function Jr(v, w) {
                return (
                  (v = Si(v)),
                  {
                    [v]: function () {
                      return w.apply(this, arguments);
                    },
                  }[v]
                );
              }
              function Mr(v, w, E) {
                if (v[w].Kd === void 0) {
                  var O = v[w];
                  (v[w] = function () {
                    return (
                      v[w].Kd.hasOwnProperty(arguments.length) ||
                        Fe(
                          `Function '${E}' called with an invalid number of arguments (${arguments.length}) - expects one of (${v[w].Kd})!`
                        ),
                      v[w].Kd[arguments.length].apply(this, arguments)
                    );
                  }),
                    (v[w].Kd = []),
                    (v[w].Kd[O.Yd] = O);
                }
              }
              function Po(v, w, E) {
                a.hasOwnProperty(v)
                  ? ((E === void 0 ||
                      (a[v].Kd !== void 0 && a[v].Kd[E] !== void 0)) &&
                      Fe(`Cannot register public name '${v}' twice`),
                    Mr(a, v, v),
                    a.hasOwnProperty(E) &&
                      Fe(
                        `Cannot register multiple overloads of a function with the same number of arguments (${E})!`
                      ),
                    (a[v].Kd[E] = w))
                  : ((a[v] = w), E !== void 0 && (a[v].sf = E));
              }
              function Mu(v, w, E, O, B, j, Q, K) {
                (this.name = v),
                  (this.constructor = w),
                  (this.ae = E),
                  (this.Td = O),
                  (this.Md = B),
                  (this.We = j),
                  (this.ge = Q),
                  (this.Te = K),
                  (this.ef = []);
              }
              function wl(v, w, E) {
                for (; w !== E; )
                  w.ge ||
                    Fe(
                      `Expected null or instance of ${E.name}, got an instance of ${w.name}`
                    ),
                    (v = w.ge(v)),
                    (w = w.Md);
                return v;
              }
              function Ch(v, w) {
                return w === null
                  ? (this.ue && Fe(`null is not a valid ${this.name}`), 0)
                  : (w.Dd || Fe(`Cannot pass "${tn(w)}" as a ${this.name}`),
                    w.Dd.Hd ||
                      Fe(
                        `Cannot pass deleted object as a pointer of type ${this.name}`
                      ),
                    wl(w.Dd.Hd, w.Dd.Jd.Gd, this.Gd));
              }
              function ee(v, w) {
                if (w === null) {
                  if (
                    (this.ue && Fe(`null is not a valid ${this.name}`), this.le)
                  ) {
                    var E = this.ve();
                    return v !== null && v.push(this.Td, E), E;
                  }
                  return 0;
                }
                if (
                  (w.Dd || Fe(`Cannot pass "${tn(w)}" as a ${this.name}`),
                  w.Dd.Hd ||
                    Fe(
                      `Cannot pass deleted object as a pointer of type ${this.name}`
                    ),
                  !this.ke &&
                    w.Dd.Jd.ke &&
                    Fe(
                      `Cannot convert argument of type ${
                        w.Dd.Pd ? w.Dd.Pd.name : w.Dd.Jd.name
                      } to parameter type ${this.name}`
                    ),
                  (E = wl(w.Dd.Hd, w.Dd.Jd.Gd, this.Gd)),
                  this.le)
                )
                  switch (
                    (w.Dd.Ld === void 0 &&
                      Fe("Passing raw pointer to smart pointer is illegal"),
                    this.kf)
                  ) {
                    case 0:
                      w.Dd.Pd === this
                        ? (E = w.Dd.Ld)
                        : Fe(
                            `Cannot convert argument of type ${
                              w.Dd.Pd ? w.Dd.Pd.name : w.Dd.Jd.name
                            } to parameter type ${this.name}`
                          );
                      break;
                    case 1:
                      E = w.Dd.Ld;
                      break;
                    case 2:
                      if (w.Dd.Pd === this) E = w.Dd.Ld;
                      else {
                        var O = w.clone();
                        (E = this.ff(
                          E,
                          Qi(function () {
                            O.delete();
                          })
                        )),
                          v !== null && v.push(this.Td, E);
                      }
                      break;
                    default:
                      Fe("Unsupporting sharing policy");
                  }
                return E;
              }
              function Se(v, w) {
                return w === null
                  ? (this.ue && Fe(`null is not a valid ${this.name}`), 0)
                  : (w.Dd || Fe(`Cannot pass "${tn(w)}" as a ${this.name}`),
                    w.Dd.Hd ||
                      Fe(
                        `Cannot pass deleted object as a pointer of type ${this.name}`
                      ),
                    w.Dd.Jd.ke &&
                      Fe(
                        `Cannot convert argument of type ${w.Dd.Jd.name} to parameter type ${this.name}`
                      ),
                    wl(w.Dd.Hd, w.Dd.Jd.Gd, this.Gd));
              }
              function Oe(v, w, E, O, B, j, Q, K, le, Ie, Ne) {
                (this.name = v),
                  (this.Gd = w),
                  (this.ue = E),
                  (this.ke = O),
                  (this.le = B),
                  (this.df = j),
                  (this.kf = Q),
                  (this.Ee = K),
                  (this.ve = le),
                  (this.ff = Ie),
                  (this.Td = Ne),
                  B || w.Md !== void 0
                    ? (this.toWireType = ee)
                    : ((this.toWireType = O ? Ch : Se), (this.Od = null));
              }
              function we(v, w, E) {
                a.hasOwnProperty(v) ||
                  Ge("Replacing nonexistant public symbol"),
                  a[v].Kd !== void 0 && E !== void 0
                    ? (a[v].Kd[E] = w)
                    : ((a[v] = w), (a[v].Yd = E));
              }
              var ze = (v, w) => {
                var E = [];
                return function () {
                  if (
                    ((E.length = 0),
                    Object.assign(E, arguments),
                    v.includes("j"))
                  ) {
                    var O = a["dynCall_" + v];
                    O =
                      E && E.length
                        ? O.apply(null, [w].concat(E))
                        : O.call(null, w);
                  } else O = oe.get(w).apply(null, E);
                  return O;
                };
              };
              function nt(v, w) {
                v = We(v);
                var E = v.includes("j") ? ze(v, w) : oe.get(w);
                return (
                  typeof E != "function" &&
                    Fe(`unknown function pointer with signature ${v}: ${w}`),
                  E
                );
              }
              var Bt = void 0;
              function qt(v) {
                v = Mw(v);
                var w = We(v);
                return Hn(v), w;
              }
              function kt(v, w) {
                function E(j) {
                  B[j] ||
                    $[j] ||
                    (W[j] ? W[j].forEach(E) : (O.push(j), (B[j] = !0)));
                }
                var O = [],
                  B = {};
                throw (w.forEach(E), new Bt(`${v}: ` + O.map(qt).join([", "])));
              }
              function hi(v, w, E, O, B) {
                var j = w.length;
                2 > j &&
                  Fe(
                    "argTypes array size mismatch! Must at least get return value and 'this' types!"
                  );
                var Q = w[1] !== null && E !== null,
                  K = !1;
                for (E = 1; E < w.length; ++E)
                  if (w[E] !== null && w[E].Od === void 0) {
                    K = !0;
                    break;
                  }
                var le = w[0].name !== "void",
                  Ie = j - 2,
                  Ne = Array(Ie),
                  $e = [],
                  ft = [];
                return function () {
                  if (
                    (arguments.length !== Ie &&
                      Fe(
                        `function ${v} called with ${arguments.length} arguments, expected ${Ie} args!`
                      ),
                    (ft.length = 0),
                    ($e.length = Q ? 2 : 1),
                    ($e[0] = B),
                    Q)
                  ) {
                    var xe = w[1].toWireType(ft, this);
                    $e[1] = xe;
                  }
                  for (var vt = 0; vt < Ie; ++vt)
                    (Ne[vt] = w[vt + 2].toWireType(ft, arguments[vt])),
                      $e.push(Ne[vt]);
                  if (((vt = O.apply(null, $e)), K)) Qe(ft);
                  else
                    for (var Ut = Q ? 1 : 2; Ut < w.length; Ut++) {
                      var Hi = Ut === 1 ? xe : Ne[Ut - 2];
                      w[Ut].Od !== null && w[Ut].Od(Hi);
                    }
                  return (xe = le ? w[0].fromWireType(vt) : void 0), xe;
                };
              }
              function ti(v, w) {
                for (var E = [], O = 0; O < v; O++) E.push(G[(w + 4 * O) >> 2]);
                return E;
              }
              function Zt() {
                (this.Sd = [void 0]), (this.Ce = []);
              }
              var pi = new Zt();
              function Er(v) {
                v >= pi.be && --pi.get(v).Fe === 0 && pi.Je(v);
              }
              var Vi = (v) => (
                  v || Fe("Cannot use deleted val. handle = " + v),
                  pi.get(v).value
                ),
                Qi = (v) => {
                  switch (v) {
                    case void 0:
                      return 1;
                    case null:
                      return 2;
                    case !0:
                      return 3;
                    case !1:
                      return 4;
                    default:
                      return pi.Ie({ Fe: 1, value: v });
                  }
                };
              function Li(v, w, E) {
                switch (w) {
                  case 0:
                    return function (O) {
                      return this.fromWireType((E ? P : R)[O]);
                    };
                  case 1:
                    return function (O) {
                      return this.fromWireType((E ? z : N)[O >> 1]);
                    };
                  case 2:
                    return function (O) {
                      return this.fromWireType((E ? L : G)[O >> 2]);
                    };
                  default:
                    throw new TypeError("Unknown integer type: " + v);
                }
              }
              function _t(v, w) {
                var E = $[v];
                return E === void 0 && Fe(w + " has unknown type " + qt(v)), E;
              }
              function tn(v) {
                if (v === null) return "null";
                var w = typeof v;
                return w === "object" || w === "array" || w === "function"
                  ? v.toString()
                  : "" + v;
              }
              function ta(v, w) {
                switch (w) {
                  case 2:
                    return function (E) {
                      return this.fromWireType(Y[E >> 2]);
                    };
                  case 3:
                    return function (E) {
                      return this.fromWireType(Z[E >> 3]);
                    };
                  default:
                    throw new TypeError("Unknown float type: " + v);
                }
              }
              function ia(v, w, E) {
                switch (w) {
                  case 0:
                    return E
                      ? function (O) {
                          return P[O];
                        }
                      : function (O) {
                          return R[O];
                        };
                  case 1:
                    return E
                      ? function (O) {
                          return z[O >> 1];
                        }
                      : function (O) {
                          return N[O >> 1];
                        };
                  case 2:
                    return E
                      ? function (O) {
                          return L[O >> 2];
                        }
                      : function (O) {
                          return G[O >> 2];
                        };
                  default:
                    throw new TypeError("Unknown integer type: " + v);
                }
              }
              var Jt = (v, w, E, O) => {
                  if (!(0 < O)) return 0;
                  var B = E;
                  O = E + O - 1;
                  for (var j = 0; j < v.length; ++j) {
                    var Q = v.charCodeAt(j);
                    if (55296 <= Q && 57343 >= Q) {
                      var K = v.charCodeAt(++j);
                      Q = (65536 + ((Q & 1023) << 10)) | (K & 1023);
                    }
                    if (127 >= Q) {
                      if (E >= O) break;
                      w[E++] = Q;
                    } else {
                      if (2047 >= Q) {
                        if (E + 1 >= O) break;
                        w[E++] = 192 | (Q >> 6);
                      } else {
                        if (65535 >= Q) {
                          if (E + 2 >= O) break;
                          w[E++] = 224 | (Q >> 12);
                        } else {
                          if (E + 3 >= O) break;
                          (w[E++] = 240 | (Q >> 18)),
                            (w[E++] = 128 | ((Q >> 12) & 63));
                        }
                        w[E++] = 128 | ((Q >> 6) & 63);
                      }
                      w[E++] = 128 | (Q & 63);
                    }
                  }
                  return (w[E] = 0), E - B;
                },
                pr = (v) => {
                  for (var w = 0, E = 0; E < v.length; ++E) {
                    var O = v.charCodeAt(E);
                    127 >= O
                      ? w++
                      : 2047 >= O
                      ? (w += 2)
                      : 55296 <= O && 57343 >= O
                      ? ((w += 4), ++E)
                      : (w += 3);
                  }
                  return w;
                },
                Nn =
                  typeof TextDecoder < "u"
                    ? new TextDecoder("utf-16le")
                    : void 0,
                ir = (v, w) => {
                  for (var E = v >> 1, O = E + w / 2; !(E >= O) && N[E]; ) ++E;
                  if (((E <<= 1), 32 < E - v && Nn))
                    return Nn.decode(R.subarray(v, E));
                  for (E = "", O = 0; !(O >= w / 2); ++O) {
                    var B = z[(v + 2 * O) >> 1];
                    if (B == 0) break;
                    E += String.fromCharCode(B);
                  }
                  return E;
                },
                ra = (v, w, E) => {
                  if ((E === void 0 && (E = 2147483647), 2 > E)) return 0;
                  E -= 2;
                  var O = w;
                  E = E < 2 * v.length ? E / 2 : v.length;
                  for (var B = 0; B < E; ++B)
                    (z[w >> 1] = v.charCodeAt(B)), (w += 2);
                  return (z[w >> 1] = 0), w - O;
                },
                Un = (v) => 2 * v.length,
                ji = (v, w) => {
                  for (var E = 0, O = ""; !(E >= w / 4); ) {
                    var B = L[(v + 4 * E) >> 2];
                    if (B == 0) break;
                    ++E,
                      65536 <= B
                        ? ((B -= 65536),
                          (O += String.fromCharCode(
                            55296 | (B >> 10),
                            56320 | (B & 1023)
                          )))
                        : (O += String.fromCharCode(B));
                  }
                  return O;
                },
                Yt = (v, w, E) => {
                  if ((E === void 0 && (E = 2147483647), 4 > E)) return 0;
                  var O = w;
                  E = O + E - 4;
                  for (var B = 0; B < v.length; ++B) {
                    var j = v.charCodeAt(B);
                    if (55296 <= j && 57343 >= j) {
                      var Q = v.charCodeAt(++B);
                      j = (65536 + ((j & 1023) << 10)) | (Q & 1023);
                    }
                    if (((L[w >> 2] = j), (w += 4), w + 4 > E)) break;
                  }
                  return (L[w >> 2] = 0), w - O;
                },
                Eu = (v) => {
                  for (var w = 0, E = 0; E < v.length; ++E) {
                    var O = v.charCodeAt(E);
                    55296 <= O && 57343 >= O && ++E, (w += 4);
                  }
                  return w;
                },
                Vn = {};
              function _l(v) {
                var w = Vn[v];
                return w === void 0 ? We(v) : w;
              }
              var Pa = [];
              function k() {
                function v(w) {
                  w.$$$embind_global$$$ = w;
                  var E =
                    typeof $$$embind_global$$$ == "object" &&
                    w.$$$embind_global$$$ == w;
                  return E || delete w.$$$embind_global$$$, E;
                }
                if (typeof globalThis == "object") return globalThis;
                if (
                  typeof $$$embind_global$$$ == "object" ||
                  (typeof global == "object" && v(global)
                    ? ($$$embind_global$$$ = global)
                    : typeof self == "object" &&
                      v(self) &&
                      ($$$embind_global$$$ = self),
                  typeof $$$embind_global$$$ == "object")
                )
                  return $$$embind_global$$$;
                throw Error("unable to get global object.");
              }
              function H(v) {
                var w = Pa.length;
                return Pa.push(v), w;
              }
              function he(v, w) {
                for (var E = Array(v), O = 0; O < v; ++O)
                  E[O] = _t(G[(w + 4 * O) >> 2], "parameter " + O);
                return E;
              }
              var X = [];
              function ve(v) {
                var w = Array(v + 1);
                return function (E, O, B) {
                  w[0] = E;
                  for (var j = 0; j < v; ++j) {
                    var Q = _t(G[(O + 4 * j) >> 2], "parameter " + j);
                    (w[j + 1] = Q.readValueFromPointer(B)),
                      (B += Q.argPackAdvance);
                  }
                  return (E = new (E.bind.apply(E, w))()), Qi(E);
                };
              }
              var Xe = {};
              function Do(v) {
                var w = v.getExtension("ANGLE_instanced_arrays");
                w &&
                  ((v.vertexAttribDivisor = function (E, O) {
                    w.vertexAttribDivisorANGLE(E, O);
                  }),
                  (v.drawArraysInstanced = function (E, O, B, j) {
                    w.drawArraysInstancedANGLE(E, O, B, j);
                  }),
                  (v.drawElementsInstanced = function (E, O, B, j, Q) {
                    w.drawElementsInstancedANGLE(E, O, B, j, Q);
                  }));
              }
              function Cu(v) {
                var w = v.getExtension("OES_vertex_array_object");
                w &&
                  ((v.createVertexArray = function () {
                    return w.createVertexArrayOES();
                  }),
                  (v.deleteVertexArray = function (E) {
                    w.deleteVertexArrayOES(E);
                  }),
                  (v.bindVertexArray = function (E) {
                    w.bindVertexArrayOES(E);
                  }),
                  (v.isVertexArray = function (E) {
                    return w.isVertexArrayOES(E);
                  }));
              }
              function Th(v) {
                var w = v.getExtension("WEBGL_draw_buffers");
                w &&
                  (v.drawBuffers = function (E, O) {
                    w.drawBuffersWEBGL(E, O);
                  });
              }
              var Ph = 1,
                jn = [],
                xs = [],
                Sp = [],
                Tu = [],
                sa = [],
                Da = [],
                Ap = [],
                rn = [],
                Sl = [],
                Al = [],
                uw = {},
                dw = {},
                pw = 4;
              function Bi(v) {
                Mp || (Mp = v);
              }
              function Dh(v) {
                for (var w = Ph++, E = v.length; E < w; E++) v[E] = null;
                return w;
              }
              function JD(v, w) {
                v.be ||
                  ((v.be = v.getContext),
                  (v.getContext = function (O, B) {
                    return (
                      (B = v.be(O, B)),
                      (O == "webgl") == B instanceof WebGLRenderingContext
                        ? B
                        : null
                    );
                  }));
                var E =
                  1 < w.majorVersion
                    ? v.getContext("webgl2", w)
                    : v.getContext("webgl", w);
                return E ? $D(E, w) : 0;
              }
              function $D(v, w) {
                var E = Dh(rn),
                  O = {
                    handle: E,
                    attributes: w,
                    version: w.majorVersion,
                    Qd: v,
                  };
                return (
                  v.canvas && (v.canvas.Ke = O),
                  (rn[E] = O),
                  (typeof w.Ue > "u" || w.Ue) && eO(O),
                  E
                );
              }
              function fw(v) {
                return (Kt = rn[v]), (a.qf = pe = Kt && Kt.Qd), !(v && !pe);
              }
              function eO(v) {
                if ((v || (v = Kt), !v.bf)) {
                  v.bf = !0;
                  var w = v.Qd;
                  Do(w),
                    Cu(w),
                    Th(w),
                    (w.ze = w.getExtension(
                      "WEBGL_draw_instanced_base_vertex_base_instance"
                    )),
                    (w.De = w.getExtension(
                      "WEBGL_multi_draw_instanced_base_vertex_base_instance"
                    )),
                    2 <= v.version &&
                      (w.Ae = w.getExtension(
                        "EXT_disjoint_timer_query_webgl2"
                      )),
                    (2 > v.version || !w.Ae) &&
                      (w.Ae = w.getExtension("EXT_disjoint_timer_query")),
                    (w.rf = w.getExtension("WEBGL_multi_draw")),
                    (w.getSupportedExtensions() || []).forEach(function (E) {
                      E.includes("lose_context") ||
                        E.includes("debug") ||
                        w.getExtension(E);
                    });
                }
              }
              var Kt,
                Mp,
                Kg = {},
                mw = () => {
                  if (!Jg) {
                    var v = {
                        USER: "web_user",
                        LOGNAME: "web_user",
                        PATH: "/",
                        PWD: "/",
                        HOME: "/home/web_user",
                        LANG:
                          (
                            (typeof navigator == "object" &&
                              navigator.languages &&
                              navigator.languages[0]) ||
                            "C"
                          ).replace("-", "_") + ".UTF-8",
                        _: h || "./this.program",
                      },
                      w;
                    for (w in Kg)
                      Kg[w] === void 0 ? delete v[w] : (v[w] = Kg[w]);
                    var E = [];
                    for (w in v) E.push(`${w}=${v[w]}`);
                    Jg = E;
                  }
                  return Jg;
                },
                Jg,
                tO = [null, [], []];
              function gw(v) {
                pe.bindVertexArray(Ap[v]);
              }
              function vw(v, w) {
                for (var E = 0; E < v; E++) {
                  var O = L[(w + 4 * E) >> 2];
                  pe.deleteVertexArray(Ap[O]), (Ap[O] = null);
                }
              }
              var Ep = [];
              function yw(v, w, E, O) {
                pe.drawElements(v, w, E, O);
              }
              function Oh(v, w, E, O) {
                for (var B = 0; B < v; B++) {
                  var j = pe[E](),
                    Q = j && Dh(O);
                  j ? ((j.name = Q), (O[Q] = j)) : Bi(1282),
                    (L[(w + 4 * B) >> 2] = Q);
                }
              }
              function xw(v, w) {
                Oh(v, w, "createVertexArray", Ap);
              }
              function bw(v, w, E) {
                if (w) {
                  var O = void 0;
                  switch (v) {
                    case 36346:
                      O = 1;
                      break;
                    case 36344:
                      E != 0 && E != 1 && Bi(1280);
                      return;
                    case 34814:
                    case 36345:
                      O = 0;
                      break;
                    case 34466:
                      var B = pe.getParameter(34467);
                      O = B ? B.length : 0;
                      break;
                    case 33309:
                      if (2 > Kt.version) {
                        Bi(1282);
                        return;
                      }
                      O = 2 * (pe.getSupportedExtensions() || []).length;
                      break;
                    case 33307:
                    case 33308:
                      if (2 > Kt.version) {
                        Bi(1280);
                        return;
                      }
                      O = v == 33307 ? 3 : 0;
                  }
                  if (O === void 0)
                    switch (((B = pe.getParameter(v)), typeof B)) {
                      case "number":
                        O = B;
                        break;
                      case "boolean":
                        O = B ? 1 : 0;
                        break;
                      case "string":
                        Bi(1280);
                        return;
                      case "object":
                        if (B === null)
                          switch (v) {
                            case 34964:
                            case 35725:
                            case 34965:
                            case 36006:
                            case 36007:
                            case 32873:
                            case 34229:
                            case 36662:
                            case 36663:
                            case 35053:
                            case 35055:
                            case 36010:
                            case 35097:
                            case 35869:
                            case 32874:
                            case 36389:
                            case 35983:
                            case 35368:
                            case 34068:
                              O = 0;
                              break;
                            default:
                              Bi(1280);
                              return;
                          }
                        else {
                          if (
                            B instanceof Float32Array ||
                            B instanceof Uint32Array ||
                            B instanceof Int32Array ||
                            B instanceof Array
                          ) {
                            for (v = 0; v < B.length; ++v)
                              switch (E) {
                                case 0:
                                  L[(w + 4 * v) >> 2] = B[v];
                                  break;
                                case 2:
                                  Y[(w + 4 * v) >> 2] = B[v];
                                  break;
                                case 4:
                                  P[(w + v) >> 0] = B[v] ? 1 : 0;
                              }
                            return;
                          }
                          try {
                            O = B.name | 0;
                          } catch (j) {
                            Bi(1280),
                              _(
                                "GL_INVALID_ENUM in glGet" +
                                  E +
                                  "v: Unknown object returned from WebGL getParameter(" +
                                  v +
                                  ")! (error: " +
                                  j +
                                  ")"
                              );
                            return;
                          }
                        }
                        break;
                      default:
                        Bi(1280),
                          _(
                            "GL_INVALID_ENUM in glGet" +
                              E +
                              "v: Native code calling glGet" +
                              E +
                              "v(" +
                              v +
                              ") and it returns " +
                              B +
                              " of type " +
                              typeof B +
                              "!"
                          );
                        return;
                    }
                  switch (E) {
                    case 1:
                      (E = O),
                        (G[w >> 2] = E),
                        (G[(w + 4) >> 2] = (E - G[w >> 2]) / 4294967296);
                      break;
                    case 0:
                      L[w >> 2] = O;
                      break;
                    case 2:
                      Y[w >> 2] = O;
                      break;
                    case 4:
                      P[w >> 0] = O ? 1 : 0;
                  }
                } else Bi(1281);
              }
              var Pu = (v) => {
                var w = pr(v) + 1,
                  E = Dp(w);
                return E && Jt(v, R, E, w), E;
              };
              function ww(v) {
                return v.slice(-1) == "]" && v.lastIndexOf("[");
              }
              function Cp(v) {
                return (
                  (v -= 5120),
                  v == 0
                    ? P
                    : v == 1
                    ? R
                    : v == 2
                    ? z
                    : v == 4
                    ? L
                    : v == 6
                    ? Y
                    : v == 5 ||
                      v == 28922 ||
                      v == 28520 ||
                      v == 30779 ||
                      v == 30782
                    ? G
                    : N
                );
              }
              function $g(v, w, E, O, B) {
                v = Cp(v);
                var j = 31 - Math.clz32(v.BYTES_PER_ELEMENT),
                  Q = pw;
                return v.subarray(
                  B >> j,
                  (B +
                    O *
                      ((E *
                        ({
                          5: 3,
                          6: 4,
                          8: 2,
                          29502: 3,
                          29504: 4,
                          26917: 2,
                          26918: 2,
                          29846: 3,
                          29847: 4,
                        }[w - 6402] || 1) *
                        (1 << j) +
                        Q -
                        1) &
                        -Q)) >>
                    j
                );
              }
              function xi(v) {
                var w = pe.Re;
                if (w) {
                  var E = w.fe[v];
                  return (
                    typeof E == "number" &&
                      (w.fe[v] = E =
                        pe.getUniformLocation(
                          w,
                          w.Ge[v] + (0 < E ? "[" + E + "]" : "")
                        )),
                    E
                  );
                }
                Bi(1282);
              }
              var Oo = [],
                Du = [],
                Tp = (v) => v % 4 === 0 && (v % 100 !== 0 || v % 400 === 0),
                _w = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                Sw = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
              function iO(v) {
                var w = Array(pr(v) + 1);
                return Jt(v, w, 0, w.length), w;
              }
              var rO = (v, w, E, O) => {
                function B(xe, vt, Ut) {
                  for (
                    xe = typeof xe == "number" ? xe.toString() : xe || "";
                    xe.length < vt;

                  )
                    xe = Ut[0] + xe;
                  return xe;
                }
                function j(xe, vt) {
                  return B(xe, vt, "0");
                }
                function Q(xe, vt) {
                  function Ut(bs) {
                    return 0 > bs ? -1 : 0 < bs ? 1 : 0;
                  }
                  var Hi;
                  return (
                    (Hi = Ut(xe.getFullYear() - vt.getFullYear())) === 0 &&
                      (Hi = Ut(xe.getMonth() - vt.getMonth())) === 0 &&
                      (Hi = Ut(xe.getDate() - vt.getDate())),
                    Hi
                  );
                }
                function K(xe) {
                  switch (xe.getDay()) {
                    case 0:
                      return new Date(xe.getFullYear() - 1, 11, 29);
                    case 1:
                      return xe;
                    case 2:
                      return new Date(xe.getFullYear(), 0, 3);
                    case 3:
                      return new Date(xe.getFullYear(), 0, 2);
                    case 4:
                      return new Date(xe.getFullYear(), 0, 1);
                    case 5:
                      return new Date(xe.getFullYear() - 1, 11, 31);
                    case 6:
                      return new Date(xe.getFullYear() - 1, 11, 30);
                  }
                }
                function le(xe) {
                  var vt = xe.Vd;
                  for (
                    xe = new Date(new Date(xe.Wd + 1900, 0, 1).getTime());
                    0 < vt;

                  ) {
                    var Ut = xe.getMonth(),
                      Hi = (Tp(xe.getFullYear()) ? _w : Sw)[Ut];
                    if (vt > Hi - xe.getDate())
                      (vt -= Hi - xe.getDate() + 1),
                        xe.setDate(1),
                        11 > Ut
                          ? xe.setMonth(Ut + 1)
                          : (xe.setMonth(0),
                            xe.setFullYear(xe.getFullYear() + 1));
                    else {
                      xe.setDate(xe.getDate() + vt);
                      break;
                    }
                  }
                  return (
                    (Ut = new Date(xe.getFullYear() + 1, 0, 4)),
                    (vt = K(new Date(xe.getFullYear(), 0, 4))),
                    (Ut = K(Ut)),
                    0 >= Q(vt, xe)
                      ? 0 >= Q(Ut, xe)
                        ? xe.getFullYear() + 1
                        : xe.getFullYear()
                      : xe.getFullYear() - 1
                  );
                }
                var Ie = L[(O + 40) >> 2];
                (O = {
                  nf: L[O >> 2],
                  mf: L[(O + 4) >> 2],
                  pe: L[(O + 8) >> 2],
                  we: L[(O + 12) >> 2],
                  qe: L[(O + 16) >> 2],
                  Wd: L[(O + 20) >> 2],
                  Rd: L[(O + 24) >> 2],
                  Vd: L[(O + 28) >> 2],
                  uf: L[(O + 32) >> 2],
                  lf: L[(O + 36) >> 2],
                  pf: Ie && Ie ? st(R, Ie) : "",
                }),
                  (E = E ? st(R, E) : ""),
                  (Ie = {
                    "%c": "%a %b %d %H:%M:%S %Y",
                    "%D": "%m/%d/%y",
                    "%F": "%Y-%m-%d",
                    "%h": "%b",
                    "%r": "%I:%M:%S %p",
                    "%R": "%H:%M",
                    "%T": "%H:%M:%S",
                    "%x": "%m/%d/%y",
                    "%X": "%H:%M:%S",
                    "%Ec": "%c",
                    "%EC": "%C",
                    "%Ex": "%m/%d/%y",
                    "%EX": "%H:%M:%S",
                    "%Ey": "%y",
                    "%EY": "%Y",
                    "%Od": "%d",
                    "%Oe": "%e",
                    "%OH": "%H",
                    "%OI": "%I",
                    "%Om": "%m",
                    "%OM": "%M",
                    "%OS": "%S",
                    "%Ou": "%u",
                    "%OU": "%U",
                    "%OV": "%V",
                    "%Ow": "%w",
                    "%OW": "%W",
                    "%Oy": "%y",
                  });
                for (var Ne in Ie) E = E.replace(new RegExp(Ne, "g"), Ie[Ne]);
                var $e =
                    "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                      " "
                    ),
                  ft =
                    "January February March April May June July August September October November December".split(
                      " "
                    );
                (Ie = {
                  "%a": (xe) => $e[xe.Rd].substring(0, 3),
                  "%A": (xe) => $e[xe.Rd],
                  "%b": (xe) => ft[xe.qe].substring(0, 3),
                  "%B": (xe) => ft[xe.qe],
                  "%C": (xe) => j(((xe.Wd + 1900) / 100) | 0, 2),
                  "%d": (xe) => j(xe.we, 2),
                  "%e": (xe) => B(xe.we, 2, " "),
                  "%g": (xe) => le(xe).toString().substring(2),
                  "%G": (xe) => le(xe),
                  "%H": (xe) => j(xe.pe, 2),
                  "%I": (xe) => (
                    (xe = xe.pe),
                    xe == 0 ? (xe = 12) : 12 < xe && (xe -= 12),
                    j(xe, 2)
                  ),
                  "%j": (xe) => {
                    for (
                      var vt = 0, Ut = 0;
                      Ut <= xe.qe - 1;
                      vt += (Tp(xe.Wd + 1900) ? _w : Sw)[Ut++]
                    );
                    return j(xe.we + vt, 3);
                  },
                  "%m": (xe) => j(xe.qe + 1, 2),
                  "%M": (xe) => j(xe.mf, 2),
                  "%n": () => `
`,
                  "%p": (xe) => (0 <= xe.pe && 12 > xe.pe ? "AM" : "PM"),
                  "%S": (xe) => j(xe.nf, 2),
                  "%t": () => "	",
                  "%u": (xe) => xe.Rd || 7,
                  "%U": (xe) => j(Math.floor((xe.Vd + 7 - xe.Rd) / 7), 2),
                  "%V": (xe) => {
                    var vt = Math.floor((xe.Vd + 7 - ((xe.Rd + 6) % 7)) / 7);
                    if ((2 >= (xe.Rd + 371 - xe.Vd - 2) % 7 && vt++, vt))
                      vt == 53 &&
                        ((Ut = (xe.Rd + 371 - xe.Vd) % 7),
                        Ut == 4 || (Ut == 3 && Tp(xe.Wd)) || (vt = 1));
                    else {
                      vt = 52;
                      var Ut = (xe.Rd + 7 - xe.Vd - 1) % 7;
                      (Ut == 4 || (Ut == 5 && Tp((xe.Wd % 400) - 1))) && vt++;
                    }
                    return j(vt, 2);
                  },
                  "%w": (xe) => xe.Rd,
                  "%W": (xe) =>
                    j(Math.floor((xe.Vd + 7 - ((xe.Rd + 6) % 7)) / 7), 2),
                  "%y": (xe) => (xe.Wd + 1900).toString().substring(2),
                  "%Y": (xe) => xe.Wd + 1900,
                  "%z": (xe) => {
                    xe = xe.lf;
                    var vt = 0 <= xe;
                    return (
                      (xe = Math.abs(xe) / 60),
                      (vt ? "+" : "-") +
                        String("0000" + ((xe / 60) * 100 + (xe % 60))).slice(-4)
                    );
                  },
                  "%Z": (xe) => xe.pf,
                  "%%": () => "%",
                }),
                  (E = E.replace(/%%/g, "\0\0"));
                for (Ne in Ie)
                  E.includes(Ne) &&
                    (E = E.replace(new RegExp(Ne, "g"), Ie[Ne](O)));
                return (
                  (E = E.replace(/\0\0/g, "%")),
                  (Ne = iO(E)),
                  Ne.length > w ? 0 : (P.set(Ne, v), Ne.length - 1)
                );
              };
              _e = a.InternalError = class extends Error {
                constructor(v) {
                  super(v), (this.name = "InternalError");
                }
              };
              for (var Aw = Array(256), Pp = 0; 256 > Pp; ++Pp)
                Aw[Pp] = String.fromCharCode(Pp);
              (ct = Aw),
                (Be = a.BindingError =
                  class extends Error {
                    constructor(v) {
                      super(v), (this.name = "BindingError");
                    }
                  }),
                (Ar.prototype.isAliasOf = function (v) {
                  if (!(this instanceof Ar && v instanceof Ar)) return !1;
                  var w = this.Dd.Jd.Gd,
                    E = this.Dd.Hd,
                    O = v.Dd.Jd.Gd;
                  for (v = v.Dd.Hd; w.Md; ) (E = w.ge(E)), (w = w.Md);
                  for (; O.Md; ) (v = O.ge(v)), (O = O.Md);
                  return w === O && E === v;
                }),
                (Ar.prototype.clone = function () {
                  if ((this.Dd.Hd || wt(this), this.Dd.ee))
                    return (this.Dd.count.value += 1), this;
                  var v = ki,
                    w = Object,
                    E = w.create,
                    O = Object.getPrototypeOf(this),
                    B = this.Dd;
                  return (
                    (v = v(
                      E.call(w, O, {
                        Dd: {
                          value: {
                            count: B.count,
                            $d: B.$d,
                            ee: B.ee,
                            Hd: B.Hd,
                            Jd: B.Jd,
                            Ld: B.Ld,
                            Pd: B.Pd,
                          },
                        },
                      })
                    )),
                    (v.Dd.count.value += 1),
                    (v.Dd.$d = !1),
                    v
                  );
                }),
                (Ar.prototype.delete = function () {
                  this.Dd.Hd || wt(this),
                    this.Dd.$d &&
                      !this.Dd.ee &&
                      Fe("Object already scheduled for deletion"),
                    ii(this),
                    ui(this.Dd),
                    this.Dd.ee ||
                      ((this.Dd.Ld = void 0), (this.Dd.Hd = void 0));
                }),
                (Ar.prototype.isDeleted = function () {
                  return !this.Dd.Hd;
                }),
                (Ar.prototype.deleteLater = function () {
                  return (
                    this.Dd.Hd || wt(this),
                    this.Dd.$d &&
                      !this.Dd.ee &&
                      Fe("Object already scheduled for deletion"),
                    Ce.push(this),
                    Ce.length === 1 && Ke && Ke(Ye),
                    (this.Dd.$d = !0),
                    this
                  );
                }),
                (a.getInheritedInstanceCount = function () {
                  return Object.keys(gt).length;
                }),
                (a.getLiveInheritedInstances = function () {
                  var v = [],
                    w;
                  for (w in gt) gt.hasOwnProperty(w) && v.push(gt[w]);
                  return v;
                }),
                (a.flushPendingDeletes = Ye),
                (a.setDelayFunction = function (v) {
                  (Ke = v), Ce.length && Ke && Ke(Ye);
                }),
                (Oe.prototype.Xe = function (v) {
                  return this.Ee && (v = this.Ee(v)), v;
                }),
                (Oe.prototype.ye = function (v) {
                  this.Td && this.Td(v);
                }),
                (Oe.prototype.argPackAdvance = 8),
                (Oe.prototype.readValueFromPointer = pt),
                (Oe.prototype.deleteObject = function (v) {
                  v !== null && v.delete();
                }),
                (Oe.prototype.fromWireType = function (v) {
                  function w() {
                    return this.le
                      ? yi(this.Gd.ae, { Jd: this.df, Hd: E, Pd: this, Ld: v })
                      : yi(this.Gd.ae, { Jd: this, Hd: v });
                  }
                  var E = this.Xe(v);
                  if (!E) return this.ye(v), null;
                  var O = Mt(this.Gd, E);
                  if (O !== void 0)
                    return O.Dd.count.value === 0
                      ? ((O.Dd.Hd = E), (O.Dd.Ld = v), O.clone())
                      : ((O = O.clone()), this.ye(v), O);
                  if (((O = this.Gd.We(E)), (O = ge[O]), !O))
                    return w.call(this);
                  O = this.ke ? O.Qe : O.pointerType;
                  var B = ei(E, this.Gd, O.Gd);
                  return B === null
                    ? w.call(this)
                    : this.le
                    ? yi(O.Gd.ae, { Jd: O, Hd: B, Pd: this, Ld: v })
                    : yi(O.Gd.ae, { Jd: O, Hd: B });
                }),
                (Bt = a.UnboundTypeError =
                  (function (v, w) {
                    var E = Jr(w, function (O) {
                      (this.name = w),
                        (this.message = O),
                        (O = Error(O).stack),
                        O !== void 0 &&
                          (this.stack =
                            this.toString() +
                            `
` +
                            O.replace(/^Error(:[^\n]*)?\n/, ""));
                    });
                    return (
                      (E.prototype = Object.create(v.prototype)),
                      (E.prototype.constructor = E),
                      (E.prototype.toString = function () {
                        return this.message === void 0
                          ? this.name
                          : `${this.name}: ${this.message}`;
                      }),
                      E
                    );
                  })(Error, "UnboundTypeError")),
                Object.assign(Zt.prototype, {
                  get(v) {
                    return this.Sd[v];
                  },
                  has(v) {
                    return this.Sd[v] !== void 0;
                  },
                  Ie(v) {
                    var w = this.Ce.pop() || this.Sd.length;
                    return (this.Sd[w] = v), w;
                  },
                  Je(v) {
                    (this.Sd[v] = void 0), this.Ce.push(v);
                  },
                }),
                pi.Sd.push(
                  { value: void 0 },
                  { value: null },
                  { value: !0 },
                  { value: !1 }
                ),
                (pi.be = pi.Sd.length),
                (a.count_emval_handles = function () {
                  for (var v = 0, w = pi.be; w < pi.Sd.length; ++w)
                    pi.Sd[w] !== void 0 && ++v;
                  return v;
                });
              for (var pe, Ys = 0; 32 > Ys; ++Ys) Ep.push(Array(Ys));
              var sO = new Float32Array(288);
              for (Ys = 0; 288 > Ys; ++Ys) Oo[Ys] = sO.subarray(0, Ys + 1);
              var aO = new Int32Array(288);
              for (Ys = 0; 288 > Ys; ++Ys) Du[Ys] = aO.subarray(0, Ys + 1);
              var nO = {
                Q: function () {
                  return 0;
                },
                Ab: () => {},
                Cb: function () {
                  return 0;
                },
                xb: () => {},
                yb: () => {},
                R: function () {},
                zb: () => {},
                v: function (v) {
                  var w = Ze[v];
                  delete Ze[v];
                  var E = w.ve,
                    O = w.Td,
                    B = w.Be,
                    j = B.map((Q) => Q.$e).concat(B.map((Q) => Q.hf));
                  V([v], j, (Q) => {
                    var K = {};
                    return (
                      B.forEach((le, Ie) => {
                        var Ne = Q[Ie],
                          $e = le.Ye,
                          ft = le.Ze,
                          xe = Q[Ie + B.length],
                          vt = le.gf,
                          Ut = le.jf;
                        K[le.Ve] = {
                          read: (Hi) => Ne.fromWireType($e(ft, Hi)),
                          write: (Hi, bs) => {
                            var Fr = [];
                            vt(Ut, Hi, xe.toWireType(Fr, bs)), Qe(Fr);
                          },
                        };
                      }),
                      [
                        {
                          name: w.name,
                          fromWireType: function (le) {
                            var Ie = {},
                              Ne;
                            for (Ne in K) Ie[Ne] = K[Ne].read(le);
                            return O(le), Ie;
                          },
                          toWireType: function (le, Ie) {
                            for (var Ne in K)
                              if (!(Ne in Ie))
                                throw new TypeError(`Missing field: "${Ne}"`);
                            var $e = E();
                            for (Ne in K) K[Ne].write($e, Ie[Ne]);
                            return le !== null && le.push(O, $e), $e;
                          },
                          argPackAdvance: 8,
                          readValueFromPointer: pt,
                          Od: O,
                        },
                      ]
                    );
                  });
                },
                pb: function () {},
                Gb: function (v, w, E, O, B) {
                  var j = De(E);
                  (w = We(w)),
                    at(v, {
                      name: w,
                      fromWireType: function (Q) {
                        return !!Q;
                      },
                      toWireType: function (Q, K) {
                        return K ? O : B;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: function (Q) {
                        if (E === 1) var K = P;
                        else if (E === 2) K = z;
                        else if (E === 4) K = L;
                        else
                          throw new TypeError(
                            "Unknown boolean type size: " + w
                          );
                        return this.fromWireType(K[Q >> j]);
                      },
                      Od: null,
                    });
                },
                k: function (v, w, E, O, B, j, Q, K, le, Ie, Ne, $e, ft) {
                  (Ne = We(Ne)),
                    (j = nt(B, j)),
                    K && (K = nt(Q, K)),
                    Ie && (Ie = nt(le, Ie)),
                    (ft = nt($e, ft));
                  var xe = Si(Ne);
                  Po(xe, function () {
                    kt(`Cannot construct ${Ne} due to unbound types`, [O]);
                  }),
                    V([v, w, E], O ? [O] : [], function (vt) {
                      if (((vt = vt[0]), O))
                        var Ut = vt.Gd,
                          Hi = Ut.ae;
                      else Hi = Ar.prototype;
                      vt = Jr(xe, function () {
                        if (Object.getPrototypeOf(this) !== bs)
                          throw new Be("Use 'new' to construct " + Ne);
                        if (Fr.Ud === void 0)
                          throw new Be(Ne + " has no accessible constructor");
                        var Ih = Fr.Ud[arguments.length];
                        if (Ih === void 0)
                          throw new Be(
                            `Tried to invoke ctor of ${Ne} with invalid number of parameters (${
                              arguments.length
                            }) - expected (${Object.keys(
                              Fr.Ud
                            ).toString()}) parameters instead!`
                          );
                        return Ih.apply(this, arguments);
                      });
                      var bs = Object.create(Hi, {
                        constructor: { value: vt },
                      });
                      vt.prototype = bs;
                      var Fr = new Mu(Ne, vt, bs, ft, Ut, j, K, Ie);
                      Fr.Md &&
                        (Fr.Md.he === void 0 && (Fr.Md.he = []),
                        Fr.Md.he.push(Fr)),
                        (Ut = new Oe(Ne, Fr, !0, !1, !1)),
                        (Hi = new Oe(Ne + "*", Fr, !1, !1, !1));
                      var sn = new Oe(Ne + " const*", Fr, !1, !0, !1);
                      return (
                        (ge[v] = { pointerType: Hi, Qe: sn }),
                        we(xe, vt),
                        [Ut, Hi, sn]
                      );
                    });
                },
                f: function (v, w, E, O, B, j, Q) {
                  var K = ti(E, O);
                  (w = We(w)),
                    (j = nt(B, j)),
                    V([], [v], function (le) {
                      function Ie() {
                        kt(`Cannot call ${Ne} due to unbound types`, K);
                      }
                      le = le[0];
                      var Ne = `${le.name}.${w}`;
                      w.startsWith("@@") && (w = Symbol[w.substring(2)]);
                      var $e = le.Gd.constructor;
                      return (
                        $e[w] === void 0
                          ? ((Ie.Yd = E - 1), ($e[w] = Ie))
                          : (Mr($e, w, Ne), ($e[w].Kd[E - 1] = Ie)),
                        V([], K, function (ft) {
                          if (
                            ((ft = [ft[0], null].concat(ft.slice(1))),
                            (ft = hi(Ne, ft, null, j, Q)),
                            $e[w].Kd === void 0
                              ? ((ft.Yd = E - 1), ($e[w] = ft))
                              : ($e[w].Kd[E - 1] = ft),
                            le.Gd.he)
                          )
                            for (let xe of le.Gd.he)
                              xe.constructor.hasOwnProperty(w) ||
                                (xe.constructor[w] = ft);
                          return [];
                        }),
                        []
                      );
                    });
                },
                t: function (v, w, E, O, B, j) {
                  var Q = ti(w, E);
                  (B = nt(O, B)),
                    V([], [v], function (K) {
                      K = K[0];
                      var le = `constructor ${K.name}`;
                      if (
                        (K.Gd.Ud === void 0 && (K.Gd.Ud = []),
                        K.Gd.Ud[w - 1] !== void 0)
                      )
                        throw new Be(
                          `Cannot register multiple constructors with identical number of parameters (${
                            w - 1
                          }) for class '${
                            K.name
                          }'! Overload resolution is currently only performed using the parameter count, not actual type info!`
                        );
                      return (
                        (K.Gd.Ud[w - 1] = () => {
                          kt(
                            `Cannot construct ${K.name} due to unbound types`,
                            Q
                          );
                        }),
                        V([], Q, function (Ie) {
                          return (
                            Ie.splice(1, 0, null),
                            (K.Gd.Ud[w - 1] = hi(le, Ie, null, B, j)),
                            []
                          );
                        }),
                        []
                      );
                    });
                },
                b: function (v, w, E, O, B, j, Q, K) {
                  var le = ti(E, O);
                  (w = We(w)),
                    (j = nt(B, j)),
                    V([], [v], function (Ie) {
                      function Ne() {
                        kt(`Cannot call ${$e} due to unbound types`, le);
                      }
                      Ie = Ie[0];
                      var $e = `${Ie.name}.${w}`;
                      w.startsWith("@@") && (w = Symbol[w.substring(2)]),
                        K && Ie.Gd.ef.push(w);
                      var ft = Ie.Gd.ae,
                        xe = ft[w];
                      return (
                        xe === void 0 ||
                        (xe.Kd === void 0 &&
                          xe.className !== Ie.name &&
                          xe.Yd === E - 2)
                          ? ((Ne.Yd = E - 2),
                            (Ne.className = Ie.name),
                            (ft[w] = Ne))
                          : (Mr(ft, w, $e), (ft[w].Kd[E - 2] = Ne)),
                        V([], le, function (vt) {
                          return (
                            (vt = hi($e, vt, Ie, j, Q)),
                            ft[w].Kd === void 0
                              ? ((vt.Yd = E - 2), (ft[w] = vt))
                              : (ft[w].Kd[E - 2] = vt),
                            []
                          );
                        }),
                        []
                      );
                    });
                },
                o: function (v, w, E) {
                  (v = We(v)),
                    V([], [w], function (O) {
                      return (O = O[0]), (a[v] = O.fromWireType(E)), [];
                    });
                },
                Fb: function (v, w) {
                  (w = We(w)),
                    at(v, {
                      name: w,
                      fromWireType: function (E) {
                        var O = Vi(E);
                        return Er(E), O;
                      },
                      toWireType: function (E, O) {
                        return Qi(O);
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: pt,
                      Od: null,
                    });
                },
                j: function (v, w, E, O) {
                  function B() {}
                  (E = De(E)),
                    (w = We(w)),
                    (B.values = {}),
                    at(v, {
                      name: w,
                      constructor: B,
                      fromWireType: function (j) {
                        return this.constructor.values[j];
                      },
                      toWireType: function (j, Q) {
                        return Q.value;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: Li(w, E, O),
                      Od: null,
                    }),
                    Po(w, B);
                },
                c: function (v, w, E) {
                  var O = _t(v, "enum");
                  (w = We(w)),
                    (v = O.constructor),
                    (O = Object.create(O.constructor.prototype, {
                      value: { value: E },
                      constructor: {
                        value: Jr(`${O.name}_${w}`, function () {}),
                      },
                    })),
                    (v.values[E] = O),
                    (v[w] = O);
                },
                T: function (v, w, E) {
                  (E = De(E)),
                    (w = We(w)),
                    at(v, {
                      name: w,
                      fromWireType: function (O) {
                        return O;
                      },
                      toWireType: function (O, B) {
                        return B;
                      },
                      argPackAdvance: 8,
                      readValueFromPointer: ta(w, E),
                      Od: null,
                    });
                },
                r: function (v, w, E, O, B, j) {
                  var Q = ti(w, E);
                  (v = We(v)),
                    (B = nt(O, B)),
                    Po(
                      v,
                      function () {
                        kt(`Cannot call ${v} due to unbound types`, Q);
                      },
                      w - 1
                    ),
                    V([], Q, function (K) {
                      return (
                        (K = [K[0], null].concat(K.slice(1))),
                        we(v, hi(v, K, null, B, j), w - 1),
                        []
                      );
                    });
                },
                x: function (v, w, E, O, B) {
                  (w = We(w)), B === -1 && (B = 4294967295), (B = De(E));
                  var j = (K) => K;
                  if (O === 0) {
                    var Q = 32 - 8 * E;
                    j = (K) => (K << Q) >>> Q;
                  }
                  (E = w.includes("unsigned")
                    ? function (K, le) {
                        return le >>> 0;
                      }
                    : function (K, le) {
                        return le;
                      }),
                    at(v, {
                      name: w,
                      fromWireType: j,
                      toWireType: E,
                      argPackAdvance: 8,
                      readValueFromPointer: ia(w, B, O !== 0),
                      Od: null,
                    });
                },
                n: function (v, w, E) {
                  function O(j) {
                    j >>= 2;
                    var Q = G;
                    return new B(Q.buffer, Q[j + 1], Q[j]);
                  }
                  var B = [
                    Int8Array,
                    Uint8Array,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array,
                  ][w];
                  (E = We(E)),
                    at(
                      v,
                      {
                        name: E,
                        fromWireType: O,
                        argPackAdvance: 8,
                        readValueFromPointer: O,
                      },
                      { af: !0 }
                    );
                },
                m: function (v, w, E, O, B, j, Q, K, le, Ie, Ne, $e) {
                  (E = We(E)),
                    (j = nt(B, j)),
                    (K = nt(Q, K)),
                    (Ie = nt(le, Ie)),
                    ($e = nt(Ne, $e)),
                    V([v], [w], function (ft) {
                      return (
                        (ft = ft[0]),
                        [new Oe(E, ft.Gd, !1, !1, !0, ft, O, j, K, Ie, $e)]
                      );
                    });
                },
                S: function (v, w) {
                  w = We(w);
                  var E = w === "std::string";
                  at(v, {
                    name: w,
                    fromWireType: function (O) {
                      var B = G[O >> 2],
                        j = O + 4;
                      if (E)
                        for (var Q = j, K = 0; K <= B; ++K) {
                          var le = j + K;
                          if (K == B || R[le] == 0) {
                            if (
                              ((Q = Q ? st(R, Q, le - Q) : ""), Ie === void 0)
                            )
                              var Ie = Q;
                            else (Ie += String.fromCharCode(0)), (Ie += Q);
                            Q = le + 1;
                          }
                        }
                      else {
                        for (Ie = Array(B), K = 0; K < B; ++K)
                          Ie[K] = String.fromCharCode(R[j + K]);
                        Ie = Ie.join("");
                      }
                      return Hn(O), Ie;
                    },
                    toWireType: function (O, B) {
                      B instanceof ArrayBuffer && (B = new Uint8Array(B));
                      var j = typeof B == "string";
                      j ||
                        B instanceof Uint8Array ||
                        B instanceof Uint8ClampedArray ||
                        B instanceof Int8Array ||
                        Fe("Cannot pass non-string to std::string");
                      var Q = E && j ? pr(B) : B.length,
                        K = Dp(4 + Q + 1),
                        le = K + 4;
                      if (((G[K >> 2] = Q), E && j)) Jt(B, R, le, Q + 1);
                      else if (j)
                        for (j = 0; j < Q; ++j) {
                          var Ie = B.charCodeAt(j);
                          255 < Ie &&
                            (Hn(le),
                            Fe(
                              "String has UTF-16 code units that do not fit in 8 bits"
                            )),
                            (R[le + j] = Ie);
                        }
                      else for (j = 0; j < Q; ++j) R[le + j] = B[j];
                      return O !== null && O.push(Hn, K), K;
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: pt,
                    Od: function (O) {
                      Hn(O);
                    },
                  });
                },
                K: function (v, w, E) {
                  if (((E = We(E)), w === 2))
                    var O = ir,
                      B = ra,
                      j = Un,
                      Q = () => N,
                      K = 1;
                  else
                    w === 4 &&
                      ((O = ji), (B = Yt), (j = Eu), (Q = () => G), (K = 2));
                  at(v, {
                    name: E,
                    fromWireType: function (le) {
                      for (
                        var Ie = G[le >> 2], Ne = Q(), $e, ft = le + 4, xe = 0;
                        xe <= Ie;
                        ++xe
                      ) {
                        var vt = le + 4 + xe * w;
                        (xe == Ie || Ne[vt >> K] == 0) &&
                          ((ft = O(ft, vt - ft)),
                          $e === void 0
                            ? ($e = ft)
                            : (($e += String.fromCharCode(0)), ($e += ft)),
                          (ft = vt + w));
                      }
                      return Hn(le), $e;
                    },
                    toWireType: function (le, Ie) {
                      typeof Ie != "string" &&
                        Fe(`Cannot pass non-string to C++ string type ${E}`);
                      var Ne = j(Ie),
                        $e = Dp(4 + Ne + w);
                      return (
                        (G[$e >> 2] = Ne >> K),
                        B(Ie, $e + 4, Ne + w),
                        le !== null && le.push(Hn, $e),
                        $e
                      );
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: pt,
                    Od: function (le) {
                      Hn(le);
                    },
                  });
                },
                w: function (v, w, E, O, B, j) {
                  Ze[v] = { name: We(w), ve: nt(E, O), Td: nt(B, j), Be: [] };
                },
                e: function (v, w, E, O, B, j, Q, K, le, Ie) {
                  Ze[v].Be.push({
                    Ve: We(w),
                    $e: E,
                    Ye: nt(O, B),
                    Ze: j,
                    hf: Q,
                    gf: nt(K, le),
                    jf: Ie,
                  });
                },
                Hb: function (v, w) {
                  (w = We(w)),
                    at(v, {
                      cf: !0,
                      name: w,
                      argPackAdvance: 0,
                      fromWireType: function () {},
                      toWireType: function () {},
                    });
                },
                Eb: () => !0,
                tb: () => {
                  throw 1 / 0;
                },
                y: function (v, w, E) {
                  (v = Vi(v)), (w = _t(w, "emval::as"));
                  var O = [],
                    B = Qi(O);
                  return (G[E >> 2] = B), w.toWireType(O, v);
                },
                Y: function (v, w, E, O, B) {
                  (v = Pa[v]), (w = Vi(w)), (E = _l(E));
                  var j = [];
                  return (G[O >> 2] = Qi(j)), v(w, E, j, B);
                },
                q: function (v, w, E, O) {
                  (v = Pa[v]), (w = Vi(w)), (E = _l(E)), v(w, E, null, O);
                },
                d: Er,
                H: function (v) {
                  return v === 0 ? Qi(k()) : ((v = _l(v)), Qi(k()[v]));
                },
                p: function (v, w) {
                  var E = he(v, w),
                    O = E[0];
                  w =
                    O.name +
                    "_$" +
                    E.slice(1)
                      .map(function (Q) {
                        return Q.name;
                      })
                      .join("_") +
                    "$";
                  var B = X[w];
                  if (B !== void 0) return B;
                  var j = Array(v - 1);
                  return (
                    (B = H((Q, K, le, Ie) => {
                      for (var Ne = 0, $e = 0; $e < v - 1; ++$e)
                        (j[$e] = E[$e + 1].readValueFromPointer(Ie + Ne)),
                          (Ne += E[$e + 1].argPackAdvance);
                      for (Q = Q[K].apply(Q, j), $e = 0; $e < v - 1; ++$e)
                        E[$e + 1].Se && E[$e + 1].Se(j[$e]);
                      if (!O.cf) return O.toWireType(le, Q);
                    })),
                    (X[w] = B)
                  );
                },
                s: function (v, w) {
                  return (v = Vi(v)), (w = Vi(w)), Qi(v[w]);
                },
                l: function (v) {
                  4 < v && (pi.get(v).Fe += 1);
                },
                G: function (v, w, E, O) {
                  v = Vi(v);
                  var B = Xe[w];
                  return B || ((B = ve(w)), (Xe[w] = B)), B(v, E, O);
                },
                C: function () {
                  return Qi([]);
                },
                g: function (v) {
                  return Qi(_l(v));
                },
                z: function () {
                  return Qi({});
                },
                jb: function (v) {
                  return (v = Vi(v)), !v;
                },
                u: function (v) {
                  var w = Vi(v);
                  Qe(w), Er(v);
                },
                i: function (v, w, E) {
                  (v = Vi(v)), (w = Vi(w)), (E = Vi(E)), (v[w] = E);
                },
                h: function (v, w) {
                  return (
                    (v = _t(v, "_emval_take_value")),
                    (v = v.readValueFromPointer(w)),
                    Qi(v)
                  );
                },
                mb: function () {
                  return -52;
                },
                nb: function () {},
                a: () => {
                  Ee("");
                },
                Db: () => performance.now(),
                ub: (v) => {
                  var w = R.length;
                  if (((v >>>= 0), 2147483648 < v)) return !1;
                  for (var E = 1; 4 >= E; E *= 2) {
                    var O = w * (1 + 0.2 / E);
                    O = Math.min(O, v + 100663296);
                    var B = Math;
                    O = Math.max(v, O);
                    e: {
                      B =
                        (B.min.call(
                          B,
                          2147483648,
                          O + ((65536 - (O % 65536)) % 65536)
                        ) -
                          C.buffer.byteLength +
                          65535) >>>
                        16;
                      try {
                        C.grow(B), q();
                        var j = 1;
                        break e;
                      } catch {}
                      j = void 0;
                    }
                    if (j) return !0;
                  }
                  return !1;
                },
                kb: function () {
                  return Kt ? Kt.handle : 0;
                },
                vb: (v, w) => {
                  var E = 0;
                  return (
                    mw().forEach(function (O, B) {
                      var j = w + E;
                      for (
                        B = G[(v + 4 * B) >> 2] = j, j = 0;
                        j < O.length;
                        ++j
                      )
                        P[B++ >> 0] = O.charCodeAt(j);
                      (P[B >> 0] = 0), (E += O.length + 1);
                    }),
                    0
                  );
                },
                wb: (v, w) => {
                  var E = mw();
                  G[v >> 2] = E.length;
                  var O = 0;
                  return (
                    E.forEach(function (B) {
                      O += B.length + 1;
                    }),
                    (G[w >> 2] = O),
                    0
                  );
                },
                J: () => 52,
                lb: function () {
                  return 52;
                },
                Bb: () => 52,
                ob: function () {
                  return 70;
                },
                P: (v, w, E, O) => {
                  for (var B = 0, j = 0; j < E; j++) {
                    var Q = G[w >> 2],
                      K = G[(w + 4) >> 2];
                    w += 8;
                    for (var le = 0; le < K; le++) {
                      var Ie = R[Q + le],
                        Ne = tO[v];
                      Ie === 0 || Ie === 10
                        ? ((v === 1 ? b : _)(st(Ne, 0)), (Ne.length = 0))
                        : Ne.push(Ie);
                    }
                    B += K;
                  }
                  return (G[O >> 2] = B), 0;
                },
                $: function (v) {
                  pe.activeTexture(v);
                },
                aa: function (v, w) {
                  pe.attachShader(xs[v], Da[w]);
                },
                ba: function (v, w, E) {
                  pe.bindAttribLocation(xs[v], w, E ? st(R, E) : "");
                },
                ca: function (v, w) {
                  v == 35051 ? (pe.se = w) : v == 35052 && (pe.Zd = w),
                    pe.bindBuffer(v, jn[w]);
                },
                _: function (v, w) {
                  pe.bindFramebuffer(v, Sp[w]);
                },
                ac: function (v, w) {
                  pe.bindRenderbuffer(v, Tu[w]);
                },
                Mb: function (v, w) {
                  pe.bindSampler(v, Sl[w]);
                },
                da: function (v, w) {
                  pe.bindTexture(v, sa[w]);
                },
                uc: gw,
                xc: gw,
                ea: function (v, w, E, O) {
                  pe.blendColor(v, w, E, O);
                },
                fa: function (v) {
                  pe.blendEquation(v);
                },
                ga: function (v, w) {
                  pe.blendFunc(v, w);
                },
                Wb: function (v, w, E, O, B, j, Q, K, le, Ie) {
                  pe.blitFramebuffer(v, w, E, O, B, j, Q, K, le, Ie);
                },
                ha: function (v, w, E, O) {
                  2 <= Kt.version
                    ? E && w
                      ? pe.bufferData(v, R, O, E, w)
                      : pe.bufferData(v, w, O)
                    : pe.bufferData(v, E ? R.subarray(E, E + w) : w, O);
                },
                ia: function (v, w, E, O) {
                  2 <= Kt.version
                    ? E && pe.bufferSubData(v, w, R, O, E)
                    : pe.bufferSubData(v, w, R.subarray(O, O + E));
                },
                bc: function (v) {
                  return pe.checkFramebufferStatus(v);
                },
                N: function (v) {
                  pe.clear(v);
                },
                Z: function (v, w, E, O) {
                  pe.clearColor(v, w, E, O);
                },
                O: function (v) {
                  pe.clearStencil(v);
                },
                rb: function (v, w, E, O) {
                  return pe.clientWaitSync(
                    Al[v],
                    w,
                    (E >>> 0) + 4294967296 * O
                  );
                },
                ja: function (v, w, E, O) {
                  pe.colorMask(!!v, !!w, !!E, !!O);
                },
                ka: function (v) {
                  pe.compileShader(Da[v]);
                },
                la: function (v, w, E, O, B, j, Q, K) {
                  2 <= Kt.version
                    ? pe.Zd || !Q
                      ? pe.compressedTexImage2D(v, w, E, O, B, j, Q, K)
                      : pe.compressedTexImage2D(v, w, E, O, B, j, R, K, Q)
                    : pe.compressedTexImage2D(
                        v,
                        w,
                        E,
                        O,
                        B,
                        j,
                        K ? R.subarray(K, K + Q) : null
                      );
                },
                ma: function (v, w, E, O, B, j, Q, K, le) {
                  2 <= Kt.version
                    ? pe.Zd || !K
                      ? pe.compressedTexSubImage2D(v, w, E, O, B, j, Q, K, le)
                      : pe.compressedTexSubImage2D(
                          v,
                          w,
                          E,
                          O,
                          B,
                          j,
                          Q,
                          R,
                          le,
                          K
                        )
                    : pe.compressedTexSubImage2D(
                        v,
                        w,
                        E,
                        O,
                        B,
                        j,
                        Q,
                        le ? R.subarray(le, le + K) : null
                      );
                },
                Ub: function (v, w, E, O, B) {
                  pe.copyBufferSubData(v, w, E, O, B);
                },
                na: function (v, w, E, O, B, j, Q, K) {
                  pe.copyTexSubImage2D(v, w, E, O, B, j, Q, K);
                },
                oa: function () {
                  var v = Dh(xs),
                    w = pe.createProgram();
                  return (
                    (w.name = v),
                    (w.oe = w.me = w.ne = 0),
                    (w.xe = 1),
                    (xs[v] = w),
                    v
                  );
                },
                pa: function (v) {
                  var w = Dh(Da);
                  return (Da[w] = pe.createShader(v)), w;
                },
                qa: function (v) {
                  pe.cullFace(v);
                },
                ra: function (v, w) {
                  for (var E = 0; E < v; E++) {
                    var O = L[(w + 4 * E) >> 2],
                      B = jn[O];
                    B &&
                      (pe.deleteBuffer(B),
                      (B.name = 0),
                      (jn[O] = null),
                      O == pe.se && (pe.se = 0),
                      O == pe.Zd && (pe.Zd = 0));
                  }
                },
                cc: function (v, w) {
                  for (var E = 0; E < v; ++E) {
                    var O = L[(w + 4 * E) >> 2],
                      B = Sp[O];
                    B &&
                      (pe.deleteFramebuffer(B), (B.name = 0), (Sp[O] = null));
                  }
                },
                sa: function (v) {
                  if (v) {
                    var w = xs[v];
                    w
                      ? (pe.deleteProgram(w), (w.name = 0), (xs[v] = null))
                      : Bi(1281);
                  }
                },
                dc: function (v, w) {
                  for (var E = 0; E < v; E++) {
                    var O = L[(w + 4 * E) >> 2],
                      B = Tu[O];
                    B &&
                      (pe.deleteRenderbuffer(B), (B.name = 0), (Tu[O] = null));
                  }
                },
                Nb: function (v, w) {
                  for (var E = 0; E < v; E++) {
                    var O = L[(w + 4 * E) >> 2],
                      B = Sl[O];
                    B && (pe.deleteSampler(B), (B.name = 0), (Sl[O] = null));
                  }
                },
                ta: function (v) {
                  if (v) {
                    var w = Da[v];
                    w ? (pe.deleteShader(w), (Da[v] = null)) : Bi(1281);
                  }
                },
                Vb: function (v) {
                  if (v) {
                    var w = Al[v];
                    w
                      ? (pe.deleteSync(w), (w.name = 0), (Al[v] = null))
                      : Bi(1281);
                  }
                },
                ua: function (v, w) {
                  for (var E = 0; E < v; E++) {
                    var O = L[(w + 4 * E) >> 2],
                      B = sa[O];
                    B && (pe.deleteTexture(B), (B.name = 0), (sa[O] = null));
                  }
                },
                vc: vw,
                yc: vw,
                va: function (v) {
                  pe.depthMask(!!v);
                },
                wa: function (v) {
                  pe.disable(v);
                },
                xa: function (v) {
                  pe.disableVertexAttribArray(v);
                },
                ya: function (v, w, E) {
                  pe.drawArrays(v, w, E);
                },
                sc: function (v, w, E, O) {
                  pe.drawArraysInstanced(v, w, E, O);
                },
                qc: function (v, w, E, O, B) {
                  pe.ze.drawArraysInstancedBaseInstanceWEBGL(v, w, E, O, B);
                },
                oc: function (v, w) {
                  for (var E = Ep[v], O = 0; O < v; O++)
                    E[O] = L[(w + 4 * O) >> 2];
                  pe.drawBuffers(E);
                },
                za: yw,
                tc: function (v, w, E, O, B) {
                  pe.drawElementsInstanced(v, w, E, O, B);
                },
                rc: function (v, w, E, O, B, j, Q) {
                  pe.ze.drawElementsInstancedBaseVertexBaseInstanceWEBGL(
                    v,
                    w,
                    E,
                    O,
                    B,
                    j,
                    Q
                  );
                },
                ic: function (v, w, E, O, B, j) {
                  yw(v, O, B, j);
                },
                Aa: function (v) {
                  pe.enable(v);
                },
                Ba: function (v) {
                  pe.enableVertexAttribArray(v);
                },
                Sb: function (v, w) {
                  return (v = pe.fenceSync(v, w))
                    ? ((w = Dh(Al)), (v.name = w), (Al[w] = v), w)
                    : 0;
                },
                Ca: function () {
                  pe.finish();
                },
                Da: function () {
                  pe.flush();
                },
                ec: function (v, w, E, O) {
                  pe.framebufferRenderbuffer(v, w, E, Tu[O]);
                },
                fc: function (v, w, E, O, B) {
                  pe.framebufferTexture2D(v, w, E, sa[O], B);
                },
                Ea: function (v) {
                  pe.frontFace(v);
                },
                Fa: function (v, w) {
                  Oh(v, w, "createBuffer", jn);
                },
                gc: function (v, w) {
                  Oh(v, w, "createFramebuffer", Sp);
                },
                hc: function (v, w) {
                  Oh(v, w, "createRenderbuffer", Tu);
                },
                Ob: function (v, w) {
                  Oh(v, w, "createSampler", Sl);
                },
                Ga: function (v, w) {
                  Oh(v, w, "createTexture", sa);
                },
                wc: xw,
                zc: xw,
                Yb: function (v) {
                  pe.generateMipmap(v);
                },
                Ha: function (v, w, E) {
                  E ? (L[E >> 2] = pe.getBufferParameter(v, w)) : Bi(1281);
                },
                Ia: function () {
                  var v = pe.getError() || Mp;
                  return (Mp = 0), v;
                },
                Ja: function (v, w) {
                  bw(v, w, 2);
                },
                Zb: function (v, w, E, O) {
                  (v = pe.getFramebufferAttachmentParameter(v, w, E)),
                    (v instanceof WebGLRenderbuffer ||
                      v instanceof WebGLTexture) &&
                      (v = v.name | 0),
                    (L[O >> 2] = v);
                },
                I: function (v, w) {
                  bw(v, w, 0);
                },
                Ka: function (v, w, E, O) {
                  (v = pe.getProgramInfoLog(xs[v])),
                    v === null && (v = "(unknown error)"),
                    (w = 0 < w && O ? Jt(v, R, O, w) : 0),
                    E && (L[E >> 2] = w);
                },
                La: function (v, w, E) {
                  if (E)
                    if (v >= Ph) Bi(1281);
                    else if (((v = xs[v]), w == 35716))
                      (v = pe.getProgramInfoLog(v)),
                        v === null && (v = "(unknown error)"),
                        (L[E >> 2] = v.length + 1);
                    else if (w == 35719) {
                      if (!v.oe)
                        for (w = 0; w < pe.getProgramParameter(v, 35718); ++w)
                          v.oe = Math.max(
                            v.oe,
                            pe.getActiveUniform(v, w).name.length + 1
                          );
                      L[E >> 2] = v.oe;
                    } else if (w == 35722) {
                      if (!v.me)
                        for (w = 0; w < pe.getProgramParameter(v, 35721); ++w)
                          v.me = Math.max(
                            v.me,
                            pe.getActiveAttrib(v, w).name.length + 1
                          );
                      L[E >> 2] = v.me;
                    } else if (w == 35381) {
                      if (!v.ne)
                        for (w = 0; w < pe.getProgramParameter(v, 35382); ++w)
                          v.ne = Math.max(
                            v.ne,
                            pe.getActiveUniformBlockName(v, w).length + 1
                          );
                      L[E >> 2] = v.ne;
                    } else L[E >> 2] = pe.getProgramParameter(v, w);
                  else Bi(1281);
                },
                _b: function (v, w, E) {
                  E
                    ? (L[E >> 2] = pe.getRenderbufferParameter(v, w))
                    : Bi(1281);
                },
                Ma: function (v, w, E, O) {
                  (v = pe.getShaderInfoLog(Da[v])),
                    v === null && (v = "(unknown error)"),
                    (w = 0 < w && O ? Jt(v, R, O, w) : 0),
                    E && (L[E >> 2] = w);
                },
                Jb: function (v, w, E, O) {
                  (v = pe.getShaderPrecisionFormat(v, w)),
                    (L[E >> 2] = v.rangeMin),
                    (L[(E + 4) >> 2] = v.rangeMax),
                    (L[O >> 2] = v.precision);
                },
                Na: function (v, w, E) {
                  E
                    ? w == 35716
                      ? ((v = pe.getShaderInfoLog(Da[v])),
                        v === null && (v = "(unknown error)"),
                        (L[E >> 2] = v ? v.length + 1 : 0))
                      : w == 35720
                      ? ((v = pe.getShaderSource(Da[v])),
                        (L[E >> 2] = v ? v.length + 1 : 0))
                      : (L[E >> 2] = pe.getShaderParameter(Da[v], w))
                    : Bi(1281);
                },
                M: function (v) {
                  var w = uw[v];
                  if (!w) {
                    switch (v) {
                      case 7939:
                        (w = pe.getSupportedExtensions() || []),
                          (w = w.concat(
                            w.map(function (O) {
                              return "GL_" + O;
                            })
                          )),
                          (w = Pu(w.join(" ")));
                        break;
                      case 7936:
                      case 7937:
                      case 37445:
                      case 37446:
                        (w = pe.getParameter(v)) || Bi(1280), (w = w && Pu(w));
                        break;
                      case 7938:
                        (w = pe.getParameter(7938)),
                          (w =
                            2 <= Kt.version
                              ? "OpenGL ES 3.0 (" + w + ")"
                              : "OpenGL ES 2.0 (" + w + ")"),
                          (w = Pu(w));
                        break;
                      case 35724:
                        w = pe.getParameter(35724);
                        var E = w.match(
                          /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/
                        );
                        E !== null &&
                          (E[1].length == 3 && (E[1] += "0"),
                          (w = "OpenGL ES GLSL ES " + E[1] + " (" + w + ")")),
                          (w = Pu(w));
                        break;
                      default:
                        Bi(1280);
                    }
                    uw[v] = w;
                  }
                  return w;
                },
                ib: function (v, w) {
                  if (2 > Kt.version) return Bi(1282), 0;
                  var E = dw[v];
                  if (E) return 0 > w || w >= E.length ? (Bi(1281), 0) : E[w];
                  switch (v) {
                    case 7939:
                      return (
                        (E = pe.getSupportedExtensions() || []),
                        (E = E.concat(
                          E.map(function (O) {
                            return "GL_" + O;
                          })
                        )),
                        (E = E.map(function (O) {
                          return Pu(O);
                        })),
                        (E = dw[v] = E),
                        0 > w || w >= E.length ? (Bi(1281), 0) : E[w]
                      );
                    default:
                      return Bi(1280), 0;
                  }
                },
                Oa: function (v, w) {
                  if (((w = w ? st(R, w) : ""), (v = xs[v]))) {
                    var E = v,
                      O = E.fe,
                      B = E.He,
                      j;
                    if (!O)
                      for (
                        E.fe = O = {}, E.Ge = {}, j = 0;
                        j < pe.getProgramParameter(E, 35718);
                        ++j
                      ) {
                        var Q = pe.getActiveUniform(E, j),
                          K = Q.name;
                        Q = Q.size;
                        var le = ww(K);
                        le = 0 < le ? K.slice(0, le) : K;
                        var Ie = E.xe;
                        for (E.xe += Q, B[le] = [Q, Ie], K = 0; K < Q; ++K)
                          (O[Ie] = K), (E.Ge[Ie++] = le);
                      }
                    if (
                      ((E = v.fe),
                      (O = 0),
                      (B = w),
                      (j = ww(w)),
                      0 < j &&
                        ((O = parseInt(w.slice(j + 1)) >>> 0),
                        (B = w.slice(0, j))),
                      (B = v.He[B]) &&
                        O < B[0] &&
                        ((O += B[1]),
                        (E[O] = E[O] || pe.getUniformLocation(v, w))))
                    )
                      return O;
                  } else Bi(1281);
                  return -1;
                },
                Kb: function (v, w, E) {
                  for (var O = Ep[w], B = 0; B < w; B++)
                    O[B] = L[(E + 4 * B) >> 2];
                  pe.invalidateFramebuffer(v, O);
                },
                Lb: function (v, w, E, O, B, j, Q) {
                  for (var K = Ep[w], le = 0; le < w; le++)
                    K[le] = L[(E + 4 * le) >> 2];
                  pe.invalidateSubFramebuffer(v, K, O, B, j, Q);
                },
                Tb: function (v) {
                  return pe.isSync(Al[v]);
                },
                Pa: function (v) {
                  return (v = sa[v]) ? pe.isTexture(v) : 0;
                },
                Qa: function (v) {
                  pe.lineWidth(v);
                },
                Ra: function (v) {
                  (v = xs[v]), pe.linkProgram(v), (v.fe = 0), (v.He = {});
                },
                mc: function (v, w, E, O, B, j) {
                  pe.De.multiDrawArraysInstancedBaseInstanceWEBGL(
                    v,
                    L,
                    w >> 2,
                    L,
                    E >> 2,
                    L,
                    O >> 2,
                    G,
                    B >> 2,
                    j
                  );
                },
                nc: function (v, w, E, O, B, j, Q, K) {
                  pe.De.multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL(
                    v,
                    L,
                    w >> 2,
                    E,
                    L,
                    O >> 2,
                    L,
                    B >> 2,
                    L,
                    j >> 2,
                    G,
                    Q >> 2,
                    K
                  );
                },
                Sa: function (v, w) {
                  v == 3317 && (pw = w), pe.pixelStorei(v, w);
                },
                pc: function (v) {
                  pe.readBuffer(v);
                },
                Ta: function (v, w, E, O, B, j, Q) {
                  if (2 <= Kt.version)
                    if (pe.se) pe.readPixels(v, w, E, O, B, j, Q);
                    else {
                      var K = Cp(j);
                      pe.readPixels(
                        v,
                        w,
                        E,
                        O,
                        B,
                        j,
                        K,
                        Q >> (31 - Math.clz32(K.BYTES_PER_ELEMENT))
                      );
                    }
                  else
                    (Q = $g(j, B, E, O, Q))
                      ? pe.readPixels(v, w, E, O, B, j, Q)
                      : Bi(1280);
                },
                $b: function (v, w, E, O) {
                  pe.renderbufferStorage(v, w, E, O);
                },
                Xb: function (v, w, E, O, B) {
                  pe.renderbufferStorageMultisample(v, w, E, O, B);
                },
                Pb: function (v, w, E) {
                  pe.samplerParameterf(Sl[v], w, E);
                },
                Qb: function (v, w, E) {
                  pe.samplerParameteri(Sl[v], w, E);
                },
                Rb: function (v, w, E) {
                  pe.samplerParameteri(Sl[v], w, L[E >> 2]);
                },
                Ua: function (v, w, E, O) {
                  pe.scissor(v, w, E, O);
                },
                Va: function (v, w, E, O) {
                  for (var B = "", j = 0; j < w; ++j) {
                    var Q = O ? L[(O + 4 * j) >> 2] : -1,
                      K = L[(E + 4 * j) >> 2];
                    (Q = K ? st(R, K, 0 > Q ? void 0 : Q) : ""), (B += Q);
                  }
                  pe.shaderSource(Da[v], B);
                },
                Wa: function (v, w, E) {
                  pe.stencilFunc(v, w, E);
                },
                Xa: function (v, w, E, O) {
                  pe.stencilFuncSeparate(v, w, E, O);
                },
                Ya: function (v) {
                  pe.stencilMask(v);
                },
                Za: function (v, w) {
                  pe.stencilMaskSeparate(v, w);
                },
                _a: function (v, w, E) {
                  pe.stencilOp(v, w, E);
                },
                $a: function (v, w, E, O) {
                  pe.stencilOpSeparate(v, w, E, O);
                },
                ab: function (v, w, E, O, B, j, Q, K, le) {
                  if (2 <= Kt.version)
                    if (pe.Zd) pe.texImage2D(v, w, E, O, B, j, Q, K, le);
                    else if (le) {
                      var Ie = Cp(K);
                      pe.texImage2D(
                        v,
                        w,
                        E,
                        O,
                        B,
                        j,
                        Q,
                        K,
                        Ie,
                        le >> (31 - Math.clz32(Ie.BYTES_PER_ELEMENT))
                      );
                    } else pe.texImage2D(v, w, E, O, B, j, Q, K, null);
                  else
                    pe.texImage2D(
                      v,
                      w,
                      E,
                      O,
                      B,
                      j,
                      Q,
                      K,
                      le ? $g(K, Q, O, B, le) : null
                    );
                },
                bb: function (v, w, E) {
                  pe.texParameterf(v, w, E);
                },
                cb: function (v, w, E) {
                  pe.texParameterf(v, w, Y[E >> 2]);
                },
                db: function (v, w, E) {
                  pe.texParameteri(v, w, E);
                },
                eb: function (v, w, E) {
                  pe.texParameteri(v, w, L[E >> 2]);
                },
                jc: function (v, w, E, O, B) {
                  pe.texStorage2D(v, w, E, O, B);
                },
                fb: function (v, w, E, O, B, j, Q, K, le) {
                  if (2 <= Kt.version)
                    if (pe.Zd) pe.texSubImage2D(v, w, E, O, B, j, Q, K, le);
                    else if (le) {
                      var Ie = Cp(K);
                      pe.texSubImage2D(
                        v,
                        w,
                        E,
                        O,
                        B,
                        j,
                        Q,
                        K,
                        Ie,
                        le >> (31 - Math.clz32(Ie.BYTES_PER_ELEMENT))
                      );
                    } else pe.texSubImage2D(v, w, E, O, B, j, Q, K, null);
                  else
                    (Ie = null),
                      le && (Ie = $g(K, Q, B, j, le)),
                      pe.texSubImage2D(v, w, E, O, B, j, Q, K, Ie);
                },
                gb: function (v, w) {
                  pe.uniform1f(xi(v), w);
                },
                hb: function (v, w, E) {
                  if (2 <= Kt.version) w && pe.uniform1fv(xi(v), Y, E >> 2, w);
                  else {
                    if (288 >= w)
                      for (var O = Oo[w - 1], B = 0; B < w; ++B)
                        O[B] = Y[(E + 4 * B) >> 2];
                    else O = Y.subarray(E >> 2, (E + 4 * w) >> 2);
                    pe.uniform1fv(xi(v), O);
                  }
                },
                Uc: function (v, w) {
                  pe.uniform1i(xi(v), w);
                },
                Vc: function (v, w, E) {
                  if (2 <= Kt.version) w && pe.uniform1iv(xi(v), L, E >> 2, w);
                  else {
                    if (288 >= w)
                      for (var O = Du[w - 1], B = 0; B < w; ++B)
                        O[B] = L[(E + 4 * B) >> 2];
                    else O = L.subarray(E >> 2, (E + 4 * w) >> 2);
                    pe.uniform1iv(xi(v), O);
                  }
                },
                Wc: function (v, w, E) {
                  pe.uniform2f(xi(v), w, E);
                },
                Xc: function (v, w, E) {
                  if (2 <= Kt.version)
                    w && pe.uniform2fv(xi(v), Y, E >> 2, 2 * w);
                  else {
                    if (144 >= w)
                      for (var O = Oo[2 * w - 1], B = 0; B < 2 * w; B += 2)
                        (O[B] = Y[(E + 4 * B) >> 2]),
                          (O[B + 1] = Y[(E + (4 * B + 4)) >> 2]);
                    else O = Y.subarray(E >> 2, (E + 8 * w) >> 2);
                    pe.uniform2fv(xi(v), O);
                  }
                },
                Tc: function (v, w, E) {
                  pe.uniform2i(xi(v), w, E);
                },
                Sc: function (v, w, E) {
                  if (2 <= Kt.version)
                    w && pe.uniform2iv(xi(v), L, E >> 2, 2 * w);
                  else {
                    if (144 >= w)
                      for (var O = Du[2 * w - 1], B = 0; B < 2 * w; B += 2)
                        (O[B] = L[(E + 4 * B) >> 2]),
                          (O[B + 1] = L[(E + (4 * B + 4)) >> 2]);
                    else O = L.subarray(E >> 2, (E + 8 * w) >> 2);
                    pe.uniform2iv(xi(v), O);
                  }
                },
                Rc: function (v, w, E, O) {
                  pe.uniform3f(xi(v), w, E, O);
                },
                Qc: function (v, w, E) {
                  if (2 <= Kt.version)
                    w && pe.uniform3fv(xi(v), Y, E >> 2, 3 * w);
                  else {
                    if (96 >= w)
                      for (var O = Oo[3 * w - 1], B = 0; B < 3 * w; B += 3)
                        (O[B] = Y[(E + 4 * B) >> 2]),
                          (O[B + 1] = Y[(E + (4 * B + 4)) >> 2]),
                          (O[B + 2] = Y[(E + (4 * B + 8)) >> 2]);
                    else O = Y.subarray(E >> 2, (E + 12 * w) >> 2);
                    pe.uniform3fv(xi(v), O);
                  }
                },
                Pc: function (v, w, E, O) {
                  pe.uniform3i(xi(v), w, E, O);
                },
                Oc: function (v, w, E) {
                  if (2 <= Kt.version)
                    w && pe.uniform3iv(xi(v), L, E >> 2, 3 * w);
                  else {
                    if (96 >= w)
                      for (var O = Du[3 * w - 1], B = 0; B < 3 * w; B += 3)
                        (O[B] = L[(E + 4 * B) >> 2]),
                          (O[B + 1] = L[(E + (4 * B + 4)) >> 2]),
                          (O[B + 2] = L[(E + (4 * B + 8)) >> 2]);
                    else O = L.subarray(E >> 2, (E + 12 * w) >> 2);
                    pe.uniform3iv(xi(v), O);
                  }
                },
                Nc: function (v, w, E, O, B) {
                  pe.uniform4f(xi(v), w, E, O, B);
                },
                Mc: function (v, w, E) {
                  if (2 <= Kt.version)
                    w && pe.uniform4fv(xi(v), Y, E >> 2, 4 * w);
                  else {
                    if (72 >= w) {
                      var O = Oo[4 * w - 1],
                        B = Y;
                      E >>= 2;
                      for (var j = 0; j < 4 * w; j += 4) {
                        var Q = E + j;
                        (O[j] = B[Q]),
                          (O[j + 1] = B[Q + 1]),
                          (O[j + 2] = B[Q + 2]),
                          (O[j + 3] = B[Q + 3]);
                      }
                    } else O = Y.subarray(E >> 2, (E + 16 * w) >> 2);
                    pe.uniform4fv(xi(v), O);
                  }
                },
                Ac: function (v, w, E, O, B) {
                  pe.uniform4i(xi(v), w, E, O, B);
                },
                Bc: function (v, w, E) {
                  if (2 <= Kt.version)
                    w && pe.uniform4iv(xi(v), L, E >> 2, 4 * w);
                  else {
                    if (72 >= w)
                      for (var O = Du[4 * w - 1], B = 0; B < 4 * w; B += 4)
                        (O[B] = L[(E + 4 * B) >> 2]),
                          (O[B + 1] = L[(E + (4 * B + 4)) >> 2]),
                          (O[B + 2] = L[(E + (4 * B + 8)) >> 2]),
                          (O[B + 3] = L[(E + (4 * B + 12)) >> 2]);
                    else O = L.subarray(E >> 2, (E + 16 * w) >> 2);
                    pe.uniform4iv(xi(v), O);
                  }
                },
                Cc: function (v, w, E, O) {
                  if (2 <= Kt.version)
                    w && pe.uniformMatrix2fv(xi(v), !!E, Y, O >> 2, 4 * w);
                  else {
                    if (72 >= w)
                      for (var B = Oo[4 * w - 1], j = 0; j < 4 * w; j += 4)
                        (B[j] = Y[(O + 4 * j) >> 2]),
                          (B[j + 1] = Y[(O + (4 * j + 4)) >> 2]),
                          (B[j + 2] = Y[(O + (4 * j + 8)) >> 2]),
                          (B[j + 3] = Y[(O + (4 * j + 12)) >> 2]);
                    else B = Y.subarray(O >> 2, (O + 16 * w) >> 2);
                    pe.uniformMatrix2fv(xi(v), !!E, B);
                  }
                },
                Dc: function (v, w, E, O) {
                  if (2 <= Kt.version)
                    w && pe.uniformMatrix3fv(xi(v), !!E, Y, O >> 2, 9 * w);
                  else {
                    if (32 >= w)
                      for (var B = Oo[9 * w - 1], j = 0; j < 9 * w; j += 9)
                        (B[j] = Y[(O + 4 * j) >> 2]),
                          (B[j + 1] = Y[(O + (4 * j + 4)) >> 2]),
                          (B[j + 2] = Y[(O + (4 * j + 8)) >> 2]),
                          (B[j + 3] = Y[(O + (4 * j + 12)) >> 2]),
                          (B[j + 4] = Y[(O + (4 * j + 16)) >> 2]),
                          (B[j + 5] = Y[(O + (4 * j + 20)) >> 2]),
                          (B[j + 6] = Y[(O + (4 * j + 24)) >> 2]),
                          (B[j + 7] = Y[(O + (4 * j + 28)) >> 2]),
                          (B[j + 8] = Y[(O + (4 * j + 32)) >> 2]);
                    else B = Y.subarray(O >> 2, (O + 36 * w) >> 2);
                    pe.uniformMatrix3fv(xi(v), !!E, B);
                  }
                },
                Ec: function (v, w, E, O) {
                  if (2 <= Kt.version)
                    w && pe.uniformMatrix4fv(xi(v), !!E, Y, O >> 2, 16 * w);
                  else {
                    if (18 >= w) {
                      var B = Oo[16 * w - 1],
                        j = Y;
                      O >>= 2;
                      for (var Q = 0; Q < 16 * w; Q += 16) {
                        var K = O + Q;
                        (B[Q] = j[K]),
                          (B[Q + 1] = j[K + 1]),
                          (B[Q + 2] = j[K + 2]),
                          (B[Q + 3] = j[K + 3]),
                          (B[Q + 4] = j[K + 4]),
                          (B[Q + 5] = j[K + 5]),
                          (B[Q + 6] = j[K + 6]),
                          (B[Q + 7] = j[K + 7]),
                          (B[Q + 8] = j[K + 8]),
                          (B[Q + 9] = j[K + 9]),
                          (B[Q + 10] = j[K + 10]),
                          (B[Q + 11] = j[K + 11]),
                          (B[Q + 12] = j[K + 12]),
                          (B[Q + 13] = j[K + 13]),
                          (B[Q + 14] = j[K + 14]),
                          (B[Q + 15] = j[K + 15]);
                      }
                    } else B = Y.subarray(O >> 2, (O + 64 * w) >> 2);
                    pe.uniformMatrix4fv(xi(v), !!E, B);
                  }
                },
                Fc: function (v) {
                  (v = xs[v]), pe.useProgram(v), (pe.Re = v);
                },
                Gc: function (v, w) {
                  pe.vertexAttrib1f(v, w);
                },
                Hc: function (v, w) {
                  pe.vertexAttrib2f(v, Y[w >> 2], Y[(w + 4) >> 2]);
                },
                Ic: function (v, w) {
                  pe.vertexAttrib3f(
                    v,
                    Y[w >> 2],
                    Y[(w + 4) >> 2],
                    Y[(w + 8) >> 2]
                  );
                },
                Jc: function (v, w) {
                  pe.vertexAttrib4f(
                    v,
                    Y[w >> 2],
                    Y[(w + 4) >> 2],
                    Y[(w + 8) >> 2],
                    Y[(w + 12) >> 2]
                  );
                },
                kc: function (v, w) {
                  pe.vertexAttribDivisor(v, w);
                },
                lc: function (v, w, E, O, B) {
                  pe.vertexAttribIPointer(v, w, E, O, B);
                },
                Kc: function (v, w, E, O, B, j) {
                  pe.vertexAttribPointer(v, w, E, !!O, B, j);
                },
                Lc: function (v, w, E, O) {
                  pe.viewport(v, w, E, O);
                },
                qb: function (v, w, E, O) {
                  pe.waitSync(Al[v], w, (E >>> 0) + 4294967296 * O);
                },
                W: uO,
                F: lO,
                E: dO,
                X: hO,
                Ib: gO,
                V: fO,
                U: vO,
                A: mO,
                B: pO,
                D: cO,
                L: oO,
                sb: (v, w, E, O) => rO(v, w, E, O),
              };
              (function () {
                function v(E) {
                  if (
                    ((A = E = E.exports),
                    (C = A.Yc),
                    q(),
                    (oe = A._c),
                    ie.unshift(A.Zc),
                    ae--,
                    a.monitorRunDependencies && a.monitorRunDependencies(ae),
                    ae == 0 &&
                      (de !== null && (clearInterval(de), (de = null)), ne))
                  ) {
                    var O = ne;
                    (ne = null), O();
                  }
                  return E;
                }
                var w = { a: nO };
                if (
                  (ae++,
                  a.monitorRunDependencies && a.monitorRunDependencies(ae),
                  a.instantiateWasm)
                )
                  try {
                    return a.instantiateWasm(w, v);
                  } catch (E) {
                    _(
                      "Module.instantiateWasm callback failed with error: " + E
                    ),
                      o(E);
                  }
                return (
                  tt(w, function (E) {
                    v(E.instance);
                  }).catch(o),
                  {}
                );
              })();
              var Hn = (a._free = (v) => (Hn = a._free = A.$c)(v)),
                Dp = (a._malloc = (v) => (Dp = a._malloc = A.ad)(v)),
                Mw = (v) => (Mw = A.bd)(v);
              a.__embind_initialize_bindings = () =>
                (a.__embind_initialize_bindings = A.cd)();
              var aa = (v, w) => (aa = A.dd)(v, w),
                na = () => (na = A.ed)(),
                oa = (v) => (oa = A.fd)(v);
              (a.dynCall_viji = (v, w, E, O, B) =>
                (a.dynCall_viji = A.gd)(v, w, E, O, B)),
                (a.dynCall_vijiii = (v, w, E, O, B, j, Q) =>
                  (a.dynCall_vijiii = A.hd)(v, w, E, O, B, j, Q)),
                (a.dynCall_viiiiij = (v, w, E, O, B, j, Q, K) =>
                  (a.dynCall_viiiiij = A.id)(v, w, E, O, B, j, Q, K)),
                (a.dynCall_jii = (v, w, E) => (a.dynCall_jii = A.jd)(v, w, E)),
                (a.dynCall_vij = (v, w, E, O) =>
                  (a.dynCall_vij = A.kd)(v, w, E, O)),
                (a.dynCall_iiij = (v, w, E, O, B) =>
                  (a.dynCall_iiij = A.ld)(v, w, E, O, B)),
                (a.dynCall_iiiij = (v, w, E, O, B, j) =>
                  (a.dynCall_iiiij = A.md)(v, w, E, O, B, j)),
                (a.dynCall_viij = (v, w, E, O, B) =>
                  (a.dynCall_viij = A.nd)(v, w, E, O, B)),
                (a.dynCall_viiij = (v, w, E, O, B, j) =>
                  (a.dynCall_viiij = A.od)(v, w, E, O, B, j)),
                (a.dynCall_ji = (v, w) => (a.dynCall_ji = A.pd)(v, w)),
                (a.dynCall_iij = (v, w, E, O) =>
                  (a.dynCall_iij = A.qd)(v, w, E, O)),
                (a.dynCall_jiiiiii = (v, w, E, O, B, j, Q) =>
                  (a.dynCall_jiiiiii = A.rd)(v, w, E, O, B, j, Q)),
                (a.dynCall_jiiiiji = (v, w, E, O, B, j, Q, K) =>
                  (a.dynCall_jiiiiji = A.sd)(v, w, E, O, B, j, Q, K)),
                (a.dynCall_iijj = (v, w, E, O, B, j) =>
                  (a.dynCall_iijj = A.td)(v, w, E, O, B, j)),
                (a.dynCall_iiiji = (v, w, E, O, B, j) =>
                  (a.dynCall_iiiji = A.ud)(v, w, E, O, B, j)),
                (a.dynCall_iiji = (v, w, E, O, B) =>
                  (a.dynCall_iiji = A.vd)(v, w, E, O, B)),
                (a.dynCall_iijjiii = (v, w, E, O, B, j, Q, K, le) =>
                  (a.dynCall_iijjiii = A.wd)(v, w, E, O, B, j, Q, K, le)),
                (a.dynCall_vijjjii = (v, w, E, O, B, j, Q, K, le, Ie) =>
                  (a.dynCall_vijjjii = A.xd)(v, w, E, O, B, j, Q, K, le, Ie)),
                (a.dynCall_jiji = (v, w, E, O, B) =>
                  (a.dynCall_jiji = A.yd)(v, w, E, O, B)),
                (a.dynCall_viijii = (v, w, E, O, B, j, Q) =>
                  (a.dynCall_viijii = A.zd)(v, w, E, O, B, j, Q)),
                (a.dynCall_iiiiij = (v, w, E, O, B, j, Q) =>
                  (a.dynCall_iiiiij = A.Ad)(v, w, E, O, B, j, Q)),
                (a.dynCall_iiiiijj = (v, w, E, O, B, j, Q, K, le) =>
                  (a.dynCall_iiiiijj = A.Bd)(v, w, E, O, B, j, Q, K, le)),
                (a.dynCall_iiiiiijj = (v, w, E, O, B, j, Q, K, le, Ie) =>
                  (a.dynCall_iiiiiijj = A.Cd)(v, w, E, O, B, j, Q, K, le, Ie));
              function oO(v, w, E, O, B) {
                var j = na();
                try {
                  oe.get(v)(w, E, O, B);
                } catch (Q) {
                  if ((oa(j), Q !== Q + 0)) throw Q;
                  aa(1, 0);
                }
              }
              function lO(v, w, E) {
                var O = na();
                try {
                  return oe.get(v)(w, E);
                } catch (B) {
                  if ((oa(O), B !== B + 0)) throw B;
                  aa(1, 0);
                }
              }
              function hO(v, w, E, O, B) {
                var j = na();
                try {
                  return oe.get(v)(w, E, O, B);
                } catch (Q) {
                  if ((oa(j), Q !== Q + 0)) throw Q;
                  aa(1, 0);
                }
              }
              function cO(v, w, E, O) {
                var B = na();
                try {
                  oe.get(v)(w, E, O);
                } catch (j) {
                  if ((oa(B), j !== j + 0)) throw j;
                  aa(1, 0);
                }
              }
              function uO(v, w) {
                var E = na();
                try {
                  return oe.get(v)(w);
                } catch (O) {
                  if ((oa(E), O !== O + 0)) throw O;
                  aa(1, 0);
                }
              }
              function dO(v, w, E, O) {
                var B = na();
                try {
                  return oe.get(v)(w, E, O);
                } catch (j) {
                  if ((oa(B), j !== j + 0)) throw j;
                  aa(1, 0);
                }
              }
              function pO(v, w, E) {
                var O = na();
                try {
                  oe.get(v)(w, E);
                } catch (B) {
                  if ((oa(O), B !== B + 0)) throw B;
                  aa(1, 0);
                }
              }
              function fO(v, w, E, O, B, j, Q, K, le, Ie) {
                var Ne = na();
                try {
                  return oe.get(v)(w, E, O, B, j, Q, K, le, Ie);
                } catch ($e) {
                  if ((oa(Ne), $e !== $e + 0)) throw $e;
                  aa(1, 0);
                }
              }
              function mO(v, w) {
                var E = na();
                try {
                  oe.get(v)(w);
                } catch (O) {
                  if ((oa(E), O !== O + 0)) throw O;
                  aa(1, 0);
                }
              }
              function gO(v, w, E, O, B, j, Q) {
                var K = na();
                try {
                  return oe.get(v)(w, E, O, B, j, Q);
                } catch (le) {
                  if ((oa(K), le !== le + 0)) throw le;
                  aa(1, 0);
                }
              }
              function vO(v) {
                var w = na();
                try {
                  oe.get(v)();
                } catch (E) {
                  if ((oa(w), E !== E + 0)) throw E;
                  aa(1, 0);
                }
              }
              var Op;
              ne = function v() {
                Op || Ew(), Op || (ne = v);
              };
              function Ew() {
                function v() {
                  if (!Op && ((Op = !0), (a.calledRun = !0), !T)) {
                    if (
                      (Je(ie),
                      n(a),
                      a.onRuntimeInitialized && a.onRuntimeInitialized(),
                      a.postRun)
                    )
                      for (
                        typeof a.postRun == "function" &&
                        (a.postRun = [a.postRun]);
                        a.postRun.length;

                      ) {
                        var w = a.postRun.shift();
                        te.unshift(w);
                      }
                    Je(te);
                  }
                }
                if (!(0 < ae)) {
                  if (a.preRun)
                    for (
                      typeof a.preRun == "function" && (a.preRun = [a.preRun]);
                      a.preRun.length;

                    )
                      ue();
                  Je(ce),
                    0 < ae ||
                      (a.setStatus
                        ? (a.setStatus("Running..."),
                          setTimeout(function () {
                            setTimeout(function () {
                              a.setStatus("");
                            }, 1),
                              v();
                          }, 1))
                        : v());
                }
              }
              if (a.preInit)
                for (
                  typeof a.preInit == "function" && (a.preInit = [a.preInit]);
                  0 < a.preInit.length;

                )
                  a.preInit.pop()();
              return Ew(), s.ready;
            }
          );
        })();
        typeof e == "object" && typeof t == "object"
          ? (t.exports = i)
          : typeof define == "function" && define.amd && define([], () => i);
      })),
      (AO = SO());
  });
var MO = Object.create,
  xg = Object.defineProperty,
  EO = Object.getOwnPropertyDescriptor,
  CO = Object.getOwnPropertyNames,
  TO = Object.getPrototypeOf,
  PO = Object.prototype.hasOwnProperty,
  DO = (e, t, i) =>
    t in e
      ? xg(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i })
      : (e[t] = i),
  Zr = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
  OO = (e, t) => {
    for (var i in t) xg(e, i, { get: t[i], enumerable: !0 });
  },
  IO = (e, t, i, r) => {
    if ((t && typeof t == "object") || typeof t == "function")
      for (let s of CO(t))
        !PO.call(e, s) &&
          s !== i &&
          xg(e, s, {
            get: () => t[s],
            enumerable: !(r = EO(t, s)) || r.enumerable,
          });
    return e;
  },
  Sr = (e, t, i) => (
    (i = e != null ? MO(TO(e)) : {}),
    IO(
      t || !e || !e.__esModule
        ? xg(i, "default", { value: e, enumerable: !0 })
        : i,
      e
    )
  ),
  Es = (e, t, i) => (DO(e, typeof t != "symbol" ? t + "" : t, i), i),
  RO = Zr((e, t) => {
    (function (i, r) {
      typeof e == "object"
        ? (t.exports = r())
        : typeof define == "function" && define.amd
        ? define(r)
        : (i.Alea = r());
    })(e, function () {
      "use strict";
      return (
        (i.importState = function (s) {
          var a = new i();
          return a.importState(s), a;
        }),
        i
      );
      function i() {
        return (function (s) {
          var a = 0,
            n = 0,
            o = 0,
            l = 1;
          s.length == 0 && (s = [+new Date()]);
          var h = r();
          (a = h(" ")), (n = h(" ")), (o = h(" "));
          for (var u = 0; u < s.length; u++)
            (a -= h(s[u])),
              a < 0 && (a += 1),
              (n -= h(s[u])),
              n < 0 && (n += 1),
              (o -= h(s[u])),
              o < 0 && (o += 1);
          h = null;
          var c = function () {
            var d = 2091639 * a + l * 23283064365386963e-26;
            return (a = n), (n = o), (o = d - (l = d | 0));
          };
          return (
            (c.next = c),
            (c.uint32 = function () {
              return c() * 4294967296;
            }),
            (c.fract53 = function () {
              return c() + ((c() * 2097152) | 0) * 11102230246251565e-32;
            }),
            (c.version = "Alea 0.9"),
            (c.args = s),
            (c.exportState = function () {
              return [a, n, o, l];
            }),
            (c.importState = function (d) {
              (a = +d[0] || 0),
                (n = +d[1] || 0),
                (o = +d[2] || 0),
                (l = +d[3] || 0);
            }),
            c
          );
        })(Array.prototype.slice.call(arguments));
      }
      function r() {
        var s = 4022871197,
          a = function (n) {
            n = n.toString();
            for (var o = 0; o < n.length; o++) {
              s += n.charCodeAt(o);
              var l = 0.02519603282416938 * s;
              (s = l >>> 0),
                (l -= s),
                (l *= s),
                (s = l >>> 0),
                (l -= s),
                (s += l * 4294967296);
            }
            return (s >>> 0) * 23283064365386963e-26;
          };
        return (a.version = "Mash 0.9"), a;
      }
    });
  }),
  FE = Zr((e, t) => {
    (function (i, r) {
      typeof e == "object" && typeof t < "u"
        ? r(e)
        : typeof define == "function" && define.amd
        ? define(["exports"], r)
        : r(
            ((i = typeof globalThis < "u" ? globalThis : i || self).SVDJS = {})
          );
    })(e, function (i) {
      "use strict";
      (i.SVD = function (r, s, a, n, o) {
        if (
          ((s = s === void 0 || s),
          (a = a === void 0 || a),
          (o = 1e-64 / (n = n || Math.pow(2, -52))),
          !r)
        )
          throw new TypeError("Matrix a is not defined");
        var l,
          h,
          u,
          c,
          d,
          p,
          f,
          m,
          g,
          y,
          x,
          b,
          _ = r[0].length,
          S = r.length;
        if (S < _) throw new TypeError("Invalid matrix: m < n");
        for (
          var M = [], C = [], A = [], T = s === "f" ? S : _, P = (y = f = 0);
          P < S;
          P++
        )
          C[P] = new Array(T).fill(0);
        for (P = 0; P < _; P++) A[P] = new Array(_).fill(0);
        var R,
          z = new Array(_).fill(0);
        for (P = 0; P < S; P++) for (l = 0; l < _; l++) C[P][l] = r[P][l];
        for (P = 0; P < _; P++) {
          for (M[P] = f, g = 0, u = P + 1, l = P; l < S; l++)
            g += Math.pow(C[l][P], 2);
          if (g < o) f = 0;
          else
            for (
              m =
                (p = C[P][P]) * (f = p < 0 ? Math.sqrt(g) : -Math.sqrt(g)) - g,
                C[P][P] = p - f,
                l = u;
              l < _;
              l++
            ) {
              for (g = 0, h = P; h < S; h++) g += C[h][P] * C[h][l];
              for (p = g / m, h = P; h < S; h++)
                C[h][l] = C[h][l] + p * C[h][P];
            }
          for (z[P] = f, g = 0, l = u; l < _; l++) g += Math.pow(C[P][l], 2);
          if (g < o) f = 0;
          else {
            for (
              m =
                (p = C[P][P + 1]) * (f = p < 0 ? Math.sqrt(g) : -Math.sqrt(g)) -
                g,
                C[P][P + 1] = p - f,
                l = u;
              l < _;
              l++
            )
              M[l] = C[P][l] / m;
            for (l = u; l < S; l++) {
              for (g = 0, h = u; h < _; h++) g += C[l][h] * C[P][h];
              for (h = u; h < _; h++) C[l][h] = C[l][h] + g * M[h];
            }
          }
          y < (x = Math.abs(z[P]) + Math.abs(M[P])) && (y = x);
        }
        if (a)
          for (P = _ - 1; 0 <= P; P--) {
            if (f !== 0) {
              for (m = C[P][P + 1] * f, l = u; l < _; l++)
                A[l][P] = C[P][l] / m;
              for (l = u; l < _; l++) {
                for (g = 0, h = u; h < _; h++) g += C[P][h] * A[h][l];
                for (h = u; h < _; h++) A[h][l] = A[h][l] + g * A[h][P];
              }
            }
            for (l = u; l < _; l++) (A[P][l] = 0), (A[l][P] = 0);
            (A[P][P] = 1), (f = M[P]), (u = P);
          }
        if (s) {
          if (s === "f")
            for (P = _; P < S; P++) {
              for (l = _; l < S; l++) C[P][l] = 0;
              C[P][P] = 1;
            }
          for (P = _ - 1; 0 <= P; P--) {
            for (u = P + 1, f = z[P], l = u; l < T; l++) C[P][l] = 0;
            if (f !== 0) {
              for (m = C[P][P] * f, l = u; l < T; l++) {
                for (g = 0, h = u; h < S; h++) g += C[h][P] * C[h][l];
                for (p = g / m, h = P; h < S; h++)
                  C[h][l] = C[h][l] + p * C[h][P];
              }
              for (l = P; l < S; l++) C[l][P] = C[l][P] / f;
            } else for (l = P; l < S; l++) C[l][P] = 0;
            C[P][P] = C[P][P] + 1;
          }
        }
        for (n *= y, h = _ - 1; 0 <= h; h--)
          for (var N = 0; N < 50; N++) {
            for (R = !1, u = h; 0 <= u; u--) {
              if (Math.abs(M[u]) <= n) {
                R = !0;
                break;
              }
              if (Math.abs(z[u - 1]) <= n) break;
            }
            if (!R) {
              for (
                d = 0, c = u - (g = 1), P = u;
                P < h + 1 &&
                ((p = g * M[P]), (M[P] = d * M[P]), !(Math.abs(p) <= n));
                P++
              )
                if (
                  ((f = z[P]),
                  (z[P] = Math.sqrt(p * p + f * f)),
                  (d = f / (m = z[P])),
                  (g = -p / m),
                  s)
                )
                  for (l = 0; l < S; l++)
                    (x = C[l][c]),
                      (b = C[l][P]),
                      (C[l][c] = x * d + b * g),
                      (C[l][P] = -x * g + b * d);
            }
            if (((b = z[h]), u === h)) {
              if (b < 0 && ((z[h] = -b), a))
                for (l = 0; l < _; l++) A[l][h] = -A[l][h];
              break;
            }
            for (
              y = z[u],
                p =
                  (((x = z[h - 1]) - b) * (x + b) +
                    ((f = M[h - 1]) - (m = M[h])) * (f + m)) /
                  (2 * m * x),
                f = Math.sqrt(p * p + 1),
                p =
                  ((y - b) * (y + b) + m * (x / (p < 0 ? p - f : p + f) - m)) /
                  y,
                P = u + (g = d = 1);
              P < h + 1;
              P++
            ) {
              if (
                ((f = M[P]),
                (x = z[P]),
                (m = g * f),
                (f *= d),
                (b = Math.sqrt(p * p + m * m)),
                (p = y * (d = p / (M[P - 1] = b)) + f * (g = m / b)),
                (f = -y * g + f * d),
                (m = x * g),
                (x *= d),
                a)
              )
                for (l = 0; l < _; l++)
                  (y = A[l][P - 1]),
                    (b = A[l][P]),
                    (A[l][P - 1] = y * d + b * g),
                    (A[l][P] = -y * g + b * d);
              if (
                ((b = Math.sqrt(p * p + m * m)),
                (p = (d = p / (z[P - 1] = b)) * f + (g = m / b) * x),
                (y = -g * f + d * x),
                s)
              )
                for (l = 0; l < S; l++)
                  (x = C[l][P - 1]),
                    (b = C[l][P]),
                    (C[l][P - 1] = x * d + b * g),
                    (C[l][P] = -x * g + b * d);
            }
            (M[u] = 0), (M[h] = p), (z[h] = y);
          }
        for (P = 0; P < _; P++) z[P] < n && (z[P] = 0);
        return { u: C, q: z, v: A };
      }),
        (i.VERSION = "1.1.1"),
        Object.defineProperty(i, "__esModule", { value: !0 });
    });
  }),
  LO = Zr((e, t) => {
    (function (i, r) {
      typeof e == "object" && typeof t < "u"
        ? (t.exports = r())
        : typeof define == "function" && define.amd
        ? define(r)
        : ((i = i || self), (i.TinyQueue = r()));
    })(e, function () {
      "use strict";
      var i = function (s, a) {
        if (
          (s === void 0 && (s = []),
          a === void 0 && (a = r),
          (this.data = s),
          (this.length = this.data.length),
          (this.compare = a),
          this.length > 0)
        )
          for (var n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
      };
      (i.prototype.push = function (s) {
        this.data.push(s), this.length++, this._up(this.length - 1);
      }),
        (i.prototype.pop = function () {
          if (this.length !== 0) {
            var s = this.data[0],
              a = this.data.pop();
            return (
              this.length--,
              this.length > 0 && ((this.data[0] = a), this._down(0)),
              s
            );
          }
        }),
        (i.prototype.peek = function () {
          return this.data[0];
        }),
        (i.prototype._up = function (s) {
          for (var a = this, n = a.data, o = a.compare, l = n[s]; s > 0; ) {
            var h = (s - 1) >> 1,
              u = n[h];
            if (o(l, u) >= 0) break;
            (n[s] = u), (s = h);
          }
          n[s] = l;
        }),
        (i.prototype._down = function (s) {
          for (
            var a = this,
              n = a.data,
              o = a.compare,
              l = this.length >> 1,
              h = n[s];
            s < l;

          ) {
            var u = (s << 1) + 1,
              c = n[u],
              d = u + 1;
            if (
              (d < this.length && o(n[d], c) < 0 && ((u = d), (c = n[d])),
              o(c, h) >= 0)
            )
              break;
            (n[s] = c), (s = u);
          }
          n[s] = h;
        });
      function r(s, a) {
        return s < a ? -1 : s > a ? 1 : 0;
      }
      return i;
    });
  }),
  BO = Zr((e, t) => {
    "use strict";
    var i = LO();
    i.default && (i = i.default), (t.exports = r), (t.exports.default = r);
    function r(h, u, c) {
      u = u || 1;
      for (var d, p, f, m, g = 0; g < h[0].length; g++) {
        var y = h[0][g];
        (!g || y[0] < d) && (d = y[0]),
          (!g || y[1] < p) && (p = y[1]),
          (!g || y[0] > f) && (f = y[0]),
          (!g || y[1] > m) && (m = y[1]);
      }
      var x = f - d,
        b = m - p,
        _ = Math.min(x, b),
        S = _ / 2;
      if (_ === 0) {
        var M = [d, p];
        return (M.distance = 0), M;
      }
      for (var C = new i(void 0, s), A = d; A < f; A += _)
        for (var T = p; T < m; T += _) C.push(new a(A + S, T + S, S, h));
      var P = o(h),
        R = new a(d + x / 2, p + b / 2, 0, h);
      R.d > P.d && (P = R);
      for (var z = C.length; C.length; ) {
        var N = C.pop();
        N.d > P.d &&
          ((P = N),
          c &&
            console.log(
              "found best %d after %d probes",
              Math.round(1e4 * N.d) / 1e4,
              z
            )),
          !(N.max - P.d <= u) &&
            ((S = N.h / 2),
            C.push(new a(N.x - S, N.y - S, S, h)),
            C.push(new a(N.x + S, N.y - S, S, h)),
            C.push(new a(N.x - S, N.y + S, S, h)),
            C.push(new a(N.x + S, N.y + S, S, h)),
            (z += 4));
      }
      c &&
        (console.log("num probes: " + z), console.log("best distance: " + P.d));
      var L = [P.x, P.y];
      return (L.distance = P.d), L;
    }
    function s(h, u) {
      return u.max - h.max;
    }
    function a(h, u, c, d) {
      (this.x = h),
        (this.y = u),
        (this.h = c),
        (this.d = n(h, u, d)),
        (this.max = this.d + this.h * Math.SQRT2);
    }
    function n(h, u, c) {
      for (var d = !1, p = 1 / 0, f = 0; f < c.length; f++)
        for (var m = c[f], g = 0, y = m.length, x = y - 1; g < y; x = g++) {
          var b = m[g],
            _ = m[x];
          b[1] > u != _[1] > u &&
            h < ((_[0] - b[0]) * (u - b[1])) / (_[1] - b[1]) + b[0] &&
            (d = !d),
            (p = Math.min(p, l(h, u, b, _)));
        }
      return p === 0 ? 0 : (d ? 1 : -1) * Math.sqrt(p);
    }
    function o(h) {
      for (
        var u = 0, c = 0, d = 0, p = h[0], f = 0, m = p.length, g = m - 1;
        f < m;
        g = f++
      ) {
        var y = p[f],
          x = p[g],
          b = y[0] * x[1] - x[0] * y[1];
        (c += (y[0] + x[0]) * b), (d += (y[1] + x[1]) * b), (u += b * 3);
      }
      return u === 0
        ? new a(p[0][0], p[0][1], 0, h)
        : new a(c / u, d / u, 0, h);
    }
    function l(h, u, c, d) {
      var p = c[0],
        f = c[1],
        m = d[0] - p,
        g = d[1] - f;
      if (m !== 0 || g !== 0) {
        var y = ((h - p) * m + (u - f) * g) / (m * m + g * g);
        y > 1
          ? ((p = d[0]), (f = d[1]))
          : y > 0 && ((p += m * y), (f += g * y));
      }
      return (m = h - p), (g = u - f), m * m + g * g;
    }
  }),
  zO = Zr((e, t) => {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = i);
    function i(r) {
      if (r === null || r === !0 || r === !1) return NaN;
      var s = Number(r);
      return isNaN(s) ? s : s < 0 ? Math.ceil(s) : Math.floor(s);
    }
    t.exports = e.default;
  }),
  FO = Zr((e, t) => {
    "use strict";
    Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = i);
    function i(r) {
      var s = new Date(
        Date.UTC(
          r.getFullYear(),
          r.getMonth(),
          r.getDate(),
          r.getHours(),
          r.getMinutes(),
          r.getSeconds(),
          r.getMilliseconds()
        )
      );
      return s.setUTCFullYear(r.getFullYear()), r.getTime() - s.getTime();
    }
    t.exports = e.default;
  }),
  kO = Zr((e) => {
    (function () {
      "use strict";
      var t = function () {
        this.init();
      };
      t.prototype = {
        init: function () {
          var c = this || i;
          return (
            (c._counter = 1e3),
            (c._html5AudioPool = []),
            (c.html5PoolSize = 10),
            (c._codecs = {}),
            (c._howls = []),
            (c._muted = !1),
            (c._volume = 1),
            (c._canPlayEvent = "canplaythrough"),
            (c._navigator =
              typeof window < "u" && window.navigator
                ? window.navigator
                : null),
            (c.masterGain = null),
            (c.noAudio = !1),
            (c.usingWebAudio = !0),
            (c.autoSuspend = !0),
            (c.ctx = null),
            (c.autoUnlock = !0),
            c._setup(),
            c
          );
        },
        volume: function (c) {
          var d = this || i;
          if (
            ((c = parseFloat(c)),
            d.ctx || u(),
            typeof c < "u" && c >= 0 && c <= 1)
          ) {
            if (((d._volume = c), d._muted)) return d;
            d.usingWebAudio &&
              d.masterGain.gain.setValueAtTime(c, i.ctx.currentTime);
            for (var p = 0; p < d._howls.length; p++)
              if (!d._howls[p]._webAudio)
                for (
                  var f = d._howls[p]._getSoundIds(), m = 0;
                  m < f.length;
                  m++
                ) {
                  var g = d._howls[p]._soundById(f[m]);
                  g && g._node && (g._node.volume = g._volume * c);
                }
            return d;
          }
          return d._volume;
        },
        mute: function (c) {
          var d = this || i;
          d.ctx || u(),
            (d._muted = c),
            d.usingWebAudio &&
              d.masterGain.gain.setValueAtTime(
                c ? 0 : d._volume,
                i.ctx.currentTime
              );
          for (var p = 0; p < d._howls.length; p++)
            if (!d._howls[p]._webAudio)
              for (
                var f = d._howls[p]._getSoundIds(), m = 0;
                m < f.length;
                m++
              ) {
                var g = d._howls[p]._soundById(f[m]);
                g && g._node && (g._node.muted = c ? !0 : g._muted);
              }
          return d;
        },
        stop: function () {
          for (var c = this || i, d = 0; d < c._howls.length; d++)
            c._howls[d].stop();
          return c;
        },
        unload: function () {
          for (var c = this || i, d = c._howls.length - 1; d >= 0; d--)
            c._howls[d].unload();
          return (
            c.usingWebAudio &&
              c.ctx &&
              typeof c.ctx.close < "u" &&
              (c.ctx.close(), (c.ctx = null), u()),
            c
          );
        },
        codecs: function (c) {
          return (this || i)._codecs[c.replace(/^x-/, "")];
        },
        _setup: function () {
          var c = this || i;
          if (
            ((c.state = (c.ctx && c.ctx.state) || "suspended"),
            c._autoSuspend(),
            !c.usingWebAudio)
          )
            if (typeof Audio < "u")
              try {
                var d = new Audio();
                typeof d.oncanplaythrough > "u" &&
                  (c._canPlayEvent = "canplay");
              } catch {
                c.noAudio = !0;
              }
            else c.noAudio = !0;
          try {
            var d = new Audio();
            d.muted && (c.noAudio = !0);
          } catch {}
          return c.noAudio || c._setupCodecs(), c;
        },
        _setupCodecs: function () {
          var c = this || i,
            d = null;
          try {
            d = typeof Audio < "u" ? new Audio() : null;
          } catch {
            return c;
          }
          if (!d || typeof d.canPlayType != "function") return c;
          var p = d.canPlayType("audio/mpeg;").replace(/^no$/, ""),
            f = c._navigator ? c._navigator.userAgent : "",
            m = f.match(/OPR\/([0-6].)/g),
            g = m && parseInt(m[0].split("/")[1], 10) < 33,
            y = f.indexOf("Safari") !== -1 && f.indexOf("Chrome") === -1,
            x = f.match(/Version\/(.*?) /),
            b = y && x && parseInt(x[1], 10) < 15;
          return (
            (c._codecs = {
              mp3: !!(
                !g &&
                (p || d.canPlayType("audio/mp3;").replace(/^no$/, ""))
              ),
              mpeg: !!p,
              opus: !!d
                .canPlayType('audio/ogg; codecs="opus"')
                .replace(/^no$/, ""),
              ogg: !!d
                .canPlayType('audio/ogg; codecs="vorbis"')
                .replace(/^no$/, ""),
              oga: !!d
                .canPlayType('audio/ogg; codecs="vorbis"')
                .replace(/^no$/, ""),
              wav: !!(
                d.canPlayType('audio/wav; codecs="1"') ||
                d.canPlayType("audio/wav")
              ).replace(/^no$/, ""),
              aac: !!d.canPlayType("audio/aac;").replace(/^no$/, ""),
              caf: !!d.canPlayType("audio/x-caf;").replace(/^no$/, ""),
              m4a: !!(
                d.canPlayType("audio/x-m4a;") ||
                d.canPlayType("audio/m4a;") ||
                d.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              m4b: !!(
                d.canPlayType("audio/x-m4b;") ||
                d.canPlayType("audio/m4b;") ||
                d.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              mp4: !!(
                d.canPlayType("audio/x-mp4;") ||
                d.canPlayType("audio/mp4;") ||
                d.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              weba: !!(
                !b &&
                d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
              ),
              webm: !!(
                !b &&
                d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
              ),
              dolby: !!d
                .canPlayType('audio/mp4; codecs="ec-3"')
                .replace(/^no$/, ""),
              flac: !!(
                d.canPlayType("audio/x-flac;") || d.canPlayType("audio/flac;")
              ).replace(/^no$/, ""),
            }),
            c
          );
        },
        _unlockAudio: function () {
          var c = this || i;
          if (!(c._audioUnlocked || !c.ctx)) {
            (c._audioUnlocked = !1),
              (c.autoUnlock = !1),
              !c._mobileUnloaded &&
                c.ctx.sampleRate !== 44100 &&
                ((c._mobileUnloaded = !0), c.unload()),
              (c._scratchBuffer = c.ctx.createBuffer(1, 1, 22050));
            var d = function (p) {
              for (; c._html5AudioPool.length < c.html5PoolSize; )
                try {
                  var f = new Audio();
                  (f._unlocked = !0), c._releaseHtml5Audio(f);
                } catch {
                  c.noAudio = !0;
                  break;
                }
              for (var m = 0; m < c._howls.length; m++)
                if (!c._howls[m]._webAudio)
                  for (
                    var g = c._howls[m]._getSoundIds(), y = 0;
                    y < g.length;
                    y++
                  ) {
                    var x = c._howls[m]._soundById(g[y]);
                    x &&
                      x._node &&
                      !x._node._unlocked &&
                      ((x._node._unlocked = !0), x._node.load());
                  }
              c._autoResume();
              var b = c.ctx.createBufferSource();
              (b.buffer = c._scratchBuffer),
                b.connect(c.ctx.destination),
                typeof b.start > "u" ? b.noteOn(0) : b.start(0),
                typeof c.ctx.resume == "function" && c.ctx.resume(),
                (b.onended = function () {
                  b.disconnect(0),
                    (c._audioUnlocked = !0),
                    document.removeEventListener("touchstart", d, !0),
                    document.removeEventListener("touchend", d, !0),
                    document.removeEventListener("click", d, !0),
                    document.removeEventListener("keydown", d, !0);
                  for (var _ = 0; _ < c._howls.length; _++)
                    c._howls[_]._emit("unlock");
                });
            };
            return (
              document.addEventListener("touchstart", d, !0),
              document.addEventListener("touchend", d, !0),
              document.addEventListener("click", d, !0),
              document.addEventListener("keydown", d, !0),
              c
            );
          }
        },
        _obtainHtml5Audio: function () {
          var c = this || i;
          if (c._html5AudioPool.length) return c._html5AudioPool.pop();
          var d = new Audio().play();
          return (
            d &&
              typeof Promise < "u" &&
              (d instanceof Promise || typeof d.then == "function") &&
              d.catch(function () {
                console.warn(
                  "HTML5 Audio pool exhausted, returning potentially locked audio object."
                );
              }),
            new Audio()
          );
        },
        _releaseHtml5Audio: function (c) {
          var d = this || i;
          return c._unlocked && d._html5AudioPool.push(c), d;
        },
        _autoSuspend: function () {
          var c = this;
          if (
            !(
              !c.autoSuspend ||
              !c.ctx ||
              typeof c.ctx.suspend > "u" ||
              !i.usingWebAudio
            )
          ) {
            for (var d = 0; d < c._howls.length; d++)
              if (c._howls[d]._webAudio) {
                for (var p = 0; p < c._howls[d]._sounds.length; p++)
                  if (!c._howls[d]._sounds[p]._paused) return c;
              }
            return (
              c._suspendTimer && clearTimeout(c._suspendTimer),
              (c._suspendTimer = setTimeout(function () {
                if (c.autoSuspend) {
                  (c._suspendTimer = null), (c.state = "suspending");
                  var f = function () {
                    (c.state = "suspended"),
                      c._resumeAfterSuspend &&
                        (delete c._resumeAfterSuspend, c._autoResume());
                  };
                  c.ctx.suspend().then(f, f);
                }
              }, 3e4)),
              c
            );
          }
        },
        _autoResume: function () {
          var c = this;
          if (!(!c.ctx || typeof c.ctx.resume > "u" || !i.usingWebAudio))
            return (
              c.state === "running" &&
              c.ctx.state !== "interrupted" &&
              c._suspendTimer
                ? (clearTimeout(c._suspendTimer), (c._suspendTimer = null))
                : c.state === "suspended" ||
                  (c.state === "running" && c.ctx.state === "interrupted")
                ? (c.ctx.resume().then(function () {
                    c.state = "running";
                    for (var d = 0; d < c._howls.length; d++)
                      c._howls[d]._emit("resume");
                  }),
                  c._suspendTimer &&
                    (clearTimeout(c._suspendTimer), (c._suspendTimer = null)))
                : c.state === "suspending" && (c._resumeAfterSuspend = !0),
              c
            );
        },
      };
      var i = new t(),
        r = function (c) {
          var d = this;
          if (!c.src || c.src.length === 0) {
            console.error(
              "An array of source files must be passed with any new Howl."
            );
            return;
          }
          d.init(c);
        };
      r.prototype = {
        init: function (c) {
          var d = this;
          return (
            i.ctx || u(),
            (d._autoplay = c.autoplay || !1),
            (d._format = typeof c.format != "string" ? c.format : [c.format]),
            (d._html5 = c.html5 || !1),
            (d._muted = c.mute || !1),
            (d._loop = c.loop || !1),
            (d._pool = c.pool || 5),
            (d._preload =
              typeof c.preload == "boolean" || c.preload === "metadata"
                ? c.preload
                : !0),
            (d._rate = c.rate || 1),
            (d._sprite = c.sprite || {}),
            (d._src = typeof c.src != "string" ? c.src : [c.src]),
            (d._volume = c.volume !== void 0 ? c.volume : 1),
            (d._xhr = {
              method: c.xhr && c.xhr.method ? c.xhr.method : "GET",
              headers: c.xhr && c.xhr.headers ? c.xhr.headers : null,
              withCredentials:
                c.xhr && c.xhr.withCredentials ? c.xhr.withCredentials : !1,
            }),
            (d._duration = 0),
            (d._state = "unloaded"),
            (d._sounds = []),
            (d._endTimers = {}),
            (d._queue = []),
            (d._playLock = !1),
            (d._onend = c.onend ? [{ fn: c.onend }] : []),
            (d._onfade = c.onfade ? [{ fn: c.onfade }] : []),
            (d._onload = c.onload ? [{ fn: c.onload }] : []),
            (d._onloaderror = c.onloaderror ? [{ fn: c.onloaderror }] : []),
            (d._onplayerror = c.onplayerror ? [{ fn: c.onplayerror }] : []),
            (d._onpause = c.onpause ? [{ fn: c.onpause }] : []),
            (d._onplay = c.onplay ? [{ fn: c.onplay }] : []),
            (d._onstop = c.onstop ? [{ fn: c.onstop }] : []),
            (d._onmute = c.onmute ? [{ fn: c.onmute }] : []),
            (d._onvolume = c.onvolume ? [{ fn: c.onvolume }] : []),
            (d._onrate = c.onrate ? [{ fn: c.onrate }] : []),
            (d._onseek = c.onseek ? [{ fn: c.onseek }] : []),
            (d._onunlock = c.onunlock ? [{ fn: c.onunlock }] : []),
            (d._onresume = []),
            (d._webAudio = i.usingWebAudio && !d._html5),
            typeof i.ctx < "u" && i.ctx && i.autoUnlock && i._unlockAudio(),
            i._howls.push(d),
            d._autoplay &&
              d._queue.push({
                event: "play",
                action: function () {
                  d.play();
                },
              }),
            d._preload && d._preload !== "none" && d.load(),
            d
          );
        },
        load: function () {
          var c = this,
            d = null;
          if (i.noAudio) {
            c._emit("loaderror", null, "No audio support.");
            return;
          }
          typeof c._src == "string" && (c._src = [c._src]);
          for (var p = 0; p < c._src.length; p++) {
            var f, m;
            if (c._format && c._format[p]) f = c._format[p];
            else {
              if (((m = c._src[p]), typeof m != "string")) {
                c._emit(
                  "loaderror",
                  null,
                  "Non-string found in selected audio sources - ignoring."
                );
                continue;
              }
              (f = /^data:audio\/([^;,]+);/i.exec(m)),
                f || (f = /\.([^.]+)$/.exec(m.split("?", 1)[0])),
                f && (f = f[1].toLowerCase());
            }
            if (
              (f ||
                console.warn(
                  'No file extension was found. Consider using the "format" property or specify an extension.'
                ),
              f && i.codecs(f))
            ) {
              d = c._src[p];
              break;
            }
          }
          if (!d) {
            c._emit(
              "loaderror",
              null,
              "No codec support for selected audio sources."
            );
            return;
          }
          return (
            (c._src = d),
            (c._state = "loading"),
            window.location.protocol === "https:" &&
              d.slice(0, 5) === "http:" &&
              ((c._html5 = !0), (c._webAudio = !1)),
            new s(c),
            c._webAudio && n(c),
            c
          );
        },
        play: function (c, d) {
          var p = this,
            f = null;
          if (typeof c == "number") (f = c), (c = null);
          else {
            if (typeof c == "string" && p._state === "loaded" && !p._sprite[c])
              return null;
            if (typeof c > "u" && ((c = "__default"), !p._playLock)) {
              for (var m = 0, g = 0; g < p._sounds.length; g++)
                p._sounds[g]._paused &&
                  !p._sounds[g]._ended &&
                  (m++, (f = p._sounds[g]._id));
              m === 1 ? (c = null) : (f = null);
            }
          }
          var y = f ? p._soundById(f) : p._inactiveSound();
          if (!y) return null;
          if (
            (f && !c && (c = y._sprite || "__default"), p._state !== "loaded")
          ) {
            (y._sprite = c), (y._ended = !1);
            var x = y._id;
            return (
              p._queue.push({
                event: "play",
                action: function () {
                  p.play(x);
                },
              }),
              x
            );
          }
          if (f && !y._paused) return d || p._loadQueue("play"), y._id;
          p._webAudio && i._autoResume();
          var b = Math.max(0, y._seek > 0 ? y._seek : p._sprite[c][0] / 1e3),
            _ = Math.max(0, (p._sprite[c][0] + p._sprite[c][1]) / 1e3 - b),
            S = (_ * 1e3) / Math.abs(y._rate),
            M = p._sprite[c][0] / 1e3,
            C = (p._sprite[c][0] + p._sprite[c][1]) / 1e3;
          (y._sprite = c), (y._ended = !1);
          var A = function () {
            (y._paused = !1),
              (y._seek = b),
              (y._start = M),
              (y._stop = C),
              (y._loop = !!(y._loop || p._sprite[c][2]));
          };
          if (b >= C) {
            p._ended(y);
            return;
          }
          var T = y._node;
          if (p._webAudio) {
            var P = function () {
              (p._playLock = !1), A(), p._refreshBuffer(y);
              var L = y._muted || p._muted ? 0 : y._volume;
              T.gain.setValueAtTime(L, i.ctx.currentTime),
                (y._playStart = i.ctx.currentTime),
                typeof T.bufferSource.start > "u"
                  ? y._loop
                    ? T.bufferSource.noteGrainOn(0, b, 86400)
                    : T.bufferSource.noteGrainOn(0, b, _)
                  : y._loop
                  ? T.bufferSource.start(0, b, 86400)
                  : T.bufferSource.start(0, b, _),
                S !== 1 / 0 &&
                  (p._endTimers[y._id] = setTimeout(p._ended.bind(p, y), S)),
                d ||
                  setTimeout(function () {
                    p._emit("play", y._id), p._loadQueue();
                  }, 0);
            };
            i.state === "running" && i.ctx.state !== "interrupted"
              ? P()
              : ((p._playLock = !0), p.once("resume", P), p._clearTimer(y._id));
          } else {
            var R = function () {
              (T.currentTime = b),
                (T.muted = y._muted || p._muted || i._muted || T.muted),
                (T.volume = y._volume * i.volume()),
                (T.playbackRate = y._rate);
              try {
                var L = T.play();
                if (
                  (L &&
                  typeof Promise < "u" &&
                  (L instanceof Promise || typeof L.then == "function")
                    ? ((p._playLock = !0),
                      A(),
                      L.then(function () {
                        (p._playLock = !1),
                          (T._unlocked = !0),
                          d ? p._loadQueue() : p._emit("play", y._id);
                      }).catch(function () {
                        (p._playLock = !1),
                          p._emit(
                            "playerror",
                            y._id,
                            "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                          ),
                          (y._ended = !0),
                          (y._paused = !0);
                      }))
                    : d || ((p._playLock = !1), A(), p._emit("play", y._id)),
                  (T.playbackRate = y._rate),
                  T.paused)
                ) {
                  p._emit(
                    "playerror",
                    y._id,
                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                  );
                  return;
                }
                c !== "__default" || y._loop
                  ? (p._endTimers[y._id] = setTimeout(p._ended.bind(p, y), S))
                  : ((p._endTimers[y._id] = function () {
                      p._ended(y),
                        T.removeEventListener("ended", p._endTimers[y._id], !1);
                    }),
                    T.addEventListener("ended", p._endTimers[y._id], !1));
              } catch (G) {
                p._emit("playerror", y._id, G);
              }
            };
            T.src ===
              "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" &&
              ((T.src = p._src), T.load());
            var z =
              (window && window.ejecta) ||
              (!T.readyState && i._navigator.isCocoonJS);
            if (T.readyState >= 3 || z) R();
            else {
              (p._playLock = !0), (p._state = "loading");
              var N = function () {
                (p._state = "loaded"),
                  R(),
                  T.removeEventListener(i._canPlayEvent, N, !1);
              };
              T.addEventListener(i._canPlayEvent, N, !1), p._clearTimer(y._id);
            }
          }
          return y._id;
        },
        pause: function (c) {
          var d = this;
          if (d._state !== "loaded" || d._playLock)
            return (
              d._queue.push({
                event: "pause",
                action: function () {
                  d.pause(c);
                },
              }),
              d
            );
          for (var p = d._getSoundIds(c), f = 0; f < p.length; f++) {
            d._clearTimer(p[f]);
            var m = d._soundById(p[f]);
            if (
              m &&
              !m._paused &&
              ((m._seek = d.seek(p[f])),
              (m._rateSeek = 0),
              (m._paused = !0),
              d._stopFade(p[f]),
              m._node)
            )
              if (d._webAudio) {
                if (!m._node.bufferSource) continue;
                typeof m._node.bufferSource.stop > "u"
                  ? m._node.bufferSource.noteOff(0)
                  : m._node.bufferSource.stop(0),
                  d._cleanBuffer(m._node);
              } else
                (!isNaN(m._node.duration) || m._node.duration === 1 / 0) &&
                  m._node.pause();
            arguments[1] || d._emit("pause", m ? m._id : null);
          }
          return d;
        },
        stop: function (c, d) {
          var p = this;
          if (p._state !== "loaded" || p._playLock)
            return (
              p._queue.push({
                event: "stop",
                action: function () {
                  p.stop(c);
                },
              }),
              p
            );
          for (var f = p._getSoundIds(c), m = 0; m < f.length; m++) {
            p._clearTimer(f[m]);
            var g = p._soundById(f[m]);
            g &&
              ((g._seek = g._start || 0),
              (g._rateSeek = 0),
              (g._paused = !0),
              (g._ended = !0),
              p._stopFade(f[m]),
              g._node &&
                (p._webAudio
                  ? g._node.bufferSource &&
                    (typeof g._node.bufferSource.stop > "u"
                      ? g._node.bufferSource.noteOff(0)
                      : g._node.bufferSource.stop(0),
                    p._cleanBuffer(g._node))
                  : (!isNaN(g._node.duration) || g._node.duration === 1 / 0) &&
                    ((g._node.currentTime = g._start || 0),
                    g._node.pause(),
                    g._node.duration === 1 / 0 && p._clearSound(g._node))),
              d || p._emit("stop", g._id));
          }
          return p;
        },
        mute: function (c, d) {
          var p = this;
          if (p._state !== "loaded" || p._playLock)
            return (
              p._queue.push({
                event: "mute",
                action: function () {
                  p.mute(c, d);
                },
              }),
              p
            );
          if (typeof d > "u")
            if (typeof c == "boolean") p._muted = c;
            else return p._muted;
          for (var f = p._getSoundIds(d), m = 0; m < f.length; m++) {
            var g = p._soundById(f[m]);
            g &&
              ((g._muted = c),
              g._interval && p._stopFade(g._id),
              p._webAudio && g._node
                ? g._node.gain.setValueAtTime(
                    c ? 0 : g._volume,
                    i.ctx.currentTime
                  )
                : g._node && (g._node.muted = i._muted ? !0 : c),
              p._emit("mute", g._id));
          }
          return p;
        },
        volume: function () {
          var c = this,
            d = arguments,
            p,
            f;
          if (d.length === 0) return c._volume;
          if (d.length === 1 || (d.length === 2 && typeof d[1] > "u")) {
            var m = c._getSoundIds(),
              g = m.indexOf(d[0]);
            g >= 0 ? (f = parseInt(d[0], 10)) : (p = parseFloat(d[0]));
          } else
            d.length >= 2 && ((p = parseFloat(d[0])), (f = parseInt(d[1], 10)));
          var y;
          if (typeof p < "u" && p >= 0 && p <= 1) {
            if (c._state !== "loaded" || c._playLock)
              return (
                c._queue.push({
                  event: "volume",
                  action: function () {
                    c.volume.apply(c, d);
                  },
                }),
                c
              );
            typeof f > "u" && (c._volume = p), (f = c._getSoundIds(f));
            for (var x = 0; x < f.length; x++)
              (y = c._soundById(f[x])),
                y &&
                  ((y._volume = p),
                  d[2] || c._stopFade(f[x]),
                  c._webAudio && y._node && !y._muted
                    ? y._node.gain.setValueAtTime(p, i.ctx.currentTime)
                    : y._node && !y._muted && (y._node.volume = p * i.volume()),
                  c._emit("volume", y._id));
          } else
            return (y = f ? c._soundById(f) : c._sounds[0]), y ? y._volume : 0;
          return c;
        },
        fade: function (c, d, p, f) {
          var m = this;
          if (m._state !== "loaded" || m._playLock)
            return (
              m._queue.push({
                event: "fade",
                action: function () {
                  m.fade(c, d, p, f);
                },
              }),
              m
            );
          (c = Math.min(Math.max(0, parseFloat(c)), 1)),
            (d = Math.min(Math.max(0, parseFloat(d)), 1)),
            (p = parseFloat(p)),
            m.volume(c, f);
          for (var g = m._getSoundIds(f), y = 0; y < g.length; y++) {
            var x = m._soundById(g[y]);
            if (x) {
              if ((f || m._stopFade(g[y]), m._webAudio && !x._muted)) {
                var b = i.ctx.currentTime,
                  _ = b + p / 1e3;
                (x._volume = c),
                  x._node.gain.setValueAtTime(c, b),
                  x._node.gain.linearRampToValueAtTime(d, _);
              }
              m._startFadeInterval(x, c, d, p, g[y], typeof f > "u");
            }
          }
          return m;
        },
        _startFadeInterval: function (c, d, p, f, m, g) {
          var y = this,
            x = d,
            b = p - d,
            _ = Math.abs(b / 0.01),
            S = Math.max(4, _ > 0 ? f / _ : f),
            M = Date.now();
          (c._fadeTo = p),
            (c._interval = setInterval(function () {
              var C = (Date.now() - M) / f;
              (M = Date.now()),
                (x += b * C),
                (x = Math.round(x * 100) / 100),
                b < 0 ? (x = Math.max(p, x)) : (x = Math.min(p, x)),
                y._webAudio ? (c._volume = x) : y.volume(x, c._id, !0),
                g && (y._volume = x),
                ((p < d && x <= p) || (p > d && x >= p)) &&
                  (clearInterval(c._interval),
                  (c._interval = null),
                  (c._fadeTo = null),
                  y.volume(p, c._id),
                  y._emit("fade", c._id));
            }, S));
        },
        _stopFade: function (c) {
          var d = this,
            p = d._soundById(c);
          return (
            p &&
              p._interval &&
              (d._webAudio &&
                p._node.gain.cancelScheduledValues(i.ctx.currentTime),
              clearInterval(p._interval),
              (p._interval = null),
              d.volume(p._fadeTo, c),
              (p._fadeTo = null),
              d._emit("fade", c)),
            d
          );
        },
        loop: function () {
          var c = this,
            d = arguments,
            p,
            f,
            m;
          if (d.length === 0) return c._loop;
          if (d.length === 1)
            if (typeof d[0] == "boolean") (p = d[0]), (c._loop = p);
            else
              return (m = c._soundById(parseInt(d[0], 10))), m ? m._loop : !1;
          else d.length === 2 && ((p = d[0]), (f = parseInt(d[1], 10)));
          for (var g = c._getSoundIds(f), y = 0; y < g.length; y++)
            (m = c._soundById(g[y])),
              m &&
                ((m._loop = p),
                c._webAudio &&
                  m._node &&
                  m._node.bufferSource &&
                  ((m._node.bufferSource.loop = p),
                  p &&
                    ((m._node.bufferSource.loopStart = m._start || 0),
                    (m._node.bufferSource.loopEnd = m._stop),
                    c.playing(g[y]) && (c.pause(g[y], !0), c.play(g[y], !0)))));
          return c;
        },
        rate: function () {
          var c = this,
            d = arguments,
            p,
            f;
          if (d.length === 0) f = c._sounds[0]._id;
          else if (d.length === 1) {
            var m = c._getSoundIds(),
              g = m.indexOf(d[0]);
            g >= 0 ? (f = parseInt(d[0], 10)) : (p = parseFloat(d[0]));
          } else
            d.length === 2 &&
              ((p = parseFloat(d[0])), (f = parseInt(d[1], 10)));
          var y;
          if (typeof p == "number") {
            if (c._state !== "loaded" || c._playLock)
              return (
                c._queue.push({
                  event: "rate",
                  action: function () {
                    c.rate.apply(c, d);
                  },
                }),
                c
              );
            typeof f > "u" && (c._rate = p), (f = c._getSoundIds(f));
            for (var x = 0; x < f.length; x++)
              if (((y = c._soundById(f[x])), y)) {
                c.playing(f[x]) &&
                  ((y._rateSeek = c.seek(f[x])),
                  (y._playStart = c._webAudio
                    ? i.ctx.currentTime
                    : y._playStart)),
                  (y._rate = p),
                  c._webAudio && y._node && y._node.bufferSource
                    ? y._node.bufferSource.playbackRate.setValueAtTime(
                        p,
                        i.ctx.currentTime
                      )
                    : y._node && (y._node.playbackRate = p);
                var b = c.seek(f[x]),
                  _ =
                    (c._sprite[y._sprite][0] + c._sprite[y._sprite][1]) / 1e3 -
                    b,
                  S = (_ * 1e3) / Math.abs(y._rate);
                (c._endTimers[f[x]] || !y._paused) &&
                  (c._clearTimer(f[x]),
                  (c._endTimers[f[x]] = setTimeout(c._ended.bind(c, y), S))),
                  c._emit("rate", y._id);
              }
          } else return (y = c._soundById(f)), y ? y._rate : c._rate;
          return c;
        },
        seek: function () {
          var c = this,
            d = arguments,
            p,
            f;
          if (d.length === 0) c._sounds.length && (f = c._sounds[0]._id);
          else if (d.length === 1) {
            var m = c._getSoundIds(),
              g = m.indexOf(d[0]);
            g >= 0
              ? (f = parseInt(d[0], 10))
              : c._sounds.length &&
                ((f = c._sounds[0]._id), (p = parseFloat(d[0])));
          } else
            d.length === 2 &&
              ((p = parseFloat(d[0])), (f = parseInt(d[1], 10)));
          if (typeof f > "u") return 0;
          if (typeof p == "number" && (c._state !== "loaded" || c._playLock))
            return (
              c._queue.push({
                event: "seek",
                action: function () {
                  c.seek.apply(c, d);
                },
              }),
              c
            );
          var y = c._soundById(f);
          if (y)
            if (typeof p == "number" && p >= 0) {
              var x = c.playing(f);
              x && c.pause(f, !0),
                (y._seek = p),
                (y._ended = !1),
                c._clearTimer(f),
                !c._webAudio &&
                  y._node &&
                  !isNaN(y._node.duration) &&
                  (y._node.currentTime = p);
              var b = function () {
                x && c.play(f, !0), c._emit("seek", f);
              };
              if (x && !c._webAudio) {
                var _ = function () {
                  c._playLock ? setTimeout(_, 0) : b();
                };
                setTimeout(_, 0);
              } else b();
            } else if (c._webAudio) {
              var S = c.playing(f) ? i.ctx.currentTime - y._playStart : 0,
                M = y._rateSeek ? y._rateSeek - y._seek : 0;
              return y._seek + (M + S * Math.abs(y._rate));
            } else return y._node.currentTime;
          return c;
        },
        playing: function (c) {
          var d = this;
          if (typeof c == "number") {
            var p = d._soundById(c);
            return p ? !p._paused : !1;
          }
          for (var f = 0; f < d._sounds.length; f++)
            if (!d._sounds[f]._paused) return !0;
          return !1;
        },
        duration: function (c) {
          var d = this,
            p = d._duration,
            f = d._soundById(c);
          return f && (p = d._sprite[f._sprite][1] / 1e3), p;
        },
        state: function () {
          return this._state;
        },
        unload: function () {
          for (var c = this, d = c._sounds, p = 0; p < d.length; p++)
            d[p]._paused || c.stop(d[p]._id),
              c._webAudio ||
                (c._clearSound(d[p]._node),
                d[p]._node.removeEventListener("error", d[p]._errorFn, !1),
                d[p]._node.removeEventListener(
                  i._canPlayEvent,
                  d[p]._loadFn,
                  !1
                ),
                d[p]._node.removeEventListener("ended", d[p]._endFn, !1),
                i._releaseHtml5Audio(d[p]._node)),
              delete d[p]._node,
              c._clearTimer(d[p]._id);
          var f = i._howls.indexOf(c);
          f >= 0 && i._howls.splice(f, 1);
          var m = !0;
          for (p = 0; p < i._howls.length; p++)
            if (
              i._howls[p]._src === c._src ||
              c._src.indexOf(i._howls[p]._src) >= 0
            ) {
              m = !1;
              break;
            }
          return (
            a && m && delete a[c._src],
            (i.noAudio = !1),
            (c._state = "unloaded"),
            (c._sounds = []),
            (c = null),
            null
          );
        },
        on: function (c, d, p, f) {
          var m = this,
            g = m["_on" + c];
          return (
            typeof d == "function" &&
              g.push(f ? { id: p, fn: d, once: f } : { id: p, fn: d }),
            m
          );
        },
        off: function (c, d, p) {
          var f = this,
            m = f["_on" + c],
            g = 0;
          if ((typeof d == "number" && ((p = d), (d = null)), d || p))
            for (g = 0; g < m.length; g++) {
              var y = p === m[g].id;
              if ((d === m[g].fn && y) || (!d && y)) {
                m.splice(g, 1);
                break;
              }
            }
          else if (c) f["_on" + c] = [];
          else {
            var x = Object.keys(f);
            for (g = 0; g < x.length; g++)
              x[g].indexOf("_on") === 0 &&
                Array.isArray(f[x[g]]) &&
                (f[x[g]] = []);
          }
          return f;
        },
        once: function (c, d, p) {
          var f = this;
          return f.on(c, d, p, 1), f;
        },
        _emit: function (c, d, p) {
          for (var f = this, m = f["_on" + c], g = m.length - 1; g >= 0; g--)
            (!m[g].id || m[g].id === d || c === "load") &&
              (setTimeout(
                function (y) {
                  y.call(this, d, p);
                }.bind(f, m[g].fn),
                0
              ),
              m[g].once && f.off(c, m[g].fn, m[g].id));
          return f._loadQueue(c), f;
        },
        _loadQueue: function (c) {
          var d = this;
          if (d._queue.length > 0) {
            var p = d._queue[0];
            p.event === c && (d._queue.shift(), d._loadQueue()),
              c || p.action();
          }
          return d;
        },
        _ended: function (c) {
          var d = this,
            p = c._sprite;
          if (
            !d._webAudio &&
            c._node &&
            !c._node.paused &&
            !c._node.ended &&
            c._node.currentTime < c._stop
          )
            return setTimeout(d._ended.bind(d, c), 100), d;
          var f = !!(c._loop || d._sprite[p][2]);
          if (
            (d._emit("end", c._id),
            !d._webAudio && f && d.stop(c._id, !0).play(c._id),
            d._webAudio && f)
          ) {
            d._emit("play", c._id),
              (c._seek = c._start || 0),
              (c._rateSeek = 0),
              (c._playStart = i.ctx.currentTime);
            var m = ((c._stop - c._start) * 1e3) / Math.abs(c._rate);
            d._endTimers[c._id] = setTimeout(d._ended.bind(d, c), m);
          }
          return (
            d._webAudio &&
              !f &&
              ((c._paused = !0),
              (c._ended = !0),
              (c._seek = c._start || 0),
              (c._rateSeek = 0),
              d._clearTimer(c._id),
              d._cleanBuffer(c._node),
              i._autoSuspend()),
            !d._webAudio && !f && d.stop(c._id, !0),
            d
          );
        },
        _clearTimer: function (c) {
          var d = this;
          if (d._endTimers[c]) {
            if (typeof d._endTimers[c] != "function")
              clearTimeout(d._endTimers[c]);
            else {
              var p = d._soundById(c);
              p &&
                p._node &&
                p._node.removeEventListener("ended", d._endTimers[c], !1);
            }
            delete d._endTimers[c];
          }
          return d;
        },
        _soundById: function (c) {
          for (var d = this, p = 0; p < d._sounds.length; p++)
            if (c === d._sounds[p]._id) return d._sounds[p];
          return null;
        },
        _inactiveSound: function () {
          var c = this;
          c._drain();
          for (var d = 0; d < c._sounds.length; d++)
            if (c._sounds[d]._ended) return c._sounds[d].reset();
          return new s(c);
        },
        _drain: function () {
          var c = this,
            d = c._pool,
            p = 0,
            f = 0;
          if (!(c._sounds.length < d)) {
            for (f = 0; f < c._sounds.length; f++) c._sounds[f]._ended && p++;
            for (f = c._sounds.length - 1; f >= 0; f--) {
              if (p <= d) return;
              c._sounds[f]._ended &&
                (c._webAudio &&
                  c._sounds[f]._node &&
                  c._sounds[f]._node.disconnect(0),
                c._sounds.splice(f, 1),
                p--);
            }
          }
        },
        _getSoundIds: function (c) {
          var d = this;
          if (typeof c > "u") {
            for (var p = [], f = 0; f < d._sounds.length; f++)
              p.push(d._sounds[f]._id);
            return p;
          } else return [c];
        },
        _refreshBuffer: function (c) {
          var d = this;
          return (
            (c._node.bufferSource = i.ctx.createBufferSource()),
            (c._node.bufferSource.buffer = a[d._src]),
            c._panner
              ? c._node.bufferSource.connect(c._panner)
              : c._node.bufferSource.connect(c._node),
            (c._node.bufferSource.loop = c._loop),
            c._loop &&
              ((c._node.bufferSource.loopStart = c._start || 0),
              (c._node.bufferSource.loopEnd = c._stop || 0)),
            c._node.bufferSource.playbackRate.setValueAtTime(
              c._rate,
              i.ctx.currentTime
            ),
            d
          );
        },
        _cleanBuffer: function (c) {
          var d = this,
            p = i._navigator && i._navigator.vendor.indexOf("Apple") >= 0;
          if (
            i._scratchBuffer &&
            c.bufferSource &&
            ((c.bufferSource.onended = null), c.bufferSource.disconnect(0), p)
          )
            try {
              c.bufferSource.buffer = i._scratchBuffer;
            } catch {}
          return (c.bufferSource = null), d;
        },
        _clearSound: function (c) {
          var d = /MSIE |Trident\//.test(
            i._navigator && i._navigator.userAgent
          );
          d ||
            (c.src =
              "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
        },
      };
      var s = function (c) {
        (this._parent = c), this.init();
      };
      s.prototype = {
        init: function () {
          var c = this,
            d = c._parent;
          return (
            (c._muted = d._muted),
            (c._loop = d._loop),
            (c._volume = d._volume),
            (c._rate = d._rate),
            (c._seek = 0),
            (c._paused = !0),
            (c._ended = !0),
            (c._sprite = "__default"),
            (c._id = ++i._counter),
            d._sounds.push(c),
            c.create(),
            c
          );
        },
        create: function () {
          var c = this,
            d = c._parent,
            p = i._muted || c._muted || c._parent._muted ? 0 : c._volume;
          return (
            d._webAudio
              ? ((c._node =
                  typeof i.ctx.createGain > "u"
                    ? i.ctx.createGainNode()
                    : i.ctx.createGain()),
                c._node.gain.setValueAtTime(p, i.ctx.currentTime),
                (c._node.paused = !0),
                c._node.connect(i.masterGain))
              : i.noAudio ||
                ((c._node = i._obtainHtml5Audio()),
                (c._errorFn = c._errorListener.bind(c)),
                c._node.addEventListener("error", c._errorFn, !1),
                (c._loadFn = c._loadListener.bind(c)),
                c._node.addEventListener(i._canPlayEvent, c._loadFn, !1),
                (c._endFn = c._endListener.bind(c)),
                c._node.addEventListener("ended", c._endFn, !1),
                (c._node.src = d._src),
                (c._node.preload = d._preload === !0 ? "auto" : d._preload),
                (c._node.volume = p * i.volume()),
                c._node.load()),
            c
          );
        },
        reset: function () {
          var c = this,
            d = c._parent;
          return (
            (c._muted = d._muted),
            (c._loop = d._loop),
            (c._volume = d._volume),
            (c._rate = d._rate),
            (c._seek = 0),
            (c._rateSeek = 0),
            (c._paused = !0),
            (c._ended = !0),
            (c._sprite = "__default"),
            (c._id = ++i._counter),
            c
          );
        },
        _errorListener: function () {
          var c = this;
          c._parent._emit(
            "loaderror",
            c._id,
            c._node.error ? c._node.error.code : 0
          ),
            c._node.removeEventListener("error", c._errorFn, !1);
        },
        _loadListener: function () {
          var c = this,
            d = c._parent;
          (d._duration = Math.ceil(c._node.duration * 10) / 10),
            Object.keys(d._sprite).length === 0 &&
              (d._sprite = { __default: [0, d._duration * 1e3] }),
            d._state !== "loaded" &&
              ((d._state = "loaded"), d._emit("load"), d._loadQueue()),
            c._node.removeEventListener(i._canPlayEvent, c._loadFn, !1);
        },
        _endListener: function () {
          var c = this,
            d = c._parent;
          d._duration === 1 / 0 &&
            ((d._duration = Math.ceil(c._node.duration * 10) / 10),
            d._sprite.__default[1] === 1 / 0 &&
              (d._sprite.__default[1] = d._duration * 1e3),
            d._ended(c)),
            c._node.removeEventListener("ended", c._endFn, !1);
        },
      };
      var a = {},
        n = function (c) {
          var d = c._src;
          if (a[d]) {
            (c._duration = a[d].duration), h(c);
            return;
          }
          if (/^data:[^;]+;base64,/.test(d)) {
            for (
              var p = atob(d.split(",")[1]),
                f = new Uint8Array(p.length),
                m = 0;
              m < p.length;
              ++m
            )
              f[m] = p.charCodeAt(m);
            l(f.buffer, c);
          } else {
            var g = new XMLHttpRequest();
            g.open(c._xhr.method, d, !0),
              (g.withCredentials = c._xhr.withCredentials),
              (g.responseType = "arraybuffer"),
              c._xhr.headers &&
                Object.keys(c._xhr.headers).forEach(function (y) {
                  g.setRequestHeader(y, c._xhr.headers[y]);
                }),
              (g.onload = function () {
                var y = (g.status + "")[0];
                if (y !== "0" && y !== "2" && y !== "3") {
                  c._emit(
                    "loaderror",
                    null,
                    "Failed loading audio file with status: " + g.status + "."
                  );
                  return;
                }
                l(g.response, c);
              }),
              (g.onerror = function () {
                c._webAudio &&
                  ((c._html5 = !0),
                  (c._webAudio = !1),
                  (c._sounds = []),
                  delete a[d],
                  c.load());
              }),
              o(g);
          }
        },
        o = function (c) {
          try {
            c.send();
          } catch {
            c.onerror();
          }
        },
        l = function (c, d) {
          var p = function () {
              d._emit("loaderror", null, "Decoding audio data failed.");
            },
            f = function (m) {
              m && d._sounds.length > 0 ? ((a[d._src] = m), h(d, m)) : p();
            };
          typeof Promise < "u" && i.ctx.decodeAudioData.length === 1
            ? i.ctx.decodeAudioData(c).then(f).catch(p)
            : i.ctx.decodeAudioData(c, f, p);
        },
        h = function (c, d) {
          d && !c._duration && (c._duration = d.duration),
            Object.keys(c._sprite).length === 0 &&
              (c._sprite = { __default: [0, c._duration * 1e3] }),
            c._state !== "loaded" &&
              ((c._state = "loaded"), c._emit("load"), c._loadQueue());
        },
        u = function () {
          if (i.usingWebAudio) {
            try {
              typeof AudioContext < "u"
                ? (i.ctx = new AudioContext())
                : typeof webkitAudioContext < "u"
                ? (i.ctx = new webkitAudioContext())
                : (i.usingWebAudio = !1);
            } catch {
              i.usingWebAudio = !1;
            }
            i.ctx || (i.usingWebAudio = !1);
            var c = /iP(hone|od|ad)/.test(
                i._navigator && i._navigator.platform
              ),
              d =
                i._navigator &&
                i._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
              p = d ? parseInt(d[1], 10) : null;
            if (c && p && p < 9) {
              var f = /safari/.test(
                i._navigator && i._navigator.userAgent.toLowerCase()
              );
              i._navigator && !f && (i.usingWebAudio = !1);
            }
            i.usingWebAudio &&
              ((i.masterGain =
                typeof i.ctx.createGain > "u"
                  ? i.ctx.createGainNode()
                  : i.ctx.createGain()),
              i.masterGain.gain.setValueAtTime(
                i._muted ? 0 : i._volume,
                i.ctx.currentTime
              ),
              i.masterGain.connect(i.ctx.destination)),
              i._setup();
          }
        };
      typeof define == "function" &&
        define.amd &&
        define([], function () {
          return { Howler: i, Howl: r };
        }),
        typeof e < "u" && ((e.Howler = i), (e.Howl = r)),
        typeof global < "u"
          ? ((global.HowlerGlobal = t),
            (global.Howler = i),
            (global.Howl = r),
            (global.Sound = s))
          : typeof window < "u" &&
            ((window.HowlerGlobal = t),
            (window.Howler = i),
            (window.Howl = r),
            (window.Sound = s));
    })(),
      (function () {
        "use strict";
        (HowlerGlobal.prototype._pos = [0, 0, 0]),
          (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
          (HowlerGlobal.prototype.stereo = function (i) {
            var r = this;
            if (!r.ctx || !r.ctx.listener) return r;
            for (var s = r._howls.length - 1; s >= 0; s--)
              r._howls[s].stereo(i);
            return r;
          }),
          (HowlerGlobal.prototype.pos = function (i, r, s) {
            var a = this;
            if (!a.ctx || !a.ctx.listener) return a;
            if (
              ((r = typeof r != "number" ? a._pos[1] : r),
              (s = typeof s != "number" ? a._pos[2] : s),
              typeof i == "number")
            )
              (a._pos = [i, r, s]),
                typeof a.ctx.listener.positionX < "u"
                  ? (a.ctx.listener.positionX.setTargetAtTime(
                      a._pos[0],
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    a.ctx.listener.positionY.setTargetAtTime(
                      a._pos[1],
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    a.ctx.listener.positionZ.setTargetAtTime(
                      a._pos[2],
                      Howler.ctx.currentTime,
                      0.1
                    ))
                  : a.ctx.listener.setPosition(a._pos[0], a._pos[1], a._pos[2]);
            else return a._pos;
            return a;
          }),
          (HowlerGlobal.prototype.orientation = function (i, r, s, a, n, o) {
            var l = this;
            if (!l.ctx || !l.ctx.listener) return l;
            var h = l._orientation;
            if (
              ((r = typeof r != "number" ? h[1] : r),
              (s = typeof s != "number" ? h[2] : s),
              (a = typeof a != "number" ? h[3] : a),
              (n = typeof n != "number" ? h[4] : n),
              (o = typeof o != "number" ? h[5] : o),
              typeof i == "number")
            )
              (l._orientation = [i, r, s, a, n, o]),
                typeof l.ctx.listener.forwardX < "u"
                  ? (l.ctx.listener.forwardX.setTargetAtTime(
                      i,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.forwardY.setTargetAtTime(
                      r,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.forwardZ.setTargetAtTime(
                      s,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.upX.setTargetAtTime(
                      a,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.upY.setTargetAtTime(
                      n,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.upZ.setTargetAtTime(
                      o,
                      Howler.ctx.currentTime,
                      0.1
                    ))
                  : l.ctx.listener.setOrientation(i, r, s, a, n, o);
            else return h;
            return l;
          }),
          (Howl.prototype.init = (function (i) {
            return function (r) {
              var s = this;
              return (
                (s._orientation = r.orientation || [1, 0, 0]),
                (s._stereo = r.stereo || null),
                (s._pos = r.pos || null),
                (s._pannerAttr = {
                  coneInnerAngle:
                    typeof r.coneInnerAngle < "u" ? r.coneInnerAngle : 360,
                  coneOuterAngle:
                    typeof r.coneOuterAngle < "u" ? r.coneOuterAngle : 360,
                  coneOuterGain:
                    typeof r.coneOuterGain < "u" ? r.coneOuterGain : 0,
                  distanceModel:
                    typeof r.distanceModel < "u" ? r.distanceModel : "inverse",
                  maxDistance: typeof r.maxDistance < "u" ? r.maxDistance : 1e4,
                  panningModel:
                    typeof r.panningModel < "u" ? r.panningModel : "HRTF",
                  refDistance: typeof r.refDistance < "u" ? r.refDistance : 1,
                  rolloffFactor:
                    typeof r.rolloffFactor < "u" ? r.rolloffFactor : 1,
                }),
                (s._onstereo = r.onstereo ? [{ fn: r.onstereo }] : []),
                (s._onpos = r.onpos ? [{ fn: r.onpos }] : []),
                (s._onorientation = r.onorientation
                  ? [{ fn: r.onorientation }]
                  : []),
                i.call(this, r)
              );
            };
          })(Howl.prototype.init)),
          (Howl.prototype.stereo = function (i, r) {
            var s = this;
            if (!s._webAudio) return s;
            if (s._state !== "loaded")
              return (
                s._queue.push({
                  event: "stereo",
                  action: function () {
                    s.stereo(i, r);
                  },
                }),
                s
              );
            var a =
              typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
            if (typeof r > "u")
              if (typeof i == "number") (s._stereo = i), (s._pos = [i, 0, 0]);
              else return s._stereo;
            for (var n = s._getSoundIds(r), o = 0; o < n.length; o++) {
              var l = s._soundById(n[o]);
              if (l)
                if (typeof i == "number")
                  (l._stereo = i),
                    (l._pos = [i, 0, 0]),
                    l._node &&
                      ((l._pannerAttr.panningModel = "equalpower"),
                      (!l._panner || !l._panner.pan) && t(l, a),
                      a === "spatial"
                        ? typeof l._panner.positionX < "u"
                          ? (l._panner.positionX.setValueAtTime(
                              i,
                              Howler.ctx.currentTime
                            ),
                            l._panner.positionY.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ),
                            l._panner.positionZ.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ))
                          : l._panner.setPosition(i, 0, 0)
                        : l._panner.pan.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          )),
                    s._emit("stereo", l._id);
                else return l._stereo;
            }
            return s;
          }),
          (Howl.prototype.pos = function (i, r, s, a) {
            var n = this;
            if (!n._webAudio) return n;
            if (n._state !== "loaded")
              return (
                n._queue.push({
                  event: "pos",
                  action: function () {
                    n.pos(i, r, s, a);
                  },
                }),
                n
              );
            if (
              ((r = typeof r != "number" ? 0 : r),
              (s = typeof s != "number" ? -0.5 : s),
              typeof a > "u")
            )
              if (typeof i == "number") n._pos = [i, r, s];
              else return n._pos;
            for (var o = n._getSoundIds(a), l = 0; l < o.length; l++) {
              var h = n._soundById(o[l]);
              if (h)
                if (typeof i == "number")
                  (h._pos = [i, r, s]),
                    h._node &&
                      ((!h._panner || h._panner.pan) && t(h, "spatial"),
                      typeof h._panner.positionX < "u"
                        ? (h._panner.positionX.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          ),
                          h._panner.positionY.setValueAtTime(
                            r,
                            Howler.ctx.currentTime
                          ),
                          h._panner.positionZ.setValueAtTime(
                            s,
                            Howler.ctx.currentTime
                          ))
                        : h._panner.setPosition(i, r, s)),
                    n._emit("pos", h._id);
                else return h._pos;
            }
            return n;
          }),
          (Howl.prototype.orientation = function (i, r, s, a) {
            var n = this;
            if (!n._webAudio) return n;
            if (n._state !== "loaded")
              return (
                n._queue.push({
                  event: "orientation",
                  action: function () {
                    n.orientation(i, r, s, a);
                  },
                }),
                n
              );
            if (
              ((r = typeof r != "number" ? n._orientation[1] : r),
              (s = typeof s != "number" ? n._orientation[2] : s),
              typeof a > "u")
            )
              if (typeof i == "number") n._orientation = [i, r, s];
              else return n._orientation;
            for (var o = n._getSoundIds(a), l = 0; l < o.length; l++) {
              var h = n._soundById(o[l]);
              if (h)
                if (typeof i == "number")
                  (h._orientation = [i, r, s]),
                    h._node &&
                      (h._panner ||
                        (h._pos || (h._pos = n._pos || [0, 0, -0.5]),
                        t(h, "spatial")),
                      typeof h._panner.orientationX < "u"
                        ? (h._panner.orientationX.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          ),
                          h._panner.orientationY.setValueAtTime(
                            r,
                            Howler.ctx.currentTime
                          ),
                          h._panner.orientationZ.setValueAtTime(
                            s,
                            Howler.ctx.currentTime
                          ))
                        : h._panner.setOrientation(i, r, s)),
                    n._emit("orientation", h._id);
                else return h._orientation;
            }
            return n;
          }),
          (Howl.prototype.pannerAttr = function () {
            var i = this,
              r = arguments,
              s,
              a,
              n;
            if (!i._webAudio) return i;
            if (r.length === 0) return i._pannerAttr;
            if (r.length === 1)
              if (typeof r[0] == "object")
                (s = r[0]),
                  typeof a > "u" &&
                    (s.pannerAttr ||
                      (s.pannerAttr = {
                        coneInnerAngle: s.coneInnerAngle,
                        coneOuterAngle: s.coneOuterAngle,
                        coneOuterGain: s.coneOuterGain,
                        distanceModel: s.distanceModel,
                        maxDistance: s.maxDistance,
                        refDistance: s.refDistance,
                        rolloffFactor: s.rolloffFactor,
                        panningModel: s.panningModel,
                      }),
                    (i._pannerAttr = {
                      coneInnerAngle:
                        typeof s.pannerAttr.coneInnerAngle < "u"
                          ? s.pannerAttr.coneInnerAngle
                          : i._coneInnerAngle,
                      coneOuterAngle:
                        typeof s.pannerAttr.coneOuterAngle < "u"
                          ? s.pannerAttr.coneOuterAngle
                          : i._coneOuterAngle,
                      coneOuterGain:
                        typeof s.pannerAttr.coneOuterGain < "u"
                          ? s.pannerAttr.coneOuterGain
                          : i._coneOuterGain,
                      distanceModel:
                        typeof s.pannerAttr.distanceModel < "u"
                          ? s.pannerAttr.distanceModel
                          : i._distanceModel,
                      maxDistance:
                        typeof s.pannerAttr.maxDistance < "u"
                          ? s.pannerAttr.maxDistance
                          : i._maxDistance,
                      refDistance:
                        typeof s.pannerAttr.refDistance < "u"
                          ? s.pannerAttr.refDistance
                          : i._refDistance,
                      rolloffFactor:
                        typeof s.pannerAttr.rolloffFactor < "u"
                          ? s.pannerAttr.rolloffFactor
                          : i._rolloffFactor,
                      panningModel:
                        typeof s.pannerAttr.panningModel < "u"
                          ? s.pannerAttr.panningModel
                          : i._panningModel,
                    }));
              else
                return (
                  (n = i._soundById(parseInt(r[0], 10))),
                  n ? n._pannerAttr : i._pannerAttr
                );
            else r.length === 2 && ((s = r[0]), (a = parseInt(r[1], 10)));
            for (var o = i._getSoundIds(a), l = 0; l < o.length; l++)
              if (((n = i._soundById(o[l])), n)) {
                var h = n._pannerAttr;
                h = {
                  coneInnerAngle:
                    typeof s.coneInnerAngle < "u"
                      ? s.coneInnerAngle
                      : h.coneInnerAngle,
                  coneOuterAngle:
                    typeof s.coneOuterAngle < "u"
                      ? s.coneOuterAngle
                      : h.coneOuterAngle,
                  coneOuterGain:
                    typeof s.coneOuterGain < "u"
                      ? s.coneOuterGain
                      : h.coneOuterGain,
                  distanceModel:
                    typeof s.distanceModel < "u"
                      ? s.distanceModel
                      : h.distanceModel,
                  maxDistance:
                    typeof s.maxDistance < "u" ? s.maxDistance : h.maxDistance,
                  refDistance:
                    typeof s.refDistance < "u" ? s.refDistance : h.refDistance,
                  rolloffFactor:
                    typeof s.rolloffFactor < "u"
                      ? s.rolloffFactor
                      : h.rolloffFactor,
                  panningModel:
                    typeof s.panningModel < "u"
                      ? s.panningModel
                      : h.panningModel,
                };
                var u = n._panner;
                u
                  ? ((u.coneInnerAngle = h.coneInnerAngle),
                    (u.coneOuterAngle = h.coneOuterAngle),
                    (u.coneOuterGain = h.coneOuterGain),
                    (u.distanceModel = h.distanceModel),
                    (u.maxDistance = h.maxDistance),
                    (u.refDistance = h.refDistance),
                    (u.rolloffFactor = h.rolloffFactor),
                    (u.panningModel = h.panningModel))
                  : (n._pos || (n._pos = i._pos || [0, 0, -0.5]),
                    t(n, "spatial"));
              }
            return i;
          }),
          (Sound.prototype.init = (function (i) {
            return function () {
              var r = this,
                s = r._parent;
              (r._orientation = s._orientation),
                (r._stereo = s._stereo),
                (r._pos = s._pos),
                (r._pannerAttr = s._pannerAttr),
                i.call(this),
                r._stereo
                  ? s.stereo(r._stereo)
                  : r._pos && s.pos(r._pos[0], r._pos[1], r._pos[2], r._id);
            };
          })(Sound.prototype.init)),
          (Sound.prototype.reset = (function (i) {
            return function () {
              var r = this,
                s = r._parent;
              return (
                (r._orientation = s._orientation),
                (r._stereo = s._stereo),
                (r._pos = s._pos),
                (r._pannerAttr = s._pannerAttr),
                r._stereo
                  ? s.stereo(r._stereo)
                  : r._pos
                  ? s.pos(r._pos[0], r._pos[1], r._pos[2], r._id)
                  : r._panner &&
                    (r._panner.disconnect(0),
                    (r._panner = void 0),
                    s._refreshBuffer(r)),
                i.call(this)
              );
            };
          })(Sound.prototype.reset));
        var t = function (i, r) {
          (r = r || "spatial"),
            r === "spatial"
              ? ((i._panner = Howler.ctx.createPanner()),
                (i._panner.coneInnerAngle = i._pannerAttr.coneInnerAngle),
                (i._panner.coneOuterAngle = i._pannerAttr.coneOuterAngle),
                (i._panner.coneOuterGain = i._pannerAttr.coneOuterGain),
                (i._panner.distanceModel = i._pannerAttr.distanceModel),
                (i._panner.maxDistance = i._pannerAttr.maxDistance),
                (i._panner.refDistance = i._pannerAttr.refDistance),
                (i._panner.rolloffFactor = i._pannerAttr.rolloffFactor),
                (i._panner.panningModel = i._pannerAttr.panningModel),
                typeof i._panner.positionX < "u"
                  ? (i._panner.positionX.setValueAtTime(
                      i._pos[0],
                      Howler.ctx.currentTime
                    ),
                    i._panner.positionY.setValueAtTime(
                      i._pos[1],
                      Howler.ctx.currentTime
                    ),
                    i._panner.positionZ.setValueAtTime(
                      i._pos[2],
                      Howler.ctx.currentTime
                    ))
                  : i._panner.setPosition(i._pos[0], i._pos[1], i._pos[2]),
                typeof i._panner.orientationX < "u"
                  ? (i._panner.orientationX.setValueAtTime(
                      i._orientation[0],
                      Howler.ctx.currentTime
                    ),
                    i._panner.orientationY.setValueAtTime(
                      i._orientation[1],
                      Howler.ctx.currentTime
                    ),
                    i._panner.orientationZ.setValueAtTime(
                      i._orientation[2],
                      Howler.ctx.currentTime
                    ))
                  : i._panner.setOrientation(
                      i._orientation[0],
                      i._orientation[1],
                      i._orientation[2]
                    ))
              : ((i._panner = Howler.ctx.createStereoPanner()),
                i._panner.pan.setValueAtTime(
                  i._stereo,
                  Howler.ctx.currentTime
                )),
            i._panner.connect(i._node),
            i._paused || i._parent.pause(i._id, !0).play(i._id, !0);
        };
      })();
  }),
  NO = Zr((e, t) => {
    "use strict";
    function i(a, n) {
      function o() {
        this.constructor = a;
      }
      (o.prototype = n.prototype), (a.prototype = new o());
    }
    function r(a, n, o, l) {
      (this.message = a),
        (this.expected = n),
        (this.found = o),
        (this.location = l),
        (this.name = "SyntaxError"),
        typeof Error.captureStackTrace == "function" &&
          Error.captureStackTrace(this, r);
    }
    i(r, Error),
      (r.buildMessage = function (a, n) {
        var o = {
          literal: function (f) {
            return '"' + h(f.text) + '"';
          },
          class: function (f) {
            var m = "",
              g;
            for (g = 0; g < f.parts.length; g++)
              m +=
                f.parts[g] instanceof Array
                  ? u(f.parts[g][0]) + "-" + u(f.parts[g][1])
                  : u(f.parts[g]);
            return "[" + (f.inverted ? "^" : "") + m + "]";
          },
          any: function (f) {
            return "any character";
          },
          end: function (f) {
            return "end of input";
          },
          other: function (f) {
            return f.description;
          },
        };
        function l(f) {
          return f.charCodeAt(0).toString(16).toUpperCase();
        }
        function h(f) {
          return f
            .replace(/\\/g, "\\\\")
            .replace(/"/g, '\\"')
            .replace(/\0/g, "\\0")
            .replace(/\t/g, "\\t")
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r")
            .replace(/[\x00-\x0F]/g, function (m) {
              return "\\x0" + l(m);
            })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (m) {
              return "\\x" + l(m);
            });
        }
        function u(f) {
          return f
            .replace(/\\/g, "\\\\")
            .replace(/\]/g, "\\]")
            .replace(/\^/g, "\\^")
            .replace(/-/g, "\\-")
            .replace(/\0/g, "\\0")
            .replace(/\t/g, "\\t")
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r")
            .replace(/[\x00-\x0F]/g, function (m) {
              return "\\x0" + l(m);
            })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function (m) {
              return "\\x" + l(m);
            });
        }
        function c(f) {
          return o[f.type](f);
        }
        function d(f) {
          var m = new Array(f.length),
            g,
            y;
          for (g = 0; g < f.length; g++) m[g] = c(f[g]);
          if ((m.sort(), m.length > 0)) {
            for (g = 1, y = 1; g < m.length; g++)
              m[g - 1] !== m[g] && ((m[y] = m[g]), y++);
            m.length = y;
          }
          switch (m.length) {
            case 1:
              return m[0];
            case 2:
              return m[0] + " or " + m[1];
            default:
              return m.slice(0, -1).join(", ") + ", or " + m[m.length - 1];
          }
        }
        function p(f) {
          return f ? '"' + h(f) + '"' : "end of input";
        }
        return "Expected " + d(a) + " but " + p(n) + " found.";
      });
    function s(a, n) {
      n = n !== void 0 ? n : {};
      var o = {},
        l = { svg_path: Ar },
        h = Ar,
        u = function (k) {
          if (!k) return [];
          for (var H = [], he = 0; he < k.length; he++)
            H = H.concat.apply(H, k[he]);
          var X = H[0];
          return X && X.code == "m" && (delete X.relative, (X.code = "M")), H;
        },
        c = function (k, H) {
          return Eu(k, H);
        },
        d = /^[Mm]/,
        p = ei(["M", "m"], !1, !1),
        f = function (k, H, he) {
          var X = Pa(k, [H]);
          return he && (X = X.concat(Pa(k == "M" ? "L" : "l", he[1]))), X;
        },
        m = /^[Zz]/,
        g = ei(["Z", "z"], !1, !1),
        y = function () {
          return Pa("Z");
        },
        x = /^[Ll]/,
        b = ei(["L", "l"], !1, !1),
        _ = function (k, H) {
          return Pa(k, H);
        },
        S = /^[Hh]/,
        M = ei(["H", "h"], !1, !1),
        C = function (k, H) {
          return Pa(
            k,
            H.map(function (he) {
              return { x: he };
            })
          );
        },
        A = /^[Vv]/,
        T = ei(["V", "v"], !1, !1),
        P = function (k, H) {
          return Pa(
            k,
            H.map(function (he) {
              return { y: he };
            })
          );
        },
        R = /^[Cc]/,
        z = ei(["C", "c"], !1, !1),
        N = function (k, H, he) {
          return { x1: k.x, y1: k.y, x2: H.x, y2: H.y, x: he.x, y: he.y };
        },
        L = /^[Ss]/,
        G = ei(["S", "s"], !1, !1),
        Y = function (k, H) {
          return { x2: k.x, y2: k.y, x: H.x, y: H.y };
        },
        Z = /^[Qq]/,
        q = ei(["Q", "q"], !1, !1),
        oe = function (k, H) {
          return { x1: k.x, y1: k.y, x: H.x, y: H.y };
        },
        ce = /^[Tt]/,
        ie = ei(["T", "t"], !1, !1),
        te = /^[Aa]/,
        ue = ei(["A", "a"], !1, !1),
        ae = function (k, H, he, X, ve, Xe) {
          return {
            rx: k,
            ry: H,
            xAxisRotation: he,
            largeArc: X,
            sweep: ve,
            x: Xe.x,
            y: Xe.y,
          };
        },
        de = function (k, H) {
          return { x: k, y: H };
        },
        ne = function (k) {
          return k * 1;
        },
        Ee = function (k) {
          return k.join("") * 1;
        },
        me = /^[01]/,
        Ae = ei(["0", "1"], !1, !1),
        ye = function (k) {
          return k == "1";
        },
        Ue = function () {
          return "";
        },
        Le = ",",
        Te = ui(",", !1),
        tt = function (k) {
          return k.join("");
        },
        Je = ".",
        rt = ui(".", !1),
        st = /^[eE]/,
        Ze = ei(["e", "E"], !1, !1),
        Qe = /^[+\-]/,
        pt = ei(["+", "-"], !1, !1),
        bt = /^[0-9]/,
        $ = ei([["0", "9"]], !1, !1),
        W = function (k) {
          return k.join("");
        },
        _e = /^[ \t\n\r]/,
        Ge = ei(
          [
            " ",
            "	",
            `
`,
            "\r",
          ],
          !1,
          !1
        ),
        V = 0,
        De = 0,
        ct = [{ line: 1, column: 1 }],
        We = 0,
        Be = [],
        Fe = 0,
        ut;
      if ("startRule" in n) {
        if (!(n.startRule in l))
          throw new Error(
            `Can't start parsing from rule "` + n.startRule + '".'
          );
        h = l[n.startRule];
      }
      function at() {
        return a.substring(De, V);
      }
      function wt() {
        return gt(De, V);
      }
      function xt(k, H) {
        throw (
          ((H = H !== void 0 ? H : gt(De, V)),
          ki([Ye(k)], a.substring(De, V), H))
        );
      }
      function ii(k, H) {
        throw ((H = H !== void 0 ? H : gt(De, V)), yi(k, H));
      }
      function ui(k, H) {
        return { type: "literal", text: k, ignoreCase: H };
      }
      function ei(k, H, he) {
        return { type: "class", parts: k, inverted: H, ignoreCase: he };
      }
      function ge() {
        return { type: "any" };
      }
      function Ce() {
        return { type: "end" };
      }
      function Ye(k) {
        return { type: "other", description: k };
      }
      function Ke(k) {
        var H = ct[k],
          he;
        if (H) return H;
        for (he = k - 1; !ct[he]; ) he--;
        for (H = ct[he], H = { line: H.line, column: H.column }; he < k; )
          a.charCodeAt(he) === 10 ? (H.line++, (H.column = 1)) : H.column++,
            he++;
        return (ct[k] = H), H;
      }
      function gt(k, H) {
        var he = Ke(k),
          X = Ke(H);
        return {
          start: { offset: k, line: he.line, column: he.column },
          end: { offset: H, line: X.line, column: X.column },
        };
      }
      function Mt(k) {
        V < We || (V > We && ((We = V), (Be = [])), Be.push(k));
      }
      function yi(k, H) {
        return new r(k, null, null, H);
      }
      function ki(k, H, he) {
        return new r(r.buildMessage(k, H), k, H, he);
      }
      function Ar() {
        var k, H, he, X, ve;
        for (k = V, H = [], he = Yt(); he !== o; ) H.push(he), (he = Yt());
        if (H !== o)
          if (((he = Si()), he === o && (he = null), he !== o)) {
            for (X = [], ve = Yt(); ve !== o; ) X.push(ve), (ve = Yt());
            X !== o ? ((De = k), (H = u(he)), (k = H)) : ((V = k), (k = o));
          } else (V = k), (k = o);
        else (V = k), (k = o);
        return k;
      }
      function Si() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = Jr()), H !== o)) {
          for (he = [], X = V, ve = [], Xe = Yt(); Xe !== o; )
            ve.push(Xe), (Xe = Yt());
          for (
            ve !== o
              ? ((Xe = Jr()),
                Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
              : ((V = X), (X = o));
            X !== o;

          ) {
            for (he.push(X), X = V, ve = [], Xe = Yt(); Xe !== o; )
              ve.push(Xe), (Xe = Yt());
            ve !== o
              ? ((Xe = Jr()),
                Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
              : ((V = X), (X = o));
          }
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Jr() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = Po()), H !== o)) {
          for (he = [], X = V, ve = [], Xe = Yt(); Xe !== o; )
            ve.push(Xe), (Xe = Yt());
          for (
            ve !== o
              ? ((Xe = Mr()),
                Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
              : ((V = X), (X = o));
            X !== o;

          ) {
            for (he.push(X), X = V, ve = [], Xe = Yt(); Xe !== o; )
              ve.push(Xe), (Xe = Yt());
            ve !== o
              ? ((Xe = Mr()),
                Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
              : ((V = X), (X = o));
          }
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Mr() {
        var k;
        return (
          (k = Mu()),
          k === o &&
            ((k = wl()),
            k === o &&
              ((k = ee()),
              k === o &&
                ((k = Oe()),
                k === o &&
                  ((k = we()),
                  k === o &&
                    ((k = Bt()),
                    k === o &&
                      ((k = hi()),
                      k === o && ((k = pi()), k === o && (k = Vi())))))))),
          k
        );
      }
      function Po() {
        var k, H, he, X, ve, Xe, Do;
        if (
          ((k = V),
          d.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(p)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = _t()),
              X !== o
                ? ((ve = V),
                  (Xe = Jt()),
                  Xe === o && (Xe = null),
                  Xe !== o
                    ? ((Do = Ch()),
                      Do !== o
                        ? ((Xe = [Xe, Do]), (ve = Xe))
                        : ((V = ve), (ve = o)))
                    : ((V = ve), (ve = o)),
                  ve === o && (ve = null),
                  ve !== o
                    ? ((De = k), (H = f(H, X, ve)), (k = H))
                    : ((V = k), (k = o)))
                : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Mu() {
        var k, H;
        return (
          (k = V),
          m.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(g)),
          H !== o && ((De = k), (H = y())),
          (k = H),
          k
        );
      }
      function wl() {
        var k, H, he, X;
        if (
          ((k = V),
          x.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(b)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = Ch()),
              X !== o ? ((De = k), (H = _(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Ch() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = _t()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = _t()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = _t()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function ee() {
        var k, H, he, X;
        if (
          ((k = V),
          S.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(M)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = Se()),
              X !== o ? ((De = k), (H = C(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Se() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = ta()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = ta()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = ta()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Oe() {
        var k, H, he, X;
        if (
          ((k = V),
          A.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(T)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = Se()),
              X !== o ? ((De = k), (H = P(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function we() {
        var k, H, he, X;
        if (
          ((k = V),
          R.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(z)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = ze()),
              X !== o ? ((De = k), (H = _(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function ze() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = nt()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = nt()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = nt()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function nt() {
        var k, H, he, X, ve, Xe;
        return (
          (k = V),
          (H = _t()),
          H !== o
            ? ((he = Jt()),
              he === o && (he = null),
              he !== o
                ? ((X = _t()),
                  X !== o
                    ? ((ve = Jt()),
                      ve === o && (ve = null),
                      ve !== o
                        ? ((Xe = _t()),
                          Xe !== o
                            ? ((De = k), (H = N(H, X, Xe)), (k = H))
                            : ((V = k), (k = o)))
                        : ((V = k), (k = o)))
                    : ((V = k), (k = o)))
                : ((V = k), (k = o)))
            : ((V = k), (k = o)),
          k
        );
      }
      function Bt() {
        var k, H, he, X;
        if (
          ((k = V),
          L.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(G)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = qt()),
              X !== o ? ((De = k), (H = _(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function qt() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = kt()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = kt()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = kt()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function kt() {
        var k, H, he, X;
        return (
          (k = V),
          (H = _t()),
          H !== o
            ? ((he = Jt()),
              he === o && (he = null),
              he !== o
                ? ((X = _t()),
                  X !== o
                    ? ((De = k), (H = Y(H, X)), (k = H))
                    : ((V = k), (k = o)))
                : ((V = k), (k = o)))
            : ((V = k), (k = o)),
          k
        );
      }
      function hi() {
        var k, H, he, X;
        if (
          ((k = V),
          Z.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(q)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = ti()),
              X !== o ? ((De = k), (H = _(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function ti() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = Zt()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = Zt()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = Zt()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Zt() {
        var k, H, he, X;
        return (
          (k = V),
          (H = _t()),
          H !== o
            ? ((he = Jt()),
              he === o && (he = null),
              he !== o
                ? ((X = _t()),
                  X !== o
                    ? ((De = k), (H = oe(H, X)), (k = H))
                    : ((V = k), (k = o)))
                : ((V = k), (k = o)))
            : ((V = k), (k = o)),
          k
        );
      }
      function pi() {
        var k, H, he, X;
        if (
          ((k = V),
          ce.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(ie)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = Er()),
              X !== o ? ((De = k), (H = _(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Er() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = _t()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = _t()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = _t()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Vi() {
        var k, H, he, X;
        if (
          ((k = V),
          te.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(ue)),
          H !== o)
        ) {
          for (he = [], X = Yt(); X !== o; ) he.push(X), (X = Yt());
          he !== o
            ? ((X = Qi()),
              X !== o ? ((De = k), (H = _(H, X)), (k = H)) : ((V = k), (k = o)))
            : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Qi() {
        var k, H, he, X, ve, Xe;
        if (((k = V), (H = Li()), H !== o)) {
          for (
            he = [],
              X = V,
              ve = Jt(),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = Li()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
            X !== o;

          )
            he.push(X),
              (X = V),
              (ve = Jt()),
              ve === o && (ve = null),
              ve !== o
                ? ((Xe = Li()),
                  Xe !== o ? ((ve = [ve, Xe]), (X = ve)) : ((V = X), (X = o)))
                : ((V = X), (X = o));
          he !== o ? ((De = k), (H = c(H, he)), (k = H)) : ((V = k), (k = o));
        } else (V = k), (k = o);
        return k;
      }
      function Li() {
        var k, H, he, X, ve, Xe, Do, Cu, Th, Ph, jn, xs;
        return (
          (k = V),
          (H = tn()),
          H !== o
            ? ((he = Jt()),
              he === o && (he = null),
              he !== o
                ? ((X = tn()),
                  X !== o
                    ? ((ve = Jt()),
                      ve === o && (ve = null),
                      ve !== o
                        ? ((Xe = ta()),
                          Xe !== o
                            ? ((Do = Jt()),
                              Do !== o
                                ? ((Cu = ia()),
                                  Cu !== o
                                    ? ((Th = Jt()),
                                      Th === o && (Th = null),
                                      Th !== o
                                        ? ((Ph = ia()),
                                          Ph !== o
                                            ? ((jn = Jt()),
                                              jn === o && (jn = null),
                                              jn !== o
                                                ? ((xs = _t()),
                                                  xs !== o
                                                    ? ((De = k),
                                                      (H = ae(
                                                        H,
                                                        X,
                                                        Xe,
                                                        Cu,
                                                        Ph,
                                                        xs
                                                      )),
                                                      (k = H))
                                                    : ((V = k), (k = o)))
                                                : ((V = k), (k = o)))
                                            : ((V = k), (k = o)))
                                        : ((V = k), (k = o)))
                                    : ((V = k), (k = o)))
                                : ((V = k), (k = o)))
                            : ((V = k), (k = o)))
                        : ((V = k), (k = o)))
                    : ((V = k), (k = o)))
                : ((V = k), (k = o)))
            : ((V = k), (k = o)),
          k
        );
      }
      function _t() {
        var k, H, he, X;
        return (
          (k = V),
          (H = ta()),
          H !== o
            ? ((he = Jt()),
              he === o && (he = null),
              he !== o
                ? ((X = ta()),
                  X !== o
                    ? ((De = k), (H = de(H, X)), (k = H))
                    : ((V = k), (k = o)))
                : ((V = k), (k = o)))
            : ((V = k), (k = o)),
          k
        );
      }
      function tn() {
        var k, H;
        return (
          (k = V),
          (H = Nn()),
          H === o && (H = ji()),
          H !== o && ((De = k), (H = ne(H))),
          (k = H),
          k
        );
      }
      function ta() {
        var k, H, he, X;
        return (
          (k = V),
          (H = V),
          (he = Un()),
          he === o && (he = null),
          he !== o
            ? ((X = Nn()),
              X !== o ? ((he = [he, X]), (H = he)) : ((V = H), (H = o)))
            : ((V = H), (H = o)),
          H === o &&
            ((H = V),
            (he = Un()),
            he === o && (he = null),
            he !== o
              ? ((X = ji()),
                X !== o ? ((he = [he, X]), (H = he)) : ((V = H), (H = o)))
              : ((V = H), (H = o))),
          H !== o && ((De = k), (H = Ee(H))),
          (k = H),
          k
        );
      }
      function ia() {
        var k, H;
        return (
          (k = V),
          me.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(Ae)),
          H !== o && ((De = k), (H = ye(H))),
          (k = H),
          k
        );
      }
      function Jt() {
        var k, H, he, X, ve;
        if (((k = V), (H = []), (he = Yt()), he !== o))
          for (; he !== o; ) H.push(he), (he = Yt());
        else H = o;
        if (H !== o)
          if (((he = pr()), he === o && (he = null), he !== o)) {
            for (X = [], ve = Yt(); ve !== o; ) X.push(ve), (ve = Yt());
            X !== o ? ((H = [H, he, X]), (k = H)) : ((V = k), (k = o));
          } else (V = k), (k = o);
        else (V = k), (k = o);
        if (k === o) {
          if (((k = V), (H = V), (he = pr()), he !== o)) {
            for (X = [], ve = Yt(); ve !== o; ) X.push(ve), (ve = Yt());
            X !== o ? ((he = [he, X]), (H = he)) : ((V = H), (H = o));
          } else (V = H), (H = o);
          H !== o && ((De = k), (H = Ue())), (k = H);
        }
        return k;
      }
      function pr() {
        var k;
        return (
          a.charCodeAt(V) === 44
            ? ((k = Le), V++)
            : ((k = o), Fe === 0 && Mt(Te)),
          k
        );
      }
      function Nn() {
        var k, H, he, X;
        return (
          (k = V),
          (H = V),
          (he = ir()),
          he !== o
            ? ((X = ra()),
              X === o && (X = null),
              X !== o ? ((he = [he, X]), (H = he)) : ((V = H), (H = o)))
            : ((V = H), (H = o)),
          H === o &&
            ((H = V),
            (he = ji()),
            he !== o
              ? ((X = ra()),
                X !== o ? ((he = [he, X]), (H = he)) : ((V = H), (H = o)))
              : ((V = H), (H = o))),
          H !== o && ((De = k), (H = tt(H))),
          (k = H),
          k
        );
      }
      function ir() {
        var k, H, he, X, ve;
        return (
          (k = V),
          (H = V),
          (he = ji()),
          he === o && (he = null),
          he !== o
            ? (a.charCodeAt(V) === 46
                ? ((X = Je), V++)
                : ((X = o), Fe === 0 && Mt(rt)),
              X !== o
                ? ((ve = ji()),
                  ve !== o
                    ? ((he = [he, X, ve]), (H = he))
                    : ((V = H), (H = o)))
                : ((V = H), (H = o)))
            : ((V = H), (H = o)),
          H === o &&
            ((H = V),
            (he = ji()),
            he !== o
              ? (a.charCodeAt(V) === 46
                  ? ((X = Je), V++)
                  : ((X = o), Fe === 0 && Mt(rt)),
                X !== o ? ((he = [he, X]), (H = he)) : ((V = H), (H = o)))
              : ((V = H), (H = o))),
          H !== o && ((De = k), (H = tt(H))),
          (k = H),
          k
        );
      }
      function ra() {
        var k, H, he, X, ve;
        return (
          (k = V),
          (H = V),
          st.test(a.charAt(V))
            ? ((he = a.charAt(V)), V++)
            : ((he = o), Fe === 0 && Mt(Ze)),
          he !== o
            ? ((X = Un()),
              X === o && (X = null),
              X !== o
                ? ((ve = ji()),
                  ve !== o
                    ? ((he = [he, X, ve]), (H = he))
                    : ((V = H), (H = o)))
                : ((V = H), (H = o)))
            : ((V = H), (H = o)),
          H !== o && ((De = k), (H = tt(H))),
          (k = H),
          k
        );
      }
      function Un() {
        var k;
        return (
          Qe.test(a.charAt(V))
            ? ((k = a.charAt(V)), V++)
            : ((k = o), Fe === 0 && Mt(pt)),
          k
        );
      }
      function ji() {
        var k, H, he;
        if (
          ((k = V),
          (H = []),
          bt.test(a.charAt(V))
            ? ((he = a.charAt(V)), V++)
            : ((he = o), Fe === 0 && Mt($)),
          he !== o)
        )
          for (; he !== o; )
            H.push(he),
              bt.test(a.charAt(V))
                ? ((he = a.charAt(V)), V++)
                : ((he = o), Fe === 0 && Mt($));
        else H = o;
        return H !== o && ((De = k), (H = W(H))), (k = H), k;
      }
      function Yt() {
        var k, H;
        return (
          (k = V),
          _e.test(a.charAt(V))
            ? ((H = a.charAt(V)), V++)
            : ((H = o), Fe === 0 && Mt(Ge)),
          H !== o && ((De = k), (H = Ue())),
          (k = H),
          k
        );
      }
      function Eu(k, H) {
        if (!H) return [k];
        for (var he = [k], X = 0, ve = H.length; X < ve; X++)
          he[X + 1] = H[X][1];
        return he;
      }
      var Vn = {
        m: "moveto",
        l: "lineto",
        h: "horizontal lineto",
        v: "vertical lineto",
        c: "curveto",
        s: "smooth curveto",
        q: "quadratic curveto",
        t: "smooth quadratic curveto",
        a: "elliptical arc",
        z: "closepath",
      };
      for (var _l in Vn) Vn[_l.toUpperCase()] = Vn[_l];
      function Pa(k, H) {
        H || (H = [{}]);
        for (var he = H.length; he--; ) {
          var X = { code: k, command: Vn[k] };
          k == k.toLowerCase() && (X.relative = !0);
          for (var ve in H[he]) X[ve] = H[he][ve];
          H[he] = X;
        }
        return H;
      }
      if (((ut = h()), ut !== o && V === a.length)) return ut;
      throw (
        (ut !== o && V < a.length && Mt(Ce()),
        ki(
          Be,
          We < a.length ? a.charAt(We) : null,
          We < a.length ? gt(We, We + 1) : gt(We, We)
        ))
      );
    }
    t.exports = { SyntaxError: r, parse: s };
  }),
  kE = Zr((e, t) => {
    var i = NO().parse;
    (i.parseSVG = i), (i.makeAbsolute = r), (t.exports = i);
    function r(s) {
      var a,
        n = { x: 0, y: 0 },
        o = { x: "x0", y: "y0", x1: "x0", y1: "y0", x2: "x0", y2: "y0" };
      return (
        s.forEach(function (l) {
          l.command === "moveto" && (a = l), (l.x0 = n.x), (l.y0 = n.y);
          for (var h in o) h in l && (l[h] += l.relative ? l[o[h]] : 0);
          "x" in l || (l.x = n.x),
            "y" in l || (l.y = n.y),
            (l.relative = !1),
            (l.code = l.code.toUpperCase()),
            l.command == "closepath" && ((l.x = a.x), (l.y = a.y)),
            (n = l);
        }),
        s
      );
    }
  }),
  UO = Zr((e, t) => {
    "use strict";
    function i(r) {
      for (var s = new Array(r), a = 0; a < r; ++a) s[a] = a;
      return s;
    }
    t.exports = i;
  }),
  VO = Zr((e, t) => {
    t.exports = function (s) {
      return s != null && (i(s) || r(s) || !!s._isBuffer);
    };
    function i(s) {
      return (
        !!s.constructor &&
        typeof s.constructor.isBuffer == "function" &&
        s.constructor.isBuffer(s)
      );
    }
    function r(s) {
      return (
        typeof s.readFloatLE == "function" &&
        typeof s.slice == "function" &&
        i(s.slice(0, 0))
      );
    }
  }),
  tp = Zr((e, t) => {
    var i = UO(),
      r = VO(),
      s = typeof Float64Array < "u";
    function a(c, d) {
      return c[0] - d[0];
    }
    function n() {
      var c = this.stride,
        d = new Array(c.length),
        p;
      for (p = 0; p < d.length; ++p) d[p] = [Math.abs(c[p]), p];
      d.sort(a);
      var f = new Array(d.length);
      for (p = 0; p < f.length; ++p) f[p] = d[p][1];
      return f;
    }
    function o(c, d) {
      var p = ["View", d, "d", c].join("");
      d < 0 && (p = "View_Nil" + c);
      var f = c === "generic";
      if (d === -1) {
        var m =
            "function " +
            p +
            "(a){this.data=a;};var proto=" +
            p +
            ".prototype;proto.dtype='" +
            c +
            "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " +
            p +
            "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" +
            p +
            "(a){return new " +
            p +
            "(a);}",
          P = new Function(m);
        return P();
      } else if (d === 0) {
        var m =
            "function " +
            p +
            "(a,d) {this.data = a;this.offset = d};var proto=" +
            p +
            ".prototype;proto.dtype='" +
            c +
            "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " +
            p +
            "_copy() {return new " +
            p +
            "(this.data,this.offset)};proto.pick=function " +
            p +
            "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " +
            p +
            "_get(){return " +
            (f ? "this.data.get(this.offset)" : "this.data[this.offset]") +
            "};proto.set=function " +
            p +
            "_set(v){return " +
            (f ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") +
            "};return function construct_" +
            p +
            "(a,b,c,d){return new " +
            p +
            "(a,d)}",
          P = new Function("TrivialArray", m);
        return P(h[c][0]);
      }
      var m = ["'use strict'"],
        g = i(d),
        y = g.map(function (R) {
          return "i" + R;
        }),
        x =
          "this.offset+" +
          g
            .map(function (R) {
              return "this.stride[" + R + "]*i" + R;
            })
            .join("+"),
        b = g
          .map(function (R) {
            return "b" + R;
          })
          .join(","),
        _ = g
          .map(function (R) {
            return "c" + R;
          })
          .join(",");
      m.push(
        "function " + p + "(a," + b + "," + _ + ",d){this.data=a",
        "this.shape=[" + b + "]",
        "this.stride=[" + _ + "]",
        "this.offset=d|0}",
        "var proto=" + p + ".prototype",
        "proto.dtype='" + c + "'",
        "proto.dimension=" + d
      ),
        m.push(
          "Object.defineProperty(proto,'size',{get:function " +
            p +
            "_size(){return " +
            g
              .map(function (R) {
                return "this.shape[" + R + "]";
              })
              .join("*"),
          "}})"
        ),
        d === 1
          ? m.push("proto.order=[0]")
          : (m.push("Object.defineProperty(proto,'order',{get:"),
            d < 4
              ? (m.push("function " + p + "_order(){"),
                d === 2
                  ? m.push(
                      "return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})"
                    )
                  : d === 3 &&
                    m.push(
                      "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
                    ))
              : m.push("ORDER})")),
        m.push("proto.set=function " + p + "_set(" + y.join(",") + ",v){"),
        f
          ? m.push("return this.data.set(" + x + ",v)}")
          : m.push("return this.data[" + x + "]=v}"),
        m.push("proto.get=function " + p + "_get(" + y.join(",") + "){"),
        f
          ? m.push("return this.data.get(" + x + ")}")
          : m.push("return this.data[" + x + "]}"),
        m.push(
          "proto.index=function " + p + "_index(",
          y.join(),
          "){return " + x + "}"
        ),
        m.push(
          "proto.hi=function " +
            p +
            "_hi(" +
            y.join(",") +
            "){return new " +
            p +
            "(this.data," +
            g
              .map(function (R) {
                return [
                  "(typeof i",
                  R,
                  "!=='number'||i",
                  R,
                  "<0)?this.shape[",
                  R,
                  "]:i",
                  R,
                  "|0",
                ].join("");
              })
              .join(",") +
            "," +
            g
              .map(function (R) {
                return "this.stride[" + R + "]";
              })
              .join(",") +
            ",this.offset)}"
        );
      var S = g.map(function (R) {
          return "a" + R + "=this.shape[" + R + "]";
        }),
        M = g.map(function (R) {
          return "c" + R + "=this.stride[" + R + "]";
        });
      m.push(
        "proto.lo=function " +
          p +
          "_lo(" +
          y.join(",") +
          "){var b=this.offset,d=0," +
          S.join(",") +
          "," +
          M.join(",")
      );
      for (var C = 0; C < d; ++C)
        m.push(
          "if(typeof i" +
            C +
            "==='number'&&i" +
            C +
            ">=0){d=i" +
            C +
            "|0;b+=c" +
            C +
            "*d;a" +
            C +
            "-=d}"
        );
      m.push(
        "return new " +
          p +
          "(this.data," +
          g
            .map(function (R) {
              return "a" + R;
            })
            .join(",") +
          "," +
          g
            .map(function (R) {
              return "c" + R;
            })
            .join(",") +
          ",b)}"
      ),
        m.push(
          "proto.step=function " +
            p +
            "_step(" +
            y.join(",") +
            "){var " +
            g
              .map(function (R) {
                return "a" + R + "=this.shape[" + R + "]";
              })
              .join(",") +
            "," +
            g
              .map(function (R) {
                return "b" + R + "=this.stride[" + R + "]";
              })
              .join(",") +
            ",c=this.offset,d=0,ceil=Math.ceil"
        );
      for (var C = 0; C < d; ++C)
        m.push(
          "if(typeof i" +
            C +
            "==='number'){d=i" +
            C +
            "|0;if(d<0){c+=b" +
            C +
            "*(a" +
            C +
            "-1);a" +
            C +
            "=ceil(-a" +
            C +
            "/d)}else{a" +
            C +
            "=ceil(a" +
            C +
            "/d)}b" +
            C +
            "*=d}"
        );
      m.push(
        "return new " +
          p +
          "(this.data," +
          g
            .map(function (R) {
              return "a" + R;
            })
            .join(",") +
          "," +
          g
            .map(function (R) {
              return "b" + R;
            })
            .join(",") +
          ",c)}"
      );
      for (var A = new Array(d), T = new Array(d), C = 0; C < d; ++C)
        (A[C] = "a[i" + C + "]"), (T[C] = "b[i" + C + "]");
      m.push(
        "proto.transpose=function " +
          p +
          "_transpose(" +
          y +
          "){" +
          y
            .map(function (R, z) {
              return R + "=(" + R + "===undefined?" + z + ":" + R + "|0)";
            })
            .join(";"),
        "var a=this.shape,b=this.stride;return new " +
          p +
          "(this.data," +
          A.join(",") +
          "," +
          T.join(",") +
          ",this.offset)}"
      ),
        m.push(
          "proto.pick=function " +
            p +
            "_pick(" +
            y +
            "){var a=[],b=[],c=this.offset"
        );
      for (var C = 0; C < d; ++C)
        m.push(
          "if(typeof i" +
            C +
            "==='number'&&i" +
            C +
            ">=0){c=(c+this.stride[" +
            C +
            "]*i" +
            C +
            ")|0}else{a.push(this.shape[" +
            C +
            "]);b.push(this.stride[" +
            C +
            "])}"
        );
      m.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),
        m.push(
          "return function construct_" +
            p +
            "(data,shape,stride,offset){return new " +
            p +
            "(data," +
            g
              .map(function (R) {
                return "shape[" + R + "]";
              })
              .join(",") +
            "," +
            g
              .map(function (R) {
                return "stride[" + R + "]";
              })
              .join(",") +
            ",offset)}"
        );
      var P = new Function(
        "CTOR_LIST",
        "ORDER",
        m.join(`
`)
      );
      return P(h[c], n);
    }
    function l(c) {
      if (r(c)) return "buffer";
      if (s)
        switch (Object.prototype.toString.call(c)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      return Array.isArray(c) ? "array" : "generic";
    }
    var h = {
      float32: [],
      float64: [],
      int8: [],
      int16: [],
      int32: [],
      uint8: [],
      uint16: [],
      uint32: [],
      array: [],
      uint8_clamped: [],
      bigint64: [],
      biguint64: [],
      buffer: [],
      generic: [],
    };
    function u(c, d, p, f) {
      if (c === void 0) {
        var _ = h.array[0];
        return _([]);
      } else typeof c == "number" && (c = [c]);
      d === void 0 && (d = [c.length]);
      var m = d.length;
      if (p === void 0) {
        p = new Array(m);
        for (var g = m - 1, y = 1; g >= 0; --g) (p[g] = y), (y *= d[g]);
      }
      if (f === void 0) {
        f = 0;
        for (var g = 0; g < m; ++g) p[g] < 0 && (f -= (d[g] - 1) * p[g]);
      }
      for (var x = l(c), b = h[x]; b.length <= m + 1; )
        b.push(o(x, b.length - 1));
      var _ = b[m + 1];
      return _(c, d, p, f);
    }
    t.exports = u;
  }),
  jO = Zr((e, t) => {
    "use strict";
    function i(a, n) {
      for (var o = 1, l = a.length, h = a[0], u = a[0], c = 1; c < l; ++c)
        if (((u = h), (h = a[c]), n(h, u))) {
          if (c === o) {
            o++;
            continue;
          }
          a[o++] = h;
        }
      return (a.length = o), a;
    }
    function r(a) {
      for (
        var n = 1, o = a.length, l = a[0], h = a[0], u = 1;
        u < o;
        ++u, h = l
      )
        if (((h = l), (l = a[u]), l !== h)) {
          if (u === n) {
            n++;
            continue;
          }
          a[n++] = l;
        }
      return (a.length = n), a;
    }
    function s(a, n, o) {
      return a.length === 0
        ? a
        : n
        ? (o || a.sort(n), i(a, n))
        : (o || a.sort(), r(a));
    }
    t.exports = s;
  }),
  HO = Zr((e, t) => {
    "use strict";
    var i = jO();
    function r(h, u, c) {
      var d = h.length,
        p = u.arrayArgs.length,
        f = u.indexArgs.length > 0,
        m = [],
        g = [],
        y = 0,
        x = 0,
        b,
        _;
      for (b = 0; b < d; ++b) g.push(["i", b, "=0"].join(""));
      for (_ = 0; _ < p; ++_)
        for (b = 0; b < d; ++b)
          (x = y),
            (y = h[b]),
            b === 0
              ? g.push(["d", _, "s", b, "=t", _, "p", y].join(""))
              : g.push(
                  [
                    "d",
                    _,
                    "s",
                    b,
                    "=(t",
                    _,
                    "p",
                    y,
                    "-s",
                    x,
                    "*t",
                    _,
                    "p",
                    x,
                    ")",
                  ].join("")
                );
      for (g.length > 0 && m.push("var " + g.join(",")), b = d - 1; b >= 0; --b)
        (y = h[b]),
          m.push(["for(i", b, "=0;i", b, "<s", y, ";++i", b, "){"].join(""));
      for (m.push(c), b = 0; b < d; ++b) {
        for (x = y, y = h[b], _ = 0; _ < p; ++_)
          m.push(["p", _, "+=d", _, "s", b].join(""));
        f &&
          (b > 0 && m.push(["index[", x, "]-=s", x].join("")),
          m.push(["++index[", y, "]"].join(""))),
          m.push("}");
      }
      return m.join(`
`);
    }
    function s(h, u, c, d) {
      for (
        var p = u.length,
          f = c.arrayArgs.length,
          m = c.blockSize,
          g = c.indexArgs.length > 0,
          y = [],
          x = 0;
        x < f;
        ++x
      )
        y.push(["var offset", x, "=p", x].join(""));
      for (var x = h; x < p; ++x)
        y.push(["for(var j" + x + "=SS[", u[x], "]|0;j", x, ">0;){"].join("")),
          y.push(["if(j", x, "<", m, "){"].join("")),
          y.push(["s", u[x], "=j", x].join("")),
          y.push(["j", x, "=0"].join("")),
          y.push(["}else{s", u[x], "=", m].join("")),
          y.push(["j", x, "-=", m, "}"].join("")),
          g && y.push(["index[", u[x], "]=j", x].join(""));
      for (var x = 0; x < f; ++x) {
        for (var b = ["offset" + x], _ = h; _ < p; ++_)
          b.push(["j", _, "*t", x, "p", u[_]].join(""));
        y.push(["p", x, "=(", b.join("+"), ")"].join(""));
      }
      y.push(r(u, c, d));
      for (var x = h; x < p; ++x) y.push("}");
      return y.join(`
`);
    }
    function a(h) {
      for (var u = 0, c = h[0].length; u < c; ) {
        for (var d = 1; d < h.length; ++d) if (h[d][u] !== h[0][u]) return u;
        ++u;
      }
      return u;
    }
    function n(h, u, c) {
      for (var d = h.body, p = [], f = [], m = 0; m < h.args.length; ++m) {
        var g = h.args[m];
        if (!(g.count <= 0)) {
          var y = new RegExp(g.name, "g"),
            x = "",
            b = u.arrayArgs.indexOf(m);
          switch (u.argTypes[m]) {
            case "offset":
              var _ = u.offsetArgIndex.indexOf(m),
                S = u.offsetArgs[_];
              (b = S.array), (x = "+q" + _);
            case "array":
              x = "p" + b + x;
              var M = "l" + m,
                C = "a" + b;
              if (u.arrayBlockIndices[b] === 0)
                g.count === 1
                  ? c[b] === "generic"
                    ? g.lvalue
                      ? (p.push(["var ", M, "=", C, ".get(", x, ")"].join("")),
                        (d = d.replace(y, M)),
                        f.push([C, ".set(", x, ",", M, ")"].join("")))
                      : (d = d.replace(y, [C, ".get(", x, ")"].join("")))
                    : (d = d.replace(y, [C, "[", x, "]"].join("")))
                  : c[b] === "generic"
                  ? (p.push(["var ", M, "=", C, ".get(", x, ")"].join("")),
                    (d = d.replace(y, M)),
                    g.lvalue && f.push([C, ".set(", x, ",", M, ")"].join("")))
                  : (p.push(["var ", M, "=", C, "[", x, "]"].join("")),
                    (d = d.replace(y, M)),
                    g.lvalue && f.push([C, "[", x, "]=", M].join("")));
              else {
                for (
                  var A = [g.name], T = [x], P = 0;
                  P < Math.abs(u.arrayBlockIndices[b]);
                  P++
                )
                  A.push("\\s*\\[([^\\]]+)\\]"),
                    T.push("$" + (P + 1) + "*t" + b + "b" + P);
                if (
                  ((y = new RegExp(A.join(""), "g")),
                  (x = T.join("+")),
                  c[b] === "generic")
                )
                  throw new Error(
                    "cwise: Generic arrays not supported in combination with blocks!"
                  );
                d = d.replace(y, [C, "[", x, "]"].join(""));
              }
              break;
            case "scalar":
              d = d.replace(y, "Y" + u.scalarArgs.indexOf(m));
              break;
            case "index":
              d = d.replace(y, "index");
              break;
            case "shape":
              d = d.replace(y, "shape");
              break;
          }
        }
      }
      return [
        p.join(`
`),
        d,
        f.join(`
`),
      ]
        .join(
          `
`
        )
        .trim();
    }
    function o(h) {
      for (var u = new Array(h.length), c = !0, d = 0; d < h.length; ++d) {
        var p = h[d],
          f = p.match(/\d+/);
        f ? (f = f[0]) : (f = ""),
          p.charAt(0) === 0
            ? (u[d] = "u" + p.charAt(1) + f)
            : (u[d] = p.charAt(0) + f),
          d > 0 && (c = c && u[d] === u[d - 1]);
      }
      return c ? u[0] : u.join("");
    }
    function l(h, u) {
      for (
        var c = (u[1].length - Math.abs(h.arrayBlockIndices[0])) | 0,
          d = new Array(h.arrayArgs.length),
          p = new Array(h.arrayArgs.length),
          f = 0;
        f < h.arrayArgs.length;
        ++f
      )
        (p[f] = u[2 * f]), (d[f] = u[2 * f + 1]);
      for (
        var m = [], g = [], y = [], x = [], b = [], f = 0;
        f < h.arrayArgs.length;
        ++f
      ) {
        h.arrayBlockIndices[f] < 0
          ? (y.push(0),
            x.push(c),
            m.push(c),
            g.push(c + h.arrayBlockIndices[f]))
          : (y.push(h.arrayBlockIndices[f]),
            x.push(h.arrayBlockIndices[f] + c),
            m.push(0),
            g.push(h.arrayBlockIndices[f]));
        for (var _ = [], S = 0; S < d[f].length; S++)
          y[f] <= d[f][S] && d[f][S] < x[f] && _.push(d[f][S] - y[f]);
        b.push(_);
      }
      for (var M = ["SS"], C = ["'use strict'"], A = [], S = 0; S < c; ++S)
        A.push(["s", S, "=SS[", S, "]"].join(""));
      for (var f = 0; f < h.arrayArgs.length; ++f) {
        M.push("a" + f), M.push("t" + f), M.push("p" + f);
        for (var S = 0; S < c; ++S)
          A.push(["t", f, "p", S, "=t", f, "[", y[f] + S, "]"].join(""));
        for (var S = 0; S < Math.abs(h.arrayBlockIndices[f]); ++S)
          A.push(["t", f, "b", S, "=t", f, "[", m[f] + S, "]"].join(""));
      }
      for (var f = 0; f < h.scalarArgs.length; ++f) M.push("Y" + f);
      if (
        (h.shapeArgs.length > 0 && A.push("shape=SS.slice(0)"),
        h.indexArgs.length > 0)
      ) {
        for (var T = new Array(c), f = 0; f < c; ++f) T[f] = "0";
        A.push(["index=[", T.join(","), "]"].join(""));
      }
      for (var f = 0; f < h.offsetArgs.length; ++f) {
        for (var P = h.offsetArgs[f], R = [], S = 0; S < P.offset.length; ++S)
          P.offset[S] !== 0 &&
            (P.offset[S] === 1
              ? R.push(["t", P.array, "p", S].join(""))
              : R.push([P.offset[S], "*t", P.array, "p", S].join("")));
        R.length === 0
          ? A.push("q" + f + "=0")
          : A.push(["q", f, "=", R.join("+")].join(""));
      }
      var z = i(
        []
          .concat(h.pre.thisVars)
          .concat(h.body.thisVars)
          .concat(h.post.thisVars)
      );
      (A = A.concat(z)), A.length > 0 && C.push("var " + A.join(","));
      for (var f = 0; f < h.arrayArgs.length; ++f) C.push("p" + f + "|=0");
      h.pre.body.length > 3 && C.push(n(h.pre, h, p));
      var N = n(h.body, h, p),
        L = a(b);
      L < c ? C.push(s(L, b[0], h, N)) : C.push(r(b[0], h, N)),
        h.post.body.length > 3 && C.push(n(h.post, h, p)),
        h.debug &&
          console.log(
            "-----Generated cwise routine for ",
            u,
            `:
` +
              C.join(`
`) +
              `
----------`
          );
      var G = [
          h.funcName || "unnamed",
          "_cwise_loop_",
          d[0].join("s"),
          "m",
          L,
          o(p),
        ].join(""),
        Y = new Function(
          [
            "function ",
            G,
            "(",
            M.join(","),
            "){",
            C.join(`
`),
            "} return ",
            G,
          ].join("")
        );
      return Y();
    }
    t.exports = l;
  }),
  GO = Zr((e, t) => {
    "use strict";
    var i = HO();
    function r(s) {
      var a = ["'use strict'", "var CACHED={}"],
        n = [],
        o = s.funcName + "_cwise_thunk";
      a.push(["return function ", o, "(", s.shimArgs.join(","), "){"].join(""));
      for (
        var l = [],
          h = [],
          u = [
            [
              "array",
              s.arrayArgs[0],
              ".shape.slice(",
              Math.max(0, s.arrayBlockIndices[0]),
              s.arrayBlockIndices[0] < 0
                ? "," + s.arrayBlockIndices[0] + ")"
                : ")",
            ].join(""),
          ],
          c = [],
          d = [],
          p = 0;
        p < s.arrayArgs.length;
        ++p
      ) {
        var f = s.arrayArgs[p];
        n.push(
          ["t", f, "=array", f, ".dtype,", "r", f, "=array", f, ".order"].join(
            ""
          )
        ),
          l.push("t" + f),
          l.push("r" + f),
          h.push("t" + f),
          h.push("r" + f + ".join()"),
          u.push("array" + f + ".data"),
          u.push("array" + f + ".stride"),
          u.push("array" + f + ".offset|0"),
          p > 0 &&
            (c.push(
              "array" +
                s.arrayArgs[0] +
                ".shape.length===array" +
                f +
                ".shape.length+" +
                (Math.abs(s.arrayBlockIndices[0]) -
                  Math.abs(s.arrayBlockIndices[p]))
            ),
            d.push(
              "array" +
                s.arrayArgs[0] +
                ".shape[shapeIndex+" +
                Math.max(0, s.arrayBlockIndices[0]) +
                "]===array" +
                f +
                ".shape[shapeIndex+" +
                Math.max(0, s.arrayBlockIndices[p]) +
                "]"
            ));
      }
      s.arrayArgs.length > 1 &&
        (a.push(
          "if (!(" +
            c.join(" && ") +
            ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"
        ),
        a.push(
          "for(var shapeIndex=array" +
            s.arrayArgs[0] +
            ".shape.length-" +
            Math.abs(s.arrayBlockIndices[0]) +
            "; shapeIndex-->0;) {"
        ),
        a.push(
          "if (!(" +
            d.join(" && ") +
            ")) throw new Error('cwise: Arrays do not all have the same shape!')"
        ),
        a.push("}"));
      for (var p = 0; p < s.scalarArgs.length; ++p)
        u.push("scalar" + s.scalarArgs[p]);
      n.push(["type=[", h.join(","), "].join()"].join("")),
        n.push("proc=CACHED[type]"),
        a.push("var " + n.join(",")),
        a.push(
          [
            "if(!proc){",
            "CACHED[type]=proc=compile([",
            l.join(","),
            "])}",
            "return proc(",
            u.join(","),
            ")}",
          ].join("")
        ),
        s.debug &&
          console.log(
            `-----Generated thunk:
` +
              a.join(`
`) +
              `
----------`
          );
      var m = new Function(
        "compile",
        a.join(`
`)
      );
      return m(i.bind(void 0, s));
    }
    t.exports = r;
  }),
  WO = Zr((e, t) => {
    "use strict";
    var i = GO();
    function r() {
      (this.argTypes = []),
        (this.shimArgs = []),
        (this.arrayArgs = []),
        (this.arrayBlockIndices = []),
        (this.scalarArgs = []),
        (this.offsetArgs = []),
        (this.offsetArgIndex = []),
        (this.indexArgs = []),
        (this.shapeArgs = []),
        (this.funcName = ""),
        (this.pre = null),
        (this.body = null),
        (this.post = null),
        (this.debug = !1);
    }
    function s(a) {
      var n = new r();
      (n.pre = a.pre), (n.body = a.body), (n.post = a.post);
      var o = a.args.slice(0);
      n.argTypes = o;
      for (var l = 0; l < o.length; ++l) {
        var h = o[l];
        if (h === "array" || (typeof h == "object" && h.blockIndices)) {
          if (
            ((n.argTypes[l] = "array"),
            n.arrayArgs.push(l),
            n.arrayBlockIndices.push(h.blockIndices ? h.blockIndices : 0),
            n.shimArgs.push("array" + l),
            l < n.pre.args.length && n.pre.args[l].count > 0)
          )
            throw new Error("cwise: pre() block may not reference array args");
          if (l < n.post.args.length && n.post.args[l].count > 0)
            throw new Error("cwise: post() block may not reference array args");
        } else if (h === "scalar")
          n.scalarArgs.push(l), n.shimArgs.push("scalar" + l);
        else if (h === "index") {
          if (
            (n.indexArgs.push(l),
            l < n.pre.args.length && n.pre.args[l].count > 0)
          )
            throw new Error("cwise: pre() block may not reference array index");
          if (l < n.body.args.length && n.body.args[l].lvalue)
            throw new Error("cwise: body() block may not write to array index");
          if (l < n.post.args.length && n.post.args[l].count > 0)
            throw new Error(
              "cwise: post() block may not reference array index"
            );
        } else if (h === "shape") {
          if (
            (n.shapeArgs.push(l), l < n.pre.args.length && n.pre.args[l].lvalue)
          )
            throw new Error("cwise: pre() block may not write to array shape");
          if (l < n.body.args.length && n.body.args[l].lvalue)
            throw new Error("cwise: body() block may not write to array shape");
          if (l < n.post.args.length && n.post.args[l].lvalue)
            throw new Error("cwise: post() block may not write to array shape");
        } else if (typeof h == "object" && h.offset)
          (n.argTypes[l] = "offset"),
            n.offsetArgs.push({ array: h.array, offset: h.offset }),
            n.offsetArgIndex.push(l);
        else throw new Error("cwise: Unknown argument type " + o[l]);
      }
      if (n.arrayArgs.length <= 0)
        throw new Error("cwise: No array arguments specified");
      if (n.pre.args.length > o.length)
        throw new Error("cwise: Too many arguments in pre() block");
      if (n.body.args.length > o.length)
        throw new Error("cwise: Too many arguments in body() block");
      if (n.post.args.length > o.length)
        throw new Error("cwise: Too many arguments in post() block");
      return (
        (n.debug = !!a.printCode || !!a.debug),
        (n.funcName = a.funcName || "cwise"),
        (n.blockSize = a.blockSize || 64),
        i(n)
      );
    }
    t.exports = s;
  }),
  ip = Zr((e) => {
    "use strict";
    var t = WO(),
      i = { body: "", args: [], thisVars: [], localVars: [] };
    function r(d) {
      if (!d) return i;
      for (var p = 0; p < d.args.length; ++p) {
        var f = d.args[p];
        p === 0
          ? (d.args[p] = {
              name: f,
              lvalue: !0,
              rvalue: !!d.rvalue,
              count: d.count || 1,
            })
          : (d.args[p] = { name: f, lvalue: !1, rvalue: !0, count: 1 });
      }
      return (
        d.thisVars || (d.thisVars = []), d.localVars || (d.localVars = []), d
      );
    }
    function s(d) {
      return t({
        args: d.args,
        pre: r(d.pre),
        body: r(d.body),
        post: r(d.proc),
        funcName: d.funcName,
      });
    }
    function a(d) {
      for (var p = [], f = 0; f < d.args.length; ++f) p.push("a" + f);
      var m = new Function(
        "P",
        [
          "return function ",
          d.funcName,
          "_ndarrayops(",
          p.join(","),
          ") {P(",
          p.join(","),
          ");return a0}",
        ].join("")
      );
      return m(s(d));
    }
    var n = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/",
      mod: "%",
      band: "&",
      bor: "|",
      bxor: "^",
      lshift: "<<",
      rshift: ">>",
      rrshift: ">>>",
    };
    (function () {
      for (var d in n) {
        var p = n[d];
        (e[d] = a({
          args: ["array", "array", "array"],
          body: { args: ["a", "b", "c"], body: "a=b" + p + "c" },
          funcName: d,
        })),
          (e[d + "eq"] = a({
            args: ["array", "array"],
            body: { args: ["a", "b"], body: "a" + p + "=b" },
            rvalue: !0,
            funcName: d + "eq",
          })),
          (e[d + "s"] = a({
            args: ["array", "array", "scalar"],
            body: { args: ["a", "b", "s"], body: "a=b" + p + "s" },
            funcName: d + "s",
          })),
          (e[d + "seq"] = a({
            args: ["array", "scalar"],
            body: { args: ["a", "s"], body: "a" + p + "=s" },
            rvalue: !0,
            funcName: d + "seq",
          }));
      }
    })();
    var o = { not: "!", bnot: "~", neg: "-", recip: "1.0/" };
    (function () {
      for (var d in o) {
        var p = o[d];
        (e[d] = a({
          args: ["array", "array"],
          body: { args: ["a", "b"], body: "a=" + p + "b" },
          funcName: d,
        })),
          (e[d + "eq"] = a({
            args: ["array"],
            body: { args: ["a"], body: "a=" + p + "a" },
            rvalue: !0,
            count: 2,
            funcName: d + "eq",
          }));
      }
    })();
    var l = {
      and: "&&",
      or: "||",
      eq: "===",
      neq: "!==",
      lt: "<",
      gt: ">",
      leq: "<=",
      geq: ">=",
    };
    (function () {
      for (var d in l) {
        var p = l[d];
        (e[d] = a({
          args: ["array", "array", "array"],
          body: { args: ["a", "b", "c"], body: "a=b" + p + "c" },
          funcName: d,
        })),
          (e[d + "s"] = a({
            args: ["array", "array", "scalar"],
            body: { args: ["a", "b", "s"], body: "a=b" + p + "s" },
            funcName: d + "s",
          })),
          (e[d + "eq"] = a({
            args: ["array", "array"],
            body: { args: ["a", "b"], body: "a=a" + p + "b" },
            rvalue: !0,
            count: 2,
            funcName: d + "eq",
          })),
          (e[d + "seq"] = a({
            args: ["array", "scalar"],
            body: { args: ["a", "s"], body: "a=a" + p + "s" },
            rvalue: !0,
            count: 2,
            funcName: d + "seq",
          }));
      }
    })();
    var h = [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "floor",
      "log",
      "round",
      "sin",
      "sqrt",
      "tan",
    ];
    (function () {
      for (var d = 0; d < h.length; ++d) {
        var p = h[d];
        (e[p] = a({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"] },
          funcName: p,
        })),
          (e[p + "eq"] = a({
            args: ["array"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: { args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"] },
            rvalue: !0,
            count: 2,
            funcName: p + "eq",
          }));
      }
    })();
    var u = ["max", "min", "atan2", "pow"];
    (function () {
      for (var d = 0; d < u.length; ++d) {
        var p = u[d];
        (e[p] = a({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
          body: {
            args: ["a", "b", "c"],
            body: "a=this_f(b,c)",
            thisVars: ["this_f"],
          },
          funcName: p,
        })),
          (e[p + "s"] = a({
            args: ["array", "array", "scalar"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: {
              args: ["a", "b", "c"],
              body: "a=this_f(b,c)",
              thisVars: ["this_f"],
            },
            funcName: p + "s",
          })),
          (e[p + "eq"] = a({
            args: ["array", "array"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: {
              args: ["a", "b"],
              body: "a=this_f(a,b)",
              thisVars: ["this_f"],
            },
            rvalue: !0,
            count: 2,
            funcName: p + "eq",
          })),
          (e[p + "seq"] = a({
            args: ["array", "scalar"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: {
              args: ["a", "b"],
              body: "a=this_f(a,b)",
              thisVars: ["this_f"],
            },
            rvalue: !0,
            count: 2,
            funcName: p + "seq",
          }));
      }
    })();
    var c = ["atan2", "pow"];
    (function () {
      for (var d = 0; d < c.length; ++d) {
        var p = c[d];
        (e[p + "op"] = a({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
          body: {
            args: ["a", "b", "c"],
            body: "a=this_f(c,b)",
            thisVars: ["this_f"],
          },
          funcName: p + "op",
        })),
          (e[p + "ops"] = a({
            args: ["array", "array", "scalar"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: {
              args: ["a", "b", "c"],
              body: "a=this_f(c,b)",
              thisVars: ["this_f"],
            },
            funcName: p + "ops",
          })),
          (e[p + "opeq"] = a({
            args: ["array", "array"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: {
              args: ["a", "b"],
              body: "a=this_f(b,a)",
              thisVars: ["this_f"],
            },
            rvalue: !0,
            count: 2,
            funcName: p + "opeq",
          })),
          (e[p + "opseq"] = a({
            args: ["array", "scalar"],
            pre: { args: [], body: "this_f=Math." + p, thisVars: ["this_f"] },
            body: {
              args: ["a", "b"],
              body: "a=this_f(b,a)",
              thisVars: ["this_f"],
            },
            rvalue: !0,
            count: 2,
            funcName: p + "opseq",
          }));
      }
    })(),
      (e.any = t({
        args: ["array"],
        pre: i,
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 1 }],
          body: "if(a){return true}",
          localVars: [],
          thisVars: [],
        },
        post: { args: [], localVars: [], thisVars: [], body: "return false" },
        funcName: "any",
      })),
      (e.all = t({
        args: ["array"],
        pre: i,
        body: {
          args: [{ name: "x", lvalue: !1, rvalue: !0, count: 1 }],
          body: "if(!x){return false}",
          localVars: [],
          thisVars: [],
        },
        post: { args: [], localVars: [], thisVars: [], body: "return true" },
        funcName: "all",
      })),
      (e.sum = t({
        args: ["array"],
        pre: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "this_s=0",
        },
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 1 }],
          body: "this_s+=a",
          localVars: [],
          thisVars: ["this_s"],
        },
        post: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "return this_s",
        },
        funcName: "sum",
      })),
      (e.prod = t({
        args: ["array"],
        pre: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "this_s=1",
        },
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 1 }],
          body: "this_s*=a",
          localVars: [],
          thisVars: ["this_s"],
        },
        post: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "return this_s",
        },
        funcName: "prod",
      })),
      (e.norm2squared = t({
        args: ["array"],
        pre: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "this_s=0",
        },
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 2 }],
          body: "this_s+=a*a",
          localVars: [],
          thisVars: ["this_s"],
        },
        post: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "return this_s",
        },
        funcName: "norm2squared",
      })),
      (e.norm2 = t({
        args: ["array"],
        pre: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "this_s=0",
        },
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 2 }],
          body: "this_s+=a*a",
          localVars: [],
          thisVars: ["this_s"],
        },
        post: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "return Math.sqrt(this_s)",
        },
        funcName: "norm2",
      })),
      (e.norminf = t({
        args: ["array"],
        pre: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "this_s=0",
        },
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 4 }],
          body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
          localVars: [],
          thisVars: ["this_s"],
        },
        post: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "return this_s",
        },
        funcName: "norminf",
      })),
      (e.norm1 = t({
        args: ["array"],
        pre: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "this_s=0",
        },
        body: {
          args: [{ name: "a", lvalue: !1, rvalue: !0, count: 3 }],
          body: "this_s+=a<0?-a:a",
          localVars: [],
          thisVars: ["this_s"],
        },
        post: {
          args: [],
          localVars: [],
          thisVars: ["this_s"],
          body: "return this_s",
        },
        funcName: "norm1",
      })),
      (e.sup = t({
        args: ["array"],
        pre: {
          body: "this_h=-Infinity",
          args: [],
          thisVars: ["this_h"],
          localVars: [],
        },
        body: {
          body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
          args: [{ name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 }],
          thisVars: ["this_h"],
          localVars: [],
        },
        post: {
          body: "return this_h",
          args: [],
          thisVars: ["this_h"],
          localVars: [],
        },
      })),
      (e.inf = t({
        args: ["array"],
        pre: {
          body: "this_h=Infinity",
          args: [],
          thisVars: ["this_h"],
          localVars: [],
        },
        body: {
          body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
          args: [{ name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 }],
          thisVars: ["this_h"],
          localVars: [],
        },
        post: {
          body: "return this_h",
          args: [],
          thisVars: ["this_h"],
          localVars: [],
        },
      })),
      (e.argmin = t({
        args: ["index", "array", "shape"],
        pre: {
          body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
          args: [
            { name: "_inline_0_arg0_", lvalue: !1, rvalue: !1, count: 0 },
            { name: "_inline_0_arg1_", lvalue: !1, rvalue: !1, count: 0 },
            { name: "_inline_0_arg2_", lvalue: !1, rvalue: !0, count: 1 },
          ],
          thisVars: ["this_i", "this_v"],
          localVars: [],
        },
        body: {
          body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
          args: [
            { name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 },
            { name: "_inline_1_arg1_", lvalue: !1, rvalue: !0, count: 2 },
          ],
          thisVars: ["this_i", "this_v"],
          localVars: ["_inline_1_k"],
        },
        post: {
          body: "{return this_i}",
          args: [],
          thisVars: ["this_i"],
          localVars: [],
        },
      })),
      (e.argmax = t({
        args: ["index", "array", "shape"],
        pre: {
          body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
          args: [
            { name: "_inline_0_arg0_", lvalue: !1, rvalue: !1, count: 0 },
            { name: "_inline_0_arg1_", lvalue: !1, rvalue: !1, count: 0 },
            { name: "_inline_0_arg2_", lvalue: !1, rvalue: !0, count: 1 },
          ],
          thisVars: ["this_i", "this_v"],
          localVars: [],
        },
        body: {
          body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
          args: [
            { name: "_inline_1_arg0_", lvalue: !1, rvalue: !0, count: 2 },
            { name: "_inline_1_arg1_", lvalue: !1, rvalue: !0, count: 2 },
          ],
          thisVars: ["this_i", "this_v"],
          localVars: ["_inline_1_k"],
        },
        post: {
          body: "{return this_i}",
          args: [],
          thisVars: ["this_i"],
          localVars: [],
        },
      })),
      (e.random = a({
        args: ["array"],
        pre: { args: [], body: "this_f=Math.random", thisVars: ["this_f"] },
        body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
        funcName: "random",
      })),
      (e.assign = a({
        args: ["array", "array"],
        body: { args: ["a", "b"], body: "a=b" },
        funcName: "assign",
      })),
      (e.assigns = a({
        args: ["array", "scalar"],
        body: { args: ["a", "b"], body: "a=b" },
        funcName: "assigns",
      })),
      (e.equals = t({
        args: ["array", "array"],
        pre: i,
        body: {
          args: [
            { name: "x", lvalue: !1, rvalue: !0, count: 1 },
            { name: "y", lvalue: !1, rvalue: !0, count: 1 },
          ],
          body: "if(x!==y){return false}",
          localVars: [],
          thisVars: [],
        },
        post: { args: [], localVars: [], thisVars: [], body: "return true" },
        funcName: "equals",
      }));
  }),
  qO = Zr((e, t) => {
    t.exports = function (i, r) {
      for (var s = i.split("."), a = r.split("."), n = 0; n < 3; n++) {
        var o = Number(s[n]),
          l = Number(a[n]);
        if (o > l) return 1;
        if (l > o) return -1;
        if (!isNaN(o) && isNaN(l)) return 1;
        if (isNaN(o) && !isNaN(l)) return -1;
      }
      return 0;
    };
  }),
  ru = "149",
  ha = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  YO = 0,
  kw = 1,
  XO = 2,
  px = 1,
  QO = 2,
  hd = 3,
  Xa = 0,
  Yr = 1,
  js = 2,
  wr = 0,
  Jl = 1,
  Nw = 2,
  Uw = 3,
  Vw = 4,
  ZO = 5,
  pc = 100,
  KO = 101,
  JO = 102,
  jw = 103,
  Hw = 104,
  $O = 200,
  eI = 201,
  tI = 202,
  iI = 203,
  NE = 204,
  UE = 205,
  rI = 206,
  sI = 207,
  aI = 208,
  nI = 209,
  oI = 210,
  lI = 0,
  hI = 1,
  cI = 2,
  cy = 3,
  uI = 4,
  dI = 5,
  pI = 6,
  fI = 7,
  VE = 0,
  mI = 1,
  gI = 2,
  Tn = 0,
  vI = 1,
  yI = 2,
  xI = 3,
  bI = 4,
  wI = 5,
  jE = 300,
  nh = 301,
  oh = 302,
  uy = 303,
  dy = 304,
  rp = 306,
  mo = 1e3,
  Ui = 1001,
  py = 1002,
  mi = 1003,
  Gw = 1004,
  av = 1005,
  Wt = 1006,
  _I = 1007,
  jc = 1008,
  ys = 1009,
  SI = 1010,
  AI = 1011,
  HE = 1012,
  MI = 1013,
  go = 1014,
  xr = 1015,
  lh = 1016,
  EI = 1017,
  CI = 1018,
  $l = 1020,
  TI = 1021,
  Wr = 1023,
  PI = 1024,
  DI = 1025,
  eh = 1026,
  hh = 1027,
  OI = 1028,
  II = 1029,
  gm = 1030,
  RI = 1031,
  GE = 1033,
  nv = 33776,
  ov = 33777,
  lv = 33778,
  hv = 33779,
  Ww = 35840,
  qw = 35841,
  Yw = 35842,
  Xw = 35843,
  LI = 36196,
  Qw = 37492,
  Zw = 37496,
  Kw = 37808,
  Jw = 37809,
  $w = 37810,
  e_ = 37811,
  t_ = 37812,
  i_ = 37813,
  r_ = 37814,
  s_ = 37815,
  a_ = 37816,
  n_ = 37817,
  o_ = 37818,
  l_ = 37819,
  h_ = 37820,
  c_ = 37821,
  cv = 36492,
  BI = 36283,
  u_ = 36284,
  d_ = 36285,
  p_ = 36286,
  WE = 2200,
  qE = 2201,
  fx = 2202,
  vm = 2300,
  ym = 2301,
  uv = 2302,
  xc = 2400,
  bc = 2401,
  xm = 2402,
  mx = 2500,
  zI = 2501,
  Qa = 3e3,
  jt = 3001,
  Eo = 3200,
  YE = 3201,
  FI = 0,
  kI = 1,
  yn = "srgb",
  bm = "srgb-linear",
  dv = 7680,
  NI = 519,
  fy = 35044,
  UI = 35048,
  f_ = "300 es",
  my = 1035,
  ls = class {
    addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      let i = this._listeners;
      i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
    }
    hasEventListener(e, t) {
      if (this._listeners === void 0) return !1;
      let i = this._listeners;
      return i[e] !== void 0 && i[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
      if (this._listeners === void 0) return;
      let i = this._listeners[e];
      if (i !== void 0) {
        let r = i.indexOf(t);
        r !== -1 && i.splice(r, 1);
      }
    }
    dispatchEvent(e) {
      if (this._listeners === void 0) return;
      let t = this._listeners[e.type];
      if (t !== void 0) {
        e.target = this;
        let i = t.slice(0);
        for (let r = 0, s = i.length; r < s; r++) i[r].call(this, e);
        e.target = null;
      }
    }
  },
  hs = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ],
  m_ = 1234567,
  xd = Math.PI / 180,
  Id = 180 / Math.PI;
function Aa() {
  let e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    hs[e & 255] +
    hs[(e >> 8) & 255] +
    hs[(e >> 16) & 255] +
    hs[(e >> 24) & 255] +
    "-" +
    hs[t & 255] +
    hs[(t >> 8) & 255] +
    "-" +
    hs[((t >> 16) & 15) | 64] +
    hs[(t >> 24) & 255] +
    "-" +
    hs[(i & 63) | 128] +
    hs[(i >> 8) & 255] +
    "-" +
    hs[(i >> 16) & 255] +
    hs[(i >> 24) & 255] +
    hs[r & 255] +
    hs[(r >> 8) & 255] +
    hs[(r >> 16) & 255] +
    hs[(r >> 24) & 255]
  ).toLowerCase();
}
function vr(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function gx(e, t) {
  return ((e % t) + t) % t;
}
function VI(e, t, i, r, s) {
  return r + ((e - t) * (s - r)) / (i - t);
}
function jI(e, t, i) {
  return e !== t ? (i - e) / (t - e) : 0;
}
function bd(e, t, i) {
  return (1 - i) * e + i * t;
}
function HI(e, t, i, r) {
  return bd(e, t, 1 - Math.exp(-i * r));
}
function GI(e, t = 1) {
  return t - Math.abs(gx(e, t * 2) - t);
}
function WI(e, t, i) {
  return e <= t
    ? 0
    : e >= i
    ? 1
    : ((e = (e - t) / (i - t)), e * e * (3 - 2 * e));
}
function qI(e, t, i) {
  return e <= t
    ? 0
    : e >= i
    ? 1
    : ((e = (e - t) / (i - t)), e * e * e * (e * (e * 6 - 15) + 10));
}
function YI(e, t) {
  return e + Math.floor(Math.random() * (t - e + 1));
}
function XI(e, t) {
  return e + Math.random() * (t - e);
}
function QI(e) {
  return e * (0.5 - Math.random());
}
function ZI(e) {
  e !== void 0 && (m_ = e);
  let t = (m_ += 1831565813);
  return (
    (t = Math.imul(t ^ (t >>> 15), t | 1)),
    (t ^= t + Math.imul(t ^ (t >>> 7), t | 61)),
    ((t ^ (t >>> 14)) >>> 0) / 4294967296
  );
}
function KI(e) {
  return e * xd;
}
function JI(e) {
  return e * Id;
}
function gy(e) {
  return (e & (e - 1)) === 0 && e !== 0;
}
function XE(e) {
  return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
}
function wm(e) {
  return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
}
function $I(e, t, i, r, s) {
  let a = Math.cos,
    n = Math.sin,
    o = a(i / 2),
    l = n(i / 2),
    h = a((t + r) / 2),
    u = n((t + r) / 2),
    c = a((t - r) / 2),
    d = n((t - r) / 2),
    p = a((r - t) / 2),
    f = n((r - t) / 2);
  switch (s) {
    case "XYX":
      e.set(o * u, l * c, l * d, o * h);
      break;
    case "YZY":
      e.set(l * d, o * u, l * c, o * h);
      break;
    case "ZXZ":
      e.set(l * c, l * d, o * u, o * h);
      break;
    case "XZX":
      e.set(o * u, l * f, l * p, o * h);
      break;
    case "YXY":
      e.set(l * p, o * u, l * f, o * h);
      break;
    case "ZYZ":
      e.set(l * f, l * p, o * u, o * h);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          s
      );
  }
}
function vo(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint16Array:
      return e / 65535;
    case Uint8Array:
      return e / 255;
    case Int16Array:
      return Math.max(e / 32767, -1);
    case Int8Array:
      return Math.max(e / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Ri(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint16Array:
      return Math.round(e * 65535);
    case Uint8Array:
      return Math.round(e * 255);
    case Int16Array:
      return Math.round(e * 32767);
    case Int8Array:
      return Math.round(e * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var dt = Object.freeze({
    __proto__: null,
    DEG2RAD: xd,
    RAD2DEG: Id,
    ceilPowerOfTwo: XE,
    clamp: vr,
    damp: HI,
    degToRad: KI,
    denormalize: vo,
    euclideanModulo: gx,
    floorPowerOfTwo: wm,
    generateUUID: Aa,
    inverseLerp: jI,
    isPowerOfTwo: gy,
    lerp: bd,
    mapLinear: VI,
    normalize: Ri,
    pingpong: GI,
    radToDeg: JI,
    randFloat: XI,
    randFloatSpread: QI,
    randInt: YI,
    seededRandom: ZI,
    setQuaternionFromProperEuler: $I,
    smootherstep: qI,
    smoothstep: WI,
  }),
  re = class {
    constructor(e = 0, t = 0) {
      (re.prototype.isVector2 = !0), (this.x = e), (this.y = t);
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return (this.x = e), (this.y = t), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), this;
    }
    add(e) {
      return (this.x += e.x), (this.y += e.y), this;
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), this;
    }
    addVectors(e, t) {
      return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
    }
    addScaledVector(e, t) {
      return (this.x += e.x * t), (this.y += e.y * t), this;
    }
    sub(e) {
      return (this.x -= e.x), (this.y -= e.y), this;
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, t) {
      return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      let t = this.x,
        i = this.y,
        r = e.elements;
      return (
        (this.x = r[0] * t + r[3] * i + r[6]),
        (this.y = r[1] * t + r[4] * i + r[7]),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        this
      );
    }
    clampLength(e, t) {
      let i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(e, Math.min(t, i))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      let t = this.x - e.x,
        i = this.y - e.y;
      return t * t + i * i;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
      );
    }
    lerpVectors(e, t, i) {
      return (
        (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
      );
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), e;
    }
    fromBufferAttribute(e, t) {
      return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
    }
    rotateAround(e, t) {
      let i = Math.cos(t),
        r = Math.sin(t),
        s = this.x - e.x,
        a = this.y - e.y;
      return (
        (this.x = s * i - a * r + e.x), (this.y = s * r + a * i + e.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  },
  lr = class {
    constructor() {
      (lr.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }
    set(e, t, i, r, s, a, n, o, l) {
      let h = this.elements;
      return (
        (h[0] = e),
        (h[1] = r),
        (h[2] = n),
        (h[3] = t),
        (h[4] = s),
        (h[5] = o),
        (h[6] = i),
        (h[7] = a),
        (h[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      let t = this.elements,
        i = e.elements;
      return (
        (t[0] = i[0]),
        (t[1] = i[1]),
        (t[2] = i[2]),
        (t[3] = i[3]),
        (t[4] = i[4]),
        (t[5] = i[5]),
        (t[6] = i[6]),
        (t[7] = i[7]),
        (t[8] = i[8]),
        this
      );
    }
    extractBasis(e, t, i) {
      return (
        e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(e) {
      let t = e.elements;
      return (
        this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      let i = e.elements,
        r = t.elements,
        s = this.elements,
        a = i[0],
        n = i[3],
        o = i[6],
        l = i[1],
        h = i[4],
        u = i[7],
        c = i[2],
        d = i[5],
        p = i[8],
        f = r[0],
        m = r[3],
        g = r[6],
        y = r[1],
        x = r[4],
        b = r[7],
        _ = r[2],
        S = r[5],
        M = r[8];
      return (
        (s[0] = a * f + n * y + o * _),
        (s[3] = a * m + n * x + o * S),
        (s[6] = a * g + n * b + o * M),
        (s[1] = l * f + h * y + u * _),
        (s[4] = l * m + h * x + u * S),
        (s[7] = l * g + h * b + u * M),
        (s[2] = c * f + d * y + p * _),
        (s[5] = c * m + d * x + p * S),
        (s[8] = c * g + d * b + p * M),
        this
      );
    }
    multiplyScalar(e) {
      let t = this.elements;
      return (
        (t[0] *= e),
        (t[3] *= e),
        (t[6] *= e),
        (t[1] *= e),
        (t[4] *= e),
        (t[7] *= e),
        (t[2] *= e),
        (t[5] *= e),
        (t[8] *= e),
        this
      );
    }
    determinant() {
      let e = this.elements,
        t = e[0],
        i = e[1],
        r = e[2],
        s = e[3],
        a = e[4],
        n = e[5],
        o = e[6],
        l = e[7],
        h = e[8];
      return (
        t * a * h - t * n * l - i * s * h + i * n * o + r * s * l - r * a * o
      );
    }
    invert() {
      let e = this.elements,
        t = e[0],
        i = e[1],
        r = e[2],
        s = e[3],
        a = e[4],
        n = e[5],
        o = e[6],
        l = e[7],
        h = e[8],
        u = h * a - n * l,
        c = n * o - h * s,
        d = l * s - a * o,
        p = t * u + i * c + r * d;
      if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      let f = 1 / p;
      return (
        (e[0] = u * f),
        (e[1] = (r * l - h * i) * f),
        (e[2] = (n * i - r * a) * f),
        (e[3] = c * f),
        (e[4] = (h * t - r * o) * f),
        (e[5] = (r * s - n * t) * f),
        (e[6] = d * f),
        (e[7] = (i * o - l * t) * f),
        (e[8] = (a * t - i * s) * f),
        this
      );
    }
    transpose() {
      let e,
        t = this.elements;
      return (
        (e = t[1]),
        (t[1] = t[3]),
        (t[3] = e),
        (e = t[2]),
        (t[2] = t[6]),
        (t[6] = e),
        (e = t[5]),
        (t[5] = t[7]),
        (t[7] = e),
        this
      );
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      let t = this.elements;
      return (
        (e[0] = t[0]),
        (e[1] = t[3]),
        (e[2] = t[6]),
        (e[3] = t[1]),
        (e[4] = t[4]),
        (e[5] = t[7]),
        (e[6] = t[2]),
        (e[7] = t[5]),
        (e[8] = t[8]),
        this
      );
    }
    setUvTransform(e, t, i, r, s, a, n) {
      let o = Math.cos(s),
        l = Math.sin(s);
      return (
        this.set(
          i * o,
          i * l,
          -i * (o * a + l * n) + a + e,
          -r * l,
          r * o,
          -r * (-l * a + o * n) + n + t,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(e, t) {
      return this.premultiply(pv.makeScale(e, t)), this;
    }
    rotate(e) {
      return this.premultiply(pv.makeRotation(-e)), this;
    }
    translate(e, t) {
      return this.premultiply(pv.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
      return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
    }
    makeRotation(e) {
      let t = Math.cos(e),
        i = Math.sin(e);
      return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
      let t = this.elements,
        i = e.elements;
      for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
      return this;
    }
    toArray(e = [], t = 0) {
      let i = this.elements;
      return (
        (e[t] = i[0]),
        (e[t + 1] = i[1]),
        (e[t + 2] = i[2]),
        (e[t + 3] = i[3]),
        (e[t + 4] = i[4]),
        (e[t + 5] = i[5]),
        (e[t + 6] = i[6]),
        (e[t + 7] = i[7]),
        (e[t + 8] = i[8]),
        e
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  },
  pv = new lr();
function QE(e) {
  for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0;
  return !1;
}
var eR = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Rp(e, t) {
  return new eR[e](t);
}
function Rd(e) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", e);
}
function th(e) {
  return e < 0.04045
    ? e * 0.0773993808
    : Math.pow(e * 0.9478672986 + 0.0521327014, 2.4);
}
function rm(e) {
  return e < 0.0031308 ? e * 12.92 : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
var fv = { [yn]: { [bm]: th }, [bm]: { [yn]: rm } },
  ws = {
    legacyMode: !0,
    get workingColorSpace() {
      return bm;
    },
    set workingColorSpace(e) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (e, t, i) {
      if (this.legacyMode || t === i || !t || !i) return e;
      if (fv[t] && fv[t][i] !== void 0) {
        let r = fv[t][i];
        return (e.r = r(e.r)), (e.g = r(e.g)), (e.b = r(e.b)), e;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function (e, t) {
      return this.convert(e, this.workingColorSpace, t);
    },
    toWorkingColorSpace: function (e, t) {
      return this.convert(e, t, this.workingColorSpace);
    },
  },
  ZE = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Tr = { r: 0, g: 0, b: 0 },
  Ra = { h: 0, s: 0, l: 0 },
  Lp = { h: 0, s: 0, l: 0 };
function mv(e, t, i) {
  return (
    i < 0 && (i += 1),
    i > 1 && (i -= 1),
    i < 1 / 6
      ? e + (t - e) * 6 * i
      : i < 1 / 2
      ? t
      : i < 2 / 3
      ? e + (t - e) * 6 * (2 / 3 - i)
      : e
  );
}
function Bp(e, t) {
  return (t.r = e.r), (t.g = e.g), (t.b = e.b), t;
}
var Et = class {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = yn) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      ws.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = ws.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      ws.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = ws.workingColorSpace) {
    if (((e = gx(e, 1)), (t = vr(t, 0, 1)), (i = vr(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      let s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        a = 2 * i - s;
      (this.r = mv(a, s, e + 1 / 3)),
        (this.g = mv(a, s, e)),
        (this.b = mv(a, s, e - 1 / 3));
    }
    return ws.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = yn) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
      let s,
        a = r[1],
        n = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(s[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(s[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(s[3], 10)) / 255),
              ws.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(s[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(s[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(s[3], 10)) / 100),
              ws.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                n
              ))
          ) {
            let o = parseFloat(s[1]) / 360,
              l = parseFloat(s[2]) / 100,
              h = parseFloat(s[3]) / 100;
            return i(s[4]), this.setHSL(o, l, h, t);
          }
          break;
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      let s = r[1],
        a = s.length;
      if (a === 3)
        return (
          (this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255),
          (this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255),
          (this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255),
          ws.toWorkingColorSpace(this, t),
          this
        );
      if (a === 6)
        return (
          (this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255),
          (this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255),
          (this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255),
          ws.toWorkingColorSpace(this, t),
          this
        );
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = yn) {
    let i = ZE[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = th(e.r)), (this.g = th(e.g)), (this.b = th(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = rm(e.r)), (this.g = rm(e.g)), (this.b = rm(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = yn) {
    return (
      ws.fromWorkingColorSpace(Bp(this, Tr), e),
      (vr(Tr.r * 255, 0, 255) << 16) ^
        (vr(Tr.g * 255, 0, 255) << 8) ^
        (vr(Tr.b * 255, 0, 255) << 0)
    );
  }
  getHexString(e = yn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = ws.workingColorSpace) {
    ws.fromWorkingColorSpace(Bp(this, Tr), t);
    let i = Tr.r,
      r = Tr.g,
      s = Tr.b,
      a = Math.max(i, r, s),
      n = Math.min(i, r, s),
      o,
      l,
      h = (n + a) / 2;
    if (n === a) (o = 0), (l = 0);
    else {
      let u = a - n;
      switch (((l = h <= 0.5 ? u / (a + n) : u / (2 - a - n)), a)) {
        case i:
          o = (r - s) / u + (r < s ? 6 : 0);
          break;
        case r:
          o = (s - i) / u + 2;
          break;
        case s:
          o = (i - r) / u + 4;
          break;
      }
      o /= 6;
    }
    return (e.h = o), (e.s = l), (e.l = h), e;
  }
  getRGB(e, t = ws.workingColorSpace) {
    return (
      ws.fromWorkingColorSpace(Bp(this, Tr), t),
      (e.r = Tr.r),
      (e.g = Tr.g),
      (e.b = Tr.b),
      e
    );
  }
  getStyle(e = yn) {
    return (
      ws.fromWorkingColorSpace(Bp(this, Tr), e),
      e !== yn
        ? `color(${e} ${Tr.r} ${Tr.g} ${Tr.b})`
        : `rgb(${(Tr.r * 255) | 0},${(Tr.g * 255) | 0},${(Tr.b * 255) | 0})`
    );
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Ra),
      (Ra.h += e),
      (Ra.s += t),
      (Ra.l += i),
      this.setHSL(Ra.h, Ra.s, Ra.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Ra), e.getHSL(Lp);
    let i = bd(Ra.h, Lp.h, t),
      r = bd(Ra.s, Lp.s, t),
      s = bd(Ra.l, Lp.l, t);
    return this.setHSL(i, r, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
Et.NAMES = ZE;
var Rh,
  KE = class {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        Rh === void 0 && (Rh = Rd("canvas")),
          (Rh.width = e.width),
          (Rh.height = e.height);
        let i = Rh.getContext("2d");
        e instanceof ImageData
          ? i.putImageData(e, 0, 0)
          : i.drawImage(e, 0, 0, e.width, e.height),
          (t = Rh);
      }
      return t.width > 2048 || t.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            e
          ),
          t.toDataURL("image/jpeg", 0.6))
        : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (
        (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
      ) {
        let t = Rd("canvas");
        (t.width = e.width), (t.height = e.height);
        let i = t.getContext("2d");
        i.drawImage(e, 0, 0, e.width, e.height);
        let r = i.getImageData(0, 0, e.width, e.height),
          s = r.data;
        for (let a = 0; a < s.length; a++) s[a] = th(s[a] / 255) * 255;
        return i.putImageData(r, 0, 0), t;
      } else if (e.data) {
        let t = e.data.slice(0);
        for (let i = 0; i < t.length; i++)
          t instanceof Uint8Array || t instanceof Uint8ClampedArray
            ? (t[i] = Math.floor(th(t[i] / 255) * 255))
            : (t[i] = th(t[i]));
        return { data: t, width: e.width, height: e.height };
      } else
        return (
          console.warn(
            "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
          ),
          e
        );
    }
  },
  JE = class {
    constructor(e = null) {
      (this.isSource = !0),
        (this.uuid = Aa()),
        (this.data = e),
        (this.version = 0);
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      let i = { uuid: this.uuid, url: "" },
        r = this.data;
      if (r !== null) {
        let s;
        if (Array.isArray(r)) {
          s = [];
          for (let a = 0, n = r.length; a < n; a++)
            r[a].isDataTexture ? s.push(gv(r[a].image)) : s.push(gv(r[a]));
        } else s = gv(r);
        i.url = s;
      }
      return t || (e.images[this.uuid] = i), i;
    }
  };
function gv(e) {
  return (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ? KE.getDataURL(e)
    : e.data
    ? {
        data: Array.from(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
var tR = 0,
  Yi = class extends ls {
    constructor(
      e = Yi.DEFAULT_IMAGE,
      t = Yi.DEFAULT_MAPPING,
      i = Ui,
      r = Ui,
      s = Wt,
      a = jc,
      n = Wr,
      o = ys,
      l = Yi.DEFAULT_ANISOTROPY,
      h = Qa
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: tR++ }),
        (this.uuid = Aa()),
        (this.name = ""),
        (this.source = new JE(e)),
        (this.mipmaps = []),
        (this.mapping = t),
        (this.wrapS = i),
        (this.wrapT = r),
        (this.magFilter = s),
        (this.minFilter = a),
        (this.anisotropy = l),
        (this.format = n),
        (this.internalFormat = null),
        (this.type = o),
        (this.offset = new re(0, 0)),
        (this.repeat = new re(1, 1)),
        (this.center = new re(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new lr()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = h),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1);
    }
    get image() {
      return this.source.data;
    }
    set image(e) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.source = e.source),
        (this.mipmaps = e.mipmaps.slice(0)),
        (this.mapping = e.mapping),
        (this.wrapS = e.wrapS),
        (this.wrapT = e.wrapT),
        (this.magFilter = e.magFilter),
        (this.minFilter = e.minFilter),
        (this.anisotropy = e.anisotropy),
        (this.format = e.format),
        (this.internalFormat = e.internalFormat),
        (this.type = e.type),
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        (this.rotation = e.rotation),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this.matrix.copy(e.matrix),
        (this.generateMipmaps = e.generateMipmaps),
        (this.premultiplyAlpha = e.premultiplyAlpha),
        (this.flipY = e.flipY),
        (this.unpackAlignment = e.unpackAlignment),
        (this.encoding = e.encoding),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      let i = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e) {
      if (this.mapping !== jE) return e;
      if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
        switch (this.wrapS) {
          case mo:
            e.x = e.x - Math.floor(e.x);
            break;
          case Ui:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case py:
            Math.abs(Math.floor(e.x) % 2) === 1
              ? (e.x = Math.ceil(e.x) - e.x)
              : (e.x = e.x - Math.floor(e.x));
            break;
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case mo:
            e.y = e.y - Math.floor(e.y);
            break;
          case Ui:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case py:
            Math.abs(Math.floor(e.y) % 2) === 1
              ? (e.y = Math.ceil(e.y) - e.y)
              : (e.y = e.y - Math.floor(e.y));
            break;
        }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === !0 && (this.version++, (this.source.needsUpdate = !0));
    }
  };
Yi.DEFAULT_IMAGE = null;
Yi.DEFAULT_MAPPING = jE;
Yi.DEFAULT_ANISOTROPY = 1;
var Lt = class {
    constructor(e = 0, t = 0, i = 0, r = 1) {
      (Lt.prototype.isVector4 = !0),
        (this.x = e),
        (this.y = t),
        (this.z = i),
        (this.w = r);
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, i, r) {
      return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setZ(e) {
      return (this.z = e), this;
    }
    setW(e) {
      return (this.w = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.z = e.z),
        (this.w = e.w !== void 0 ? e.w : 1),
        this
      );
    }
    add(e) {
      return (
        (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
      );
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
    }
    addVectors(e, t) {
      return (
        (this.x = e.x + t.x),
        (this.y = e.y + t.y),
        (this.z = e.z + t.z),
        (this.w = e.w + t.w),
        this
      );
    }
    addScaledVector(e, t) {
      return (
        (this.x += e.x * t),
        (this.y += e.y * t),
        (this.z += e.z * t),
        (this.w += e.w * t),
        this
      );
    }
    sub(e) {
      return (
        (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
      );
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
    }
    subVectors(e, t) {
      return (
        (this.x = e.x - t.x),
        (this.y = e.y - t.y),
        (this.z = e.z - t.z),
        (this.w = e.w - t.w),
        this
      );
    }
    multiply(e) {
      return (
        (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
      );
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
    }
    applyMatrix4(e) {
      let t = this.x,
        i = this.y,
        r = this.z,
        s = this.w,
        a = e.elements;
      return (
        (this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * s),
        (this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * s),
        (this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * s),
        (this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * s),
        this
      );
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      let t = Math.sqrt(1 - e.w * e.w);
      return (
        t < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(e) {
      let t,
        i,
        r,
        s,
        a = e.elements,
        n = a[0],
        o = a[4],
        l = a[8],
        h = a[1],
        u = a[5],
        c = a[9],
        d = a[2],
        p = a[6],
        f = a[10];
      if (
        Math.abs(o - h) < 0.01 &&
        Math.abs(l - d) < 0.01 &&
        Math.abs(c - p) < 0.01
      ) {
        if (
          Math.abs(o + h) < 0.1 &&
          Math.abs(l + d) < 0.1 &&
          Math.abs(c + p) < 0.1 &&
          Math.abs(n + u + f - 3) < 0.1
        )
          return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        let g = (n + 1) / 2,
          y = (u + 1) / 2,
          x = (f + 1) / 2,
          b = (o + h) / 4,
          _ = (l + d) / 4,
          S = (c + p) / 4;
        return (
          g > y && g > x
            ? g < 0.01
              ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
              : ((i = Math.sqrt(g)), (r = b / i), (s = _ / i))
            : y > x
            ? y < 0.01
              ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(y)), (i = b / r), (s = S / r))
            : x < 0.01
            ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
            : ((s = Math.sqrt(x)), (i = _ / s), (r = S / s)),
          this.set(i, r, s, t),
          this
        );
      }
      let m = Math.sqrt(
        (p - c) * (p - c) + (l - d) * (l - d) + (h - o) * (h - o)
      );
      return (
        Math.abs(m) < 0.001 && (m = 1),
        (this.x = (p - c) / m),
        (this.y = (l - d) / m),
        (this.z = (h - o) / m),
        (this.w = Math.acos((n + u + f - 1) / 2)),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)),
        (this.y = Math.min(this.y, e.y)),
        (this.z = Math.min(this.z, e.z)),
        (this.w = Math.min(this.w, e.w)),
        this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)),
        (this.y = Math.max(this.y, e.y)),
        (this.z = Math.max(this.z, e.z)),
        (this.w = Math.max(this.w, e.w)),
        this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        (this.z = Math.max(e.z, Math.min(t.z, this.z))),
        (this.w = Math.max(e.w, Math.min(t.w, this.w))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        (this.z = Math.max(e, Math.min(t, this.z))),
        (this.w = Math.max(e, Math.min(t, this.w))),
        this
      );
    }
    clampLength(e, t) {
      let i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(e, Math.min(t, i))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t),
        (this.y += (e.y - this.y) * t),
        (this.z += (e.z - this.z) * t),
        (this.w += (e.w - this.w) * t),
        this
      );
    }
    lerpVectors(e, t, i) {
      return (
        (this.x = e.x + (t.x - e.x) * i),
        (this.y = e.y + (t.y - e.y) * i),
        (this.z = e.z + (t.z - e.z) * i),
        (this.w = e.w + (t.w - e.w) * i),
        this
      );
    }
    equals(e) {
      return (
        e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
      );
    }
    fromArray(e, t = 0) {
      return (
        (this.x = e[t]),
        (this.y = e[t + 1]),
        (this.z = e[t + 2]),
        (this.w = e[t + 3]),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this.x),
        (e[t + 1] = this.y),
        (e[t + 2] = this.z),
        (e[t + 3] = this.w),
        e
      );
    }
    fromBufferAttribute(e, t) {
      return (
        (this.x = e.getX(t)),
        (this.y = e.getY(t)),
        (this.z = e.getZ(t)),
        (this.w = e.getW(t)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  },
  gi = class extends ls {
    constructor(e = 1, t = 1, i = {}) {
      super(),
        (this.isWebGLRenderTarget = !0),
        (this.width = e),
        (this.height = t),
        (this.depth = 1),
        (this.scissor = new Lt(0, 0, e, t)),
        (this.scissorTest = !1),
        (this.viewport = new Lt(0, 0, e, t));
      let r = { width: e, height: t, depth: 1 };
      (this.texture = new Yi(
        r,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.encoding
      )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.flipY = !1),
        (this.texture.generateMipmaps =
          i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
        (this.texture.internalFormat =
          i.internalFormat !== void 0 ? i.internalFormat : null),
        (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Wt),
        (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
        (this.stencilBuffer =
          i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
        (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null),
        (this.samples = i.samples !== void 0 ? i.samples : 0);
    }
    setSize(e, t, i = 1) {
      (this.width !== e || this.height !== t || this.depth !== i) &&
        ((this.width = e),
        (this.height = t),
        (this.depth = i),
        (this.texture.image.width = e),
        (this.texture.image.height = t),
        (this.texture.image.depth = i),
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.width = e.width),
        (this.height = e.height),
        (this.depth = e.depth),
        this.viewport.copy(e.viewport),
        (this.texture = e.texture.clone()),
        (this.texture.isRenderTargetTexture = !0);
      let t = Object.assign({}, e.texture.image);
      return (
        (this.texture.source = new JE(t)),
        (this.depthBuffer = e.depthBuffer),
        (this.stencilBuffer = e.stencilBuffer),
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        (this.samples = e.samples),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  },
  $E = class extends Yi {
    constructor(e = null, t = 1, i = 1, r = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: e, width: t, height: i, depth: r }),
        (this.magFilter = mi),
        (this.minFilter = mi),
        (this.wrapR = Ui),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  },
  iR = class extends Yi {
    constructor(e = null, t = 1, i = 1, r = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: e, width: t, height: i, depth: r }),
        (this.magFilter = mi),
        (this.minFilter = mi),
        (this.wrapR = Ui),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  },
  rR = class extends gi {
    constructor(e = 1, t = 1, i = 1, r = {}) {
      super(e, t, r), (this.isWebGLMultipleRenderTargets = !0);
      let s = this.texture;
      this.texture = [];
      for (let a = 0; a < i; a++)
        (this.texture[a] = s.clone()),
          (this.texture[a].isRenderTargetTexture = !0);
    }
    setSize(e, t, i = 1) {
      if (this.width !== e || this.height !== t || this.depth !== i) {
        (this.width = e), (this.height = t), (this.depth = i);
        for (let r = 0, s = this.texture.length; r < s; r++)
          (this.texture[r].image.width = e),
            (this.texture[r].image.height = t),
            (this.texture[r].image.depth = i);
        this.dispose();
      }
      return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
    }
    copy(e) {
      this.dispose(),
        (this.width = e.width),
        (this.height = e.height),
        (this.depth = e.depth),
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        (this.depthBuffer = e.depthBuffer),
        (this.stencilBuffer = e.stencilBuffer),
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        (this.texture.length = 0);
      for (let t = 0, i = e.texture.length; t < i; t++)
        (this.texture[t] = e.texture[t].clone()),
          (this.texture[t].isRenderTargetTexture = !0);
      return this;
    }
  },
  Rt = class {
    constructor(e = 0, t = 0, i = 0, r = 1) {
      (this.isQuaternion = !0),
        (this._x = e),
        (this._y = t),
        (this._z = i),
        (this._w = r);
    }
    static slerpFlat(e, t, i, r, s, a, n) {
      let o = i[r + 0],
        l = i[r + 1],
        h = i[r + 2],
        u = i[r + 3],
        c = s[a + 0],
        d = s[a + 1],
        p = s[a + 2],
        f = s[a + 3];
      if (n === 0) {
        (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = u);
        return;
      }
      if (n === 1) {
        (e[t + 0] = c), (e[t + 1] = d), (e[t + 2] = p), (e[t + 3] = f);
        return;
      }
      if (u !== f || o !== c || l !== d || h !== p) {
        let m = 1 - n,
          g = o * c + l * d + h * p + u * f,
          y = g >= 0 ? 1 : -1,
          x = 1 - g * g;
        if (x > Number.EPSILON) {
          let _ = Math.sqrt(x),
            S = Math.atan2(_, g * y);
          (m = Math.sin(m * S) / _), (n = Math.sin(n * S) / _);
        }
        let b = n * y;
        if (
          ((o = o * m + c * b),
          (l = l * m + d * b),
          (h = h * m + p * b),
          (u = u * m + f * b),
          m === 1 - n)
        ) {
          let _ = 1 / Math.sqrt(o * o + l * l + h * h + u * u);
          (o *= _), (l *= _), (h *= _), (u *= _);
        }
      }
      (e[t] = o), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = u);
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, a) {
      let n = i[r],
        o = i[r + 1],
        l = i[r + 2],
        h = i[r + 3],
        u = s[a],
        c = s[a + 1],
        d = s[a + 2],
        p = s[a + 3];
      return (
        (e[t] = n * p + h * u + o * d - l * c),
        (e[t + 1] = o * p + h * c + l * u - n * d),
        (e[t + 2] = l * p + h * d + n * c - o * u),
        (e[t + 3] = h * p - n * u - o * c - l * d),
        e
      );
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this._x = e), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this._y = e), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      (this._z = e), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      (this._w = e), this._onChangeCallback();
    }
    set(e, t, i, r) {
      return (
        (this._x = e),
        (this._y = t),
        (this._z = i),
        (this._w = r),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return (
        (this._x = e.x),
        (this._y = e.y),
        (this._z = e.z),
        (this._w = e.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(e, t) {
      let i = e._x,
        r = e._y,
        s = e._z,
        a = e._order,
        n = Math.cos,
        o = Math.sin,
        l = n(i / 2),
        h = n(r / 2),
        u = n(s / 2),
        c = o(i / 2),
        d = o(r / 2),
        p = o(s / 2);
      switch (a) {
        case "XYZ":
          (this._x = c * h * u + l * d * p),
            (this._y = l * d * u - c * h * p),
            (this._z = l * h * p + c * d * u),
            (this._w = l * h * u - c * d * p);
          break;
        case "YXZ":
          (this._x = c * h * u + l * d * p),
            (this._y = l * d * u - c * h * p),
            (this._z = l * h * p - c * d * u),
            (this._w = l * h * u + c * d * p);
          break;
        case "ZXY":
          (this._x = c * h * u - l * d * p),
            (this._y = l * d * u + c * h * p),
            (this._z = l * h * p + c * d * u),
            (this._w = l * h * u - c * d * p);
          break;
        case "ZYX":
          (this._x = c * h * u - l * d * p),
            (this._y = l * d * u + c * h * p),
            (this._z = l * h * p - c * d * u),
            (this._w = l * h * u + c * d * p);
          break;
        case "YZX":
          (this._x = c * h * u + l * d * p),
            (this._y = l * d * u + c * h * p),
            (this._z = l * h * p - c * d * u),
            (this._w = l * h * u - c * d * p);
          break;
        case "XZY":
          (this._x = c * h * u - l * d * p),
            (this._y = l * d * u - c * h * p),
            (this._z = l * h * p + c * d * u),
            (this._w = l * h * u + c * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              a
          );
      }
      return t !== !1 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      let i = t / 2,
        r = Math.sin(i);
      return (
        (this._x = e.x * r),
        (this._y = e.y * r),
        (this._z = e.z * r),
        (this._w = Math.cos(i)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(e) {
      let t = e.elements,
        i = t[0],
        r = t[4],
        s = t[8],
        a = t[1],
        n = t[5],
        o = t[9],
        l = t[2],
        h = t[6],
        u = t[10],
        c = i + n + u;
      if (c > 0) {
        let d = 0.5 / Math.sqrt(c + 1);
        (this._w = 0.25 / d),
          (this._x = (h - o) * d),
          (this._y = (s - l) * d),
          (this._z = (a - r) * d);
      } else if (i > n && i > u) {
        let d = 2 * Math.sqrt(1 + i - n - u);
        (this._w = (h - o) / d),
          (this._x = 0.25 * d),
          (this._y = (r + a) / d),
          (this._z = (s + l) / d);
      } else if (n > u) {
        let d = 2 * Math.sqrt(1 + n - i - u);
        (this._w = (s - l) / d),
          (this._x = (r + a) / d),
          (this._y = 0.25 * d),
          (this._z = (o + h) / d);
      } else {
        let d = 2 * Math.sqrt(1 + u - i - n);
        (this._w = (a - r) / d),
          (this._x = (s + l) / d),
          (this._y = (o + h) / d),
          (this._z = 0.25 * d);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let i = e.dot(t) + 1;
      return (
        i < Number.EPSILON
          ? ((i = 0),
            Math.abs(e.x) > Math.abs(e.z)
              ? ((this._x = -e.y),
                (this._y = e.x),
                (this._z = 0),
                (this._w = i))
              : ((this._x = 0),
                (this._y = -e.z),
                (this._z = e.y),
                (this._w = i)))
          : ((this._x = e.y * t.z - e.z * t.y),
            (this._y = e.z * t.x - e.x * t.z),
            (this._z = e.x * t.y - e.y * t.x),
            (this._w = i)),
        this.normalize()
      );
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(vr(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      let i = this.angleTo(e);
      if (i === 0) return this;
      let r = Math.min(1, t / i);
      return this.slerp(e, r), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let e = this.length();
      return (
        e === 0
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((e = 1 / e),
            (this._x = this._x * e),
            (this._y = this._y * e),
            (this._z = this._z * e),
            (this._w = this._w * e)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(e) {
      return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      let i = e._x,
        r = e._y,
        s = e._z,
        a = e._w,
        n = t._x,
        o = t._y,
        l = t._z,
        h = t._w;
      return (
        (this._x = i * h + a * n + r * l - s * o),
        (this._y = r * h + a * o + s * n - i * l),
        (this._z = s * h + a * l + i * o - r * n),
        (this._w = a * h - i * n - r * o - s * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      let i = this._x,
        r = this._y,
        s = this._z,
        a = this._w,
        n = a * e._w + i * e._x + r * e._y + s * e._z;
      if (
        (n < 0
          ? ((this._w = -e._w),
            (this._x = -e._x),
            (this._y = -e._y),
            (this._z = -e._z),
            (n = -n))
          : this.copy(e),
        n >= 1)
      )
        return (this._w = a), (this._x = i), (this._y = r), (this._z = s), this;
      let o = 1 - n * n;
      if (o <= Number.EPSILON) {
        let d = 1 - t;
        return (
          (this._w = d * a + t * this._w),
          (this._x = d * i + t * this._x),
          (this._y = d * r + t * this._y),
          (this._z = d * s + t * this._z),
          this.normalize(),
          this._onChangeCallback(),
          this
        );
      }
      let l = Math.sqrt(o),
        h = Math.atan2(l, n),
        u = Math.sin((1 - t) * h) / l,
        c = Math.sin(t * h) / l;
      return (
        (this._w = a * u + this._w * c),
        (this._x = i * u + this._x * c),
        (this._y = r * u + this._y * c),
        (this._z = s * u + this._z * c),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(e, t, i) {
      return this.copy(e).slerp(t, i);
    }
    random() {
      let e = Math.random(),
        t = Math.sqrt(1 - e),
        i = Math.sqrt(e),
        r = 2 * Math.PI * Math.random(),
        s = 2 * Math.PI * Math.random();
      return this.set(
        t * Math.cos(r),
        i * Math.sin(s),
        i * Math.cos(s),
        t * Math.sin(r)
      );
    }
    equals(e) {
      return (
        e._x === this._x &&
        e._y === this._y &&
        e._z === this._z &&
        e._w === this._w
      );
    }
    fromArray(e, t = 0) {
      return (
        (this._x = e[t]),
        (this._y = e[t + 1]),
        (this._z = e[t + 2]),
        (this._w = e[t + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this._x),
        (e[t + 1] = this._y),
        (e[t + 2] = this._z),
        (e[t + 3] = this._w),
        e
      );
    }
    fromBufferAttribute(e, t) {
      return (
        (this._x = e.getX(t)),
        (this._y = e.getY(t)),
        (this._z = e.getZ(t)),
        (this._w = e.getW(t)),
        this
      );
    }
    _onChange(e) {
      return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  },
  I = class {
    constructor(e = 0, t = 0, i = 0) {
      (I.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
    }
    set(e, t, i) {
      return (
        i === void 0 && (i = this.z),
        (this.x = e),
        (this.y = t),
        (this.z = i),
        this
      );
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), (this.z = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setZ(e) {
      return (this.z = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
    }
    add(e) {
      return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), (this.z += e), this;
    }
    addVectors(e, t) {
      return (
        (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
      );
    }
    addScaledVector(e, t) {
      return (
        (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
      );
    }
    sub(e) {
      return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), (this.z -= e), this;
    }
    subVectors(e, t) {
      return (
        (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
      );
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), (this.z *= e), this;
    }
    multiplyVectors(e, t) {
      return (
        (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
      );
    }
    applyEuler(e) {
      return this.applyQuaternion(g_.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(g_.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      let t = this.x,
        i = this.y,
        r = this.z,
        s = e.elements;
      return (
        (this.x = s[0] * t + s[3] * i + s[6] * r),
        (this.y = s[1] * t + s[4] * i + s[7] * r),
        (this.z = s[2] * t + s[5] * i + s[8] * r),
        this
      );
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      let t = this.x,
        i = this.y,
        r = this.z,
        s = e.elements,
        a = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
      return (
        (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * a),
        (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * a),
        (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * a),
        this
      );
    }
    applyQuaternion(e) {
      let t = this.x,
        i = this.y,
        r = this.z,
        s = e.x,
        a = e.y,
        n = e.z,
        o = e.w,
        l = o * t + a * r - n * i,
        h = o * i + n * t - s * r,
        u = o * r + s * i - a * t,
        c = -s * t - a * i - n * r;
      return (
        (this.x = l * o + c * -s + h * -n - u * -a),
        (this.y = h * o + c * -a + u * -s - l * -n),
        (this.z = u * o + c * -n + l * -a - h * -s),
        this
      );
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
        e.projectionMatrix
      );
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
        e.matrixWorld
      );
    }
    transformDirection(e) {
      let t = this.x,
        i = this.y,
        r = this.z,
        s = e.elements;
      return (
        (this.x = s[0] * t + s[4] * i + s[8] * r),
        (this.y = s[1] * t + s[5] * i + s[9] * r),
        (this.z = s[2] * t + s[6] * i + s[10] * r),
        this.normalize()
      );
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)),
        (this.y = Math.min(this.y, e.y)),
        (this.z = Math.min(this.z, e.z)),
        this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)),
        (this.y = Math.max(this.y, e.y)),
        (this.z = Math.max(this.z, e.z)),
        this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        (this.z = Math.max(e.z, Math.min(t.z, this.z))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        (this.z = Math.max(e, Math.min(t, this.z))),
        this
      );
    }
    clampLength(e, t) {
      let i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(
        Math.max(e, Math.min(t, i))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t),
        (this.y += (e.y - this.y) * t),
        (this.z += (e.z - this.z) * t),
        this
      );
    }
    lerpVectors(e, t, i) {
      return (
        (this.x = e.x + (t.x - e.x) * i),
        (this.y = e.y + (t.y - e.y) * i),
        (this.z = e.z + (t.z - e.z) * i),
        this
      );
    }
    cross(e) {
      return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      let i = e.x,
        r = e.y,
        s = e.z,
        a = t.x,
        n = t.y,
        o = t.z;
      return (
        (this.x = r * o - s * n),
        (this.y = s * a - i * o),
        (this.z = i * n - r * a),
        this
      );
    }
    projectOnVector(e) {
      let t = e.lengthSq();
      if (t === 0) return this.set(0, 0, 0);
      let i = e.dot(this) / t;
      return this.copy(e).multiplyScalar(i);
    }
    projectOnPlane(e) {
      return vv.copy(this).projectOnVector(e), this.sub(vv);
    }
    reflect(e) {
      return this.sub(vv.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      let t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      let i = this.dot(e) / t;
      return Math.acos(vr(i, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      let t = this.x - e.x,
        i = this.y - e.y,
        r = this.z - e.z;
      return t * t + i * i + r * r;
    }
    manhattanDistanceTo(e) {
      return (
        Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
      );
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, i) {
      let r = Math.sin(t) * e;
      return (
        (this.x = r * Math.sin(i)),
        (this.y = Math.cos(t) * e),
        (this.z = r * Math.cos(i)),
        this
      );
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, i) {
      return (
        (this.x = e * Math.sin(t)),
        (this.y = i),
        (this.z = e * Math.cos(t)),
        this
      );
    }
    setFromMatrixPosition(e) {
      let t = e.elements;
      return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
    }
    setFromMatrixScale(e) {
      let t = this.setFromMatrixColumn(e, 0).length(),
        i = this.setFromMatrixColumn(e, 1).length(),
        r = this.setFromMatrixColumn(e, 2).length();
      return (this.x = t), (this.y = i), (this.z = r), this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
      return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
    }
    fromBufferAttribute(e, t) {
      return (
        (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      let e = (Math.random() - 0.5) * 2,
        t = Math.random() * Math.PI * 2,
        i = Math.sqrt(1 - e ** 2);
      return (
        (this.x = i * Math.cos(t)),
        (this.y = i * Math.sin(t)),
        (this.z = e),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  },
  vv = new I(),
  g_ = new Rt(),
  ur = class {
    constructor(
      e = new I(1 / 0, 1 / 0, 1 / 0),
      t = new I(-1 / 0, -1 / 0, -1 / 0)
    ) {
      (this.isBox3 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      let t = 1 / 0,
        i = 1 / 0,
        r = 1 / 0,
        s = -1 / 0,
        a = -1 / 0,
        n = -1 / 0;
      for (let o = 0, l = e.length; o < l; o += 3) {
        let h = e[o],
          u = e[o + 1],
          c = e[o + 2];
        h < t && (t = h),
          u < i && (i = u),
          c < r && (r = c),
          h > s && (s = h),
          u > a && (a = u),
          c > n && (n = c);
      }
      return this.min.set(t, i, r), this.max.set(s, a, n), this;
    }
    setFromBufferAttribute(e) {
      let t = 1 / 0,
        i = 1 / 0,
        r = 1 / 0,
        s = -1 / 0,
        a = -1 / 0,
        n = -1 / 0;
      for (let o = 0, l = e.count; o < l; o++) {
        let h = e.getX(o),
          u = e.getY(o),
          c = e.getZ(o);
        h < t && (t = h),
          u < i && (i = u),
          c < r && (r = c),
          h > s && (s = h),
          u > a && (a = u),
          c > n && (n = c);
      }
      return this.min.set(t, i, r), this.max.set(s, a, n), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      let i = El.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
    }
    setFromObject(e, t = !1) {
      return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(e) {
      return this.isEmpty()
        ? e.set(0, 0, 0)
        : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = !1) {
      e.updateWorldMatrix(!1, !1);
      let i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes != null && i.attributes.position !== void 0) {
          let s = i.attributes.position;
          for (let a = 0, n = s.count; a < n; a++)
            El.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld),
              this.expandByPoint(El);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            yv.copy(i.boundingBox),
            yv.applyMatrix4(e.matrixWorld),
            this.union(yv);
      let r = e.children;
      for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
      return this;
    }
    containsPoint(e) {
      return !(
        e.x < this.min.x ||
        e.x > this.max.x ||
        e.y < this.min.y ||
        e.y > this.max.y ||
        e.z < this.min.z ||
        e.z > this.max.z
      );
    }
    containsBox(e) {
      return (
        this.min.x <= e.min.x &&
        e.max.x <= this.max.x &&
        this.min.y <= e.min.y &&
        e.max.y <= this.max.y &&
        this.min.z <= e.min.z &&
        e.max.z <= this.max.z
      );
    }
    getParameter(e, t) {
      return t.set(
        (e.x - this.min.x) / (this.max.x - this.min.x),
        (e.y - this.min.y) / (this.max.y - this.min.y),
        (e.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(e) {
      return !(
        e.max.x < this.min.x ||
        e.min.x > this.max.x ||
        e.max.y < this.min.y ||
        e.min.y > this.max.y ||
        e.max.z < this.min.z ||
        e.min.z > this.max.z
      );
    }
    intersectsSphere(e) {
      return (
        this.clampPoint(e.center, El),
        El.distanceToSquared(e.center) <= e.radius * e.radius
      );
    }
    intersectsPlane(e) {
      let t, i;
      return (
        e.normal.x > 0
          ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
          : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
        e.normal.y > 0
          ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
          : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
        e.normal.z > 0
          ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
          : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
        t <= -e.constant && i >= -e.constant
      );
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return !1;
      this.getCenter(Ru),
        zp.subVectors(this.max, Ru),
        Lh.subVectors(e.a, Ru),
        Bh.subVectors(e.b, Ru),
        zh.subVectors(e.c, Ru),
        Ro.subVectors(Bh, Lh),
        Lo.subVectors(zh, Bh),
        Cl.subVectors(Lh, zh);
      let t = [
        0,
        -Ro.z,
        Ro.y,
        0,
        -Lo.z,
        Lo.y,
        0,
        -Cl.z,
        Cl.y,
        Ro.z,
        0,
        -Ro.x,
        Lo.z,
        0,
        -Lo.x,
        Cl.z,
        0,
        -Cl.x,
        -Ro.y,
        Ro.x,
        0,
        -Lo.y,
        Lo.x,
        0,
        -Cl.y,
        Cl.x,
        0,
      ];
      return !xv(t, Lh, Bh, zh, zp) ||
        ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !xv(t, Lh, Bh, zh, zp))
        ? !1
        : (Fp.crossVectors(Ro, Lo),
          (t = [Fp.x, Fp.y, Fp.z]),
          xv(t, Lh, Bh, zh, zp));
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return El.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    getBoundingSphere(e) {
      return (
        this.getCenter(e.center),
        (e.radius = this.getSize(El).length() * 0.5),
        e
      );
    }
    intersect(e) {
      return (
        this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return this.isEmpty()
        ? this
        : (Wn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
          Wn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
          Wn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
          Wn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
          Wn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
          Wn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
          Wn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
          Wn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
          this.setFromPoints(Wn),
          this);
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  },
  Wn = [new I(), new I(), new I(), new I(), new I(), new I(), new I(), new I()],
  El = new I(),
  yv = new ur(),
  Lh = new I(),
  Bh = new I(),
  zh = new I(),
  Ro = new I(),
  Lo = new I(),
  Cl = new I(),
  Ru = new I(),
  zp = new I(),
  Fp = new I(),
  Tl = new I();
function xv(e, t, i, r, s) {
  for (let a = 0, n = e.length - 3; a <= n; a += 3) {
    Tl.fromArray(e, a);
    let o = s.x * Math.abs(Tl.x) + s.y * Math.abs(Tl.y) + s.z * Math.abs(Tl.z),
      l = t.dot(Tl),
      h = i.dot(Tl),
      u = r.dot(Tl);
    if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > o) return !1;
  }
  return !0;
}
var sR = new ur(),
  Lu = new I(),
  bv = new I(),
  Ws = class {
    constructor(e = new I(), t = -1) {
      (this.center = e), (this.radius = t);
    }
    set(e, t) {
      return this.center.copy(e), (this.radius = t), this;
    }
    setFromPoints(e, t) {
      let i = this.center;
      t !== void 0 ? i.copy(t) : sR.setFromPoints(e).getCenter(i);
      let r = 0;
      for (let s = 0, a = e.length; s < a; s++)
        r = Math.max(r, i.distanceToSquared(e[s]));
      return (this.radius = Math.sqrt(r)), this;
    }
    copy(e) {
      return this.center.copy(e.center), (this.radius = e.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      let t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      let i = this.center.distanceToSquared(e);
      return (
        t.copy(e),
        i > this.radius * this.radius &&
          (t.sub(this.center).normalize(),
          t.multiplyScalar(this.radius).add(this.center)),
        t
      );
    }
    getBoundingBox(e) {
      return this.isEmpty()
        ? (e.makeEmpty(), e)
        : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return (
        this.center.applyMatrix4(e),
        (this.radius = this.radius * e.getMaxScaleOnAxis()),
        this
      );
    }
    translate(e) {
      return this.center.add(e), this;
    }
    expandByPoint(e) {
      if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
      Lu.subVectors(e, this.center);
      let t = Lu.lengthSq();
      if (t > this.radius * this.radius) {
        let i = Math.sqrt(t),
          r = (i - this.radius) * 0.5;
        this.center.addScaledVector(Lu, r / i), (this.radius += r);
      }
      return this;
    }
    union(e) {
      return e.isEmpty()
        ? this
        : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (bv.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(Lu.copy(e.center).add(bv)),
              this.expandByPoint(Lu.copy(e.center).sub(bv))),
          this);
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  qn = new I(),
  wv = new I(),
  kp = new I(),
  Bo = new I(),
  _v = new I(),
  Np = new I(),
  Sv = new I(),
  su = class {
    constructor(e = new I(), t = new I(0, 0, -1)) {
      (this.origin = e), (this.direction = t);
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return t.copy(this.direction).multiplyScalar(e).add(this.origin);
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, qn)), this;
    }
    closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      let i = t.dot(this.direction);
      return i < 0
        ? t.copy(this.origin)
        : t.copy(this.direction).multiplyScalar(i).add(this.origin);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      let t = qn.subVectors(e, this.origin).dot(this.direction);
      return t < 0
        ? this.origin.distanceToSquared(e)
        : (qn.copy(this.direction).multiplyScalar(t).add(this.origin),
          qn.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, i, r) {
      wv.copy(e).add(t).multiplyScalar(0.5),
        kp.copy(t).sub(e).normalize(),
        Bo.copy(this.origin).sub(wv);
      let s = e.distanceTo(t) * 0.5,
        a = -this.direction.dot(kp),
        n = Bo.dot(this.direction),
        o = -Bo.dot(kp),
        l = Bo.lengthSq(),
        h = Math.abs(1 - a * a),
        u,
        c,
        d,
        p;
      if (h > 0)
        if (((u = a * o - n), (c = a * n - o), (p = s * h), u >= 0))
          if (c >= -p)
            if (c <= p) {
              let f = 1 / h;
              (u *= f),
                (c *= f),
                (d = u * (u + a * c + 2 * n) + c * (a * u + c + 2 * o) + l);
            } else
              (c = s),
                (u = Math.max(0, -(a * c + n))),
                (d = -u * u + c * (c + 2 * o) + l);
          else
            (c = -s),
              (u = Math.max(0, -(a * c + n))),
              (d = -u * u + c * (c + 2 * o) + l);
        else
          c <= -p
            ? ((u = Math.max(0, -(-a * s + n))),
              (c = u > 0 ? -s : Math.min(Math.max(-s, -o), s)),
              (d = -u * u + c * (c + 2 * o) + l))
            : c <= p
            ? ((u = 0),
              (c = Math.min(Math.max(-s, -o), s)),
              (d = c * (c + 2 * o) + l))
            : ((u = Math.max(0, -(a * s + n))),
              (c = u > 0 ? s : Math.min(Math.max(-s, -o), s)),
              (d = -u * u + c * (c + 2 * o) + l));
      else
        (c = a > 0 ? -s : s),
          (u = Math.max(0, -(a * c + n))),
          (d = -u * u + c * (c + 2 * o) + l);
      return (
        i && i.copy(this.direction).multiplyScalar(u).add(this.origin),
        r && r.copy(kp).multiplyScalar(c).add(wv),
        d
      );
    }
    intersectSphere(e, t) {
      qn.subVectors(e.center, this.origin);
      let i = qn.dot(this.direction),
        r = qn.dot(qn) - i * i,
        s = e.radius * e.radius;
      if (r > s) return null;
      let a = Math.sqrt(s - r),
        n = i - a,
        o = i + a;
      return n < 0 && o < 0 ? null : n < 0 ? this.at(o, t) : this.at(n, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      let t = e.normal.dot(this.direction);
      if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
      let i = -(this.origin.dot(e.normal) + e.constant) / t;
      return i >= 0 ? i : null;
    }
    intersectPlane(e, t) {
      let i = this.distanceToPlane(e);
      return i === null ? null : this.at(i, t);
    }
    intersectsPlane(e) {
      let t = e.distanceToPoint(this.origin);
      return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let i,
        r,
        s,
        a,
        n,
        o,
        l = 1 / this.direction.x,
        h = 1 / this.direction.y,
        u = 1 / this.direction.z,
        c = this.origin;
      return (
        l >= 0
          ? ((i = (e.min.x - c.x) * l), (r = (e.max.x - c.x) * l))
          : ((i = (e.max.x - c.x) * l), (r = (e.min.x - c.x) * l)),
        h >= 0
          ? ((s = (e.min.y - c.y) * h), (a = (e.max.y - c.y) * h))
          : ((s = (e.max.y - c.y) * h), (a = (e.min.y - c.y) * h)),
        i > a ||
        s > r ||
        ((s > i || isNaN(i)) && (i = s),
        (a < r || isNaN(r)) && (r = a),
        u >= 0
          ? ((n = (e.min.z - c.z) * u), (o = (e.max.z - c.z) * u))
          : ((n = (e.max.z - c.z) * u), (o = (e.min.z - c.z) * u)),
        i > o || n > r) ||
        ((n > i || i !== i) && (i = n), (o < r || r !== r) && (r = o), r < 0)
          ? null
          : this.at(i >= 0 ? i : r, t)
      );
    }
    intersectsBox(e) {
      return this.intersectBox(e, qn) !== null;
    }
    intersectTriangle(e, t, i, r, s) {
      _v.subVectors(t, e), Np.subVectors(i, e), Sv.crossVectors(_v, Np);
      let a = this.direction.dot(Sv),
        n;
      if (a > 0) {
        if (r) return null;
        n = 1;
      } else if (a < 0) (n = -1), (a = -a);
      else return null;
      Bo.subVectors(this.origin, e);
      let o = n * this.direction.dot(Np.crossVectors(Bo, Np));
      if (o < 0) return null;
      let l = n * this.direction.dot(_v.cross(Bo));
      if (l < 0 || o + l > a) return null;
      let h = -n * Bo.dot(Sv);
      return h < 0 ? null : this.at(h / a, s);
    }
    applyMatrix4(e) {
      return (
        this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
      );
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  je = class {
    constructor() {
      (je.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    set(e, t, i, r, s, a, n, o, l, h, u, c, d, p, f, m) {
      let g = this.elements;
      return (
        (g[0] = e),
        (g[4] = t),
        (g[8] = i),
        (g[12] = r),
        (g[1] = s),
        (g[5] = a),
        (g[9] = n),
        (g[13] = o),
        (g[2] = l),
        (g[6] = h),
        (g[10] = u),
        (g[14] = c),
        (g[3] = d),
        (g[7] = p),
        (g[11] = f),
        (g[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new je().fromArray(this.elements);
    }
    copy(e) {
      let t = this.elements,
        i = e.elements;
      return (
        (t[0] = i[0]),
        (t[1] = i[1]),
        (t[2] = i[2]),
        (t[3] = i[3]),
        (t[4] = i[4]),
        (t[5] = i[5]),
        (t[6] = i[6]),
        (t[7] = i[7]),
        (t[8] = i[8]),
        (t[9] = i[9]),
        (t[10] = i[10]),
        (t[11] = i[11]),
        (t[12] = i[12]),
        (t[13] = i[13]),
        (t[14] = i[14]),
        (t[15] = i[15]),
        this
      );
    }
    copyPosition(e) {
      let t = this.elements,
        i = e.elements;
      return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
    }
    setFromMatrix3(e) {
      let t = e.elements;
      return (
        this.set(
          t[0],
          t[3],
          t[6],
          0,
          t[1],
          t[4],
          t[7],
          0,
          t[2],
          t[5],
          t[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractBasis(e, t, i) {
      return (
        e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(e, t, i) {
      return (
        this.set(
          e.x,
          t.x,
          i.x,
          0,
          e.y,
          t.y,
          i.y,
          0,
          e.z,
          t.z,
          i.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(e) {
      let t = this.elements,
        i = e.elements,
        r = 1 / Fh.setFromMatrixColumn(e, 0).length(),
        s = 1 / Fh.setFromMatrixColumn(e, 1).length(),
        a = 1 / Fh.setFromMatrixColumn(e, 2).length();
      return (
        (t[0] = i[0] * r),
        (t[1] = i[1] * r),
        (t[2] = i[2] * r),
        (t[3] = 0),
        (t[4] = i[4] * s),
        (t[5] = i[5] * s),
        (t[6] = i[6] * s),
        (t[7] = 0),
        (t[8] = i[8] * a),
        (t[9] = i[9] * a),
        (t[10] = i[10] * a),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        this
      );
    }
    makeRotationFromEuler(e) {
      let t = this.elements,
        i = e.x,
        r = e.y,
        s = e.z,
        a = Math.cos(i),
        n = Math.sin(i),
        o = Math.cos(r),
        l = Math.sin(r),
        h = Math.cos(s),
        u = Math.sin(s);
      if (e.order === "XYZ") {
        let c = a * h,
          d = a * u,
          p = n * h,
          f = n * u;
        (t[0] = o * h),
          (t[4] = -o * u),
          (t[8] = l),
          (t[1] = d + p * l),
          (t[5] = c - f * l),
          (t[9] = -n * o),
          (t[2] = f - c * l),
          (t[6] = p + d * l),
          (t[10] = a * o);
      } else if (e.order === "YXZ") {
        let c = o * h,
          d = o * u,
          p = l * h,
          f = l * u;
        (t[0] = c + f * n),
          (t[4] = p * n - d),
          (t[8] = a * l),
          (t[1] = a * u),
          (t[5] = a * h),
          (t[9] = -n),
          (t[2] = d * n - p),
          (t[6] = f + c * n),
          (t[10] = a * o);
      } else if (e.order === "ZXY") {
        let c = o * h,
          d = o * u,
          p = l * h,
          f = l * u;
        (t[0] = c - f * n),
          (t[4] = -a * u),
          (t[8] = p + d * n),
          (t[1] = d + p * n),
          (t[5] = a * h),
          (t[9] = f - c * n),
          (t[2] = -a * l),
          (t[6] = n),
          (t[10] = a * o);
      } else if (e.order === "ZYX") {
        let c = a * h,
          d = a * u,
          p = n * h,
          f = n * u;
        (t[0] = o * h),
          (t[4] = p * l - d),
          (t[8] = c * l + f),
          (t[1] = o * u),
          (t[5] = f * l + c),
          (t[9] = d * l - p),
          (t[2] = -l),
          (t[6] = n * o),
          (t[10] = a * o);
      } else if (e.order === "YZX") {
        let c = a * o,
          d = a * l,
          p = n * o,
          f = n * l;
        (t[0] = o * h),
          (t[4] = f - c * u),
          (t[8] = p * u + d),
          (t[1] = u),
          (t[5] = a * h),
          (t[9] = -n * h),
          (t[2] = -l * h),
          (t[6] = d * u + p),
          (t[10] = c - f * u);
      } else if (e.order === "XZY") {
        let c = a * o,
          d = a * l,
          p = n * o,
          f = n * l;
        (t[0] = o * h),
          (t[4] = -u),
          (t[8] = l * h),
          (t[1] = c * u + f),
          (t[5] = a * h),
          (t[9] = d * u - p),
          (t[2] = p * u - d),
          (t[6] = n * h),
          (t[10] = f * u + c);
      }
      return (
        (t[3] = 0),
        (t[7] = 0),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(e) {
      return this.compose(aR, e, nR);
    }
    lookAt(e, t, i) {
      let r = this.elements;
      return (
        Xs.subVectors(e, t),
        Xs.lengthSq() === 0 && (Xs.z = 1),
        Xs.normalize(),
        zo.crossVectors(i, Xs),
        zo.lengthSq() === 0 &&
          (Math.abs(i.z) === 1 ? (Xs.x += 1e-4) : (Xs.z += 1e-4),
          Xs.normalize(),
          zo.crossVectors(i, Xs)),
        zo.normalize(),
        Up.crossVectors(Xs, zo),
        (r[0] = zo.x),
        (r[4] = Up.x),
        (r[8] = Xs.x),
        (r[1] = zo.y),
        (r[5] = Up.y),
        (r[9] = Xs.y),
        (r[2] = zo.z),
        (r[6] = Up.z),
        (r[10] = Xs.z),
        this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      let i = e.elements,
        r = t.elements,
        s = this.elements,
        a = i[0],
        n = i[4],
        o = i[8],
        l = i[12],
        h = i[1],
        u = i[5],
        c = i[9],
        d = i[13],
        p = i[2],
        f = i[6],
        m = i[10],
        g = i[14],
        y = i[3],
        x = i[7],
        b = i[11],
        _ = i[15],
        S = r[0],
        M = r[4],
        C = r[8],
        A = r[12],
        T = r[1],
        P = r[5],
        R = r[9],
        z = r[13],
        N = r[2],
        L = r[6],
        G = r[10],
        Y = r[14],
        Z = r[3],
        q = r[7],
        oe = r[11],
        ce = r[15];
      return (
        (s[0] = a * S + n * T + o * N + l * Z),
        (s[4] = a * M + n * P + o * L + l * q),
        (s[8] = a * C + n * R + o * G + l * oe),
        (s[12] = a * A + n * z + o * Y + l * ce),
        (s[1] = h * S + u * T + c * N + d * Z),
        (s[5] = h * M + u * P + c * L + d * q),
        (s[9] = h * C + u * R + c * G + d * oe),
        (s[13] = h * A + u * z + c * Y + d * ce),
        (s[2] = p * S + f * T + m * N + g * Z),
        (s[6] = p * M + f * P + m * L + g * q),
        (s[10] = p * C + f * R + m * G + g * oe),
        (s[14] = p * A + f * z + m * Y + g * ce),
        (s[3] = y * S + x * T + b * N + _ * Z),
        (s[7] = y * M + x * P + b * L + _ * q),
        (s[11] = y * C + x * R + b * G + _ * oe),
        (s[15] = y * A + x * z + b * Y + _ * ce),
        this
      );
    }
    multiplyScalar(e) {
      let t = this.elements;
      return (
        (t[0] *= e),
        (t[4] *= e),
        (t[8] *= e),
        (t[12] *= e),
        (t[1] *= e),
        (t[5] *= e),
        (t[9] *= e),
        (t[13] *= e),
        (t[2] *= e),
        (t[6] *= e),
        (t[10] *= e),
        (t[14] *= e),
        (t[3] *= e),
        (t[7] *= e),
        (t[11] *= e),
        (t[15] *= e),
        this
      );
    }
    determinant() {
      let e = this.elements,
        t = e[0],
        i = e[4],
        r = e[8],
        s = e[12],
        a = e[1],
        n = e[5],
        o = e[9],
        l = e[13],
        h = e[2],
        u = e[6],
        c = e[10],
        d = e[14],
        p = e[3],
        f = e[7],
        m = e[11],
        g = e[15];
      return (
        p *
          (+s * o * u -
            r * l * u -
            s * n * c +
            i * l * c +
            r * n * d -
            i * o * d) +
        f *
          (+t * o * d -
            t * l * c +
            s * a * c -
            r * a * d +
            r * l * h -
            s * o * h) +
        m *
          (+t * l * u -
            t * n * d -
            s * a * u +
            i * a * d +
            s * n * h -
            i * l * h) +
        g *
          (-r * n * h -
            t * o * u +
            t * n * c +
            r * a * u -
            i * a * c +
            i * o * h)
      );
    }
    transpose() {
      let e = this.elements,
        t;
      return (
        (t = e[1]),
        (e[1] = e[4]),
        (e[4] = t),
        (t = e[2]),
        (e[2] = e[8]),
        (e[8] = t),
        (t = e[6]),
        (e[6] = e[9]),
        (e[9] = t),
        (t = e[3]),
        (e[3] = e[12]),
        (e[12] = t),
        (t = e[7]),
        (e[7] = e[13]),
        (e[13] = t),
        (t = e[11]),
        (e[11] = e[14]),
        (e[14] = t),
        this
      );
    }
    setPosition(e, t, i) {
      let r = this.elements;
      return (
        e.isVector3
          ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
          : ((r[12] = e), (r[13] = t), (r[14] = i)),
        this
      );
    }
    invert() {
      let e = this.elements,
        t = e[0],
        i = e[1],
        r = e[2],
        s = e[3],
        a = e[4],
        n = e[5],
        o = e[6],
        l = e[7],
        h = e[8],
        u = e[9],
        c = e[10],
        d = e[11],
        p = e[12],
        f = e[13],
        m = e[14],
        g = e[15],
        y =
          u * m * l - f * c * l + f * o * d - n * m * d - u * o * g + n * c * g,
        x =
          p * c * l - h * m * l - p * o * d + a * m * d + h * o * g - a * c * g,
        b =
          h * f * l - p * u * l + p * n * d - a * f * d - h * n * g + a * u * g,
        _ =
          p * u * o - h * f * o - p * n * c + a * f * c + h * n * m - a * u * m,
        S = t * y + i * x + r * b + s * _;
      if (S === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      let M = 1 / S;
      return (
        (e[0] = y * M),
        (e[1] =
          (f * c * s -
            u * m * s -
            f * r * d +
            i * m * d +
            u * r * g -
            i * c * g) *
          M),
        (e[2] =
          (n * m * s -
            f * o * s +
            f * r * l -
            i * m * l -
            n * r * g +
            i * o * g) *
          M),
        (e[3] =
          (u * o * s -
            n * c * s -
            u * r * l +
            i * c * l +
            n * r * d -
            i * o * d) *
          M),
        (e[4] = x * M),
        (e[5] =
          (h * m * s -
            p * c * s +
            p * r * d -
            t * m * d -
            h * r * g +
            t * c * g) *
          M),
        (e[6] =
          (p * o * s -
            a * m * s -
            p * r * l +
            t * m * l +
            a * r * g -
            t * o * g) *
          M),
        (e[7] =
          (a * c * s -
            h * o * s +
            h * r * l -
            t * c * l -
            a * r * d +
            t * o * d) *
          M),
        (e[8] = b * M),
        (e[9] =
          (p * u * s -
            h * f * s -
            p * i * d +
            t * f * d +
            h * i * g -
            t * u * g) *
          M),
        (e[10] =
          (a * f * s -
            p * n * s +
            p * i * l -
            t * f * l -
            a * i * g +
            t * n * g) *
          M),
        (e[11] =
          (h * n * s -
            a * u * s -
            h * i * l +
            t * u * l +
            a * i * d -
            t * n * d) *
          M),
        (e[12] = _ * M),
        (e[13] =
          (h * f * r -
            p * u * r +
            p * i * c -
            t * f * c -
            h * i * m +
            t * u * m) *
          M),
        (e[14] =
          (p * n * r -
            a * f * r -
            p * i * o +
            t * f * o +
            a * i * m -
            t * n * m) *
          M),
        (e[15] =
          (a * u * r -
            h * n * r +
            h * i * o -
            t * u * o -
            a * i * c +
            t * n * c) *
          M),
        this
      );
    }
    scale(e) {
      let t = this.elements,
        i = e.x,
        r = e.y,
        s = e.z;
      return (
        (t[0] *= i),
        (t[4] *= r),
        (t[8] *= s),
        (t[1] *= i),
        (t[5] *= r),
        (t[9] *= s),
        (t[2] *= i),
        (t[6] *= r),
        (t[10] *= s),
        (t[3] *= i),
        (t[7] *= r),
        (t[11] *= s),
        this
      );
    }
    getMaxScaleOnAxis() {
      let e = this.elements,
        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, i, r));
    }
    makeTranslation(e, t, i) {
      return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
      let t = Math.cos(e),
        i = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      let t = Math.cos(e),
        i = Math.sin(e);
      return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      let t = Math.cos(e),
        i = Math.sin(e);
      return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      let i = Math.cos(t),
        r = Math.sin(t),
        s = 1 - i,
        a = e.x,
        n = e.y,
        o = e.z,
        l = s * a,
        h = s * n;
      return (
        this.set(
          l * a + i,
          l * n - r * o,
          l * o + r * n,
          0,
          l * n + r * o,
          h * n + i,
          h * o - r * a,
          0,
          l * o - r * n,
          h * o + r * a,
          s * o * o + i,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(e, t, i) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, i, r, s, a) {
      return this.set(1, i, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, i) {
      let r = this.elements,
        s = t._x,
        a = t._y,
        n = t._z,
        o = t._w,
        l = s + s,
        h = a + a,
        u = n + n,
        c = s * l,
        d = s * h,
        p = s * u,
        f = a * h,
        m = a * u,
        g = n * u,
        y = o * l,
        x = o * h,
        b = o * u,
        _ = i.x,
        S = i.y,
        M = i.z;
      return (
        (r[0] = (1 - (f + g)) * _),
        (r[1] = (d + b) * _),
        (r[2] = (p - x) * _),
        (r[3] = 0),
        (r[4] = (d - b) * S),
        (r[5] = (1 - (c + g)) * S),
        (r[6] = (m + y) * S),
        (r[7] = 0),
        (r[8] = (p + x) * M),
        (r[9] = (m - y) * M),
        (r[10] = (1 - (c + f)) * M),
        (r[11] = 0),
        (r[12] = e.x),
        (r[13] = e.y),
        (r[14] = e.z),
        (r[15] = 1),
        this
      );
    }
    decompose(e, t, i) {
      let r = this.elements,
        s = Fh.set(r[0], r[1], r[2]).length(),
        a = Fh.set(r[4], r[5], r[6]).length(),
        n = Fh.set(r[8], r[9], r[10]).length();
      this.determinant() < 0 && (s = -s),
        (e.x = r[12]),
        (e.y = r[13]),
        (e.z = r[14]),
        La.copy(this);
      let o = 1 / s,
        l = 1 / a,
        h = 1 / n;
      return (
        (La.elements[0] *= o),
        (La.elements[1] *= o),
        (La.elements[2] *= o),
        (La.elements[4] *= l),
        (La.elements[5] *= l),
        (La.elements[6] *= l),
        (La.elements[8] *= h),
        (La.elements[9] *= h),
        (La.elements[10] *= h),
        t.setFromRotationMatrix(La),
        (i.x = s),
        (i.y = a),
        (i.z = n),
        this
      );
    }
    makePerspective(e, t, i, r, s, a) {
      let n = this.elements,
        o = (2 * s) / (t - e),
        l = (2 * s) / (i - r),
        h = (t + e) / (t - e),
        u = (i + r) / (i - r),
        c = -(a + s) / (a - s),
        d = (-2 * a * s) / (a - s);
      return (
        (n[0] = o),
        (n[4] = 0),
        (n[8] = h),
        (n[12] = 0),
        (n[1] = 0),
        (n[5] = l),
        (n[9] = u),
        (n[13] = 0),
        (n[2] = 0),
        (n[6] = 0),
        (n[10] = c),
        (n[14] = d),
        (n[3] = 0),
        (n[7] = 0),
        (n[11] = -1),
        (n[15] = 0),
        this
      );
    }
    makeOrthographic(e, t, i, r, s, a) {
      let n = this.elements,
        o = 1 / (t - e),
        l = 1 / (i - r),
        h = 1 / (a - s),
        u = (t + e) * o,
        c = (i + r) * l,
        d = (a + s) * h;
      return (
        (n[0] = 2 * o),
        (n[4] = 0),
        (n[8] = 0),
        (n[12] = -u),
        (n[1] = 0),
        (n[5] = 2 * l),
        (n[9] = 0),
        (n[13] = -c),
        (n[2] = 0),
        (n[6] = 0),
        (n[10] = -2 * h),
        (n[14] = -d),
        (n[3] = 0),
        (n[7] = 0),
        (n[11] = 0),
        (n[15] = 1),
        this
      );
    }
    equals(e) {
      let t = this.elements,
        i = e.elements;
      for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
      return this;
    }
    toArray(e = [], t = 0) {
      let i = this.elements;
      return (
        (e[t] = i[0]),
        (e[t + 1] = i[1]),
        (e[t + 2] = i[2]),
        (e[t + 3] = i[3]),
        (e[t + 4] = i[4]),
        (e[t + 5] = i[5]),
        (e[t + 6] = i[6]),
        (e[t + 7] = i[7]),
        (e[t + 8] = i[8]),
        (e[t + 9] = i[9]),
        (e[t + 10] = i[10]),
        (e[t + 11] = i[11]),
        (e[t + 12] = i[12]),
        (e[t + 13] = i[13]),
        (e[t + 14] = i[14]),
        (e[t + 15] = i[15]),
        e
      );
    }
  },
  Fh = new I(),
  La = new je(),
  aR = new I(0, 0, 0),
  nR = new I(1, 1, 1),
  zo = new I(),
  Up = new I(),
  Xs = new I(),
  v_ = new je(),
  y_ = new Rt(),
  Ir = class {
    constructor(e = 0, t = 0, i = 0, r = Ir.DEFAULT_ORDER) {
      (this.isEuler = !0),
        (this._x = e),
        (this._y = t),
        (this._z = i),
        (this._order = r);
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this._x = e), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this._y = e), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      (this._z = e), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      (this._order = e), this._onChangeCallback();
    }
    set(e, t, i, r = this._order) {
      return (
        (this._x = e),
        (this._y = t),
        (this._z = i),
        (this._order = r),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return (
        (this._x = e._x),
        (this._y = e._y),
        (this._z = e._z),
        (this._order = e._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(e, t = this._order, i = !0) {
      let r = e.elements,
        s = r[0],
        a = r[4],
        n = r[8],
        o = r[1],
        l = r[5],
        h = r[9],
        u = r[2],
        c = r[6],
        d = r[10];
      switch (t) {
        case "XYZ":
          (this._y = Math.asin(vr(n, -1, 1))),
            Math.abs(n) < 0.9999999
              ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-a, s)))
              : ((this._x = Math.atan2(c, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-vr(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._y = Math.atan2(n, d)), (this._z = Math.atan2(o, l)))
              : ((this._y = Math.atan2(-u, s)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(vr(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-a, l)))
              : ((this._y = 0), (this._z = Math.atan2(o, s)));
          break;
        case "ZYX":
          (this._y = Math.asin(-vr(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._x = Math.atan2(c, d)), (this._z = Math.atan2(o, s)))
              : ((this._x = 0), (this._z = Math.atan2(-a, l)));
          break;
        case "YZX":
          (this._z = Math.asin(vr(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-u, s)))
              : ((this._x = 0), (this._y = Math.atan2(n, d)));
          break;
        case "XZY":
          (this._z = Math.asin(-vr(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(c, l)), (this._y = Math.atan2(n, s)))
              : ((this._x = Math.atan2(-h, d)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              t
          );
      }
      return (this._order = t), i === !0 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, i) {
      return (
        v_.makeRotationFromQuaternion(e), this.setFromRotationMatrix(v_, t, i)
      );
    }
    setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
      return y_.setFromEuler(this), this.setFromQuaternion(y_, e);
    }
    equals(e) {
      return (
        e._x === this._x &&
        e._y === this._y &&
        e._z === this._z &&
        e._order === this._order
      );
    }
    fromArray(e) {
      return (
        (this._x = e[0]),
        (this._y = e[1]),
        (this._z = e[2]),
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this._x),
        (e[t + 1] = this._y),
        (e[t + 2] = this._z),
        (e[t + 3] = this._order),
        e
      );
    }
    _onChange(e) {
      return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  };
Ir.DEFAULT_ORDER = "XYZ";
var vx = class {
    constructor() {
      this.mask = 1;
    }
    set(e) {
      this.mask = ((1 << e) | 0) >>> 0;
    }
    enable(e) {
      this.mask |= (1 << e) | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e) {
      this.mask ^= (1 << e) | 0;
    }
    disable(e) {
      this.mask &= ~((1 << e) | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
      return (this.mask & ((1 << e) | 0)) !== 0;
    }
  },
  oR = 0,
  x_ = new I(),
  kh = new Rt(),
  Yn = new je(),
  Vp = new I(),
  Bu = new I(),
  lR = new I(),
  hR = new Rt(),
  b_ = new I(1, 0, 0),
  w_ = new I(0, 1, 0),
  __ = new I(0, 0, 1),
  cR = { type: "added" },
  S_ = { type: "removed" },
  _i = class extends ls {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, "id", { value: oR++ }),
        (this.uuid = Aa()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = _i.DEFAULT_UP.clone());
      let e = new I(),
        t = new Ir(),
        i = new Rt(),
        r = new I(1, 1, 1);
      function s() {
        i.setFromEuler(t, !1);
      }
      function a() {
        t.setFromQuaternion(i, void 0, !1);
      }
      t._onChange(s),
        i._onChange(a),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: e },
          rotation: { configurable: !0, enumerable: !0, value: t },
          quaternion: { configurable: !0, enumerable: !0, value: i },
          scale: { configurable: !0, enumerable: !0, value: r },
          modelViewMatrix: { value: new je() },
          normalMatrix: { value: new lr() },
        }),
        (this.matrix = new je()),
        (this.matrixWorld = new je()),
        (this.matrixAutoUpdate = _i.DEFAULT_MATRIX_AUTO_UPDATE),
        (this.matrixWorldNeedsUpdate = !1),
        (this.matrixWorldAutoUpdate = _i.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
        (this.layers = new vx()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
      return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, !0);
    }
    setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
      this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
      return kh.setFromAxisAngle(e, t), this.quaternion.multiply(kh), this;
    }
    rotateOnWorldAxis(e, t) {
      return kh.setFromAxisAngle(e, t), this.quaternion.premultiply(kh), this;
    }
    rotateX(e) {
      return this.rotateOnAxis(b_, e);
    }
    rotateY(e) {
      return this.rotateOnAxis(w_, e);
    }
    rotateZ(e) {
      return this.rotateOnAxis(__, e);
    }
    translateOnAxis(e, t) {
      return (
        x_.copy(e).applyQuaternion(this.quaternion),
        this.position.add(x_.multiplyScalar(t)),
        this
      );
    }
    translateX(e) {
      return this.translateOnAxis(b_, e);
    }
    translateY(e) {
      return this.translateOnAxis(w_, e);
    }
    translateZ(e) {
      return this.translateOnAxis(__, e);
    }
    localToWorld(e) {
      return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
      return (
        this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Yn.copy(this.matrixWorld).invert())
      );
    }
    lookAt(e, t, i) {
      e.isVector3 ? Vp.copy(e) : Vp.set(e, t, i);
      let r = this.parent;
      this.updateWorldMatrix(!0, !1),
        Bu.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? Yn.lookAt(Bu, Vp, this.up)
          : Yn.lookAt(Vp, Bu, this.up),
        this.quaternion.setFromRotationMatrix(Yn),
        r &&
          (Yn.extractRotation(r.matrixWorld),
          kh.setFromRotationMatrix(Yn),
          this.quaternion.premultiply(kh.invert()));
    }
    add(e) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return e === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            e
          ),
          this)
        : (e && e.isObject3D
            ? (e.parent !== null && e.parent.remove(e),
              (e.parent = this),
              this.children.push(e),
              e.dispatchEvent(cR))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                e
              ),
          this);
    }
    remove(e) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
        return this;
      }
      let t = this.children.indexOf(e);
      return (
        t !== -1 &&
          ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(S_)),
        this
      );
    }
    removeFromParent() {
      let e = this.parent;
      return e !== null && e.remove(this), this;
    }
    clear() {
      for (let e = 0; e < this.children.length; e++) {
        let t = this.children[e];
        (t.parent = null), t.dispatchEvent(S_);
      }
      return (this.children.length = 0), this;
    }
    attach(e) {
      return (
        this.updateWorldMatrix(!0, !1),
        Yn.copy(this.matrixWorld).invert(),
        e.parent !== null &&
          (e.parent.updateWorldMatrix(!0, !1),
          Yn.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Yn),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(e) {
      return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
      return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let i = 0, r = this.children.length; i < r; i++) {
        let s = this.children[i].getObjectByProperty(e, t);
        if (s !== void 0) return s;
      }
    }
    getObjectsByProperty(e, t) {
      let i = [];
      this[e] === t && i.push(this);
      for (let r = 0, s = this.children.length; r < s; r++) {
        let a = this.children[r].getObjectsByProperty(e, t);
        a.length > 0 && (i = i.concat(a));
      }
      return i;
    }
    getWorldPosition(e) {
      return (
        this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(e) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Bu, e, lR), e
      );
    }
    getWorldScale(e) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Bu, hR, e), e
      );
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(!0, !1);
      let t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {}
    traverse(e) {
      e(this);
      let t = this.children;
      for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
    }
    traverseVisible(e) {
      if (this.visible === !1) return;
      e(this);
      let t = this.children;
      for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
    }
    traverseAncestors(e) {
      let t = this.parent;
      t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (e = !0));
      let t = this.children;
      for (let i = 0, r = t.length; i < r; i++) {
        let s = t[i];
        (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
      }
    }
    updateWorldMatrix(e, t) {
      let i = this.parent;
      if (
        (e === !0 &&
          i !== null &&
          i.matrixWorldAutoUpdate === !0 &&
          i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        t === !0)
      ) {
        let r = this.children;
        for (let s = 0, a = r.length; s < a; s++) {
          let n = r[s];
          n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!1, !0);
        }
      }
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string",
        i = {};
      t &&
        ((e = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (i.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      let r = {};
      (r.uuid = this.uuid),
        (r.type = this.type),
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        (r.layers = this.layers.mask),
        (r.matrix = this.matrix.toArray()),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((r.type = "InstancedMesh"),
          (r.count = this.count),
          (r.instanceMatrix = this.instanceMatrix.toJSON()),
          this.instanceColor !== null &&
            (r.instanceColor = this.instanceColor.toJSON()));
      function s(n, o) {
        return n[o.uuid] === void 0 && (n[o.uuid] = o.toJSON(e)), o.uuid;
      }
      if (this.isScene)
        this.background &&
          (this.background.isColor
            ? (r.background = this.background.toJSON())
            : this.background.isTexture &&
              (r.background = this.background.toJSON(e).uuid)),
          this.environment &&
            this.environment.isTexture &&
            this.environment.isRenderTargetTexture !== !0 &&
            (r.environment = this.environment.toJSON(e).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        r.geometry = s(e.geometries, this.geometry);
        let n = this.geometry.parameters;
        if (n !== void 0 && n.shapes !== void 0) {
          let o = n.shapes;
          if (Array.isArray(o))
            for (let l = 0, h = o.length; l < h; l++) {
              let u = o[l];
              s(e.shapes, u);
            }
          else s(e.shapes, o);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((r.bindMode = this.bindMode),
          (r.bindMatrix = this.bindMatrix.toArray()),
          this.skeleton !== void 0 &&
            (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
        this.material !== void 0)
      )
        if (Array.isArray(this.material)) {
          let n = [];
          for (let o = 0, l = this.material.length; o < l; o++)
            n.push(s(e.materials, this.material[o]));
          r.material = n;
        } else r.material = s(e.materials, this.material);
      if (this.children.length > 0) {
        r.children = [];
        for (let n = 0; n < this.children.length; n++)
          r.children.push(this.children[n].toJSON(e).object);
      }
      if (this.animations.length > 0) {
        r.animations = [];
        for (let n = 0; n < this.animations.length; n++) {
          let o = this.animations[n];
          r.animations.push(s(e.animations, o));
        }
      }
      if (t) {
        let n = a(e.geometries),
          o = a(e.materials),
          l = a(e.textures),
          h = a(e.images),
          u = a(e.shapes),
          c = a(e.skeletons),
          d = a(e.animations),
          p = a(e.nodes);
        n.length > 0 && (i.geometries = n),
          o.length > 0 && (i.materials = o),
          l.length > 0 && (i.textures = l),
          h.length > 0 && (i.images = h),
          u.length > 0 && (i.shapes = u),
          c.length > 0 && (i.skeletons = c),
          d.length > 0 && (i.animations = d),
          p.length > 0 && (i.nodes = p);
      }
      return (i.object = r), i;
      function a(n) {
        let o = [];
        for (let l in n) {
          let h = n[l];
          delete h.metadata, o.push(h);
        }
        return o;
      }
    }
    clone(e) {
      return new this.constructor().copy(this, e);
    }
    copy(e, t = !0) {
      if (
        ((this.name = e.name),
        this.up.copy(e.up),
        this.position.copy(e.position),
        (this.rotation.order = e.rotation.order),
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
        (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
        (this.layers.mask = e.layers.mask),
        (this.visible = e.visible),
        (this.castShadow = e.castShadow),
        (this.receiveShadow = e.receiveShadow),
        (this.frustumCulled = e.frustumCulled),
        (this.renderOrder = e.renderOrder),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        t === !0)
      )
        for (let i = 0; i < e.children.length; i++) {
          let r = e.children[i];
          this.add(r.clone());
        }
      return this;
    }
  };
_i.DEFAULT_UP = new I(0, 1, 0);
_i.DEFAULT_MATRIX_AUTO_UPDATE = !0;
_i.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
var Ba = new I(),
  Xn = new I(),
  Av = new I(),
  Qn = new I(),
  Nh = new I(),
  Uh = new I(),
  A_ = new I(),
  Mv = new I(),
  Ev = new I(),
  Cv = new I(),
  rs = class {
    constructor(e = new I(), t = new I(), i = new I()) {
      (this.a = e), (this.b = t), (this.c = i);
    }
    static getNormal(e, t, i, r) {
      r.subVectors(i, t), Ba.subVectors(e, t), r.cross(Ba);
      let s = r.lengthSq();
      return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
    }
    static getBarycoord(e, t, i, r, s) {
      Ba.subVectors(r, t), Xn.subVectors(i, t), Av.subVectors(e, t);
      let a = Ba.dot(Ba),
        n = Ba.dot(Xn),
        o = Ba.dot(Av),
        l = Xn.dot(Xn),
        h = Xn.dot(Av),
        u = a * l - n * n;
      if (u === 0) return s.set(-2, -1, -1);
      let c = 1 / u,
        d = (l * o - n * h) * c,
        p = (a * h - n * o) * c;
      return s.set(1 - d - p, p, d);
    }
    static containsPoint(e, t, i, r) {
      return (
        this.getBarycoord(e, t, i, r, Qn),
        Qn.x >= 0 && Qn.y >= 0 && Qn.x + Qn.y <= 1
      );
    }
    static getUV(e, t, i, r, s, a, n, o) {
      return (
        this.getBarycoord(e, t, i, r, Qn),
        o.set(0, 0),
        o.addScaledVector(s, Qn.x),
        o.addScaledVector(a, Qn.y),
        o.addScaledVector(n, Qn.z),
        o
      );
    }
    static isFrontFacing(e, t, i, r) {
      return Ba.subVectors(i, t), Xn.subVectors(e, t), Ba.cross(Xn).dot(r) < 0;
    }
    set(e, t, i) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
    }
    setFromPointsAndIndices(e, t, i, r) {
      return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
    }
    setFromAttributeAndIndices(e, t, i, r) {
      return (
        this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return (
        Ba.subVectors(this.c, this.b),
        Xn.subVectors(this.a, this.b),
        Ba.cross(Xn).length() * 0.5
      );
    }
    getMidpoint(e) {
      return e
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(e) {
      return rs.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
      return rs.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getUV(e, t, i, r, s) {
      return rs.getUV(e, this.a, this.b, this.c, t, i, r, s);
    }
    containsPoint(e) {
      return rs.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return rs.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      let i = this.a,
        r = this.b,
        s = this.c,
        a,
        n;
      Nh.subVectors(r, i), Uh.subVectors(s, i), Mv.subVectors(e, i);
      let o = Nh.dot(Mv),
        l = Uh.dot(Mv);
      if (o <= 0 && l <= 0) return t.copy(i);
      Ev.subVectors(e, r);
      let h = Nh.dot(Ev),
        u = Uh.dot(Ev);
      if (h >= 0 && u <= h) return t.copy(r);
      let c = o * u - h * l;
      if (c <= 0 && o >= 0 && h <= 0)
        return (a = o / (o - h)), t.copy(i).addScaledVector(Nh, a);
      Cv.subVectors(e, s);
      let d = Nh.dot(Cv),
        p = Uh.dot(Cv);
      if (p >= 0 && d <= p) return t.copy(s);
      let f = d * l - o * p;
      if (f <= 0 && l >= 0 && p <= 0)
        return (n = l / (l - p)), t.copy(i).addScaledVector(Uh, n);
      let m = h * p - d * u;
      if (m <= 0 && u - h >= 0 && d - p >= 0)
        return (
          A_.subVectors(s, r),
          (n = (u - h) / (u - h + (d - p))),
          t.copy(r).addScaledVector(A_, n)
        );
      let g = 1 / (m + f + c);
      return (
        (a = f * g),
        (n = c * g),
        t.copy(i).addScaledVector(Nh, a).addScaledVector(Uh, n)
      );
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  },
  uR = 0,
  sp = class extends ls {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, "id", { value: uR++ }),
        (this.uuid = Aa()),
        (this.name = ""),
        (this.type = "Material"),
        (this.blending = Jl),
        (this.side = Xa),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = NE),
        (this.blendDst = UE),
        (this.blendEquation = pc),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = cy),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = NI),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = dv),
        (this.stencilZFail = dv),
        (this.stencilZPass = dv),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.forceSinglePass = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e) {
      if (e !== void 0)
        for (let t in e) {
          let i = e[t];
          if (i === void 0) {
            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
            continue;
          }
          let r = this[t];
          if (r === void 0) {
            console.warn(
              "THREE." +
                this.type +
                ": '" +
                t +
                "' is not a property of this material."
            );
            continue;
          }
          r && r.isColor
            ? r.set(i)
            : r && r.isVector3 && i && i.isVector3
            ? r.copy(i)
            : (this[t] = i);
        }
    }
    toJSON(e) {
      let t = e === void 0 || typeof e == "string";
      t && (e = { textures: {}, images: {} });
      let i = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      (i.uuid = this.uuid),
        (i.type = this.type),
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 &&
          (i.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          this.emissiveIntensity !== 1 &&
          (i.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 &&
          (i.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 &&
          (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
          (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 &&
          (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 &&
          (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (i.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((i.lightMap = this.lightMap.toJSON(e).uuid),
          (i.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((i.aoMap = this.aoMap.toJSON(e).uuid),
          (i.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
          (i.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((i.normalMap = this.normalMap.toJSON(e).uuid),
          (i.normalMapType = this.normalMapType),
          (i.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
          (i.displacementScale = this.displacementScale),
          (i.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((i.envMap = this.envMap.toJSON(e).uuid),
          this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 &&
          (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 &&
          (i.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 &&
          this.attenuationDistance !== 1 / 0 &&
          (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 &&
          (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 &&
          (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Jl && (i.blending = this.blending),
        this.side !== Xa && (i.side = this.side),
        this.vertexColors && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = this.transparent),
        (i.depthFunc = this.depthFunc),
        (i.depthTest = this.depthTest),
        (i.depthWrite = this.depthWrite),
        (i.colorWrite = this.colorWrite),
        (i.stencilWrite = this.stencilWrite),
        (i.stencilWriteMask = this.stencilWriteMask),
        (i.stencilFunc = this.stencilFunc),
        (i.stencilRef = this.stencilRef),
        (i.stencilFuncMask = this.stencilFuncMask),
        (i.stencilFail = this.stencilFail),
        (i.stencilZFail = this.stencilZFail),
        (i.stencilZPass = this.stencilZPass),
        this.rotation !== void 0 &&
          this.rotation !== 0 &&
          (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 &&
          (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 &&
          (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 &&
          this.linewidth !== 1 &&
          (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 &&
          (i.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 &&
          (i.premultipliedAlpha = this.premultipliedAlpha),
        this.forceSinglePass === !0 &&
          (i.forceSinglePass = this.forceSinglePass),
        this.wireframe === !0 && (i.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" &&
          (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" &&
          (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = this.flatShading),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
      function r(s) {
        let a = [];
        for (let n in s) {
          let o = s[n];
          delete o.metadata, a.push(o);
        }
        return a;
      }
      if (t) {
        let s = r(e.textures),
          a = r(e.images);
        s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
      }
      return i;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.name = e.name),
        (this.blending = e.blending),
        (this.side = e.side),
        (this.vertexColors = e.vertexColors),
        (this.opacity = e.opacity),
        (this.transparent = e.transparent),
        (this.blendSrc = e.blendSrc),
        (this.blendDst = e.blendDst),
        (this.blendEquation = e.blendEquation),
        (this.blendSrcAlpha = e.blendSrcAlpha),
        (this.blendDstAlpha = e.blendDstAlpha),
        (this.blendEquationAlpha = e.blendEquationAlpha),
        (this.depthFunc = e.depthFunc),
        (this.depthTest = e.depthTest),
        (this.depthWrite = e.depthWrite),
        (this.stencilWriteMask = e.stencilWriteMask),
        (this.stencilFunc = e.stencilFunc),
        (this.stencilRef = e.stencilRef),
        (this.stencilFuncMask = e.stencilFuncMask),
        (this.stencilFail = e.stencilFail),
        (this.stencilZFail = e.stencilZFail),
        (this.stencilZPass = e.stencilZPass),
        (this.stencilWrite = e.stencilWrite);
      let t = e.clippingPlanes,
        i = null;
      if (t !== null) {
        let r = t.length;
        i = new Array(r);
        for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
      }
      return (
        (this.clippingPlanes = i),
        (this.clipIntersection = e.clipIntersection),
        (this.clipShadows = e.clipShadows),
        (this.shadowSide = e.shadowSide),
        (this.colorWrite = e.colorWrite),
        (this.precision = e.precision),
        (this.polygonOffset = e.polygonOffset),
        (this.polygonOffsetFactor = e.polygonOffsetFactor),
        (this.polygonOffsetUnits = e.polygonOffsetUnits),
        (this.dithering = e.dithering),
        (this.alphaTest = e.alphaTest),
        (this.alphaToCoverage = e.alphaToCoverage),
        (this.premultipliedAlpha = e.premultipliedAlpha),
        (this.forceSinglePass = e.forceSinglePass),
        (this.visible = e.visible),
        (this.toneMapped = e.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
  },
  mh = class extends sp {
    constructor(e) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = "MeshBasicMaterial"),
        (this.color = new Et(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = VE),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        (this.specularMap = e.specularMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.combine = e.combine),
        (this.reflectivity = e.reflectivity),
        (this.refractionRatio = e.refractionRatio),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.fog = e.fog),
        this
      );
    }
  },
  fr = new I(),
  jp = new re(),
  It = class {
    constructor(e, t, i = !1) {
      if (Array.isArray(e))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.isBufferAttribute = !0),
        (this.name = ""),
        (this.array = e),
        (this.itemSize = t),
        (this.count = e !== void 0 ? e.length / t : 0),
        (this.normalized = i),
        (this.usage = fy),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    setUsage(e) {
      return (this.usage = e), this;
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.array = new e.array.constructor(e.array)),
        (this.itemSize = e.itemSize),
        (this.count = e.count),
        (this.normalized = e.normalized),
        (this.usage = e.usage),
        this
      );
    }
    copyAt(e, t, i) {
      (e *= this.itemSize), (i *= t.itemSize);
      for (let r = 0, s = this.itemSize; r < s; r++)
        this.array[e + r] = t.array[i + r];
      return this;
    }
    copyArray(e) {
      return this.array.set(e), this;
    }
    applyMatrix3(e) {
      if (this.itemSize === 2)
        for (let t = 0, i = this.count; t < i; t++)
          jp.fromBufferAttribute(this, t),
            jp.applyMatrix3(e),
            this.setXY(t, jp.x, jp.y);
      else if (this.itemSize === 3)
        for (let t = 0, i = this.count; t < i; t++)
          fr.fromBufferAttribute(this, t),
            fr.applyMatrix3(e),
            this.setXYZ(t, fr.x, fr.y, fr.z);
      return this;
    }
    applyMatrix4(e) {
      for (let t = 0, i = this.count; t < i; t++)
        fr.fromBufferAttribute(this, t),
          fr.applyMatrix4(e),
          this.setXYZ(t, fr.x, fr.y, fr.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, i = this.count; t < i; t++)
        fr.fromBufferAttribute(this, t),
          fr.applyNormalMatrix(e),
          this.setXYZ(t, fr.x, fr.y, fr.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, i = this.count; t < i; t++)
        fr.fromBufferAttribute(this, t),
          fr.transformDirection(e),
          this.setXYZ(t, fr.x, fr.y, fr.z);
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    getX(e) {
      let t = this.array[e * this.itemSize];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    setX(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.array[e * this.itemSize] = t),
        this
      );
    }
    getY(e) {
      let t = this.array[e * this.itemSize + 1];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    setY(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.array[e * this.itemSize + 1] = t),
        this
      );
    }
    getZ(e) {
      let t = this.array[e * this.itemSize + 2];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    setZ(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.array[e * this.itemSize + 2] = t),
        this
      );
    }
    getW(e) {
      let t = this.array[e * this.itemSize + 3];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    setW(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.array[e * this.itemSize + 3] = t),
        this
      );
    }
    setXY(e, t, i) {
      return (
        (e *= this.itemSize),
        this.normalized && ((t = Ri(t, this.array)), (i = Ri(i, this.array))),
        (this.array[e + 0] = t),
        (this.array[e + 1] = i),
        this
      );
    }
    setXYZ(e, t, i, r) {
      return (
        (e *= this.itemSize),
        this.normalized &&
          ((t = Ri(t, this.array)),
          (i = Ri(i, this.array)),
          (r = Ri(r, this.array))),
        (this.array[e + 0] = t),
        (this.array[e + 1] = i),
        (this.array[e + 2] = r),
        this
      );
    }
    setXYZW(e, t, i, r, s) {
      return (
        (e *= this.itemSize),
        this.normalized &&
          ((t = Ri(t, this.array)),
          (i = Ri(i, this.array)),
          (r = Ri(r, this.array)),
          (s = Ri(s, this.array))),
        (this.array[e + 0] = t),
        (this.array[e + 1] = i),
        (this.array[e + 2] = r),
        (this.array[e + 3] = s),
        this
      );
    }
    onUpload(e) {
      return (this.onUploadCallback = e), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      let e = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return (
        this.name !== "" && (e.name = this.name),
        this.usage !== fy && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
          (e.updateRange = this.updateRange),
        e
      );
    }
    copyColorsArray() {
      console.error(
        "THREE.BufferAttribute: copyColorsArray() was removed in r144."
      );
    }
    copyVector2sArray() {
      console.error(
        "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
      );
    }
    copyVector3sArray() {
      console.error(
        "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
      );
    }
    copyVector4sArray() {
      console.error(
        "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
      );
    }
  },
  eC = class extends It {
    constructor(e, t, i) {
      super(new Uint16Array(e), t, i);
    }
  },
  Ec = class extends It {
    constructor(e, t, i) {
      super(new Uint32Array(e), t, i);
    }
  },
  ot = class extends It {
    constructor(e, t, i) {
      super(new Float32Array(e), t, i);
    }
  },
  dR = 0,
  ca = new je(),
  Tv = new _i(),
  Vh = new I(),
  Qs = new ur(),
  zu = new ur(),
  Nr = new I(),
  yt = class extends ls {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, "id", { value: dR++ }),
        (this.uuid = Aa()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(e) {
      return (
        Array.isArray(e)
          ? (this.index = new (QE(e) ? Ec : eC)(e, 1))
          : (this.index = e),
        this
      );
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    setAttribute(e, t) {
      return (this.attributes[e] = t), this;
    }
    deleteAttribute(e) {
      return delete this.attributes[e], this;
    }
    hasAttribute(e) {
      return this.attributes[e] !== void 0;
    }
    addGroup(e, t, i = 0) {
      this.groups.push({ start: e, count: t, materialIndex: i });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e, t) {
      (this.drawRange.start = e), (this.drawRange.count = t);
    }
    applyMatrix4(e) {
      let t = this.attributes.position;
      t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
      let i = this.attributes.normal;
      if (i !== void 0) {
        let s = new lr().getNormalMatrix(e);
        i.applyNormalMatrix(s), (i.needsUpdate = !0);
      }
      let r = this.attributes.tangent;
      return (
        r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(e) {
      return ca.makeRotationFromQuaternion(e), this.applyMatrix4(ca), this;
    }
    rotateX(e) {
      return ca.makeRotationX(e), this.applyMatrix4(ca), this;
    }
    rotateY(e) {
      return ca.makeRotationY(e), this.applyMatrix4(ca), this;
    }
    rotateZ(e) {
      return ca.makeRotationZ(e), this.applyMatrix4(ca), this;
    }
    translate(e, t, i) {
      return ca.makeTranslation(e, t, i), this.applyMatrix4(ca), this;
    }
    scale(e, t, i) {
      return ca.makeScale(e, t, i), this.applyMatrix4(ca), this;
    }
    lookAt(e) {
      return (
        Tv.lookAt(e), Tv.updateMatrix(), this.applyMatrix4(Tv.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(Vh).negate(),
        this.translate(Vh.x, Vh.y, Vh.z),
        this
      );
    }
    setFromPoints(e) {
      let t = [];
      for (let i = 0, r = e.length; i < r; i++) {
        let s = e[i];
        t.push(s.x, s.y, s.z || 0);
      }
      return this.setAttribute("position", new ot(t, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new ur());
      let e = this.attributes.position,
        t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
          this.boundingBox.set(
            new I(-1 / 0, -1 / 0, -1 / 0),
            new I(1 / 0, 1 / 0, 1 / 0)
          );
        return;
      }
      if (e !== void 0) {
        if ((this.boundingBox.setFromBufferAttribute(e), t))
          for (let i = 0, r = t.length; i < r; i++) {
            let s = t[i];
            Qs.setFromBufferAttribute(s),
              this.morphTargetsRelative
                ? (Nr.addVectors(this.boundingBox.min, Qs.min),
                  this.boundingBox.expandByPoint(Nr),
                  Nr.addVectors(this.boundingBox.max, Qs.max),
                  this.boundingBox.expandByPoint(Nr))
                : (this.boundingBox.expandByPoint(Qs.min),
                  this.boundingBox.expandByPoint(Qs.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Ws());
      let e = this.attributes.position,
        t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
          this.boundingSphere.set(new I(), 1 / 0);
        return;
      }
      if (e) {
        let i = this.boundingSphere.center;
        if ((Qs.setFromBufferAttribute(e), t))
          for (let s = 0, a = t.length; s < a; s++) {
            let n = t[s];
            zu.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (Nr.addVectors(Qs.min, zu.min),
                  Qs.expandByPoint(Nr),
                  Nr.addVectors(Qs.max, zu.max),
                  Qs.expandByPoint(Nr))
                : (Qs.expandByPoint(zu.min), Qs.expandByPoint(zu.max));
          }
        Qs.getCenter(i);
        let r = 0;
        for (let s = 0, a = e.count; s < a; s++)
          Nr.fromBufferAttribute(e, s),
            (r = Math.max(r, i.distanceToSquared(Nr)));
        if (t)
          for (let s = 0, a = t.length; s < a; s++) {
            let n = t[s],
              o = this.morphTargetsRelative;
            for (let l = 0, h = n.count; l < h; l++)
              Nr.fromBufferAttribute(n, l),
                o && (Vh.fromBufferAttribute(e, l), Nr.add(Vh)),
                (r = Math.max(r, i.distanceToSquared(Nr)));
          }
        (this.boundingSphere.radius = Math.sqrt(r)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    }
    computeTangents() {
      let e = this.index,
        t = this.attributes;
      if (
        e === null ||
        t.position === void 0 ||
        t.normal === void 0 ||
        t.uv === void 0
      ) {
        console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
        );
        return;
      }
      let i = e.array,
        r = t.position.array,
        s = t.normal.array,
        a = t.uv.array,
        n = r.length / 3;
      this.hasAttribute("tangent") === !1 &&
        this.setAttribute("tangent", new It(new Float32Array(4 * n), 4));
      let o = this.getAttribute("tangent").array,
        l = [],
        h = [];
      for (let T = 0; T < n; T++) (l[T] = new I()), (h[T] = new I());
      let u = new I(),
        c = new I(),
        d = new I(),
        p = new re(),
        f = new re(),
        m = new re(),
        g = new I(),
        y = new I();
      function x(T, P, R) {
        u.fromArray(r, T * 3),
          c.fromArray(r, P * 3),
          d.fromArray(r, R * 3),
          p.fromArray(a, T * 2),
          f.fromArray(a, P * 2),
          m.fromArray(a, R * 2),
          c.sub(u),
          d.sub(u),
          f.sub(p),
          m.sub(p);
        let z = 1 / (f.x * m.y - m.x * f.y);
        !isFinite(z) ||
          (g
            .copy(c)
            .multiplyScalar(m.y)
            .addScaledVector(d, -f.y)
            .multiplyScalar(z),
          y
            .copy(d)
            .multiplyScalar(f.x)
            .addScaledVector(c, -m.x)
            .multiplyScalar(z),
          l[T].add(g),
          l[P].add(g),
          l[R].add(g),
          h[T].add(y),
          h[P].add(y),
          h[R].add(y));
      }
      let b = this.groups;
      b.length === 0 && (b = [{ start: 0, count: i.length }]);
      for (let T = 0, P = b.length; T < P; ++T) {
        let R = b[T],
          z = R.start,
          N = R.count;
        for (let L = z, G = z + N; L < G; L += 3)
          x(i[L + 0], i[L + 1], i[L + 2]);
      }
      let _ = new I(),
        S = new I(),
        M = new I(),
        C = new I();
      function A(T) {
        M.fromArray(s, T * 3), C.copy(M);
        let P = l[T];
        _.copy(P),
          _.sub(M.multiplyScalar(M.dot(P))).normalize(),
          S.crossVectors(C, P);
        let R = S.dot(h[T]) < 0 ? -1 : 1;
        (o[T * 4] = _.x),
          (o[T * 4 + 1] = _.y),
          (o[T * 4 + 2] = _.z),
          (o[T * 4 + 3] = R);
      }
      for (let T = 0, P = b.length; T < P; ++T) {
        let R = b[T],
          z = R.start,
          N = R.count;
        for (let L = z, G = z + N; L < G; L += 3)
          A(i[L + 0]), A(i[L + 1]), A(i[L + 2]);
      }
    }
    computeVertexNormals() {
      let e = this.index,
        t = this.getAttribute("position");
      if (t !== void 0) {
        let i = this.getAttribute("normal");
        if (i === void 0)
          (i = new It(new Float32Array(t.count * 3), 3)),
            this.setAttribute("normal", i);
        else for (let c = 0, d = i.count; c < d; c++) i.setXYZ(c, 0, 0, 0);
        let r = new I(),
          s = new I(),
          a = new I(),
          n = new I(),
          o = new I(),
          l = new I(),
          h = new I(),
          u = new I();
        if (e)
          for (let c = 0, d = e.count; c < d; c += 3) {
            let p = e.getX(c + 0),
              f = e.getX(c + 1),
              m = e.getX(c + 2);
            r.fromBufferAttribute(t, p),
              s.fromBufferAttribute(t, f),
              a.fromBufferAttribute(t, m),
              h.subVectors(a, s),
              u.subVectors(r, s),
              h.cross(u),
              n.fromBufferAttribute(i, p),
              o.fromBufferAttribute(i, f),
              l.fromBufferAttribute(i, m),
              n.add(h),
              o.add(h),
              l.add(h),
              i.setXYZ(p, n.x, n.y, n.z),
              i.setXYZ(f, o.x, o.y, o.z),
              i.setXYZ(m, l.x, l.y, l.z);
          }
        else
          for (let c = 0, d = t.count; c < d; c += 3)
            r.fromBufferAttribute(t, c + 0),
              s.fromBufferAttribute(t, c + 1),
              a.fromBufferAttribute(t, c + 2),
              h.subVectors(a, s),
              u.subVectors(r, s),
              h.cross(u),
              i.setXYZ(c + 0, h.x, h.y, h.z),
              i.setXYZ(c + 1, h.x, h.y, h.z),
              i.setXYZ(c + 2, h.x, h.y, h.z);
        this.normalizeNormals(), (i.needsUpdate = !0);
      }
    }
    merge() {
      return (
        console.error(
          "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."
        ),
        this
      );
    }
    normalizeNormals() {
      let e = this.attributes.normal;
      for (let t = 0, i = e.count; t < i; t++)
        Nr.fromBufferAttribute(e, t),
          Nr.normalize(),
          e.setXYZ(t, Nr.x, Nr.y, Nr.z);
    }
    toNonIndexed() {
      function e(n, o) {
        let l = n.array,
          h = n.itemSize,
          u = n.normalized,
          c = new l.constructor(o.length * h),
          d = 0,
          p = 0;
        for (let f = 0, m = o.length; f < m; f++) {
          n.isInterleavedBufferAttribute
            ? (d = o[f] * n.data.stride + n.offset)
            : (d = o[f] * h);
          for (let g = 0; g < h; g++) c[p++] = l[d++];
        }
        return new It(c, h, u);
      }
      if (this.index === null)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
          ),
          this
        );
      let t = new yt(),
        i = this.index.array,
        r = this.attributes;
      for (let n in r) {
        let o = r[n],
          l = e(o, i);
        t.setAttribute(n, l);
      }
      let s = this.morphAttributes;
      for (let n in s) {
        let o = [],
          l = s[n];
        for (let h = 0, u = l.length; h < u; h++) {
          let c = l[h],
            d = e(c, i);
          o.push(d);
        }
        t.morphAttributes[n] = o;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      let a = this.groups;
      for (let n = 0, o = a.length; n < o; n++) {
        let l = a[n];
        t.addGroup(l.start, l.count, l.materialIndex);
      }
      return t;
    }
    toJSON() {
      let e = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((e.uuid = this.uuid),
        (e.type = this.type),
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0)
      ) {
        let o = this.parameters;
        for (let l in o) o[l] !== void 0 && (e[l] = o[l]);
        return e;
      }
      e.data = { attributes: {} };
      let t = this.index;
      t !== null &&
        (e.data.index = {
          type: t.array.constructor.name,
          array: Array.prototype.slice.call(t.array),
        });
      let i = this.attributes;
      for (let o in i) {
        let l = i[o];
        e.data.attributes[o] = l.toJSON(e.data);
      }
      let r = {},
        s = !1;
      for (let o in this.morphAttributes) {
        let l = this.morphAttributes[o],
          h = [];
        for (let u = 0, c = l.length; u < c; u++) {
          let d = l[u];
          h.push(d.toJSON(e.data));
        }
        h.length > 0 && ((r[o] = h), (s = !0));
      }
      s &&
        ((e.data.morphAttributes = r),
        (e.data.morphTargetsRelative = this.morphTargetsRelative));
      let a = this.groups;
      a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
      let n = this.boundingSphere;
      return (
        n !== null &&
          (e.data.boundingSphere = {
            center: n.center.toArray(),
            radius: n.radius,
          }),
        e
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      let t = {};
      this.name = e.name;
      let i = e.index;
      i !== null && this.setIndex(i.clone(t));
      let r = e.attributes;
      for (let l in r) {
        let h = r[l];
        this.setAttribute(l, h.clone(t));
      }
      let s = e.morphAttributes;
      for (let l in s) {
        let h = [],
          u = s[l];
        for (let c = 0, d = u.length; c < d; c++) h.push(u[c].clone(t));
        this.morphAttributes[l] = h;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      let a = e.groups;
      for (let l = 0, h = a.length; l < h; l++) {
        let u = a[l];
        this.addGroup(u.start, u.count, u.materialIndex);
      }
      let n = e.boundingBox;
      n !== null && (this.boundingBox = n.clone());
      let o = e.boundingSphere;
      return (
        o !== null && (this.boundingSphere = o.clone()),
        (this.drawRange.start = e.drawRange.start),
        (this.drawRange.count = e.drawRange.count),
        (this.userData = e.userData),
        e.parameters !== void 0 &&
          (this.parameters = Object.assign({}, e.parameters)),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  },
  M_ = new je(),
  jh = new su(),
  Pv = new Ws(),
  Fu = new I(),
  ku = new I(),
  Nu = new I(),
  Dv = new I(),
  Hp = new I(),
  Gp = new re(),
  Wp = new re(),
  qp = new re(),
  Ov = new I(),
  Yp = new I(),
  br = class extends _i {
    constructor(e = new yt(), t = new mh()) {
      super(),
        (this.isMesh = !0),
        (this.type = "Mesh"),
        (this.geometry = e),
        (this.material = t),
        this.updateMorphTargets();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        e.morphTargetInfluences !== void 0 &&
          (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 &&
          (this.morphTargetDictionary = Object.assign(
            {},
            e.morphTargetDictionary
          )),
        (this.material = e.material),
        (this.geometry = e.geometry),
        this
      );
    }
    updateMorphTargets() {
      let e = this.geometry.morphAttributes,
        t = Object.keys(e);
      if (t.length > 0) {
        let i = e[t[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, s = i.length; r < s; r++) {
            let a = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = r);
          }
        }
      }
    }
    getVertexPosition(e, t) {
      let i = this.geometry,
        r = i.attributes.position,
        s = i.morphAttributes.position,
        a = i.morphTargetsRelative;
      t.fromBufferAttribute(r, e);
      let n = this.morphTargetInfluences;
      if (s && n) {
        Hp.set(0, 0, 0);
        for (let o = 0, l = s.length; o < l; o++) {
          let h = n[o],
            u = s[o];
          h !== 0 &&
            (Dv.fromBufferAttribute(u, e),
            a ? Hp.addScaledVector(Dv, h) : Hp.addScaledVector(Dv.sub(t), h));
        }
        t.add(Hp);
      }
      return this.isSkinnedMesh && this.boneTransform(e, t), t;
    }
    raycast(e, t) {
      let i = this.geometry,
        r = this.material,
        s = this.matrixWorld;
      if (
        r === void 0 ||
        (i.boundingSphere === null && i.computeBoundingSphere(),
        Pv.copy(i.boundingSphere),
        Pv.applyMatrix4(s),
        e.ray.intersectsSphere(Pv) === !1) ||
        (M_.copy(s).invert(),
        jh.copy(e.ray).applyMatrix4(M_),
        i.boundingBox !== null && jh.intersectsBox(i.boundingBox) === !1)
      )
        return;
      let a,
        n = i.index,
        o = i.attributes.position,
        l = i.attributes.uv,
        h = i.attributes.uv2,
        u = i.groups,
        c = i.drawRange;
      if (n !== null)
        if (Array.isArray(r))
          for (let d = 0, p = u.length; d < p; d++) {
            let f = u[d],
              m = r[f.materialIndex],
              g = Math.max(f.start, c.start),
              y = Math.min(
                n.count,
                Math.min(f.start + f.count, c.start + c.count)
              );
            for (let x = g, b = y; x < b; x += 3) {
              let _ = n.getX(x),
                S = n.getX(x + 1),
                M = n.getX(x + 2);
              (a = Xp(this, m, e, jh, l, h, _, S, M)),
                a &&
                  ((a.faceIndex = Math.floor(x / 3)),
                  (a.face.materialIndex = f.materialIndex),
                  t.push(a));
            }
          }
        else {
          let d = Math.max(0, c.start),
            p = Math.min(n.count, c.start + c.count);
          for (let f = d, m = p; f < m; f += 3) {
            let g = n.getX(f),
              y = n.getX(f + 1),
              x = n.getX(f + 2);
            (a = Xp(this, r, e, jh, l, h, g, y, x)),
              a && ((a.faceIndex = Math.floor(f / 3)), t.push(a));
          }
        }
      else if (o !== void 0)
        if (Array.isArray(r))
          for (let d = 0, p = u.length; d < p; d++) {
            let f = u[d],
              m = r[f.materialIndex],
              g = Math.max(f.start, c.start),
              y = Math.min(
                o.count,
                Math.min(f.start + f.count, c.start + c.count)
              );
            for (let x = g, b = y; x < b; x += 3) {
              let _ = x,
                S = x + 1,
                M = x + 2;
              (a = Xp(this, m, e, jh, l, h, _, S, M)),
                a &&
                  ((a.faceIndex = Math.floor(x / 3)),
                  (a.face.materialIndex = f.materialIndex),
                  t.push(a));
            }
          }
        else {
          let d = Math.max(0, c.start),
            p = Math.min(o.count, c.start + c.count);
          for (let f = d, m = p; f < m; f += 3) {
            let g = f,
              y = f + 1,
              x = f + 2;
            (a = Xp(this, r, e, jh, l, h, g, y, x)),
              a && ((a.faceIndex = Math.floor(f / 3)), t.push(a));
          }
        }
    }
  };
function pR(e, t, i, r, s, a, n, o) {
  let l;
  if (
    (t.side === Yr
      ? (l = r.intersectTriangle(n, a, s, !0, o))
      : (l = r.intersectTriangle(s, a, n, t.side === Xa, o)),
    l === null)
  )
    return null;
  Yp.copy(o), Yp.applyMatrix4(e.matrixWorld);
  let h = i.ray.origin.distanceTo(Yp);
  return h < i.near || h > i.far
    ? null
    : { distance: h, point: Yp.clone(), object: e };
}
function Xp(e, t, i, r, s, a, n, o, l) {
  e.getVertexPosition(n, Fu),
    e.getVertexPosition(o, ku),
    e.getVertexPosition(l, Nu);
  let h = pR(e, t, i, r, Fu, ku, Nu, Ov);
  if (h) {
    s &&
      (Gp.fromBufferAttribute(s, n),
      Wp.fromBufferAttribute(s, o),
      qp.fromBufferAttribute(s, l),
      (h.uv = rs.getUV(Ov, Fu, ku, Nu, Gp, Wp, qp, new re()))),
      a &&
        (Gp.fromBufferAttribute(a, n),
        Wp.fromBufferAttribute(a, o),
        qp.fromBufferAttribute(a, l),
        (h.uv2 = rs.getUV(Ov, Fu, ku, Nu, Gp, Wp, qp, new re())));
    let u = { a: n, b: o, c: l, normal: new I(), materialIndex: 0 };
    rs.getNormal(Fu, ku, Nu, u.normal), (h.face = u);
  }
  return h;
}
var Za = class extends yt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: a,
      });
    let n = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
    let o = [],
      l = [],
      h = [],
      u = [],
      c = 0,
      d = 0;
    p("z", "y", "x", -1, -1, i, t, e, a, s, 0),
      p("z", "y", "x", 1, -1, i, t, -e, a, s, 1),
      p("x", "z", "y", 1, 1, e, i, t, r, a, 2),
      p("x", "z", "y", 1, -1, e, i, -t, r, a, 3),
      p("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      p("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(o),
      this.setAttribute("position", new ot(l, 3)),
      this.setAttribute("normal", new ot(h, 3)),
      this.setAttribute("uv", new ot(u, 2));
    function p(f, m, g, y, x, b, _, S, M, C, A) {
      let T = b / M,
        P = _ / C,
        R = b / 2,
        z = _ / 2,
        N = S / 2,
        L = M + 1,
        G = C + 1,
        Y = 0,
        Z = 0,
        q = new I();
      for (let oe = 0; oe < G; oe++) {
        let ce = oe * P - z;
        for (let ie = 0; ie < L; ie++) {
          let te = ie * T - R;
          (q[f] = te * y),
            (q[m] = ce * x),
            (q[g] = N),
            l.push(q.x, q.y, q.z),
            (q[f] = 0),
            (q[m] = 0),
            (q[g] = S > 0 ? 1 : -1),
            h.push(q.x, q.y, q.z),
            u.push(ie / M),
            u.push(1 - oe / C),
            (Y += 1);
        }
      }
      for (let oe = 0; oe < C; oe++)
        for (let ce = 0; ce < M; ce++) {
          let ie = c + ce + L * oe,
            te = c + ce + L * (oe + 1),
            ue = c + (ce + 1) + L * (oe + 1),
            ae = c + (ce + 1) + L * oe;
          o.push(ie, te, ae), o.push(te, ue, ae), (Z += 6);
        }
      n.addGroup(d, Z, A), (d += Z), (c += Y);
    }
  }
  static fromJSON(e) {
    return new Za(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
};
function Hc(e) {
  let t = {};
  for (let i in e) {
    t[i] = {};
    for (let r in e[i]) {
      let s = e[i][r];
      s &&
      (s.isColor ||
        s.isMatrix3 ||
        s.isMatrix4 ||
        s.isVector2 ||
        s.isVector3 ||
        s.isVector4 ||
        s.isTexture ||
        s.isQuaternion)
        ? (t[i][r] = s.clone())
        : Array.isArray(s)
        ? (t[i][r] = s.slice())
        : (t[i][r] = s);
    }
  }
  return t;
}
function Ms(e) {
  let t = {};
  for (let i = 0; i < e.length; i++) {
    let r = Hc(e[i]);
    for (let s in r) t[s] = r[s];
  }
  return t;
}
function fR(e) {
  let t = [];
  for (let i = 0; i < e.length; i++) t.push(e[i].clone());
  return t;
}
function tC(e) {
  return e.getRenderTarget() === null && e.outputEncoding === jt ? yn : bm;
}
var au = { clone: Hc, merge: Ms },
  mR = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  gR = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
  vi = class extends sp {
    constructor(e) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader = mR),
        (this.fragmentShader = gR),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        e !== void 0 && this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.fragmentShader = e.fragmentShader),
        (this.vertexShader = e.vertexShader),
        (this.uniforms = Hc(e.uniforms)),
        (this.uniformsGroups = fR(e.uniformsGroups)),
        (this.defines = Object.assign({}, e.defines)),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.fog = e.fog),
        (this.lights = e.lights),
        (this.clipping = e.clipping),
        (this.extensions = Object.assign({}, e.extensions)),
        (this.glslVersion = e.glslVersion),
        this
      );
    }
    toJSON(e) {
      let t = super.toJSON(e);
      (t.glslVersion = this.glslVersion), (t.uniforms = {});
      for (let r in this.uniforms) {
        let s = this.uniforms[r].value;
        s && s.isTexture
          ? (t.uniforms[r] = { type: "t", value: s.toJSON(e).uuid })
          : s && s.isColor
          ? (t.uniforms[r] = { type: "c", value: s.getHex() })
          : s && s.isVector2
          ? (t.uniforms[r] = { type: "v2", value: s.toArray() })
          : s && s.isVector3
          ? (t.uniforms[r] = { type: "v3", value: s.toArray() })
          : s && s.isVector4
          ? (t.uniforms[r] = { type: "v4", value: s.toArray() })
          : s && s.isMatrix3
          ? (t.uniforms[r] = { type: "m3", value: s.toArray() })
          : s && s.isMatrix4
          ? (t.uniforms[r] = { type: "m4", value: s.toArray() })
          : (t.uniforms[r] = { value: s });
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        (t.vertexShader = this.vertexShader),
        (t.fragmentShader = this.fragmentShader);
      let i = {};
      for (let r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
      return Object.keys(i).length > 0 && (t.extensions = i), t;
    }
  },
  gh = class extends _i {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new je()),
        (this.projectionMatrix = new je()),
        (this.projectionMatrixInverse = new je());
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
      );
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(!0, !1);
      let t = this.matrixWorld.elements;
      return e.set(-t[8], -t[9], -t[10]).normalize();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  ds = class extends gh {
    constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = "PerspectiveCamera"),
        (this.fov = e),
        (this.zoom = 1),
        (this.near = i),
        (this.far = r),
        (this.focus = 10),
        (this.aspect = t),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.fov = e.fov),
        (this.zoom = e.zoom),
        (this.near = e.near),
        (this.far = e.far),
        (this.focus = e.focus),
        (this.aspect = e.aspect),
        (this.view = e.view === null ? null : Object.assign({}, e.view)),
        (this.filmGauge = e.filmGauge),
        (this.filmOffset = e.filmOffset),
        this
      );
    }
    setFocalLength(e) {
      let t = (0.5 * this.getFilmHeight()) / e;
      (this.fov = Id * 2 * Math.atan(t)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      let e = Math.tan(xd * 0.5 * this.fov);
      return (0.5 * this.getFilmHeight()) / e;
    }
    getEffectiveFOV() {
      return Id * 2 * Math.atan(Math.tan(xd * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, i, r, s, a) {
      (this.aspect = e / t),
        this.view === null &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = e),
        (this.view.fullHeight = t),
        (this.view.offsetX = i),
        (this.view.offsetY = r),
        (this.view.width = s),
        (this.view.height = a),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let e = this.near,
        t = (e * Math.tan(xd * 0.5 * this.fov)) / this.zoom,
        i = 2 * t,
        r = this.aspect * i,
        s = -0.5 * r,
        a = this.view;
      if (this.view !== null && this.view.enabled) {
        let o = a.fullWidth,
          l = a.fullHeight;
        (s += (a.offsetX * r) / o),
          (t -= (a.offsetY * i) / l),
          (r *= a.width / o),
          (i *= a.height / l);
      }
      let n = this.filmOffset;
      n !== 0 && (s += (e * n) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return (
        (t.object.fov = this.fov),
        (t.object.zoom = this.zoom),
        (t.object.near = this.near),
        (t.object.far = this.far),
        (t.object.focus = this.focus),
        (t.object.aspect = this.aspect),
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        (t.object.filmGauge = this.filmGauge),
        (t.object.filmOffset = this.filmOffset),
        t
      );
    }
  },
  Hh = -90,
  Gh = 1,
  vR = class extends _i {
    constructor(e, t, i) {
      super(), (this.type = "CubeCamera"), (this.renderTarget = i);
      let r = new ds(Hh, Gh, e, t);
      (r.layers = this.layers),
        r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        this.add(r);
      let s = new ds(Hh, Gh, e, t);
      (s.layers = this.layers),
        s.up.set(0, 1, 0),
        s.lookAt(-1, 0, 0),
        this.add(s);
      let a = new ds(Hh, Gh, e, t);
      (a.layers = this.layers),
        a.up.set(0, 0, -1),
        a.lookAt(0, 1, 0),
        this.add(a);
      let n = new ds(Hh, Gh, e, t);
      (n.layers = this.layers),
        n.up.set(0, 0, 1),
        n.lookAt(0, -1, 0),
        this.add(n);
      let o = new ds(Hh, Gh, e, t);
      (o.layers = this.layers),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        this.add(o);
      let l = new ds(Hh, Gh, e, t);
      (l.layers = this.layers),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1),
        this.add(l);
    }
    update(e, t) {
      this.parent === null && this.updateMatrixWorld();
      let i = this.renderTarget,
        [r, s, a, n, o, l] = this.children,
        h = e.getRenderTarget(),
        u = e.toneMapping,
        c = e.xr.enabled;
      (e.toneMapping = Tn), (e.xr.enabled = !1);
      let d = i.texture.generateMipmaps;
      (i.texture.generateMipmaps = !1),
        e.setRenderTarget(i, 0),
        e.render(t, r),
        e.setRenderTarget(i, 1),
        e.render(t, s),
        e.setRenderTarget(i, 2),
        e.render(t, a),
        e.setRenderTarget(i, 3),
        e.render(t, n),
        e.setRenderTarget(i, 4),
        e.render(t, o),
        (i.texture.generateMipmaps = d),
        e.setRenderTarget(i, 5),
        e.render(t, l),
        e.setRenderTarget(h),
        (e.toneMapping = u),
        (e.xr.enabled = c),
        (i.texture.needsPMREMUpdate = !0);
    }
  },
  yx = class extends Yi {
    constructor(e, t, i, r, s, a, n, o, l, h) {
      (e = e !== void 0 ? e : []),
        (t = t !== void 0 ? t : nh),
        super(e, t, i, r, s, a, n, o, l, h),
        (this.isCubeTexture = !0),
        (this.flipY = !1);
    }
    get images() {
      return this.image;
    }
    set images(e) {
      this.image = e;
    }
  },
  yR = class extends gi {
    constructor(e = 1, t = {}) {
      super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
      let i = { width: e, height: e, depth: 1 },
        r = [i, i, i, i, i, i];
      (this.texture = new yx(
        r,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.encoding
      )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
        (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Wt);
    }
    fromEquirectangularTexture(e, t) {
      (this.texture.type = t.type),
        (this.texture.encoding = t.encoding),
        (this.texture.generateMipmaps = t.generateMipmaps),
        (this.texture.minFilter = t.minFilter),
        (this.texture.magFilter = t.magFilter);
      let i = {
          uniforms: { tEquirect: { value: null } },
          vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
          fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
        },
        r = new Za(5, 5, 5),
        s = new vi({
          name: "CubemapFromEquirect",
          uniforms: Hc(i.uniforms),
          vertexShader: i.vertexShader,
          fragmentShader: i.fragmentShader,
          side: Yr,
          blending: wr,
        });
      s.uniforms.tEquirect.value = t;
      let a = new br(r, s),
        n = t.minFilter;
      return (
        t.minFilter === jc && (t.minFilter = Wt),
        new vR(1, 10, this).update(e, a),
        (t.minFilter = n),
        a.geometry.dispose(),
        a.material.dispose(),
        this
      );
    }
    clear(e, t, i, r) {
      let s = e.getRenderTarget();
      for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, r);
      e.setRenderTarget(s);
    }
  },
  Iv = new I(),
  xR = new I(),
  bR = new lr(),
  Ks = class {
    constructor(e = new I(1, 0, 0), t = 0) {
      (this.isPlane = !0), (this.normal = e), (this.constant = t);
    }
    set(e, t) {
      return this.normal.copy(e), (this.constant = t), this;
    }
    setComponents(e, t, i, r) {
      return this.normal.set(e, t, i), (this.constant = r), this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    }
    setFromCoplanarPoints(e, t, i) {
      let r = Iv.subVectors(i, t).cross(xR.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(r, e), this;
    }
    copy(e) {
      return this.normal.copy(e.normal), (this.constant = e.constant), this;
    }
    normalize() {
      let e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), (this.constant *= e), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return t
        .copy(this.normal)
        .multiplyScalar(-this.distanceToPoint(e))
        .add(e);
    }
    intersectLine(e, t) {
      let i = e.delta(Iv),
        r = this.normal.dot(i);
      if (r === 0)
        return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
      let s = -(e.start.dot(this.normal) + this.constant) / r;
      return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start);
    }
    intersectsLine(e) {
      let t = this.distanceToPoint(e.start),
        i = this.distanceToPoint(e.end);
      return (t < 0 && i > 0) || (i < 0 && t > 0);
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
      let i = t || bR.getNormalMatrix(e),
        r = this.coplanarPoint(Iv).applyMatrix4(e),
        s = this.normal.applyMatrix3(i).normalize();
      return (this.constant = -r.dot(s)), this;
    }
    translate(e) {
      return (this.constant -= e.dot(this.normal)), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  Wh = new Ws(),
  Qp = new I(),
  xx = class {
    constructor(
      e = new Ks(),
      t = new Ks(),
      i = new Ks(),
      r = new Ks(),
      s = new Ks(),
      a = new Ks()
    ) {
      this.planes = [e, t, i, r, s, a];
    }
    set(e, t, i, r, s, a) {
      let n = this.planes;
      return (
        n[0].copy(e),
        n[1].copy(t),
        n[2].copy(i),
        n[3].copy(r),
        n[4].copy(s),
        n[5].copy(a),
        this
      );
    }
    copy(e) {
      let t = this.planes;
      for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
      return this;
    }
    setFromProjectionMatrix(e) {
      let t = this.planes,
        i = e.elements,
        r = i[0],
        s = i[1],
        a = i[2],
        n = i[3],
        o = i[4],
        l = i[5],
        h = i[6],
        u = i[7],
        c = i[8],
        d = i[9],
        p = i[10],
        f = i[11],
        m = i[12],
        g = i[13],
        y = i[14],
        x = i[15];
      return (
        t[0].setComponents(n - r, u - o, f - c, x - m).normalize(),
        t[1].setComponents(n + r, u + o, f + c, x + m).normalize(),
        t[2].setComponents(n + s, u + l, f + d, x + g).normalize(),
        t[3].setComponents(n - s, u - l, f - d, x - g).normalize(),
        t[4].setComponents(n - a, u - h, f - p, x - y).normalize(),
        t[5].setComponents(n + a, u + h, f + p, x + y).normalize(),
        this
      );
    }
    intersectsObject(e) {
      let t = e.geometry;
      return (
        t.boundingSphere === null && t.computeBoundingSphere(),
        Wh.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Wh)
      );
    }
    intersectsSprite(e) {
      return (
        Wh.center.set(0, 0, 0),
        (Wh.radius = 0.7071067811865476),
        Wh.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Wh)
      );
    }
    intersectsSphere(e) {
      let t = this.planes,
        i = e.center,
        r = -e.radius;
      for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
      return !0;
    }
    intersectsBox(e) {
      let t = this.planes;
      for (let i = 0; i < 6; i++) {
        let r = t[i];
        if (
          ((Qp.x = r.normal.x > 0 ? e.max.x : e.min.x),
          (Qp.y = r.normal.y > 0 ? e.max.y : e.min.y),
          (Qp.z = r.normal.z > 0 ? e.max.z : e.min.z),
          r.distanceToPoint(Qp) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(e) {
      let t = this.planes;
      for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
function iC() {
  let e = null,
    t = !1,
    i = null,
    r = null;
  function s(a, n) {
    i(a, n), (r = e.requestAnimationFrame(s));
  }
  return {
    start: function () {
      t !== !0 && i !== null && ((r = e.requestAnimationFrame(s)), (t = !0));
    },
    stop: function () {
      e.cancelAnimationFrame(r), (t = !1);
    },
    setAnimationLoop: function (a) {
      i = a;
    },
    setContext: function (a) {
      e = a;
    },
  };
}
function wR(e, t) {
  let i = t.isWebGL2,
    r = new WeakMap();
  function s(h, u) {
    let c = h.array,
      d = h.usage,
      p = e.createBuffer();
    e.bindBuffer(u, p), e.bufferData(u, c, d), h.onUploadCallback();
    let f;
    if (c instanceof Float32Array) f = 5126;
    else if (c instanceof Uint16Array)
      if (h.isFloat16BufferAttribute)
        if (i) f = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else f = 5123;
    else if (c instanceof Int16Array) f = 5122;
    else if (c instanceof Uint32Array) f = 5125;
    else if (c instanceof Int32Array) f = 5124;
    else if (c instanceof Int8Array) f = 5120;
    else if (c instanceof Uint8Array) f = 5121;
    else if (c instanceof Uint8ClampedArray) f = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: p,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: h.version,
    };
  }
  function a(h, u, c) {
    let d = u.array,
      p = u.updateRange;
    e.bindBuffer(c, h),
      p.count === -1
        ? e.bufferSubData(c, 0, d)
        : (i
            ? e.bufferSubData(
                c,
                p.offset * d.BYTES_PER_ELEMENT,
                d,
                p.offset,
                p.count
              )
            : e.bufferSubData(
                c,
                p.offset * d.BYTES_PER_ELEMENT,
                d.subarray(p.offset, p.offset + p.count)
              ),
          (p.count = -1)),
      u.onUploadCallback();
  }
  function n(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), r.get(h);
  }
  function o(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    let u = r.get(h);
    u && (e.deleteBuffer(u.buffer), r.delete(h));
  }
  function l(h, u) {
    if (h.isGLBufferAttribute) {
      let d = r.get(h);
      (!d || d.version < h.version) &&
        r.set(h, {
          buffer: h.buffer,
          type: h.type,
          bytesPerElement: h.elementSize,
          version: h.version,
        });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    let c = r.get(h);
    c === void 0
      ? r.set(h, s(h, u))
      : c.version < h.version && (a(c.buffer, h, u), (c.version = h.version));
  }
  return { get: n, remove: o, update: l };
}
var vh = class extends yt {
    constructor(e = 1, t = 1, i = 1, r = 1) {
      super(),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: e,
          height: t,
          widthSegments: i,
          heightSegments: r,
        });
      let s = e / 2,
        a = t / 2,
        n = Math.floor(i),
        o = Math.floor(r),
        l = n + 1,
        h = o + 1,
        u = e / n,
        c = t / o,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let g = 0; g < h; g++) {
        let y = g * c - a;
        for (let x = 0; x < l; x++) {
          let b = x * u - s;
          p.push(b, -y, 0), f.push(0, 0, 1), m.push(x / n), m.push(1 - g / o);
        }
      }
      for (let g = 0; g < o; g++)
        for (let y = 0; y < n; y++) {
          let x = y + l * g,
            b = y + l * (g + 1),
            _ = y + 1 + l * (g + 1),
            S = y + 1 + l * g;
          d.push(x, b, S), d.push(b, _, S);
        }
      this.setIndex(d),
        this.setAttribute("position", new ot(p, 3)),
        this.setAttribute("normal", new ot(f, 3)),
        this.setAttribute("uv", new ot(m, 2));
    }
    static fromJSON(e) {
      return new vh(e.width, e.height, e.widthSegments, e.heightSegments);
    }
  },
  _R = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  SR = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  AR = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  MR = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  ER = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  CR = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  TR = "vec3 transformed = vec3( position );",
  PR = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  DR = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  OR = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  IR = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  RR = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  LR = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  BR = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  zR = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  FR = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  kR = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  NR = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  UR = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  VR = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  jR = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  HR = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  GR = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  WR = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  qR = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  YR = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  XR = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  QR = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  ZR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  KR = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  JR = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  $R = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  eL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  tL = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  iL = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  rL = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  sL = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  aL = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  nL = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  oL = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  lL = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  hL = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  cL = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  uL = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  dL = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  pL = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  fL = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  mL = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  gL = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  vL = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  yL = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  xL = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  bL = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  wL = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  _L = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  SL = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  AL = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  ML = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  EL = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  CL = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  TL = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  PL = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  DL = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  OL = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  IL = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  RL = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  LL = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  BL = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  zL = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  FL = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  kL = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  NL = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  UL = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  VL = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  jL = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  HL = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  GL = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  WL = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  qL = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  YL = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  XL = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  QL = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  ZL = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  KL = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  JL = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  $L = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  e4 = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  t4 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  i4 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  r4 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  s4 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  a4 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  n4 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  o4 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  l4 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  h4 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  c4 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  u4 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  d4 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  p4 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  f4 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  m4 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  g4 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  v4 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  y4 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  x4 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
  b4 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  w4 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  _4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  S4 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  A4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  M4 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  E4 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  C4 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  T4 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  P4 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  D4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  O4 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  I4 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  R4 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  L4 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  B4 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  z4 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  F4 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  k4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  N4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  U4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  V4 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  j4 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  H4 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  G4 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  W4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  q4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Y4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  X4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  Q4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Z4 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  K4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  J4 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  $4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Gt = {
    alphamap_fragment: _R,
    alphamap_pars_fragment: SR,
    alphatest_fragment: AR,
    alphatest_pars_fragment: MR,
    aomap_fragment: ER,
    aomap_pars_fragment: CR,
    begin_vertex: TR,
    beginnormal_vertex: PR,
    bsdfs: DR,
    iridescence_fragment: OR,
    bumpmap_pars_fragment: IR,
    clipping_planes_fragment: RR,
    clipping_planes_pars_fragment: LR,
    clipping_planes_pars_vertex: BR,
    clipping_planes_vertex: zR,
    color_fragment: FR,
    color_pars_fragment: kR,
    color_pars_vertex: NR,
    color_vertex: UR,
    common: VR,
    cube_uv_reflection_fragment: jR,
    defaultnormal_vertex: HR,
    displacementmap_pars_vertex: GR,
    displacementmap_vertex: WR,
    emissivemap_fragment: qR,
    emissivemap_pars_fragment: YR,
    encodings_fragment: XR,
    encodings_pars_fragment: QR,
    envmap_fragment: ZR,
    envmap_common_pars_fragment: KR,
    envmap_pars_fragment: JR,
    envmap_pars_vertex: $R,
    envmap_physical_pars_fragment: uL,
    envmap_vertex: eL,
    fog_vertex: tL,
    fog_pars_vertex: iL,
    fog_fragment: rL,
    fog_pars_fragment: sL,
    gradientmap_pars_fragment: aL,
    lightmap_fragment: nL,
    lightmap_pars_fragment: oL,
    lights_lambert_fragment: lL,
    lights_lambert_pars_fragment: hL,
    lights_pars_begin: cL,
    lights_toon_fragment: dL,
    lights_toon_pars_fragment: pL,
    lights_phong_fragment: fL,
    lights_phong_pars_fragment: mL,
    lights_physical_fragment: gL,
    lights_physical_pars_fragment: vL,
    lights_fragment_begin: yL,
    lights_fragment_maps: xL,
    lights_fragment_end: bL,
    logdepthbuf_fragment: wL,
    logdepthbuf_pars_fragment: _L,
    logdepthbuf_pars_vertex: SL,
    logdepthbuf_vertex: AL,
    map_fragment: ML,
    map_pars_fragment: EL,
    map_particle_fragment: CL,
    map_particle_pars_fragment: TL,
    metalnessmap_fragment: PL,
    metalnessmap_pars_fragment: DL,
    morphcolor_vertex: OL,
    morphnormal_vertex: IL,
    morphtarget_pars_vertex: RL,
    morphtarget_vertex: LL,
    normal_fragment_begin: BL,
    normal_fragment_maps: zL,
    normal_pars_fragment: FL,
    normal_pars_vertex: kL,
    normal_vertex: NL,
    normalmap_pars_fragment: UL,
    clearcoat_normal_fragment_begin: VL,
    clearcoat_normal_fragment_maps: jL,
    clearcoat_pars_fragment: HL,
    iridescence_pars_fragment: GL,
    output_fragment: WL,
    packing: qL,
    premultiplied_alpha_fragment: YL,
    project_vertex: XL,
    dithering_fragment: QL,
    dithering_pars_fragment: ZL,
    roughnessmap_fragment: KL,
    roughnessmap_pars_fragment: JL,
    shadowmap_pars_fragment: $L,
    shadowmap_pars_vertex: e4,
    shadowmap_vertex: t4,
    shadowmask_pars_fragment: i4,
    skinbase_vertex: r4,
    skinning_pars_vertex: s4,
    skinning_vertex: a4,
    skinnormal_vertex: n4,
    specularmap_fragment: o4,
    specularmap_pars_fragment: l4,
    tonemapping_fragment: h4,
    tonemapping_pars_fragment: c4,
    transmission_fragment: u4,
    transmission_pars_fragment: d4,
    uv_pars_fragment: p4,
    uv_pars_vertex: f4,
    uv_vertex: m4,
    uv2_pars_fragment: g4,
    uv2_pars_vertex: v4,
    uv2_vertex: y4,
    worldpos_vertex: x4,
    background_vert: b4,
    background_frag: w4,
    backgroundCube_vert: _4,
    backgroundCube_frag: S4,
    cube_vert: A4,
    cube_frag: M4,
    depth_vert: E4,
    depth_frag: C4,
    distanceRGBA_vert: T4,
    distanceRGBA_frag: P4,
    equirect_vert: D4,
    equirect_frag: O4,
    linedashed_vert: I4,
    linedashed_frag: R4,
    meshbasic_vert: L4,
    meshbasic_frag: B4,
    meshlambert_vert: z4,
    meshlambert_frag: F4,
    meshmatcap_vert: k4,
    meshmatcap_frag: N4,
    meshnormal_vert: U4,
    meshnormal_frag: V4,
    meshphong_vert: j4,
    meshphong_frag: H4,
    meshphysical_vert: G4,
    meshphysical_frag: W4,
    meshtoon_vert: q4,
    meshtoon_frag: Y4,
    points_vert: X4,
    points_frag: Q4,
    shadow_vert: Z4,
    shadow_frag: K4,
    sprite_vert: J4,
    sprite_frag: $4,
  },
  et = {
    common: {
      diffuse: { value: new Et(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new lr() },
      uv2Transform: { value: new lr() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new re(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Et(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Et(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new lr() },
    },
    sprite: {
      diffuse: { value: new Et(16777215) },
      opacity: { value: 1 },
      center: { value: new re(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new lr() },
    },
  },
  bn = {
    basic: {
      uniforms: Ms([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.fog,
      ]),
      vertexShader: Gt.meshbasic_vert,
      fragmentShader: Gt.meshbasic_frag,
    },
    lambert: {
      uniforms: Ms([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        et.lights,
        { emissive: { value: new Et(0) } },
      ]),
      vertexShader: Gt.meshlambert_vert,
      fragmentShader: Gt.meshlambert_frag,
    },
    phong: {
      uniforms: Ms([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        et.lights,
        {
          emissive: { value: new Et(0) },
          specular: { value: new Et(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Gt.meshphong_vert,
      fragmentShader: Gt.meshphong_frag,
    },
    standard: {
      uniforms: Ms([
        et.common,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.roughnessmap,
        et.metalnessmap,
        et.fog,
        et.lights,
        {
          emissive: { value: new Et(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Gt.meshphysical_vert,
      fragmentShader: Gt.meshphysical_frag,
    },
    toon: {
      uniforms: Ms([
        et.common,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.gradientmap,
        et.fog,
        et.lights,
        { emissive: { value: new Et(0) } },
      ]),
      vertexShader: Gt.meshtoon_vert,
      fragmentShader: Gt.meshtoon_frag,
    },
    matcap: {
      uniforms: Ms([
        et.common,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Gt.meshmatcap_vert,
      fragmentShader: Gt.meshmatcap_frag,
    },
    points: {
      uniforms: Ms([et.points, et.fog]),
      vertexShader: Gt.points_vert,
      fragmentShader: Gt.points_frag,
    },
    dashed: {
      uniforms: Ms([
        et.common,
        et.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Gt.linedashed_vert,
      fragmentShader: Gt.linedashed_frag,
    },
    depth: {
      uniforms: Ms([et.common, et.displacementmap]),
      vertexShader: Gt.depth_vert,
      fragmentShader: Gt.depth_frag,
    },
    normal: {
      uniforms: Ms([
        et.common,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Gt.meshnormal_vert,
      fragmentShader: Gt.meshnormal_frag,
    },
    sprite: {
      uniforms: Ms([et.sprite, et.fog]),
      vertexShader: Gt.sprite_vert,
      fragmentShader: Gt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new lr() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Gt.background_vert,
      fragmentShader: Gt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Gt.backgroundCube_vert,
      fragmentShader: Gt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Gt.cube_vert,
      fragmentShader: Gt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Gt.equirect_vert,
      fragmentShader: Gt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Ms([
        et.common,
        et.displacementmap,
        {
          referencePosition: { value: new I() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Gt.distanceRGBA_vert,
      fragmentShader: Gt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Ms([
        et.lights,
        et.fog,
        { color: { value: new Et(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Gt.shadow_vert,
      fragmentShader: Gt.shadow_frag,
    },
  };
bn.physical = {
  uniforms: Ms([
    bn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new re(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Et(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new re() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Et(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Et(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: Gt.meshphysical_vert,
  fragmentShader: Gt.meshphysical_frag,
};
var Zp = { r: 0, b: 0, g: 0 };
function eB(e, t, i, r, s, a, n) {
  let o = new Et(0),
    l = a === !0 ? 0 : 1,
    h,
    u,
    c = null,
    d = 0,
    p = null;
  function f(g, y) {
    let x = !1,
      b = y.isScene === !0 ? y.background : null;
    b && b.isTexture && (b = (y.backgroundBlurriness > 0 ? i : t).get(b));
    let _ = e.xr,
      S = _.getSession && _.getSession();
    S && S.environmentBlendMode === "additive" && (b = null),
      b === null ? m(o, l) : b && b.isColor && (m(b, 1), (x = !0)),
      (e.autoClear || x) &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
      b && (b.isCubeTexture || b.mapping === rp)
        ? (u === void 0 &&
            ((u = new br(
              new Za(1, 1, 1),
              new vi({
                name: "BackgroundCubeMaterial",
                uniforms: Hc(bn.backgroundCube.uniforms),
                vertexShader: bn.backgroundCube.vertexShader,
                fragmentShader: bn.backgroundCube.fragmentShader,
                side: Yr,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (M, C, A) {
              this.matrixWorld.copyPosition(A.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            s.update(u)),
          (u.material.uniforms.envMap.value = b),
          (u.material.uniforms.flipEnvMap.value =
            b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1),
          (u.material.uniforms.backgroundBlurriness.value =
            y.backgroundBlurriness),
          (u.material.uniforms.backgroundIntensity.value =
            y.backgroundIntensity),
          (u.material.toneMapped = b.encoding !== jt),
          (c !== b || d !== b.version || p !== e.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (c = b),
            (d = b.version),
            (p = e.toneMapping)),
          u.layers.enableAll(),
          g.unshift(u, u.geometry, u.material, 0, 0, null))
        : b &&
          b.isTexture &&
          (h === void 0 &&
            ((h = new br(
              new vh(2, 2),
              new vi({
                name: "BackgroundMaterial",
                uniforms: Hc(bn.background.uniforms),
                vertexShader: bn.background.vertexShader,
                fragmentShader: bn.background.fragmentShader,
                side: Xa,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            Object.defineProperty(h.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            s.update(h)),
          (h.material.uniforms.t2D.value = b),
          (h.material.uniforms.backgroundIntensity.value =
            y.backgroundIntensity),
          (h.material.toneMapped = b.encoding !== jt),
          b.matrixAutoUpdate === !0 && b.updateMatrix(),
          h.material.uniforms.uvTransform.value.copy(b.matrix),
          (c !== b || d !== b.version || p !== e.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (c = b),
            (d = b.version),
            (p = e.toneMapping)),
          h.layers.enableAll(),
          g.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function m(g, y) {
    g.getRGB(Zp, tC(e)), r.buffers.color.setClear(Zp.r, Zp.g, Zp.b, y, n);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (g, y = 1) {
      o.set(g), (l = y), m(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (g) {
      (l = g), m(o, l);
    },
    render: f,
  };
}
function tB(e, t, i, r) {
  let s = e.getParameter(34921),
    a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
    n = r.isWebGL2 || a !== null,
    o = {},
    l = g(null),
    h = l,
    u = !1;
  function c(L, G, Y, Z, q) {
    let oe = !1;
    if (n) {
      let ce = m(Z, Y, G);
      h !== ce && ((h = ce), p(h.object)),
        (oe = y(L, Z, Y, q)),
        oe && x(L, Z, Y, q);
    } else {
      let ce = G.wireframe === !0;
      (h.geometry !== Z.id || h.program !== Y.id || h.wireframe !== ce) &&
        ((h.geometry = Z.id),
        (h.program = Y.id),
        (h.wireframe = ce),
        (oe = !0));
    }
    q !== null && i.update(q, 34963),
      (oe || u) &&
        ((u = !1),
        A(L, G, Y, Z),
        q !== null && e.bindBuffer(34963, i.get(q).buffer));
  }
  function d() {
    return r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES();
  }
  function p(L) {
    return r.isWebGL2 ? e.bindVertexArray(L) : a.bindVertexArrayOES(L);
  }
  function f(L) {
    return r.isWebGL2 ? e.deleteVertexArray(L) : a.deleteVertexArrayOES(L);
  }
  function m(L, G, Y) {
    let Z = Y.wireframe === !0,
      q = o[L.id];
    q === void 0 && ((q = {}), (o[L.id] = q));
    let oe = q[G.id];
    oe === void 0 && ((oe = {}), (q[G.id] = oe));
    let ce = oe[Z];
    return ce === void 0 && ((ce = g(d())), (oe[Z] = ce)), ce;
  }
  function g(L) {
    let G = [],
      Y = [],
      Z = [];
    for (let q = 0; q < s; q++) (G[q] = 0), (Y[q] = 0), (Z[q] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: G,
      enabledAttributes: Y,
      attributeDivisors: Z,
      object: L,
      attributes: {},
      index: null,
    };
  }
  function y(L, G, Y, Z) {
    let q = h.attributes,
      oe = G.attributes,
      ce = 0,
      ie = Y.getAttributes();
    for (let te in ie)
      if (ie[te].location >= 0) {
        let ue = q[te],
          ae = oe[te];
        if (
          (ae === void 0 &&
            (te === "instanceMatrix" &&
              L.instanceMatrix &&
              (ae = L.instanceMatrix),
            te === "instanceColor" &&
              L.instanceColor &&
              (ae = L.instanceColor)),
          ue === void 0 || ue.attribute !== ae || (ae && ue.data !== ae.data))
        )
          return !0;
        ce++;
      }
    return h.attributesNum !== ce || h.index !== Z;
  }
  function x(L, G, Y, Z) {
    let q = {},
      oe = G.attributes,
      ce = 0,
      ie = Y.getAttributes();
    for (let te in ie)
      if (ie[te].location >= 0) {
        let ue = oe[te];
        ue === void 0 &&
          (te === "instanceMatrix" &&
            L.instanceMatrix &&
            (ue = L.instanceMatrix),
          te === "instanceColor" && L.instanceColor && (ue = L.instanceColor));
        let ae = {};
        (ae.attribute = ue),
          ue && ue.data && (ae.data = ue.data),
          (q[te] = ae),
          ce++;
      }
    (h.attributes = q), (h.attributesNum = ce), (h.index = Z);
  }
  function b() {
    let L = h.newAttributes;
    for (let G = 0, Y = L.length; G < Y; G++) L[G] = 0;
  }
  function _(L) {
    S(L, 0);
  }
  function S(L, G) {
    let Y = h.newAttributes,
      Z = h.enabledAttributes,
      q = h.attributeDivisors;
    (Y[L] = 1),
      Z[L] === 0 && (e.enableVertexAttribArray(L), (Z[L] = 1)),
      q[L] !== G &&
        ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
          r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](L, G),
        (q[L] = G));
  }
  function M() {
    let L = h.newAttributes,
      G = h.enabledAttributes;
    for (let Y = 0, Z = G.length; Y < Z; Y++)
      G[Y] !== L[Y] && (e.disableVertexAttribArray(Y), (G[Y] = 0));
  }
  function C(L, G, Y, Z, q, oe) {
    r.isWebGL2 === !0 && (Y === 5124 || Y === 5125)
      ? e.vertexAttribIPointer(L, G, Y, q, oe)
      : e.vertexAttribPointer(L, G, Y, Z, q, oe);
  }
  function A(L, G, Y, Z) {
    if (
      r.isWebGL2 === !1 &&
      (L.isInstancedMesh || Z.isInstancedBufferGeometry) &&
      t.get("ANGLE_instanced_arrays") === null
    )
      return;
    b();
    let q = Z.attributes,
      oe = Y.getAttributes(),
      ce = G.defaultAttributeValues;
    for (let ie in oe) {
      let te = oe[ie];
      if (te.location >= 0) {
        let ue = q[ie];
        if (
          (ue === void 0 &&
            (ie === "instanceMatrix" &&
              L.instanceMatrix &&
              (ue = L.instanceMatrix),
            ie === "instanceColor" &&
              L.instanceColor &&
              (ue = L.instanceColor)),
          ue !== void 0)
        ) {
          let ae = ue.normalized,
            de = ue.itemSize,
            ne = i.get(ue);
          if (ne === void 0) continue;
          let Ee = ne.buffer,
            me = ne.type,
            Ae = ne.bytesPerElement;
          if (ue.isInterleavedBufferAttribute) {
            let ye = ue.data,
              Ue = ye.stride,
              Le = ue.offset;
            if (ye.isInstancedInterleavedBuffer) {
              for (let Te = 0; Te < te.locationSize; Te++)
                S(te.location + Te, ye.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                Z._maxInstanceCount === void 0 &&
                (Z._maxInstanceCount = ye.meshPerAttribute * ye.count);
            } else
              for (let Te = 0; Te < te.locationSize; Te++) _(te.location + Te);
            e.bindBuffer(34962, Ee);
            for (let Te = 0; Te < te.locationSize; Te++)
              C(
                te.location + Te,
                de / te.locationSize,
                me,
                ae,
                Ue * Ae,
                (Le + (de / te.locationSize) * Te) * Ae
              );
          } else {
            if (ue.isInstancedBufferAttribute) {
              for (let ye = 0; ye < te.locationSize; ye++)
                S(te.location + ye, ue.meshPerAttribute);
              L.isInstancedMesh !== !0 &&
                Z._maxInstanceCount === void 0 &&
                (Z._maxInstanceCount = ue.meshPerAttribute * ue.count);
            } else
              for (let ye = 0; ye < te.locationSize; ye++) _(te.location + ye);
            e.bindBuffer(34962, Ee);
            for (let ye = 0; ye < te.locationSize; ye++)
              C(
                te.location + ye,
                de / te.locationSize,
                me,
                ae,
                de * Ae,
                (de / te.locationSize) * ye * Ae
              );
          }
        } else if (ce !== void 0) {
          let ae = ce[ie];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                e.vertexAttrib2fv(te.location, ae);
                break;
              case 3:
                e.vertexAttrib3fv(te.location, ae);
                break;
              case 4:
                e.vertexAttrib4fv(te.location, ae);
                break;
              default:
                e.vertexAttrib1fv(te.location, ae);
            }
        }
      }
    }
    M();
  }
  function T() {
    z();
    for (let L in o) {
      let G = o[L];
      for (let Y in G) {
        let Z = G[Y];
        for (let q in Z) f(Z[q].object), delete Z[q];
        delete G[Y];
      }
      delete o[L];
    }
  }
  function P(L) {
    if (o[L.id] === void 0) return;
    let G = o[L.id];
    for (let Y in G) {
      let Z = G[Y];
      for (let q in Z) f(Z[q].object), delete Z[q];
      delete G[Y];
    }
    delete o[L.id];
  }
  function R(L) {
    for (let G in o) {
      let Y = o[G];
      if (Y[L.id] === void 0) continue;
      let Z = Y[L.id];
      for (let q in Z) f(Z[q].object), delete Z[q];
      delete Y[L.id];
    }
  }
  function z() {
    N(), (u = !0), h !== l && ((h = l), p(h.object));
  }
  function N() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: c,
    reset: z,
    resetDefaultState: N,
    dispose: T,
    releaseStatesOfGeometry: P,
    releaseStatesOfProgram: R,
    initAttributes: b,
    enableAttribute: _,
    disableUnusedAttributes: M,
  };
}
function iB(e, t, i, r) {
  let s = r.isWebGL2,
    a;
  function n(h) {
    a = h;
  }
  function o(h, u) {
    e.drawArrays(a, h, u), i.update(u, a, 1);
  }
  function l(h, u, c) {
    if (c === 0) return;
    let d, p;
    if (s) (d = e), (p = "drawArraysInstanced");
    else if (
      ((d = t.get("ANGLE_instanced_arrays")),
      (p = "drawArraysInstancedANGLE"),
      d === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    d[p](a, h, u, c), i.update(u, a, c);
  }
  (this.setMode = n), (this.render = o), (this.renderInstances = l);
}
function rB(e, t, i) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      let C = t.get("EXT_texture_filter_anisotropic");
      r = e.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function a(C) {
    if (C === "highp") {
      if (
        e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        e.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      C = "mediump";
    }
    return C === "mediump" &&
      e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      e.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  let n =
      typeof WebGL2RenderingContext < "u" &&
      e instanceof WebGL2RenderingContext,
    o = i.precision !== void 0 ? i.precision : "highp",
    l = a(o);
  l !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      l,
      "instead."
    ),
    (o = l));
  let h = n || t.has("WEBGL_draw_buffers"),
    u = i.logarithmicDepthBuffer === !0,
    c = e.getParameter(34930),
    d = e.getParameter(35660),
    p = e.getParameter(3379),
    f = e.getParameter(34076),
    m = e.getParameter(34921),
    g = e.getParameter(36347),
    y = e.getParameter(36348),
    x = e.getParameter(36349),
    b = d > 0,
    _ = n || t.has("OES_texture_float"),
    S = b && _,
    M = n ? e.getParameter(36183) : 0;
  return {
    isWebGL2: n,
    drawBuffers: h,
    getMaxAnisotropy: s,
    getMaxPrecision: a,
    precision: o,
    logarithmicDepthBuffer: u,
    maxTextures: c,
    maxVertexTextures: d,
    maxTextureSize: p,
    maxCubemapSize: f,
    maxAttributes: m,
    maxVertexUniforms: g,
    maxVaryings: y,
    maxFragmentUniforms: x,
    vertexTextures: b,
    floatFragmentTextures: _,
    floatVertexTextures: S,
    maxSamples: M,
  };
}
function sB(e) {
  let t = this,
    i = null,
    r = 0,
    s = !1,
    a = !1,
    n = new Ks(),
    o = new lr(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (c, d) {
      let p = c.length !== 0 || d || r !== 0 || s;
      return (s = d), (r = c.length), p;
    }),
    (this.beginShadows = function () {
      (a = !0), u(null);
    }),
    (this.endShadows = function () {
      a = !1;
    }),
    (this.setGlobalState = function (c, d) {
      i = u(c, d, 0);
    }),
    (this.setState = function (c, d, p) {
      let f = c.clippingPlanes,
        m = c.clipIntersection,
        g = c.clipShadows,
        y = e.get(c);
      if (!s || f === null || f.length === 0 || (a && !g)) a ? u(null) : h();
      else {
        let x = a ? 0 : r,
          b = x * 4,
          _ = y.clippingState || null;
        (l.value = _), (_ = u(f, d, b, p));
        for (let S = 0; S !== b; ++S) _[S] = i[S];
        (y.clippingState = _),
          (this.numIntersection = m ? this.numPlanes : 0),
          (this.numPlanes += x);
      }
    });
  function h() {
    l.value !== i && ((l.value = i), (l.needsUpdate = r > 0)),
      (t.numPlanes = r),
      (t.numIntersection = 0);
  }
  function u(c, d, p, f) {
    let m = c !== null ? c.length : 0,
      g = null;
    if (m !== 0) {
      if (((g = l.value), f !== !0 || g === null)) {
        let y = p + m * 4,
          x = d.matrixWorldInverse;
        o.getNormalMatrix(x),
          (g === null || g.length < y) && (g = new Float32Array(y));
        for (let b = 0, _ = p; b !== m; ++b, _ += 4)
          n.copy(c[b]).applyMatrix4(x, o),
            n.normal.toArray(g, _),
            (g[_ + 3] = n.constant);
      }
      (l.value = g), (l.needsUpdate = !0);
    }
    return (t.numPlanes = m), (t.numIntersection = 0), g;
  }
}
function aB(e) {
  let t = new WeakMap();
  function i(n, o) {
    return o === uy ? (n.mapping = nh) : o === dy && (n.mapping = oh), n;
  }
  function r(n) {
    if (n && n.isTexture && n.isRenderTargetTexture === !1) {
      let o = n.mapping;
      if (o === uy || o === dy)
        if (t.has(n)) {
          let l = t.get(n).texture;
          return i(l, n.mapping);
        } else {
          let l = n.image;
          if (l && l.height > 0) {
            let h = new yR(l.height / 2);
            return (
              h.fromEquirectangularTexture(e, n),
              t.set(n, h),
              n.addEventListener("dispose", s),
              i(h.texture, n.mapping)
            );
          } else return null;
        }
    }
    return n;
  }
  function s(n) {
    let o = n.target;
    o.removeEventListener("dispose", s);
    let l = t.get(o);
    l !== void 0 && (t.delete(o), l.dispose());
  }
  function a() {
    t = new WeakMap();
  }
  return { get: r, dispose: a };
}
var bx = class extends gh {
    constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = e),
        (this.right = t),
        (this.top = i),
        (this.bottom = r),
        (this.near = s),
        (this.far = a),
        this.updateProjectionMatrix();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.left = e.left),
        (this.right = e.right),
        (this.top = e.top),
        (this.bottom = e.bottom),
        (this.near = e.near),
        (this.far = e.far),
        (this.zoom = e.zoom),
        (this.view = e.view === null ? null : Object.assign({}, e.view)),
        this
      );
    }
    setViewOffset(e, t, i, r, s, a) {
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = e),
        (this.view.fullHeight = t),
        (this.view.offsetX = i),
        (this.view.offsetY = r),
        (this.view.width = s),
        (this.view.height = a),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let e = (this.right - this.left) / (2 * this.zoom),
        t = (this.top - this.bottom) / (2 * this.zoom),
        i = (this.right + this.left) / 2,
        r = (this.top + this.bottom) / 2,
        s = i - e,
        a = i + e,
        n = r + t,
        o = r - t;
      if (this.view !== null && this.view.enabled) {
        let l = (this.right - this.left) / this.view.fullWidth / this.zoom,
          h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (s += l * this.view.offsetX),
          (a = s + l * this.view.width),
          (n -= h * this.view.offsetY),
          (o = n - h * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(s, a, n, o, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return (
        (t.object.zoom = this.zoom),
        (t.object.left = this.left),
        (t.object.right = this.right),
        (t.object.top = this.top),
        (t.object.bottom = this.bottom),
        (t.object.near = this.near),
        (t.object.far = this.far),
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
      );
    }
  },
  wc = 4,
  E_ = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  kl = 20,
  Rv = new bx(),
  C_ = new Et(),
  Lv = null,
  Rl = (1 + Math.sqrt(5)) / 2,
  qh = 1 / Rl,
  T_ = [
    new I(1, 1, 1),
    new I(-1, 1, 1),
    new I(1, 1, -1),
    new I(-1, 1, -1),
    new I(0, Rl, qh),
    new I(0, Rl, -qh),
    new I(qh, 0, Rl),
    new I(-qh, 0, Rl),
    new I(Rl, qh, 0),
    new I(-Rl, qh, 0),
  ],
  P_ = class {
    constructor(e) {
      (this._renderer = e),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, i = 0.1, r = 100) {
      (Lv = this._renderer.getRenderTarget()), this._setSize(256);
      let s = this._allocateTargets();
      return (
        (s.depthBuffer = !0),
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
      );
    }
    fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
      return this._fromTexture(e, t);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null &&
        ((this._cubemapMaterial = I_()),
        this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null &&
        ((this._equirectMaterial = O_()),
        this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
      (this._lodMax = Math.floor(Math.log2(e))),
        (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null &&
          this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++)
        this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
      this._renderer.setRenderTarget(Lv),
        (e.scissorTest = !1),
        Kp(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
      e.mapping === nh || e.mapping === oh
        ? this._setSize(
            e.image.length === 0
              ? 16
              : e.image[0].width || e.image[0].image.width
          )
        : this._setSize(e.image.width / 4),
        (Lv = this._renderer.getRenderTarget());
      let i = t || this._allocateTargets();
      return (
        this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
      );
    }
    _allocateTargets() {
      let e = 3 * Math.max(this._cubeSize, 112),
        t = 4 * this._cubeSize,
        i = {
          magFilter: Wt,
          minFilter: Wt,
          generateMipmaps: !1,
          type: lh,
          format: Wr,
          encoding: Qa,
          depthBuffer: !1,
        },
        r = D_(e, t, i);
      if (
        this._pingPongRenderTarget === null ||
        this._pingPongRenderTarget.width !== e ||
        this._pingPongRenderTarget.height !== t
      ) {
        this._pingPongRenderTarget !== null && this._dispose(),
          (this._pingPongRenderTarget = D_(e, t, i));
        let { _lodMax: s } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = nB(s)),
          (this._blurMaterial = oB(s, e, t));
      }
      return r;
    }
    _compileMaterial(e) {
      let t = new br(this._lodPlanes[0], e);
      this._renderer.compile(t, Rv);
    }
    _sceneToCubeUV(e, t, i, r) {
      let s = new ds(90, 1, t, i),
        a = [1, -1, 1, 1, 1, 1],
        n = [1, 1, 1, -1, -1, -1],
        o = this._renderer,
        l = o.autoClear,
        h = o.toneMapping;
      o.getClearColor(C_), (o.toneMapping = Tn), (o.autoClear = !1);
      let u = new mh({
          name: "PMREM.Background",
          side: Yr,
          depthWrite: !1,
          depthTest: !1,
        }),
        c = new br(new Za(), u),
        d = !1,
        p = e.background;
      p
        ? p.isColor && (u.color.copy(p), (e.background = null), (d = !0))
        : (u.color.copy(C_), (d = !0));
      for (let f = 0; f < 6; f++) {
        let m = f % 3;
        m === 0
          ? (s.up.set(0, a[f], 0), s.lookAt(n[f], 0, 0))
          : m === 1
          ? (s.up.set(0, 0, a[f]), s.lookAt(0, n[f], 0))
          : (s.up.set(0, a[f], 0), s.lookAt(0, 0, n[f]));
        let g = this._cubeSize;
        Kp(r, m * g, f > 2 ? g : 0, g, g),
          o.setRenderTarget(r),
          d && o.render(c, s),
          o.render(e, s);
      }
      c.geometry.dispose(),
        c.material.dispose(),
        (o.toneMapping = h),
        (o.autoClear = l),
        (e.background = p);
    }
    _textureToCubeUV(e, t) {
      let i = this._renderer,
        r = e.mapping === nh || e.mapping === oh;
      r
        ? (this._cubemapMaterial === null && (this._cubemapMaterial = I_()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            e.isRenderTargetTexture === !1 ? -1 : 1))
        : this._equirectMaterial === null && (this._equirectMaterial = O_());
      let s = r ? this._cubemapMaterial : this._equirectMaterial,
        a = new br(this._lodPlanes[0], s),
        n = s.uniforms;
      n.envMap.value = e;
      let o = this._cubeSize;
      Kp(t, 0, 0, 3 * o, 2 * o), i.setRenderTarget(t), i.render(a, Rv);
    }
    _applyPMREM(e) {
      let t = this._renderer,
        i = t.autoClear;
      t.autoClear = !1;
      for (let r = 1; r < this._lodPlanes.length; r++) {
        let s = Math.sqrt(
            this._sigmas[r] * this._sigmas[r] -
              this._sigmas[r - 1] * this._sigmas[r - 1]
          ),
          a = T_[(r - 1) % T_.length];
        this._blur(e, r - 1, r, s, a);
      }
      t.autoClear = i;
    }
    _blur(e, t, i, r, s) {
      let a = this._pingPongRenderTarget;
      this._halfBlur(e, a, t, i, r, "latitudinal", s),
        this._halfBlur(a, e, i, i, r, "longitudinal", s);
    }
    _halfBlur(e, t, i, r, s, a, n) {
      let o = this._renderer,
        l = this._blurMaterial;
      a !== "latitudinal" &&
        a !== "longitudinal" &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      let h = 3,
        u = new br(this._lodPlanes[r], l),
        c = l.uniforms,
        d = this._sizeLods[i] - 1,
        p = isFinite(s) ? Math.PI / (2 * d) : (2 * Math.PI) / (2 * kl - 1),
        f = s / p,
        m = isFinite(s) ? 1 + Math.floor(h * f) : kl;
      m > kl &&
        console.warn(
          `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${kl}`
        );
      let g = [],
        y = 0;
      for (let M = 0; M < kl; ++M) {
        let C = M / f,
          A = Math.exp((-C * C) / 2);
        g.push(A), M === 0 ? (y += A) : M < m && (y += 2 * A);
      }
      for (let M = 0; M < g.length; M++) g[M] = g[M] / y;
      (c.envMap.value = e.texture),
        (c.samples.value = m),
        (c.weights.value = g),
        (c.latitudinal.value = a === "latitudinal"),
        n && (c.poleAxis.value = n);
      let { _lodMax: x } = this;
      (c.dTheta.value = p), (c.mipInt.value = x - i);
      let b = this._sizeLods[r],
        _ = 3 * b * (r > x - wc ? r - x + wc : 0),
        S = 4 * (this._cubeSize - b);
      Kp(t, _, S, 3 * b, 2 * b), o.setRenderTarget(t), o.render(u, Rv);
    }
  };
function nB(e) {
  let t = [],
    i = [],
    r = [],
    s = e,
    a = e - wc + 1 + E_.length;
  for (let n = 0; n < a; n++) {
    let o = Math.pow(2, s);
    i.push(o);
    let l = 1 / o;
    n > e - wc ? (l = E_[n - e + wc - 1]) : n === 0 && (l = 0), r.push(l);
    let h = 1 / (o - 2),
      u = -h,
      c = 1 + h,
      d = [u, u, c, u, c, c, u, u, c, c, u, c],
      p = 6,
      f = 6,
      m = 3,
      g = 2,
      y = 1,
      x = new Float32Array(m * f * p),
      b = new Float32Array(g * f * p),
      _ = new Float32Array(y * f * p);
    for (let M = 0; M < p; M++) {
      let C = ((M % 3) * 2) / 3 - 1,
        A = M > 2 ? 0 : -1,
        T = [
          C,
          A,
          0,
          C + 2 / 3,
          A,
          0,
          C + 2 / 3,
          A + 1,
          0,
          C,
          A,
          0,
          C + 2 / 3,
          A + 1,
          0,
          C,
          A + 1,
          0,
        ];
      x.set(T, m * f * M), b.set(d, g * f * M);
      let P = [M, M, M, M, M, M];
      _.set(P, y * f * M);
    }
    let S = new yt();
    S.setAttribute("position", new It(x, m)),
      S.setAttribute("uv", new It(b, g)),
      S.setAttribute("faceIndex", new It(_, y)),
      t.push(S),
      s > wc && s--;
  }
  return { lodPlanes: t, sizeLods: i, sigmas: r };
}
function D_(e, t, i) {
  let r = new gi(e, t, i);
  return (
    (r.texture.mapping = rp),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function Kp(e, t, i, r, s) {
  e.viewport.set(t, i, r, s), e.scissor.set(t, i, r, s);
}
function oB(e, t, i) {
  let r = new Float32Array(kl),
    s = new I(0, 1, 0);
  return new vi({
    name: "SphericalGaussianBlur",
    defines: {
      n: kl,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${e}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s },
    },
    vertexShader: wx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: wr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function O_() {
  return new vi({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: wx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: wr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function I_() {
  return new vi({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: wx(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: wr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function wx() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function lB(e) {
  let t = new WeakMap(),
    i = null;
  function r(o) {
    if (o && o.isTexture) {
      let l = o.mapping,
        h = l === uy || l === dy,
        u = l === nh || l === oh;
      if (h || u)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let c = t.get(o);
          return (
            i === null && (i = new P_(e)),
            (c = h ? i.fromEquirectangular(o, c) : i.fromCubemap(o, c)),
            t.set(o, c),
            c.texture
          );
        } else {
          if (t.has(o)) return t.get(o).texture;
          {
            let c = o.image;
            if ((h && c && c.height > 0) || (u && c && s(c))) {
              i === null && (i = new P_(e));
              let d = h ? i.fromEquirectangular(o) : i.fromCubemap(o);
              return t.set(o, d), o.addEventListener("dispose", a), d.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function s(o) {
    let l = 0,
      h = 6;
    for (let u = 0; u < h; u++) o[u] !== void 0 && l++;
    return l === h;
  }
  function a(o) {
    let l = o.target;
    l.removeEventListener("dispose", a);
    let h = t.get(l);
    h !== void 0 && (t.delete(l), h.dispose());
  }
  function n() {
    (t = new WeakMap()), i !== null && (i.dispose(), (i = null));
  }
  return { get: r, dispose: n };
}
function hB(e) {
  let t = {};
  function i(r) {
    if (t[r] !== void 0) return t[r];
    let s;
    switch (r) {
      case "WEBGL_depth_texture":
        s =
          e.getExtension("WEBGL_depth_texture") ||
          e.getExtension("MOZ_WEBGL_depth_texture") ||
          e.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s =
          e.getExtension("EXT_texture_filter_anisotropic") ||
          e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s =
          e.getExtension("WEBGL_compressed_texture_s3tc") ||
          e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s =
          e.getExtension("WEBGL_compressed_texture_pvrtc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = e.getExtension(r);
    }
    return (t[r] = s), s;
  }
  return {
    has: function (r) {
      return i(r) !== null;
    },
    init: function (r) {
      r.isWebGL2
        ? i("EXT_color_buffer_float")
        : (i("WEBGL_depth_texture"),
          i("OES_texture_float"),
          i("OES_texture_half_float"),
          i("OES_texture_half_float_linear"),
          i("OES_standard_derivatives"),
          i("OES_element_index_uint"),
          i("OES_vertex_array_object"),
          i("ANGLE_instanced_arrays")),
        i("OES_texture_float_linear"),
        i("EXT_color_buffer_half_float"),
        i("WEBGL_multisampled_render_to_texture");
    },
    get: function (r) {
      let s = i(r);
      return (
        s === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        s
      );
    },
  };
}
function cB(e, t, i, r) {
  let s = {},
    a = new WeakMap();
  function n(c) {
    let d = c.target;
    d.index !== null && t.remove(d.index);
    for (let f in d.attributes) t.remove(d.attributes[f]);
    d.removeEventListener("dispose", n), delete s[d.id];
    let p = a.get(d);
    p && (t.remove(p), a.delete(d)),
      r.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      i.memory.geometries--;
  }
  function o(c, d) {
    return (
      s[d.id] === !0 ||
        (d.addEventListener("dispose", n),
        (s[d.id] = !0),
        i.memory.geometries++),
      d
    );
  }
  function l(c) {
    let d = c.attributes;
    for (let f in d) t.update(d[f], 34962);
    let p = c.morphAttributes;
    for (let f in p) {
      let m = p[f];
      for (let g = 0, y = m.length; g < y; g++) t.update(m[g], 34962);
    }
  }
  function h(c) {
    let d = [],
      p = c.index,
      f = c.attributes.position,
      m = 0;
    if (p !== null) {
      let x = p.array;
      m = p.version;
      for (let b = 0, _ = x.length; b < _; b += 3) {
        let S = x[b + 0],
          M = x[b + 1],
          C = x[b + 2];
        d.push(S, M, M, C, C, S);
      }
    } else {
      let x = f.array;
      m = f.version;
      for (let b = 0, _ = x.length / 3 - 1; b < _; b += 3) {
        let S = b + 0,
          M = b + 1,
          C = b + 2;
        d.push(S, M, M, C, C, S);
      }
    }
    let g = new (QE(d) ? Ec : eC)(d, 1);
    g.version = m;
    let y = a.get(c);
    y && t.remove(y), a.set(c, g);
  }
  function u(c) {
    let d = a.get(c);
    if (d) {
      let p = c.index;
      p !== null && d.version < p.version && h(c);
    } else h(c);
    return a.get(c);
  }
  return { get: o, update: l, getWireframeAttribute: u };
}
function uB(e, t, i, r) {
  let s = r.isWebGL2,
    a;
  function n(d) {
    a = d;
  }
  let o, l;
  function h(d) {
    (o = d.type), (l = d.bytesPerElement);
  }
  function u(d, p) {
    e.drawElements(a, p, o, d * l), i.update(p, a, 1);
  }
  function c(d, p, f) {
    if (f === 0) return;
    let m, g;
    if (s) (m = e), (g = "drawElementsInstanced");
    else if (
      ((m = t.get("ANGLE_instanced_arrays")),
      (g = "drawElementsInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    m[g](a, p, o, d * l, f), i.update(p, a, f);
  }
  (this.setMode = n),
    (this.setIndex = h),
    (this.render = u),
    (this.renderInstances = c);
}
function dB(e) {
  let t = { geometries: 0, textures: 0 },
    i = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(a, n, o) {
    switch ((i.calls++, n)) {
      case 4:
        i.triangles += o * (a / 3);
        break;
      case 1:
        i.lines += o * (a / 2);
        break;
      case 3:
        i.lines += o * (a - 1);
        break;
      case 2:
        i.lines += o * a;
        break;
      case 0:
        i.points += o * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        break;
    }
  }
  function s() {
    i.frame++, (i.calls = 0), (i.triangles = 0), (i.points = 0), (i.lines = 0);
  }
  return {
    memory: t,
    render: i,
    programs: null,
    autoReset: !0,
    reset: s,
    update: r,
  };
}
function pB(e, t) {
  return e[0] - t[0];
}
function fB(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function mB(e, t, i) {
  let r = {},
    s = new Float32Array(8),
    a = new WeakMap(),
    n = new Lt(),
    o = [];
  for (let h = 0; h < 8; h++) o[h] = [h, 0];
  function l(h, u, c, d) {
    let p = h.morphTargetInfluences;
    if (t.isWebGL2 === !0) {
      let f =
          u.morphAttributes.position ||
          u.morphAttributes.normal ||
          u.morphAttributes.color,
        m = f !== void 0 ? f.length : 0,
        g = a.get(u);
      if (g === void 0 || g.count !== m) {
        let b = function () {
          L.dispose(), a.delete(u), u.removeEventListener("dispose", b);
        };
        g !== void 0 && g.texture.dispose();
        let _ = u.morphAttributes.position !== void 0,
          S = u.morphAttributes.normal !== void 0,
          M = u.morphAttributes.color !== void 0,
          C = u.morphAttributes.position || [],
          A = u.morphAttributes.normal || [],
          T = u.morphAttributes.color || [],
          P = 0;
        _ === !0 && (P = 1), S === !0 && (P = 2), M === !0 && (P = 3);
        let R = u.attributes.position.count * P,
          z = 1;
        R > t.maxTextureSize &&
          ((z = Math.ceil(R / t.maxTextureSize)), (R = t.maxTextureSize));
        let N = new Float32Array(R * z * 4 * m),
          L = new $E(N, R, z, m);
        (L.type = xr), (L.needsUpdate = !0);
        let G = P * 4;
        for (let Y = 0; Y < m; Y++) {
          let Z = C[Y],
            q = A[Y],
            oe = T[Y],
            ce = R * z * 4 * Y;
          for (let ie = 0; ie < Z.count; ie++) {
            let te = ie * G;
            _ === !0 &&
              (n.fromBufferAttribute(Z, ie),
              (N[ce + te + 0] = n.x),
              (N[ce + te + 1] = n.y),
              (N[ce + te + 2] = n.z),
              (N[ce + te + 3] = 0)),
              S === !0 &&
                (n.fromBufferAttribute(q, ie),
                (N[ce + te + 4] = n.x),
                (N[ce + te + 5] = n.y),
                (N[ce + te + 6] = n.z),
                (N[ce + te + 7] = 0)),
              M === !0 &&
                (n.fromBufferAttribute(oe, ie),
                (N[ce + te + 8] = n.x),
                (N[ce + te + 9] = n.y),
                (N[ce + te + 10] = n.z),
                (N[ce + te + 11] = oe.itemSize === 4 ? n.w : 1));
          }
        }
        (g = { count: m, texture: L, size: new re(R, z) }),
          a.set(u, g),
          u.addEventListener("dispose", b);
      }
      let y = 0;
      for (let b = 0; b < p.length; b++) y += p[b];
      let x = u.morphTargetsRelative ? 1 : 1 - y;
      d.getUniforms().setValue(e, "morphTargetBaseInfluence", x),
        d.getUniforms().setValue(e, "morphTargetInfluences", p),
        d.getUniforms().setValue(e, "morphTargetsTexture", g.texture, i),
        d.getUniforms().setValue(e, "morphTargetsTextureSize", g.size);
    } else {
      let f = p === void 0 ? 0 : p.length,
        m = r[u.id];
      if (m === void 0 || m.length !== f) {
        m = [];
        for (let _ = 0; _ < f; _++) m[_] = [_, 0];
        r[u.id] = m;
      }
      for (let _ = 0; _ < f; _++) {
        let S = m[_];
        (S[0] = _), (S[1] = p[_]);
      }
      m.sort(fB);
      for (let _ = 0; _ < 8; _++)
        _ < f && m[_][1]
          ? ((o[_][0] = m[_][0]), (o[_][1] = m[_][1]))
          : ((o[_][0] = Number.MAX_SAFE_INTEGER), (o[_][1] = 0));
      o.sort(pB);
      let g = u.morphAttributes.position,
        y = u.morphAttributes.normal,
        x = 0;
      for (let _ = 0; _ < 8; _++) {
        let S = o[_],
          M = S[0],
          C = S[1];
        M !== Number.MAX_SAFE_INTEGER && C
          ? (g &&
              u.getAttribute("morphTarget" + _) !== g[M] &&
              u.setAttribute("morphTarget" + _, g[M]),
            y &&
              u.getAttribute("morphNormal" + _) !== y[M] &&
              u.setAttribute("morphNormal" + _, y[M]),
            (s[_] = C),
            (x += C))
          : (g &&
              u.hasAttribute("morphTarget" + _) === !0 &&
              u.deleteAttribute("morphTarget" + _),
            y &&
              u.hasAttribute("morphNormal" + _) === !0 &&
              u.deleteAttribute("morphNormal" + _),
            (s[_] = 0));
      }
      let b = u.morphTargetsRelative ? 1 : 1 - x;
      d.getUniforms().setValue(e, "morphTargetBaseInfluence", b),
        d.getUniforms().setValue(e, "morphTargetInfluences", s);
    }
  }
  return { update: l };
}
function gB(e, t, i, r) {
  let s = new WeakMap();
  function a(l) {
    let h = r.render.frame,
      u = l.geometry,
      c = t.get(l, u);
    return (
      s.get(c) !== h && (t.update(c), s.set(c, h)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        i.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && i.update(l.instanceColor, 34962)),
      c
    );
  }
  function n() {
    s = new WeakMap();
  }
  function o(l) {
    let h = l.target;
    h.removeEventListener("dispose", o),
      i.remove(h.instanceMatrix),
      h.instanceColor !== null && i.remove(h.instanceColor);
  }
  return { update: a, dispose: n };
}
var rC = new Yi(),
  sC = new $E(),
  aC = new iR(),
  nC = new yx(),
  R_ = [],
  L_ = [],
  B_ = new Float32Array(16),
  z_ = new Float32Array(9),
  F_ = new Float32Array(4);
function nu(e, t, i) {
  let r = e[0];
  if (r <= 0 || r > 0) return e;
  let s = t * i,
    a = R_[s];
  if ((a === void 0 && ((a = new Float32Array(s)), (R_[s] = a)), t !== 0)) {
    r.toArray(a, 0);
    for (let n = 1, o = 0; n !== t; ++n) (o += i), e[n].toArray(a, o);
  }
  return a;
}
function Lr(e, t) {
  if (e.length !== t.length) return !1;
  for (let i = 0, r = e.length; i < r; i++) if (e[i] !== t[i]) return !1;
  return !0;
}
function Br(e, t) {
  for (let i = 0, r = t.length; i < r; i++) e[i] = t[i];
}
function bg(e, t) {
  let i = L_[t];
  i === void 0 && ((i = new Int32Array(t)), (L_[t] = i));
  for (let r = 0; r !== t; ++r) i[r] = e.allocateTextureUnit();
  return i;
}
function vB(e, t) {
  let i = this.cache;
  i[0] !== t && (e.uniform1f(this.addr, t), (i[0] = t));
}
function yB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y) &&
      (e.uniform2f(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (Lr(i, t)) return;
    e.uniform2fv(this.addr, t), Br(i, t);
  }
}
function xB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) &&
      (e.uniform3f(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else if (t.r !== void 0)
    (i[0] !== t.r || i[1] !== t.g || i[2] !== t.b) &&
      (e.uniform3f(this.addr, t.r, t.g, t.b),
      (i[0] = t.r),
      (i[1] = t.g),
      (i[2] = t.b));
  else {
    if (Lr(i, t)) return;
    e.uniform3fv(this.addr, t), Br(i, t);
  }
}
function bB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) &&
      (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (Lr(i, t)) return;
    e.uniform4fv(this.addr, t), Br(i, t);
  }
}
function wB(e, t) {
  let i = this.cache,
    r = t.elements;
  if (r === void 0) {
    if (Lr(i, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), Br(i, t);
  } else {
    if (Lr(i, r)) return;
    F_.set(r), e.uniformMatrix2fv(this.addr, !1, F_), Br(i, r);
  }
}
function _B(e, t) {
  let i = this.cache,
    r = t.elements;
  if (r === void 0) {
    if (Lr(i, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), Br(i, t);
  } else {
    if (Lr(i, r)) return;
    z_.set(r), e.uniformMatrix3fv(this.addr, !1, z_), Br(i, r);
  }
}
function SB(e, t) {
  let i = this.cache,
    r = t.elements;
  if (r === void 0) {
    if (Lr(i, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), Br(i, t);
  } else {
    if (Lr(i, r)) return;
    B_.set(r), e.uniformMatrix4fv(this.addr, !1, B_), Br(i, r);
  }
}
function AB(e, t) {
  let i = this.cache;
  i[0] !== t && (e.uniform1i(this.addr, t), (i[0] = t));
}
function MB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y) &&
      (e.uniform2i(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (Lr(i, t)) return;
    e.uniform2iv(this.addr, t), Br(i, t);
  }
}
function EB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) &&
      (e.uniform3i(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else {
    if (Lr(i, t)) return;
    e.uniform3iv(this.addr, t), Br(i, t);
  }
}
function CB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) &&
      (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (Lr(i, t)) return;
    e.uniform4iv(this.addr, t), Br(i, t);
  }
}
function TB(e, t) {
  let i = this.cache;
  i[0] !== t && (e.uniform1ui(this.addr, t), (i[0] = t));
}
function PB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y) &&
      (e.uniform2ui(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (Lr(i, t)) return;
    e.uniform2uiv(this.addr, t), Br(i, t);
  }
}
function DB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) &&
      (e.uniform3ui(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else {
    if (Lr(i, t)) return;
    e.uniform3uiv(this.addr, t), Br(i, t);
  }
}
function OB(e, t) {
  let i = this.cache;
  if (t.x !== void 0)
    (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) &&
      (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (Lr(i, t)) return;
    e.uniform4uiv(this.addr, t), Br(i, t);
  }
}
function IB(e, t, i) {
  let r = this.cache,
    s = i.allocateTextureUnit();
  r[0] !== s && (e.uniform1i(this.addr, s), (r[0] = s)),
    i.setTexture2D(t || rC, s);
}
function RB(e, t, i) {
  let r = this.cache,
    s = i.allocateTextureUnit();
  r[0] !== s && (e.uniform1i(this.addr, s), (r[0] = s)),
    i.setTexture3D(t || aC, s);
}
function LB(e, t, i) {
  let r = this.cache,
    s = i.allocateTextureUnit();
  r[0] !== s && (e.uniform1i(this.addr, s), (r[0] = s)),
    i.setTextureCube(t || nC, s);
}
function BB(e, t, i) {
  let r = this.cache,
    s = i.allocateTextureUnit();
  r[0] !== s && (e.uniform1i(this.addr, s), (r[0] = s)),
    i.setTexture2DArray(t || sC, s);
}
function zB(e) {
  switch (e) {
    case 5126:
      return vB;
    case 35664:
      return yB;
    case 35665:
      return xB;
    case 35666:
      return bB;
    case 35674:
      return wB;
    case 35675:
      return _B;
    case 35676:
      return SB;
    case 5124:
    case 35670:
      return AB;
    case 35667:
    case 35671:
      return MB;
    case 35668:
    case 35672:
      return EB;
    case 35669:
    case 35673:
      return CB;
    case 5125:
      return TB;
    case 36294:
      return PB;
    case 36295:
      return DB;
    case 36296:
      return OB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return IB;
    case 35679:
    case 36299:
    case 36307:
      return RB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return LB;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return BB;
  }
}
function FB(e, t) {
  e.uniform1fv(this.addr, t);
}
function kB(e, t) {
  let i = nu(t, this.size, 2);
  e.uniform2fv(this.addr, i);
}
function NB(e, t) {
  let i = nu(t, this.size, 3);
  e.uniform3fv(this.addr, i);
}
function UB(e, t) {
  let i = nu(t, this.size, 4);
  e.uniform4fv(this.addr, i);
}
function VB(e, t) {
  let i = nu(t, this.size, 4);
  e.uniformMatrix2fv(this.addr, !1, i);
}
function jB(e, t) {
  let i = nu(t, this.size, 9);
  e.uniformMatrix3fv(this.addr, !1, i);
}
function HB(e, t) {
  let i = nu(t, this.size, 16);
  e.uniformMatrix4fv(this.addr, !1, i);
}
function GB(e, t) {
  e.uniform1iv(this.addr, t);
}
function WB(e, t) {
  e.uniform2iv(this.addr, t);
}
function qB(e, t) {
  e.uniform3iv(this.addr, t);
}
function YB(e, t) {
  e.uniform4iv(this.addr, t);
}
function XB(e, t) {
  e.uniform1uiv(this.addr, t);
}
function QB(e, t) {
  e.uniform2uiv(this.addr, t);
}
function ZB(e, t) {
  e.uniform3uiv(this.addr, t);
}
function KB(e, t) {
  e.uniform4uiv(this.addr, t);
}
function JB(e, t, i) {
  let r = this.cache,
    s = t.length,
    a = bg(i, s);
  Lr(r, a) || (e.uniform1iv(this.addr, a), Br(r, a));
  for (let n = 0; n !== s; ++n) i.setTexture2D(t[n] || rC, a[n]);
}
function $B(e, t, i) {
  let r = this.cache,
    s = t.length,
    a = bg(i, s);
  Lr(r, a) || (e.uniform1iv(this.addr, a), Br(r, a));
  for (let n = 0; n !== s; ++n) i.setTexture3D(t[n] || aC, a[n]);
}
function ez(e, t, i) {
  let r = this.cache,
    s = t.length,
    a = bg(i, s);
  Lr(r, a) || (e.uniform1iv(this.addr, a), Br(r, a));
  for (let n = 0; n !== s; ++n) i.setTextureCube(t[n] || nC, a[n]);
}
function tz(e, t, i) {
  let r = this.cache,
    s = t.length,
    a = bg(i, s);
  Lr(r, a) || (e.uniform1iv(this.addr, a), Br(r, a));
  for (let n = 0; n !== s; ++n) i.setTexture2DArray(t[n] || sC, a[n]);
}
function iz(e) {
  switch (e) {
    case 5126:
      return FB;
    case 35664:
      return kB;
    case 35665:
      return NB;
    case 35666:
      return UB;
    case 35674:
      return VB;
    case 35675:
      return jB;
    case 35676:
      return HB;
    case 5124:
    case 35670:
      return GB;
    case 35667:
    case 35671:
      return WB;
    case 35668:
    case 35672:
      return qB;
    case 35669:
    case 35673:
      return YB;
    case 5125:
      return XB;
    case 36294:
      return QB;
    case 36295:
      return ZB;
    case 36296:
      return KB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return JB;
    case 35679:
    case 36299:
    case 36307:
      return $B;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return ez;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return tz;
  }
}
var rz = class {
    constructor(e, t, i) {
      (this.id = e),
        (this.addr = i),
        (this.cache = []),
        (this.setValue = zB(t.type));
    }
  },
  sz = class {
    constructor(e, t, i) {
      (this.id = e),
        (this.addr = i),
        (this.cache = []),
        (this.size = t.size),
        (this.setValue = iz(t.type));
    }
  },
  az = class {
    constructor(e) {
      (this.id = e), (this.seq = []), (this.map = {});
    }
    setValue(e, t, i) {
      let r = this.seq;
      for (let s = 0, a = r.length; s !== a; ++s) {
        let n = r[s];
        n.setValue(e, t[n.id], i);
      }
    }
  },
  Bv = /(\w+)(\])?(\[|\.)?/g;
function k_(e, t) {
  e.seq.push(t), (e.map[t.id] = t);
}
function nz(e, t, i) {
  let r = e.name,
    s = r.length;
  for (Bv.lastIndex = 0; ; ) {
    let a = Bv.exec(r),
      n = Bv.lastIndex,
      o = a[1],
      l = a[2] === "]",
      h = a[3];
    if ((l && (o = o | 0), h === void 0 || (h === "[" && n + 2 === s))) {
      k_(i, h === void 0 ? new rz(o, e, t) : new sz(o, e, t));
      break;
    } else {
      let u = i.map[o];
      u === void 0 && ((u = new az(o)), k_(i, u)), (i = u);
    }
  }
}
var sm = class {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    let i = e.getProgramParameter(t, 35718);
    for (let r = 0; r < i; ++r) {
      let s = e.getActiveUniform(t, r),
        a = e.getUniformLocation(t, s.name);
      nz(s, a, this);
    }
  }
  setValue(e, t, i, r) {
    let s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    let r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      let n = t[s],
        o = i[n.id];
      o.needsUpdate !== !1 && n.setValue(e, o.value, r);
    }
  }
  static seqWithValue(e, t) {
    let i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      let a = e[r];
      a.id in t && i.push(a);
    }
    return i;
  }
};
function N_(e, t, i) {
  let r = e.createShader(t);
  return e.shaderSource(r, i), e.compileShader(r), r;
}
var oz = 0;
function lz(e, t) {
  let i = e.split(`
`),
    r = [],
    s = Math.max(t - 6, 0),
    a = Math.min(t + 6, i.length);
  for (let n = s; n < a; n++) {
    let o = n + 1;
    r.push(`${o === t ? ">" : " "} ${o}: ${i[n]}`);
  }
  return r.join(`
`);
}
function hz(e) {
  switch (e) {
    case Qa:
      return ["Linear", "( value )"];
    case jt:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
        ["Linear", "( value )"]
      );
  }
}
function U_(e, t, i) {
  let r = e.getShaderParameter(t, 35713),
    s = e.getShaderInfoLog(t).trim();
  if (r && s === "") return "";
  let a = /ERROR: 0:(\d+)/.exec(s);
  if (a) {
    let n = parseInt(a[1]);
    return (
      i.toUpperCase() +
      `

` +
      s +
      `

` +
      lz(e.getShaderSource(t), n)
    );
  } else return s;
}
function cz(e, t) {
  let i = hz(t);
  return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
}
function uz(e, t) {
  let i;
  switch (t) {
    case vI:
      i = "Linear";
      break;
    case yI:
      i = "Reinhard";
      break;
    case xI:
      i = "OptimizedCineon";
      break;
    case bI:
      i = "ACESFilmic";
      break;
    case wI:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        (i = "Linear");
  }
  return (
    "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  );
}
function dz(e) {
  return [
    e.extensionDerivatives ||
    !!e.envMapCubeUVHeight ||
    e.bumpMap ||
    e.tangentSpaceNormalMap ||
    e.clearcoatNormalMap ||
    e.flatShading ||
    e.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
    e.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
    e.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(cd).join(`
`);
}
function pz(e) {
  let t = [];
  for (let i in e) {
    let r = e[i];
    r !== !1 && t.push("#define " + i + " " + r);
  }
  return t.join(`
`);
}
function fz(e, t) {
  let i = {},
    r = e.getProgramParameter(t, 35721);
  for (let s = 0; s < r; s++) {
    let a = e.getActiveAttrib(t, s),
      n = a.name,
      o = 1;
    a.type === 35674 && (o = 2),
      a.type === 35675 && (o = 3),
      a.type === 35676 && (o = 4),
      (i[n] = {
        type: a.type,
        location: e.getAttribLocation(t, n),
        locationSize: o,
      });
  }
  return i;
}
function cd(e) {
  return e !== "";
}
function V_(e, t) {
  let i =
    t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return e
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, i)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function j_(e, t) {
  return e
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection
    );
}
var mz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function vy(e) {
  return e.replace(mz, gz);
}
function gz(e, t) {
  let i = Gt[t];
  if (i === void 0) throw new Error("Can not resolve #include <" + t + ">");
  return vy(i);
}
var vz =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function H_(e) {
  return e.replace(vz, yz);
}
function yz(e, t, i, r) {
  let s = "";
  for (let a = parseInt(t); a < parseInt(i); a++)
    s += r
      .replace(/\[\s*i\s*\]/g, "[ " + a + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, a);
  return s;
}
function G_(e) {
  let t =
    "precision " +
    e.precision +
    ` float;
precision ` +
    e.precision +
    " int;";
  return (
    e.precision === "highp"
      ? (t += `
#define HIGH_PRECISION`)
      : e.precision === "mediump"
      ? (t += `
#define MEDIUM_PRECISION`)
      : e.precision === "lowp" &&
        (t += `
#define LOW_PRECISION`),
    t
  );
}
function xz(e) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return (
    e.shadowMapType === px
      ? (t = "SHADOWMAP_TYPE_PCF")
      : e.shadowMapType === QO
      ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
      : e.shadowMapType === hd && (t = "SHADOWMAP_TYPE_VSM"),
    t
  );
}
function bz(e) {
  let t = "ENVMAP_TYPE_CUBE";
  if (e.envMap)
    switch (e.envMapMode) {
      case nh:
      case oh:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case rp:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
function wz(e) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (e.envMap)
    switch (e.envMapMode) {
      case oh:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function _z(e) {
  let t = "ENVMAP_BLENDING_NONE";
  if (e.envMap)
    switch (e.combine) {
      case VE:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case mI:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case gI:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function Sz(e) {
  let t = e.envMapCubeUVHeight;
  if (t === null) return null;
  let i = Math.log2(t) - 2,
    r = 1 / t;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)),
    texelHeight: r,
    maxMip: i,
  };
}
function Az(e, t, i, r) {
  let s = e.getContext(),
    a = i.defines,
    n = i.vertexShader,
    o = i.fragmentShader,
    l = xz(i),
    h = bz(i),
    u = wz(i),
    c = _z(i),
    d = Sz(i),
    p = i.isWebGL2 ? "" : dz(i),
    f = pz(a),
    m = s.createProgram(),
    g,
    y,
    x = i.glslVersion
      ? "#version " +
        i.glslVersion +
        `
`
      : "";
  i.isRawShaderMaterial
    ? ((g = [f].filter(cd).join(`
`)),
      g.length > 0 &&
        (g += `
`),
      (y = [p, f].filter(cd).join(`
`)),
      y.length > 0 &&
        (y += `
`))
    : ((g = [
        G_(i),
        "#define SHADER_NAME " + i.shaderName,
        f,
        i.instancing ? "#define USE_INSTANCING" : "",
        i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        i.useFog && i.fog ? "#define USE_FOG" : "",
        i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
        i.map ? "#define USE_MAP" : "",
        i.envMap ? "#define USE_ENVMAP" : "",
        i.envMap ? "#define " + u : "",
        i.lightMap ? "#define USE_LIGHTMAP" : "",
        i.aoMap ? "#define USE_AOMAP" : "",
        i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        i.bumpMap ? "#define USE_BUMPMAP" : "",
        i.normalMap ? "#define USE_NORMALMAP" : "",
        i.normalMap && i.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        i.normalMap && i.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        i.displacementMap && i.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        i.specularMap ? "#define USE_SPECULARMAP" : "",
        i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        i.metalnessMap ? "#define USE_METALNESSMAP" : "",
        i.alphaMap ? "#define USE_ALPHAMAP" : "",
        i.transmission ? "#define USE_TRANSMISSION" : "",
        i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        i.vertexTangents ? "#define USE_TANGENT" : "",
        i.vertexColors ? "#define USE_COLOR" : "",
        i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        i.vertexUvs ? "#define USE_UV" : "",
        i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        i.flatShading ? "#define FLAT_SHADED" : "",
        i.skinning ? "#define USE_SKINNING" : "",
        i.morphTargets ? "#define USE_MORPHTARGETS" : "",
        i.morphNormals && i.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        i.morphTargetsCount > 0 && i.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        i.morphTargetsCount > 0 && i.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride
          : "",
        i.morphTargetsCount > 0 && i.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount
          : "",
        i.doubleSided ? "#define DOUBLE_SIDED" : "",
        i.flipSided ? "#define FLIP_SIDED" : "",
        i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        i.shadowMapEnabled ? "#define " + l : "",
        i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(cd).join(`
`)),
      (y = [
        p,
        G_(i),
        "#define SHADER_NAME " + i.shaderName,
        f,
        i.useFog && i.fog ? "#define USE_FOG" : "",
        i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
        i.map ? "#define USE_MAP" : "",
        i.matcap ? "#define USE_MATCAP" : "",
        i.envMap ? "#define USE_ENVMAP" : "",
        i.envMap ? "#define " + h : "",
        i.envMap ? "#define " + u : "",
        i.envMap ? "#define " + c : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        i.lightMap ? "#define USE_LIGHTMAP" : "",
        i.aoMap ? "#define USE_AOMAP" : "",
        i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        i.bumpMap ? "#define USE_BUMPMAP" : "",
        i.normalMap ? "#define USE_NORMALMAP" : "",
        i.normalMap && i.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        i.normalMap && i.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        i.clearcoat ? "#define USE_CLEARCOAT" : "",
        i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        i.iridescence ? "#define USE_IRIDESCENCE" : "",
        i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        i.specularMap ? "#define USE_SPECULARMAP" : "",
        i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        i.metalnessMap ? "#define USE_METALNESSMAP" : "",
        i.alphaMap ? "#define USE_ALPHAMAP" : "",
        i.alphaTest ? "#define USE_ALPHATEST" : "",
        i.sheen ? "#define USE_SHEEN" : "",
        i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        i.transmission ? "#define USE_TRANSMISSION" : "",
        i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        i.vertexTangents ? "#define USE_TANGENT" : "",
        i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "",
        i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        i.vertexUvs ? "#define USE_UV" : "",
        i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        i.gradientMap ? "#define USE_GRADIENTMAP" : "",
        i.flatShading ? "#define FLAT_SHADED" : "",
        i.doubleSided ? "#define DOUBLE_SIDED" : "",
        i.flipSided ? "#define FLIP_SIDED" : "",
        i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        i.shadowMapEnabled ? "#define " + l : "",
        i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        i.toneMapping !== Tn ? "#define TONE_MAPPING" : "",
        i.toneMapping !== Tn ? Gt.tonemapping_pars_fragment : "",
        i.toneMapping !== Tn ? uz("toneMapping", i.toneMapping) : "",
        i.dithering ? "#define DITHERING" : "",
        i.opaque ? "#define OPAQUE" : "",
        Gt.encodings_pars_fragment,
        cz("linearToOutputTexel", i.outputEncoding),
        i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
        `
`,
      ].filter(cd).join(`
`))),
    (n = vy(n)),
    (n = V_(n, i)),
    (n = j_(n, i)),
    (o = vy(o)),
    (o = V_(o, i)),
    (o = j_(o, i)),
    (n = H_(n)),
    (o = H_(o)),
    i.isWebGL2 &&
      i.isRawShaderMaterial !== !0 &&
      ((x = `#version 300 es
`),
      (g =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        g),
      (y =
        [
          "#define varying in",
          i.glslVersion === f_
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          i.glslVersion === f_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        y));
  let b = x + g + n,
    _ = x + y + o,
    S = N_(s, 35633, b),
    M = N_(s, 35632, _);
  if (
    (s.attachShader(m, S),
    s.attachShader(m, M),
    i.index0AttributeName !== void 0
      ? s.bindAttribLocation(m, 0, i.index0AttributeName)
      : i.morphTargets === !0 && s.bindAttribLocation(m, 0, "position"),
    s.linkProgram(m),
    e.debug.checkShaderErrors)
  ) {
    let T = s.getProgramInfoLog(m).trim(),
      P = s.getShaderInfoLog(S).trim(),
      R = s.getShaderInfoLog(M).trim(),
      z = !0,
      N = !0;
    if (s.getProgramParameter(m, 35714) === !1) {
      z = !1;
      let L = U_(s, S, "vertex"),
        G = U_(s, M, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " +
          s.getError() +
          " - VALIDATE_STATUS " +
          s.getProgramParameter(m, 35715) +
          `

Program Info Log: ` +
          T +
          `
` +
          L +
          `
` +
          G
      );
    } else
      T !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", T)
        : (P === "" || R === "") && (N = !1);
    N &&
      (this.diagnostics = {
        runnable: z,
        programLog: T,
        vertexShader: { log: P, prefix: g },
        fragmentShader: { log: R, prefix: y },
      });
  }
  s.deleteShader(S), s.deleteShader(M);
  let C;
  this.getUniforms = function () {
    return C === void 0 && (C = new sm(s, m)), C;
  };
  let A;
  return (
    (this.getAttributes = function () {
      return A === void 0 && (A = fz(s, m)), A;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        s.deleteProgram(m),
        (this.program = void 0);
    }),
    (this.name = i.shaderName),
    (this.id = oz++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = S),
    (this.fragmentShader = M),
    this
  );
}
var Mz = 0,
  Ez = class {
    constructor() {
      (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(e) {
      let t = e.vertexShader,
        i = e.fragmentShader,
        r = this._getShaderStage(t),
        s = this._getShaderStage(i),
        a = this._getShaderCacheForMaterial(e);
      return (
        a.has(r) === !1 && (a.add(r), r.usedTimes++),
        a.has(s) === !1 && (a.add(s), s.usedTimes++),
        this
      );
    }
    remove(e) {
      let t = this.materialCache.get(e);
      for (let i of t)
        i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
      return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
      let t = this.materialCache,
        i = t.get(e);
      return i === void 0 && ((i = new Set()), t.set(e, i)), i;
    }
    _getShaderStage(e) {
      let t = this.shaderCache,
        i = t.get(e);
      return i === void 0 && ((i = new Cz(e)), t.set(e, i)), i;
    }
  },
  Cz = class {
    constructor(e) {
      (this.id = Mz++), (this.code = e), (this.usedTimes = 0);
    }
  };
function Tz(e, t, i, r, s, a, n) {
  let o = new vx(),
    l = new Ez(),
    h = [],
    u = s.isWebGL2,
    c = s.logarithmicDepthBuffer,
    d = s.vertexTextures,
    p = s.precision,
    f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
  function m(A, T, P, R, z) {
    let N = R.fog,
      L = z.geometry,
      G = A.isMeshStandardMaterial ? R.environment : null,
      Y = (A.isMeshStandardMaterial ? i : t).get(A.envMap || G),
      Z = !!Y && Y.mapping === rp ? Y.image.height : null,
      q = f[A.type];
    A.precision !== null &&
      ((p = s.getMaxPrecision(A.precision)),
      p !== A.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          A.precision,
          "not supported, using",
          p,
          "instead."
        ));
    let oe =
        L.morphAttributes.position ||
        L.morphAttributes.normal ||
        L.morphAttributes.color,
      ce = oe !== void 0 ? oe.length : 0,
      ie = 0;
    L.morphAttributes.position !== void 0 && (ie = 1),
      L.morphAttributes.normal !== void 0 && (ie = 2),
      L.morphAttributes.color !== void 0 && (ie = 3);
    let te, ue, ae, de;
    if (q) {
      let ye = bn[q];
      (te = ye.vertexShader), (ue = ye.fragmentShader);
    } else
      (te = A.vertexShader),
        (ue = A.fragmentShader),
        l.update(A),
        (ae = l.getVertexShaderID(A)),
        (de = l.getFragmentShaderID(A));
    let ne = e.getRenderTarget(),
      Ee = A.alphaTest > 0,
      me = A.clearcoat > 0,
      Ae = A.iridescence > 0;
    return {
      isWebGL2: u,
      shaderID: q,
      shaderName: A.type,
      vertexShader: te,
      fragmentShader: ue,
      defines: A.defines,
      customVertexShaderID: ae,
      customFragmentShaderID: de,
      isRawShaderMaterial: A.isRawShaderMaterial === !0,
      glslVersion: A.glslVersion,
      precision: p,
      instancing: z.isInstancedMesh === !0,
      instancingColor: z.isInstancedMesh === !0 && z.instanceColor !== null,
      supportsVertexTextures: d,
      outputEncoding:
        ne === null
          ? e.outputEncoding
          : ne.isXRRenderTarget === !0
          ? ne.texture.encoding
          : Qa,
      map: !!A.map,
      matcap: !!A.matcap,
      envMap: !!Y,
      envMapMode: Y && Y.mapping,
      envMapCubeUVHeight: Z,
      lightMap: !!A.lightMap,
      aoMap: !!A.aoMap,
      emissiveMap: !!A.emissiveMap,
      bumpMap: !!A.bumpMap,
      normalMap: !!A.normalMap,
      objectSpaceNormalMap: A.normalMapType === kI,
      tangentSpaceNormalMap: A.normalMapType === FI,
      decodeVideoTexture:
        !!A.map && A.map.isVideoTexture === !0 && A.map.encoding === jt,
      clearcoat: me,
      clearcoatMap: me && !!A.clearcoatMap,
      clearcoatRoughnessMap: me && !!A.clearcoatRoughnessMap,
      clearcoatNormalMap: me && !!A.clearcoatNormalMap,
      iridescence: Ae,
      iridescenceMap: Ae && !!A.iridescenceMap,
      iridescenceThicknessMap: Ae && !!A.iridescenceThicknessMap,
      displacementMap: !!A.displacementMap,
      roughnessMap: !!A.roughnessMap,
      metalnessMap: !!A.metalnessMap,
      specularMap: !!A.specularMap,
      specularIntensityMap: !!A.specularIntensityMap,
      specularColorMap: !!A.specularColorMap,
      opaque: A.transparent === !1 && A.blending === Jl,
      alphaMap: !!A.alphaMap,
      alphaTest: Ee,
      gradientMap: !!A.gradientMap,
      sheen: A.sheen > 0,
      sheenColorMap: !!A.sheenColorMap,
      sheenRoughnessMap: !!A.sheenRoughnessMap,
      transmission: A.transmission > 0,
      transmissionMap: !!A.transmissionMap,
      thicknessMap: !!A.thicknessMap,
      combine: A.combine,
      vertexTangents: !!A.normalMap && !!L.attributes.tangent,
      vertexColors: A.vertexColors,
      vertexAlphas:
        A.vertexColors === !0 &&
        !!L.attributes.color &&
        L.attributes.color.itemSize === 4,
      vertexUvs:
        !!A.map ||
        !!A.bumpMap ||
        !!A.normalMap ||
        !!A.specularMap ||
        !!A.alphaMap ||
        !!A.emissiveMap ||
        !!A.roughnessMap ||
        !!A.metalnessMap ||
        !!A.clearcoatMap ||
        !!A.clearcoatRoughnessMap ||
        !!A.clearcoatNormalMap ||
        !!A.iridescenceMap ||
        !!A.iridescenceThicknessMap ||
        !!A.displacementMap ||
        !!A.transmissionMap ||
        !!A.thicknessMap ||
        !!A.specularIntensityMap ||
        !!A.specularColorMap ||
        !!A.sheenColorMap ||
        !!A.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          !!A.map ||
          !!A.bumpMap ||
          !!A.normalMap ||
          !!A.specularMap ||
          !!A.alphaMap ||
          !!A.emissiveMap ||
          !!A.roughnessMap ||
          !!A.metalnessMap ||
          !!A.clearcoatNormalMap ||
          !!A.iridescenceMap ||
          !!A.iridescenceThicknessMap ||
          A.transmission > 0 ||
          !!A.transmissionMap ||
          !!A.thicknessMap ||
          !!A.specularIntensityMap ||
          !!A.specularColorMap ||
          A.sheen > 0 ||
          !!A.sheenColorMap ||
          !!A.sheenRoughnessMap
        ) && !!A.displacementMap,
      fog: !!N,
      useFog: A.fog === !0,
      fogExp2: N && N.isFogExp2,
      flatShading: !!A.flatShading,
      sizeAttenuation: A.sizeAttenuation,
      logarithmicDepthBuffer: c,
      skinning: z.isSkinnedMesh === !0,
      morphTargets: L.morphAttributes.position !== void 0,
      morphNormals: L.morphAttributes.normal !== void 0,
      morphColors: L.morphAttributes.color !== void 0,
      morphTargetsCount: ce,
      morphTextureStride: ie,
      numDirLights: T.directional.length,
      numPointLights: T.point.length,
      numSpotLights: T.spot.length,
      numSpotLightMaps: T.spotLightMap.length,
      numRectAreaLights: T.rectArea.length,
      numHemiLights: T.hemi.length,
      numDirLightShadows: T.directionalShadowMap.length,
      numPointLightShadows: T.pointShadowMap.length,
      numSpotLightShadows: T.spotShadowMap.length,
      numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
      numClippingPlanes: n.numPlanes,
      numClipIntersection: n.numIntersection,
      dithering: A.dithering,
      shadowMapEnabled: e.shadowMap.enabled && P.length > 0,
      shadowMapType: e.shadowMap.type,
      toneMapping: A.toneMapped ? e.toneMapping : Tn,
      physicallyCorrectLights: e.physicallyCorrectLights,
      premultipliedAlpha: A.premultipliedAlpha,
      doubleSided: A.side === js,
      flipSided: A.side === Yr,
      useDepthPacking: !!A.depthPacking,
      depthPacking: A.depthPacking || 0,
      index0AttributeName: A.index0AttributeName,
      extensionDerivatives: A.extensions && A.extensions.derivatives,
      extensionFragDepth: A.extensions && A.extensions.fragDepth,
      extensionDrawBuffers: A.extensions && A.extensions.drawBuffers,
      extensionShaderTextureLOD: A.extensions && A.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: A.customProgramCacheKey(),
    };
  }
  function g(A) {
    let T = [];
    if (
      (A.shaderID
        ? T.push(A.shaderID)
        : (T.push(A.customVertexShaderID), T.push(A.customFragmentShaderID)),
      A.defines !== void 0)
    )
      for (let P in A.defines) T.push(P), T.push(A.defines[P]);
    return (
      A.isRawShaderMaterial === !1 &&
        (y(T, A), x(T, A), T.push(e.outputEncoding)),
      T.push(A.customProgramCacheKey),
      T.join()
    );
  }
  function y(A, T) {
    A.push(T.precision),
      A.push(T.outputEncoding),
      A.push(T.envMapMode),
      A.push(T.envMapCubeUVHeight),
      A.push(T.combine),
      A.push(T.vertexUvs),
      A.push(T.fogExp2),
      A.push(T.sizeAttenuation),
      A.push(T.morphTargetsCount),
      A.push(T.morphAttributeCount),
      A.push(T.numDirLights),
      A.push(T.numPointLights),
      A.push(T.numSpotLights),
      A.push(T.numSpotLightMaps),
      A.push(T.numHemiLights),
      A.push(T.numRectAreaLights),
      A.push(T.numDirLightShadows),
      A.push(T.numPointLightShadows),
      A.push(T.numSpotLightShadows),
      A.push(T.numSpotLightShadowsWithMaps),
      A.push(T.shadowMapType),
      A.push(T.toneMapping),
      A.push(T.numClippingPlanes),
      A.push(T.numClipIntersection),
      A.push(T.depthPacking);
  }
  function x(A, T) {
    o.disableAll(),
      T.isWebGL2 && o.enable(0),
      T.supportsVertexTextures && o.enable(1),
      T.instancing && o.enable(2),
      T.instancingColor && o.enable(3),
      T.map && o.enable(4),
      T.matcap && o.enable(5),
      T.envMap && o.enable(6),
      T.lightMap && o.enable(7),
      T.aoMap && o.enable(8),
      T.emissiveMap && o.enable(9),
      T.bumpMap && o.enable(10),
      T.normalMap && o.enable(11),
      T.objectSpaceNormalMap && o.enable(12),
      T.tangentSpaceNormalMap && o.enable(13),
      T.clearcoat && o.enable(14),
      T.clearcoatMap && o.enable(15),
      T.clearcoatRoughnessMap && o.enable(16),
      T.clearcoatNormalMap && o.enable(17),
      T.iridescence && o.enable(18),
      T.iridescenceMap && o.enable(19),
      T.iridescenceThicknessMap && o.enable(20),
      T.displacementMap && o.enable(21),
      T.specularMap && o.enable(22),
      T.roughnessMap && o.enable(23),
      T.metalnessMap && o.enable(24),
      T.gradientMap && o.enable(25),
      T.alphaMap && o.enable(26),
      T.alphaTest && o.enable(27),
      T.vertexColors && o.enable(28),
      T.vertexAlphas && o.enable(29),
      T.vertexUvs && o.enable(30),
      T.vertexTangents && o.enable(31),
      T.uvsVertexOnly && o.enable(32),
      A.push(o.mask),
      o.disableAll(),
      T.fog && o.enable(0),
      T.useFog && o.enable(1),
      T.flatShading && o.enable(2),
      T.logarithmicDepthBuffer && o.enable(3),
      T.skinning && o.enable(4),
      T.morphTargets && o.enable(5),
      T.morphNormals && o.enable(6),
      T.morphColors && o.enable(7),
      T.premultipliedAlpha && o.enable(8),
      T.shadowMapEnabled && o.enable(9),
      T.physicallyCorrectLights && o.enable(10),
      T.doubleSided && o.enable(11),
      T.flipSided && o.enable(12),
      T.useDepthPacking && o.enable(13),
      T.dithering && o.enable(14),
      T.specularIntensityMap && o.enable(15),
      T.specularColorMap && o.enable(16),
      T.transmission && o.enable(17),
      T.transmissionMap && o.enable(18),
      T.thicknessMap && o.enable(19),
      T.sheen && o.enable(20),
      T.sheenColorMap && o.enable(21),
      T.sheenRoughnessMap && o.enable(22),
      T.decodeVideoTexture && o.enable(23),
      T.opaque && o.enable(24),
      A.push(o.mask);
  }
  function b(A) {
    let T = f[A.type],
      P;
    if (T) {
      let R = bn[T];
      P = au.clone(R.uniforms);
    } else P = A.uniforms;
    return P;
  }
  function _(A, T) {
    let P;
    for (let R = 0, z = h.length; R < z; R++) {
      let N = h[R];
      if (N.cacheKey === T) {
        (P = N), ++P.usedTimes;
        break;
      }
    }
    return P === void 0 && ((P = new Az(e, T, A, a)), h.push(P)), P;
  }
  function S(A) {
    if (--A.usedTimes === 0) {
      let T = h.indexOf(A);
      (h[T] = h[h.length - 1]), h.pop(), A.destroy();
    }
  }
  function M(A) {
    l.remove(A);
  }
  function C() {
    l.dispose();
  }
  return {
    getParameters: m,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: _,
    releaseProgram: S,
    releaseShaderCache: M,
    programs: h,
    dispose: C,
  };
}
function Pz() {
  let e = new WeakMap();
  function t(a) {
    let n = e.get(a);
    return n === void 0 && ((n = {}), e.set(a, n)), n;
  }
  function i(a) {
    e.delete(a);
  }
  function r(a, n, o) {
    e.get(a)[n] = o;
  }
  function s() {
    e = new WeakMap();
  }
  return { get: t, remove: i, update: r, dispose: s };
}
function Dz(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.material.id !== t.material.id
    ? e.material.id - t.material.id
    : e.z !== t.z
    ? e.z - t.z
    : e.id - t.id;
}
function W_(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.z !== t.z
    ? t.z - e.z
    : e.id - t.id;
}
function q_() {
  let e = [],
    t = 0,
    i = [],
    r = [],
    s = [];
  function a() {
    (t = 0), (i.length = 0), (r.length = 0), (s.length = 0);
  }
  function n(c, d, p, f, m, g) {
    let y = e[t];
    return (
      y === void 0
        ? ((y = {
            id: c.id,
            object: c,
            geometry: d,
            material: p,
            groupOrder: f,
            renderOrder: c.renderOrder,
            z: m,
            group: g,
          }),
          (e[t] = y))
        : ((y.id = c.id),
          (y.object = c),
          (y.geometry = d),
          (y.material = p),
          (y.groupOrder = f),
          (y.renderOrder = c.renderOrder),
          (y.z = m),
          (y.group = g)),
      t++,
      y
    );
  }
  function o(c, d, p, f, m, g) {
    let y = n(c, d, p, f, m, g);
    p.transmission > 0
      ? r.push(y)
      : p.transparent === !0
      ? s.push(y)
      : i.push(y);
  }
  function l(c, d, p, f, m, g) {
    let y = n(c, d, p, f, m, g);
    p.transmission > 0
      ? r.unshift(y)
      : p.transparent === !0
      ? s.unshift(y)
      : i.unshift(y);
  }
  function h(c, d) {
    i.length > 1 && i.sort(c || Dz),
      r.length > 1 && r.sort(d || W_),
      s.length > 1 && s.sort(d || W_);
  }
  function u() {
    for (let c = t, d = e.length; c < d; c++) {
      let p = e[c];
      if (p.id === null) break;
      (p.id = null),
        (p.object = null),
        (p.geometry = null),
        (p.material = null),
        (p.group = null);
    }
  }
  return {
    opaque: i,
    transmissive: r,
    transparent: s,
    init: a,
    push: o,
    unshift: l,
    finish: u,
    sort: h,
  };
}
function Oz() {
  let e = new WeakMap();
  function t(r, s) {
    let a = e.get(r),
      n;
    return (
      a === void 0
        ? ((n = new q_()), e.set(r, [n]))
        : s >= a.length
        ? ((n = new q_()), a.push(n))
        : (n = a[s]),
      n
    );
  }
  function i() {
    e = new WeakMap();
  }
  return { get: t, dispose: i };
}
function Iz() {
  let e = {};
  return {
    get: function (t) {
      if (e[t.id] !== void 0) return e[t.id];
      let i;
      switch (t.type) {
        case "DirectionalLight":
          i = { direction: new I(), color: new Et() };
          break;
        case "SpotLight":
          i = {
            position: new I(),
            direction: new I(),
            color: new Et(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          i = { position: new I(), color: new Et(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          i = { direction: new I(), skyColor: new Et(), groundColor: new Et() };
          break;
        case "RectAreaLight":
          i = {
            color: new Et(),
            position: new I(),
            halfWidth: new I(),
            halfHeight: new I(),
          };
          break;
      }
      return (e[t.id] = i), i;
    },
  };
}
function Rz() {
  let e = {};
  return {
    get: function (t) {
      if (e[t.id] !== void 0) return e[t.id];
      let i;
      switch (t.type) {
        case "DirectionalLight":
          i = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new re(),
          };
          break;
        case "SpotLight":
          i = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new re(),
          };
          break;
        case "PointLight":
          i = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new re(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (e[t.id] = i), i;
    },
  };
}
var Lz = 0;
function Bz(e, t) {
  return (
    (t.castShadow ? 2 : 0) -
    (e.castShadow ? 2 : 0) +
    (t.map ? 1 : 0) -
    (e.map ? 1 : 0)
  );
}
function zz(e, t) {
  let i = new Iz(),
    r = Rz(),
    s = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let u = 0; u < 9; u++) s.probe.push(new I());
  let a = new I(),
    n = new je(),
    o = new je();
  function l(u, c) {
    let d = 0,
      p = 0,
      f = 0;
    for (let R = 0; R < 9; R++) s.probe[R].set(0, 0, 0);
    let m = 0,
      g = 0,
      y = 0,
      x = 0,
      b = 0,
      _ = 0,
      S = 0,
      M = 0,
      C = 0,
      A = 0;
    u.sort(Bz);
    let T = c !== !0 ? Math.PI : 1;
    for (let R = 0, z = u.length; R < z; R++) {
      let N = u[R],
        L = N.color,
        G = N.intensity,
        Y = N.distance,
        Z = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
      if (N.isAmbientLight)
        (d += L.r * G * T), (p += L.g * G * T), (f += L.b * G * T);
      else if (N.isLightProbe)
        for (let q = 0; q < 9; q++)
          s.probe[q].addScaledVector(N.sh.coefficients[q], G);
      else if (N.isDirectionalLight) {
        let q = i.get(N);
        if (
          (q.color.copy(N.color).multiplyScalar(N.intensity * T), N.castShadow)
        ) {
          let oe = N.shadow,
            ce = r.get(N);
          (ce.shadowBias = oe.bias),
            (ce.shadowNormalBias = oe.normalBias),
            (ce.shadowRadius = oe.radius),
            (ce.shadowMapSize = oe.mapSize),
            (s.directionalShadow[m] = ce),
            (s.directionalShadowMap[m] = Z),
            (s.directionalShadowMatrix[m] = N.shadow.matrix),
            _++;
        }
        (s.directional[m] = q), m++;
      } else if (N.isSpotLight) {
        let q = i.get(N);
        q.position.setFromMatrixPosition(N.matrixWorld),
          q.color.copy(L).multiplyScalar(G * T),
          (q.distance = Y),
          (q.coneCos = Math.cos(N.angle)),
          (q.penumbraCos = Math.cos(N.angle * (1 - N.penumbra))),
          (q.decay = N.decay),
          (s.spot[y] = q);
        let oe = N.shadow;
        if (
          (N.map &&
            ((s.spotLightMap[C] = N.map),
            C++,
            oe.updateMatrices(N),
            N.castShadow && A++),
          (s.spotLightMatrix[y] = oe.matrix),
          N.castShadow)
        ) {
          let ce = r.get(N);
          (ce.shadowBias = oe.bias),
            (ce.shadowNormalBias = oe.normalBias),
            (ce.shadowRadius = oe.radius),
            (ce.shadowMapSize = oe.mapSize),
            (s.spotShadow[y] = ce),
            (s.spotShadowMap[y] = Z),
            M++;
        }
        y++;
      } else if (N.isRectAreaLight) {
        let q = i.get(N);
        q.color.copy(L).multiplyScalar(G),
          q.halfWidth.set(N.width * 0.5, 0, 0),
          q.halfHeight.set(0, N.height * 0.5, 0),
          (s.rectArea[x] = q),
          x++;
      } else if (N.isPointLight) {
        let q = i.get(N);
        if (
          (q.color.copy(N.color).multiplyScalar(N.intensity * T),
          (q.distance = N.distance),
          (q.decay = N.decay),
          N.castShadow)
        ) {
          let oe = N.shadow,
            ce = r.get(N);
          (ce.shadowBias = oe.bias),
            (ce.shadowNormalBias = oe.normalBias),
            (ce.shadowRadius = oe.radius),
            (ce.shadowMapSize = oe.mapSize),
            (ce.shadowCameraNear = oe.camera.near),
            (ce.shadowCameraFar = oe.camera.far),
            (s.pointShadow[g] = ce),
            (s.pointShadowMap[g] = Z),
            (s.pointShadowMatrix[g] = N.shadow.matrix),
            S++;
        }
        (s.point[g] = q), g++;
      } else if (N.isHemisphereLight) {
        let q = i.get(N);
        q.skyColor.copy(N.color).multiplyScalar(G * T),
          q.groundColor.copy(N.groundColor).multiplyScalar(G * T),
          (s.hemi[b] = q),
          b++;
      }
    }
    x > 0 &&
      (t.isWebGL2 || e.has("OES_texture_float_linear") === !0
        ? ((s.rectAreaLTC1 = et.LTC_FLOAT_1), (s.rectAreaLTC2 = et.LTC_FLOAT_2))
        : e.has("OES_texture_half_float_linear") === !0
        ? ((s.rectAreaLTC1 = et.LTC_HALF_1), (s.rectAreaLTC2 = et.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (s.ambient[0] = d),
      (s.ambient[1] = p),
      (s.ambient[2] = f);
    let P = s.hash;
    (P.directionalLength !== m ||
      P.pointLength !== g ||
      P.spotLength !== y ||
      P.rectAreaLength !== x ||
      P.hemiLength !== b ||
      P.numDirectionalShadows !== _ ||
      P.numPointShadows !== S ||
      P.numSpotShadows !== M ||
      P.numSpotMaps !== C) &&
      ((s.directional.length = m),
      (s.spot.length = y),
      (s.rectArea.length = x),
      (s.point.length = g),
      (s.hemi.length = b),
      (s.directionalShadow.length = _),
      (s.directionalShadowMap.length = _),
      (s.pointShadow.length = S),
      (s.pointShadowMap.length = S),
      (s.spotShadow.length = M),
      (s.spotShadowMap.length = M),
      (s.directionalShadowMatrix.length = _),
      (s.pointShadowMatrix.length = S),
      (s.spotLightMatrix.length = M + C - A),
      (s.spotLightMap.length = C),
      (s.numSpotLightShadowsWithMaps = A),
      (P.directionalLength = m),
      (P.pointLength = g),
      (P.spotLength = y),
      (P.rectAreaLength = x),
      (P.hemiLength = b),
      (P.numDirectionalShadows = _),
      (P.numPointShadows = S),
      (P.numSpotShadows = M),
      (P.numSpotMaps = C),
      (s.version = Lz++));
  }
  function h(u, c) {
    let d = 0,
      p = 0,
      f = 0,
      m = 0,
      g = 0,
      y = c.matrixWorldInverse;
    for (let x = 0, b = u.length; x < b; x++) {
      let _ = u[x];
      if (_.isDirectionalLight) {
        let S = s.directional[d];
        S.direction.setFromMatrixPosition(_.matrixWorld),
          a.setFromMatrixPosition(_.target.matrixWorld),
          S.direction.sub(a),
          S.direction.transformDirection(y),
          d++;
      } else if (_.isSpotLight) {
        let S = s.spot[f];
        S.position.setFromMatrixPosition(_.matrixWorld),
          S.position.applyMatrix4(y),
          S.direction.setFromMatrixPosition(_.matrixWorld),
          a.setFromMatrixPosition(_.target.matrixWorld),
          S.direction.sub(a),
          S.direction.transformDirection(y),
          f++;
      } else if (_.isRectAreaLight) {
        let S = s.rectArea[m];
        S.position.setFromMatrixPosition(_.matrixWorld),
          S.position.applyMatrix4(y),
          o.identity(),
          n.copy(_.matrixWorld),
          n.premultiply(y),
          o.extractRotation(n),
          S.halfWidth.set(_.width * 0.5, 0, 0),
          S.halfHeight.set(0, _.height * 0.5, 0),
          S.halfWidth.applyMatrix4(o),
          S.halfHeight.applyMatrix4(o),
          m++;
      } else if (_.isPointLight) {
        let S = s.point[p];
        S.position.setFromMatrixPosition(_.matrixWorld),
          S.position.applyMatrix4(y),
          p++;
      } else if (_.isHemisphereLight) {
        let S = s.hemi[g];
        S.direction.setFromMatrixPosition(_.matrixWorld),
          S.direction.transformDirection(y),
          g++;
      }
    }
  }
  return { setup: l, setupView: h, state: s };
}
function Y_(e, t) {
  let i = new zz(e, t),
    r = [],
    s = [];
  function a() {
    (r.length = 0), (s.length = 0);
  }
  function n(u) {
    r.push(u);
  }
  function o(u) {
    s.push(u);
  }
  function l(u) {
    i.setup(r, u);
  }
  function h(u) {
    i.setupView(r, u);
  }
  return {
    init: a,
    state: { lightsArray: r, shadowsArray: s, lights: i },
    setupLights: l,
    setupLightsView: h,
    pushLight: n,
    pushShadow: o,
  };
}
function Fz(e, t) {
  let i = new WeakMap();
  function r(a, n = 0) {
    let o = i.get(a),
      l;
    return (
      o === void 0
        ? ((l = new Y_(e, t)), i.set(a, [l]))
        : n >= o.length
        ? ((l = new Y_(e, t)), o.push(l))
        : (l = o[n]),
      l
    );
  }
  function s() {
    i = new WeakMap();
  }
  return { get: r, dispose: s };
}
var oC = class extends sp {
    constructor(e) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = Eo),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.depthPacking = e.depthPacking),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        this
      );
    }
  },
  kz = class extends sp {
    constructor(e) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new I()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        (this.nearDistance = e.nearDistance),
        (this.farDistance = e.farDistance),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        this
      );
    }
  },
  Nz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  Uz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Vz(e, t, i) {
  let r = new xx(),
    s = new re(),
    a = new re(),
    n = new Lt(),
    o = new oC({ depthPacking: YE }),
    l = new kz(),
    h = {},
    u = i.maxTextureSize,
    c = { [Xa]: Yr, [Yr]: Xa, [js]: js },
    d = new vi({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new re() },
        radius: { value: 4 },
      },
      vertexShader: Nz,
      fragmentShader: Uz,
    }),
    p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  let f = new yt();
  f.setAttribute(
    "position",
    new It(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  let m = new br(f, d),
    g = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = px),
    (this.render = function (_, S, M) {
      if (
        g.enabled === !1 ||
        (g.autoUpdate === !1 && g.needsUpdate === !1) ||
        _.length === 0
      )
        return;
      let C = e.getRenderTarget(),
        A = e.getActiveCubeFace(),
        T = e.getActiveMipmapLevel(),
        P = e.state;
      P.setBlending(wr),
        P.buffers.color.setClear(1, 1, 1, 1),
        P.buffers.depth.setTest(!0),
        P.setScissorTest(!1);
      for (let R = 0, z = _.length; R < z; R++) {
        let N = _[R],
          L = N.shadow;
        if (L === void 0) {
          console.warn("THREE.WebGLShadowMap:", N, "has no shadow.");
          continue;
        }
        if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
        s.copy(L.mapSize);
        let G = L.getFrameExtents();
        if (
          (s.multiply(G),
          a.copy(L.mapSize),
          (s.x > u || s.y > u) &&
            (s.x > u &&
              ((a.x = Math.floor(u / G.x)),
              (s.x = a.x * G.x),
              (L.mapSize.x = a.x)),
            s.y > u &&
              ((a.y = Math.floor(u / G.y)),
              (s.y = a.y * G.y),
              (L.mapSize.y = a.y))),
          L.map === null)
        ) {
          let Z = this.type !== hd ? { minFilter: mi, magFilter: mi } : {};
          (L.map = new gi(s.x, s.y, Z)),
            (L.map.texture.name = N.name + ".shadowMap"),
            L.camera.updateProjectionMatrix();
        }
        e.setRenderTarget(L.map), e.clear();
        let Y = L.getViewportCount();
        for (let Z = 0; Z < Y; Z++) {
          let q = L.getViewport(Z);
          n.set(a.x * q.x, a.y * q.y, a.x * q.z, a.y * q.w),
            P.viewport(n),
            L.updateMatrices(N, Z),
            (r = L.getFrustum()),
            b(S, M, L.camera, N, this.type);
        }
        L.isPointLightShadow !== !0 && this.type === hd && y(L, M),
          (L.needsUpdate = !1);
      }
      (g.needsUpdate = !1), e.setRenderTarget(C, A, T);
    });
  function y(_, S) {
    let M = t.update(m);
    d.defines.VSM_SAMPLES !== _.blurSamples &&
      ((d.defines.VSM_SAMPLES = _.blurSamples),
      (p.defines.VSM_SAMPLES = _.blurSamples),
      (d.needsUpdate = !0),
      (p.needsUpdate = !0)),
      _.mapPass === null && (_.mapPass = new gi(s.x, s.y)),
      (d.uniforms.shadow_pass.value = _.map.texture),
      (d.uniforms.resolution.value = _.mapSize),
      (d.uniforms.radius.value = _.radius),
      e.setRenderTarget(_.mapPass),
      e.clear(),
      e.renderBufferDirect(S, null, M, d, m, null),
      (p.uniforms.shadow_pass.value = _.mapPass.texture),
      (p.uniforms.resolution.value = _.mapSize),
      (p.uniforms.radius.value = _.radius),
      e.setRenderTarget(_.map),
      e.clear(),
      e.renderBufferDirect(S, null, M, p, m, null);
  }
  function x(_, S, M, C, A, T) {
    let P = null,
      R =
        M.isPointLight === !0
          ? _.customDistanceMaterial
          : _.customDepthMaterial;
    if (R !== void 0) P = R;
    else if (
      ((P = M.isPointLight === !0 ? l : o),
      (e.localClippingEnabled &&
        S.clipShadows === !0 &&
        Array.isArray(S.clippingPlanes) &&
        S.clippingPlanes.length !== 0) ||
        (S.displacementMap && S.displacementScale !== 0) ||
        (S.alphaMap && S.alphaTest > 0) ||
        (S.map && S.alphaTest > 0))
    ) {
      let z = P.uuid,
        N = S.uuid,
        L = h[z];
      L === void 0 && ((L = {}), (h[z] = L));
      let G = L[N];
      G === void 0 && ((G = P.clone()), (L[N] = G)), (P = G);
    }
    return (
      (P.visible = S.visible),
      (P.wireframe = S.wireframe),
      T === hd
        ? (P.side = S.shadowSide !== null ? S.shadowSide : S.side)
        : (P.side = S.shadowSide !== null ? S.shadowSide : c[S.side]),
      (P.alphaMap = S.alphaMap),
      (P.alphaTest = S.alphaTest),
      (P.map = S.map),
      (P.clipShadows = S.clipShadows),
      (P.clippingPlanes = S.clippingPlanes),
      (P.clipIntersection = S.clipIntersection),
      (P.displacementMap = S.displacementMap),
      (P.displacementScale = S.displacementScale),
      (P.displacementBias = S.displacementBias),
      (P.wireframeLinewidth = S.wireframeLinewidth),
      (P.linewidth = S.linewidth),
      M.isPointLight === !0 &&
        P.isMeshDistanceMaterial === !0 &&
        (P.referencePosition.setFromMatrixPosition(M.matrixWorld),
        (P.nearDistance = C),
        (P.farDistance = A)),
      P
    );
  }
  function b(_, S, M, C, A) {
    if (_.visible === !1) return;
    if (
      _.layers.test(S.layers) &&
      (_.isMesh || _.isLine || _.isPoints) &&
      (_.castShadow || (_.receiveShadow && A === hd)) &&
      (!_.frustumCulled || r.intersectsObject(_))
    ) {
      _.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, _.matrixWorld);
      let P = t.update(_),
        R = _.material;
      if (Array.isArray(R)) {
        let z = P.groups;
        for (let N = 0, L = z.length; N < L; N++) {
          let G = z[N],
            Y = R[G.materialIndex];
          if (Y && Y.visible) {
            let Z = x(_, Y, C, M.near, M.far, A);
            e.renderBufferDirect(M, null, P, Z, _, G);
          }
        }
      } else if (R.visible) {
        let z = x(_, R, C, M.near, M.far, A);
        e.renderBufferDirect(M, null, P, z, _, null);
      }
    }
    let T = _.children;
    for (let P = 0, R = T.length; P < R; P++) b(T[P], S, M, C, A);
  }
}
function jz(e, t, i) {
  let r = i.isWebGL2;
  function s() {
    let ge = !1,
      Ce = new Lt(),
      Ye = null,
      Ke = new Lt(0, 0, 0, 0);
    return {
      setMask: function (gt) {
        Ye !== gt && !ge && (e.colorMask(gt, gt, gt, gt), (Ye = gt));
      },
      setLocked: function (gt) {
        ge = gt;
      },
      setClear: function (gt, Mt, yi, ki, Ar) {
        Ar === !0 && ((gt *= ki), (Mt *= ki), (yi *= ki)),
          Ce.set(gt, Mt, yi, ki),
          Ke.equals(Ce) === !1 && (e.clearColor(gt, Mt, yi, ki), Ke.copy(Ce));
      },
      reset: function () {
        (ge = !1), (Ye = null), Ke.set(-1, 0, 0, 0);
      },
    };
  }
  function a() {
    let ge = !1,
      Ce = null,
      Ye = null,
      Ke = null;
    return {
      setTest: function (gt) {
        gt ? Ee(2929) : me(2929);
      },
      setMask: function (gt) {
        Ce !== gt && !ge && (e.depthMask(gt), (Ce = gt));
      },
      setFunc: function (gt) {
        if (Ye !== gt) {
          switch (gt) {
            case lI:
              e.depthFunc(512);
              break;
            case hI:
              e.depthFunc(519);
              break;
            case cI:
              e.depthFunc(513);
              break;
            case cy:
              e.depthFunc(515);
              break;
            case uI:
              e.depthFunc(514);
              break;
            case dI:
              e.depthFunc(518);
              break;
            case pI:
              e.depthFunc(516);
              break;
            case fI:
              e.depthFunc(517);
              break;
            default:
              e.depthFunc(515);
          }
          Ye = gt;
        }
      },
      setLocked: function (gt) {
        ge = gt;
      },
      setClear: function (gt) {
        Ke !== gt && (e.clearDepth(gt), (Ke = gt));
      },
      reset: function () {
        (ge = !1), (Ce = null), (Ye = null), (Ke = null);
      },
    };
  }
  function n() {
    let ge = !1,
      Ce = null,
      Ye = null,
      Ke = null,
      gt = null,
      Mt = null,
      yi = null,
      ki = null,
      Ar = null;
    return {
      setTest: function (Si) {
        ge || (Si ? Ee(2960) : me(2960));
      },
      setMask: function (Si) {
        Ce !== Si && !ge && (e.stencilMask(Si), (Ce = Si));
      },
      setFunc: function (Si, Jr, Mr) {
        (Ye !== Si || Ke !== Jr || gt !== Mr) &&
          (e.stencilFunc(Si, Jr, Mr), (Ye = Si), (Ke = Jr), (gt = Mr));
      },
      setOp: function (Si, Jr, Mr) {
        (Mt !== Si || yi !== Jr || ki !== Mr) &&
          (e.stencilOp(Si, Jr, Mr), (Mt = Si), (yi = Jr), (ki = Mr));
      },
      setLocked: function (Si) {
        ge = Si;
      },
      setClear: function (Si) {
        Ar !== Si && (e.clearStencil(Si), (Ar = Si));
      },
      reset: function () {
        (ge = !1),
          (Ce = null),
          (Ye = null),
          (Ke = null),
          (gt = null),
          (Mt = null),
          (yi = null),
          (ki = null),
          (Ar = null);
      },
    };
  }
  let o = new s(),
    l = new a(),
    h = new n(),
    u = new WeakMap(),
    c = new WeakMap(),
    d = {},
    p = {},
    f = new WeakMap(),
    m = [],
    g = null,
    y = !1,
    x = null,
    b = null,
    _ = null,
    S = null,
    M = null,
    C = null,
    A = null,
    T = !1,
    P = null,
    R = null,
    z = null,
    N = null,
    L = null,
    G = e.getParameter(35661),
    Y = !1,
    Z = 0,
    q = e.getParameter(7938);
  q.indexOf("WebGL") !== -1
    ? ((Z = parseFloat(/^WebGL (\d)/.exec(q)[1])), (Y = Z >= 1))
    : q.indexOf("OpenGL ES") !== -1 &&
      ((Z = parseFloat(/^OpenGL ES (\d)/.exec(q)[1])), (Y = Z >= 2));
  let oe = null,
    ce = {},
    ie = e.getParameter(3088),
    te = e.getParameter(2978),
    ue = new Lt().fromArray(ie),
    ae = new Lt().fromArray(te);
  function de(ge, Ce, Ye) {
    let Ke = new Uint8Array(4),
      gt = e.createTexture();
    e.bindTexture(ge, gt),
      e.texParameteri(ge, 10241, 9728),
      e.texParameteri(ge, 10240, 9728);
    for (let Mt = 0; Mt < Ye; Mt++)
      e.texImage2D(Ce + Mt, 0, 6408, 1, 1, 0, 6408, 5121, Ke);
    return gt;
  }
  let ne = {};
  (ne[3553] = de(3553, 3553, 1)),
    (ne[34067] = de(34067, 34069, 6)),
    o.setClear(0, 0, 0, 1),
    l.setClear(1),
    h.setClear(0),
    Ee(2929),
    l.setFunc(cy),
    rt(!1),
    st(kw),
    Ee(2884),
    tt(wr);
  function Ee(ge) {
    d[ge] !== !0 && (e.enable(ge), (d[ge] = !0));
  }
  function me(ge) {
    d[ge] !== !1 && (e.disable(ge), (d[ge] = !1));
  }
  function Ae(ge, Ce) {
    return p[ge] !== Ce
      ? (e.bindFramebuffer(ge, Ce),
        (p[ge] = Ce),
        r && (ge === 36009 && (p[36160] = Ce), ge === 36160 && (p[36009] = Ce)),
        !0)
      : !1;
  }
  function ye(ge, Ce) {
    let Ye = m,
      Ke = !1;
    if (ge)
      if (
        ((Ye = f.get(Ce)),
        Ye === void 0 && ((Ye = []), f.set(Ce, Ye)),
        ge.isWebGLMultipleRenderTargets)
      ) {
        let gt = ge.texture;
        if (Ye.length !== gt.length || Ye[0] !== 36064) {
          for (let Mt = 0, yi = gt.length; Mt < yi; Mt++) Ye[Mt] = 36064 + Mt;
          (Ye.length = gt.length), (Ke = !0);
        }
      } else Ye[0] !== 36064 && ((Ye[0] = 36064), (Ke = !0));
    else Ye[0] !== 1029 && ((Ye[0] = 1029), (Ke = !0));
    Ke &&
      (i.isWebGL2
        ? e.drawBuffers(Ye)
        : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ye));
  }
  function Ue(ge) {
    return g !== ge ? (e.useProgram(ge), (g = ge), !0) : !1;
  }
  let Le = { [pc]: 32774, [KO]: 32778, [JO]: 32779 };
  if (r) (Le[jw] = 32775), (Le[Hw] = 32776);
  else {
    let ge = t.get("EXT_blend_minmax");
    ge !== null && ((Le[jw] = ge.MIN_EXT), (Le[Hw] = ge.MAX_EXT));
  }
  let Te = {
    [$O]: 0,
    [eI]: 1,
    [tI]: 768,
    [NE]: 770,
    [oI]: 776,
    [aI]: 774,
    [rI]: 772,
    [iI]: 769,
    [UE]: 771,
    [nI]: 775,
    [sI]: 773,
  };
  function tt(ge, Ce, Ye, Ke, gt, Mt, yi, ki) {
    if (ge === wr) {
      y === !0 && (me(3042), (y = !1));
      return;
    }
    if ((y === !1 && (Ee(3042), (y = !0)), ge !== ZO)) {
      if (ge !== x || ki !== T) {
        if (
          ((b !== pc || M !== pc) &&
            (e.blendEquation(32774), (b = pc), (M = pc)),
          ki)
        )
          switch (ge) {
            case Jl:
              e.blendFuncSeparate(1, 771, 1, 771);
              break;
            case Nw:
              e.blendFunc(1, 1);
              break;
            case Uw:
              e.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Vw:
              e.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ge);
              break;
          }
        else
          switch (ge) {
            case Jl:
              e.blendFuncSeparate(770, 771, 1, 771);
              break;
            case Nw:
              e.blendFunc(770, 1);
              break;
            case Uw:
              e.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Vw:
              e.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ge);
              break;
          }
        (_ = null), (S = null), (C = null), (A = null), (x = ge), (T = ki);
      }
      return;
    }
    (gt = gt || Ce),
      (Mt = Mt || Ye),
      (yi = yi || Ke),
      (Ce !== b || gt !== M) &&
        (e.blendEquationSeparate(Le[Ce], Le[gt]), (b = Ce), (M = gt)),
      (Ye !== _ || Ke !== S || Mt !== C || yi !== A) &&
        (e.blendFuncSeparate(Te[Ye], Te[Ke], Te[Mt], Te[yi]),
        (_ = Ye),
        (S = Ke),
        (C = Mt),
        (A = yi)),
      (x = ge),
      (T = !1);
  }
  function Je(ge, Ce) {
    ge.side === js ? me(2884) : Ee(2884);
    let Ye = ge.side === Yr;
    Ce && (Ye = !Ye),
      rt(Ye),
      ge.blending === Jl && ge.transparent === !1
        ? tt(wr)
        : tt(
            ge.blending,
            ge.blendEquation,
            ge.blendSrc,
            ge.blendDst,
            ge.blendEquationAlpha,
            ge.blendSrcAlpha,
            ge.blendDstAlpha,
            ge.premultipliedAlpha
          ),
      l.setFunc(ge.depthFunc),
      l.setTest(ge.depthTest),
      l.setMask(ge.depthWrite),
      o.setMask(ge.colorWrite);
    let Ke = ge.stencilWrite;
    h.setTest(Ke),
      Ke &&
        (h.setMask(ge.stencilWriteMask),
        h.setFunc(ge.stencilFunc, ge.stencilRef, ge.stencilFuncMask),
        h.setOp(ge.stencilFail, ge.stencilZFail, ge.stencilZPass)),
      Qe(ge.polygonOffset, ge.polygonOffsetFactor, ge.polygonOffsetUnits),
      ge.alphaToCoverage === !0 ? Ee(32926) : me(32926);
  }
  function rt(ge) {
    P !== ge && (ge ? e.frontFace(2304) : e.frontFace(2305), (P = ge));
  }
  function st(ge) {
    ge !== YO
      ? (Ee(2884),
        ge !== R &&
          (ge === kw
            ? e.cullFace(1029)
            : ge === XO
            ? e.cullFace(1028)
            : e.cullFace(1032)))
      : me(2884),
      (R = ge);
  }
  function Ze(ge) {
    ge !== z && (Y && e.lineWidth(ge), (z = ge));
  }
  function Qe(ge, Ce, Ye) {
    ge
      ? (Ee(32823),
        (N !== Ce || L !== Ye) && (e.polygonOffset(Ce, Ye), (N = Ce), (L = Ye)))
      : me(32823);
  }
  function pt(ge) {
    ge ? Ee(3089) : me(3089);
  }
  function bt(ge) {
    ge === void 0 && (ge = 33984 + G - 1),
      oe !== ge && (e.activeTexture(ge), (oe = ge));
  }
  function $(ge, Ce, Ye) {
    Ye === void 0 && (oe === null ? (Ye = 33984 + G - 1) : (Ye = oe));
    let Ke = ce[Ye];
    Ke === void 0 && ((Ke = { type: void 0, texture: void 0 }), (ce[Ye] = Ke)),
      (Ke.type !== ge || Ke.texture !== Ce) &&
        (oe !== Ye && (e.activeTexture(Ye), (oe = Ye)),
        e.bindTexture(ge, Ce || ne[ge]),
        (Ke.type = ge),
        (Ke.texture = Ce));
  }
  function W() {
    let ge = ce[oe];
    ge !== void 0 &&
      ge.type !== void 0 &&
      (e.bindTexture(ge.type, null), (ge.type = void 0), (ge.texture = void 0));
  }
  function _e() {
    try {
      e.compressedTexImage2D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Ge() {
    try {
      e.compressedTexImage3D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function V() {
    try {
      e.texSubImage2D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function De() {
    try {
      e.texSubImage3D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function ct() {
    try {
      e.compressedTexSubImage2D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function We() {
    try {
      e.compressedTexSubImage3D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Be() {
    try {
      e.texStorage2D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function Fe() {
    try {
      e.texStorage3D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function ut() {
    try {
      e.texImage2D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function at() {
    try {
      e.texImage3D.apply(e, arguments);
    } catch (ge) {
      console.error("THREE.WebGLState:", ge);
    }
  }
  function wt(ge) {
    ue.equals(ge) === !1 && (e.scissor(ge.x, ge.y, ge.z, ge.w), ue.copy(ge));
  }
  function xt(ge) {
    ae.equals(ge) === !1 && (e.viewport(ge.x, ge.y, ge.z, ge.w), ae.copy(ge));
  }
  function ii(ge, Ce) {
    let Ye = c.get(Ce);
    Ye === void 0 && ((Ye = new WeakMap()), c.set(Ce, Ye));
    let Ke = Ye.get(ge);
    Ke === void 0 &&
      ((Ke = e.getUniformBlockIndex(Ce, ge.name)), Ye.set(ge, Ke));
  }
  function ui(ge, Ce) {
    let Ye = c.get(Ce).get(ge);
    u.get(Ce) !== Ye &&
      (e.uniformBlockBinding(Ce, Ye, ge.__bindingPointIndex), u.set(Ce, Ye));
  }
  function ei() {
    e.disable(3042),
      e.disable(2884),
      e.disable(2929),
      e.disable(32823),
      e.disable(3089),
      e.disable(2960),
      e.disable(32926),
      e.blendEquation(32774),
      e.blendFunc(1, 0),
      e.blendFuncSeparate(1, 0, 1, 0),
      e.colorMask(!0, !0, !0, !0),
      e.clearColor(0, 0, 0, 0),
      e.depthMask(!0),
      e.depthFunc(513),
      e.clearDepth(1),
      e.stencilMask(4294967295),
      e.stencilFunc(519, 0, 4294967295),
      e.stencilOp(7680, 7680, 7680),
      e.clearStencil(0),
      e.cullFace(1029),
      e.frontFace(2305),
      e.polygonOffset(0, 0),
      e.activeTexture(33984),
      e.bindFramebuffer(36160, null),
      r === !0 &&
        (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)),
      e.useProgram(null),
      e.lineWidth(1),
      e.scissor(0, 0, e.canvas.width, e.canvas.height),
      e.viewport(0, 0, e.canvas.width, e.canvas.height),
      (d = {}),
      (oe = null),
      (ce = {}),
      (p = {}),
      (f = new WeakMap()),
      (m = []),
      (g = null),
      (y = !1),
      (x = null),
      (b = null),
      (_ = null),
      (S = null),
      (M = null),
      (C = null),
      (A = null),
      (T = !1),
      (P = null),
      (R = null),
      (z = null),
      (N = null),
      (L = null),
      ue.set(0, 0, e.canvas.width, e.canvas.height),
      ae.set(0, 0, e.canvas.width, e.canvas.height),
      o.reset(),
      l.reset(),
      h.reset();
  }
  return {
    buffers: { color: o, depth: l, stencil: h },
    enable: Ee,
    disable: me,
    bindFramebuffer: Ae,
    drawBuffers: ye,
    useProgram: Ue,
    setBlending: tt,
    setMaterial: Je,
    setFlipSided: rt,
    setCullFace: st,
    setLineWidth: Ze,
    setPolygonOffset: Qe,
    setScissorTest: pt,
    activeTexture: bt,
    bindTexture: $,
    unbindTexture: W,
    compressedTexImage2D: _e,
    compressedTexImage3D: Ge,
    texImage2D: ut,
    texImage3D: at,
    updateUBOMapping: ii,
    uniformBlockBinding: ui,
    texStorage2D: Be,
    texStorage3D: Fe,
    texSubImage2D: V,
    texSubImage3D: De,
    compressedTexSubImage2D: ct,
    compressedTexSubImage3D: We,
    scissor: wt,
    viewport: xt,
    reset: ei,
  };
}
function Hz(e, t, i, r, s, a, n) {
  let o = s.isWebGL2,
    l = s.maxTextures,
    h = s.maxCubemapSize,
    u = s.maxTextureSize,
    c = s.maxSamples,
    d = t.has("WEBGL_multisampled_render_to_texture")
      ? t.get("WEBGL_multisampled_render_to_texture")
      : null,
    p =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    f = new WeakMap(),
    m,
    g = new WeakMap(),
    y = !1;
  try {
    y =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x($, W) {
    return y ? new OffscreenCanvas($, W) : Rd("canvas");
  }
  function b($, W, _e, Ge) {
    let V = 1;
    if (
      (($.width > Ge || $.height > Ge) &&
        (V = Ge / Math.max($.width, $.height)),
      V < 1 || W === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && $ instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && $ instanceof ImageBitmap)
      ) {
        let De = W ? wm : Math.floor,
          ct = De(V * $.width),
          We = De(V * $.height);
        m === void 0 && (m = x(ct, We));
        let Be = _e ? x(ct, We) : m;
        return (
          (Be.width = ct),
          (Be.height = We),
          Be.getContext("2d").drawImage($, 0, 0, ct, We),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              $.width +
              "x" +
              $.height +
              ") to (" +
              ct +
              "x" +
              We +
              ")."
          ),
          Be
        );
      } else
        return (
          "data" in $ &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                $.width +
                "x" +
                $.height +
                ")."
            ),
          $
        );
    return $;
  }
  function _($) {
    return gy($.width) && gy($.height);
  }
  function S($) {
    return o
      ? !1
      : $.wrapS !== Ui ||
          $.wrapT !== Ui ||
          ($.minFilter !== mi && $.minFilter !== Wt);
  }
  function M($, W) {
    return $.generateMipmaps && W && $.minFilter !== mi && $.minFilter !== Wt;
  }
  function C($) {
    e.generateMipmap($);
  }
  function A($, W, _e, Ge, V = !1) {
    if (o === !1) return W;
    if ($ !== null) {
      if (e[$] !== void 0) return e[$];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          $ +
          "'"
      );
    }
    let De = W;
    return (
      W === 6403 &&
        (_e === 5126 && (De = 33326),
        _e === 5131 && (De = 33325),
        _e === 5121 && (De = 33321)),
      W === 33319 &&
        (_e === 5126 && (De = 33328),
        _e === 5131 && (De = 33327),
        _e === 5121 && (De = 33323)),
      W === 6408 &&
        (_e === 5126 && (De = 34836),
        _e === 5131 && (De = 34842),
        _e === 5121 && (De = Ge === jt && V === !1 ? 35907 : 32856),
        _e === 32819 && (De = 32854),
        _e === 32820 && (De = 32855)),
      (De === 33325 ||
        De === 33326 ||
        De === 33327 ||
        De === 33328 ||
        De === 34842 ||
        De === 34836) &&
        t.get("EXT_color_buffer_float"),
      De
    );
  }
  function T($, W, _e) {
    return M($, _e) === !0 ||
      ($.isFramebufferTexture && $.minFilter !== mi && $.minFilter !== Wt)
      ? Math.log2(Math.max(W.width, W.height)) + 1
      : $.mipmaps !== void 0 && $.mipmaps.length > 0
      ? $.mipmaps.length
      : $.isCompressedTexture && Array.isArray($.image)
      ? W.mipmaps.length
      : 1;
  }
  function P($) {
    return $ === mi || $ === Gw || $ === av ? 9728 : 9729;
  }
  function R($) {
    let W = $.target;
    W.removeEventListener("dispose", R), N(W), W.isVideoTexture && f.delete(W);
  }
  function z($) {
    let W = $.target;
    W.removeEventListener("dispose", z), G(W);
  }
  function N($) {
    let W = r.get($);
    if (W.__webglInit === void 0) return;
    let _e = $.source,
      Ge = g.get(_e);
    if (Ge) {
      let V = Ge[W.__cacheKey];
      V.usedTimes--,
        V.usedTimes === 0 && L($),
        Object.keys(Ge).length === 0 && g.delete(_e);
    }
    r.remove($);
  }
  function L($) {
    let W = r.get($);
    e.deleteTexture(W.__webglTexture);
    let _e = $.source,
      Ge = g.get(_e);
    delete Ge[W.__cacheKey], n.memory.textures--;
  }
  function G($) {
    let W = $.texture,
      _e = r.get($),
      Ge = r.get(W);
    if (
      (Ge.__webglTexture !== void 0 &&
        (e.deleteTexture(Ge.__webglTexture), n.memory.textures--),
      $.depthTexture && $.depthTexture.dispose(),
      $.isWebGLCubeRenderTarget)
    )
      for (let V = 0; V < 6; V++)
        e.deleteFramebuffer(_e.__webglFramebuffer[V]),
          _e.__webglDepthbuffer &&
            e.deleteRenderbuffer(_e.__webglDepthbuffer[V]);
    else {
      if (
        (e.deleteFramebuffer(_e.__webglFramebuffer),
        _e.__webglDepthbuffer && e.deleteRenderbuffer(_e.__webglDepthbuffer),
        _e.__webglMultisampledFramebuffer &&
          e.deleteFramebuffer(_e.__webglMultisampledFramebuffer),
        _e.__webglColorRenderbuffer)
      )
        for (let V = 0; V < _e.__webglColorRenderbuffer.length; V++)
          _e.__webglColorRenderbuffer[V] &&
            e.deleteRenderbuffer(_e.__webglColorRenderbuffer[V]);
      _e.__webglDepthRenderbuffer &&
        e.deleteRenderbuffer(_e.__webglDepthRenderbuffer);
    }
    if ($.isWebGLMultipleRenderTargets)
      for (let V = 0, De = W.length; V < De; V++) {
        let ct = r.get(W[V]);
        ct.__webglTexture &&
          (e.deleteTexture(ct.__webglTexture), n.memory.textures--),
          r.remove(W[V]);
      }
    r.remove(W), r.remove($);
  }
  let Y = 0;
  function Z() {
    Y = 0;
  }
  function q() {
    let $ = Y;
    return (
      $ >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            $ +
            " texture units while this GPU supports only " +
            l
        ),
      (Y += 1),
      $
    );
  }
  function oe($) {
    let W = [];
    return (
      W.push($.wrapS),
      W.push($.wrapT),
      W.push($.wrapR || 0),
      W.push($.magFilter),
      W.push($.minFilter),
      W.push($.anisotropy),
      W.push($.internalFormat),
      W.push($.format),
      W.push($.type),
      W.push($.generateMipmaps),
      W.push($.premultiplyAlpha),
      W.push($.flipY),
      W.push($.unpackAlignment),
      W.push($.encoding),
      W.join()
    );
  }
  function ce($, W) {
    let _e = r.get($);
    if (
      ($.isVideoTexture && pt($),
      $.isRenderTargetTexture === !1 &&
        $.version > 0 &&
        _e.__version !== $.version)
    ) {
      let Ge = $.image;
      if (Ge === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Ge.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        me(_e, $, W);
        return;
      }
    }
    i.bindTexture(3553, _e.__webglTexture, 33984 + W);
  }
  function ie($, W) {
    let _e = r.get($);
    if ($.version > 0 && _e.__version !== $.version) {
      me(_e, $, W);
      return;
    }
    i.bindTexture(35866, _e.__webglTexture, 33984 + W);
  }
  function te($, W) {
    let _e = r.get($);
    if ($.version > 0 && _e.__version !== $.version) {
      me(_e, $, W);
      return;
    }
    i.bindTexture(32879, _e.__webglTexture, 33984 + W);
  }
  function ue($, W) {
    let _e = r.get($);
    if ($.version > 0 && _e.__version !== $.version) {
      Ae(_e, $, W);
      return;
    }
    i.bindTexture(34067, _e.__webglTexture, 33984 + W);
  }
  let ae = { [mo]: 10497, [Ui]: 33071, [py]: 33648 },
    de = {
      [mi]: 9728,
      [Gw]: 9984,
      [av]: 9986,
      [Wt]: 9729,
      [_I]: 9985,
      [jc]: 9987,
    };
  function ne($, W, _e) {
    if (
      (_e
        ? (e.texParameteri($, 10242, ae[W.wrapS]),
          e.texParameteri($, 10243, ae[W.wrapT]),
          ($ === 32879 || $ === 35866) &&
            e.texParameteri($, 32882, ae[W.wrapR]),
          e.texParameteri($, 10240, de[W.magFilter]),
          e.texParameteri($, 10241, de[W.minFilter]))
        : (e.texParameteri($, 10242, 33071),
          e.texParameteri($, 10243, 33071),
          ($ === 32879 || $ === 35866) && e.texParameteri($, 32882, 33071),
          (W.wrapS !== Ui || W.wrapT !== Ui) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          e.texParameteri($, 10240, P(W.magFilter)),
          e.texParameteri($, 10241, P(W.minFilter)),
          W.minFilter !== mi &&
            W.minFilter !== Wt &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      t.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      let Ge = t.get("EXT_texture_filter_anisotropic");
      if (
        W.magFilter === mi ||
        (W.minFilter !== av && W.minFilter !== jc) ||
        (W.type === xr && t.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          W.type === lh &&
          t.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (W.anisotropy > 1 || r.get(W).__currentAnisotropy) &&
        (e.texParameterf(
          $,
          Ge.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(W.anisotropy, s.getMaxAnisotropy())
        ),
        (r.get(W).__currentAnisotropy = W.anisotropy));
    }
  }
  function Ee($, W) {
    let _e = !1;
    $.__webglInit === void 0 &&
      (($.__webglInit = !0), W.addEventListener("dispose", R));
    let Ge = W.source,
      V = g.get(Ge);
    V === void 0 && ((V = {}), g.set(Ge, V));
    let De = oe(W);
    if (De !== $.__cacheKey) {
      V[De] === void 0 &&
        ((V[De] = { texture: e.createTexture(), usedTimes: 0 }),
        n.memory.textures++,
        (_e = !0)),
        V[De].usedTimes++;
      let ct = V[$.__cacheKey];
      ct !== void 0 &&
        (V[$.__cacheKey].usedTimes--, ct.usedTimes === 0 && L(W)),
        ($.__cacheKey = De),
        ($.__webglTexture = V[De].texture);
    }
    return _e;
  }
  function me($, W, _e) {
    let Ge = 3553;
    (W.isDataArrayTexture || W.isCompressedArrayTexture) && (Ge = 35866),
      W.isData3DTexture && (Ge = 32879);
    let V = Ee($, W),
      De = W.source;
    i.bindTexture(Ge, $.__webglTexture, 33984 + _e);
    let ct = r.get(De);
    if (De.version !== ct.__version || V === !0) {
      i.activeTexture(33984 + _e),
        e.pixelStorei(37440, W.flipY),
        e.pixelStorei(37441, W.premultiplyAlpha),
        e.pixelStorei(3317, W.unpackAlignment),
        e.pixelStorei(37443, 0);
      let We = S(W) && _(W.image) === !1,
        Be = b(W.image, We, !1, u);
      Be = bt(W, Be);
      let Fe = _(Be) || o,
        ut = a.convert(W.format, W.encoding),
        at = a.convert(W.type),
        wt = A(W.internalFormat, ut, at, W.encoding, W.isVideoTexture);
      ne(Ge, W, Fe);
      let xt,
        ii = W.mipmaps,
        ui = o && W.isVideoTexture !== !0,
        ei = ct.__version === void 0 || V === !0,
        ge = T(W, Be, Fe);
      if (W.isDepthTexture)
        (wt = 6402),
          o
            ? W.type === xr
              ? (wt = 36012)
              : W.type === go
              ? (wt = 33190)
              : W.type === $l
              ? (wt = 35056)
              : (wt = 33189)
            : W.type === xr &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          W.format === eh &&
            wt === 6402 &&
            W.type !== HE &&
            W.type !== go &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (W.type = go),
            (at = a.convert(W.type))),
          W.format === hh &&
            wt === 6402 &&
            ((wt = 34041),
            W.type !== $l &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (W.type = $l),
              (at = a.convert(W.type)))),
          ei &&
            (ui
              ? i.texStorage2D(3553, 1, wt, Be.width, Be.height)
              : i.texImage2D(
                  3553,
                  0,
                  wt,
                  Be.width,
                  Be.height,
                  0,
                  ut,
                  at,
                  null
                ));
      else if (W.isDataTexture)
        if (ii.length > 0 && Fe) {
          ui && ei && i.texStorage2D(3553, ge, wt, ii[0].width, ii[0].height);
          for (let Ce = 0, Ye = ii.length; Ce < Ye; Ce++)
            (xt = ii[Ce]),
              ui
                ? i.texSubImage2D(
                    3553,
                    Ce,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    ut,
                    at,
                    xt.data
                  )
                : i.texImage2D(
                    3553,
                    Ce,
                    wt,
                    xt.width,
                    xt.height,
                    0,
                    ut,
                    at,
                    xt.data
                  );
          W.generateMipmaps = !1;
        } else
          ui
            ? (ei && i.texStorage2D(3553, ge, wt, Be.width, Be.height),
              i.texSubImage2D(
                3553,
                0,
                0,
                0,
                Be.width,
                Be.height,
                ut,
                at,
                Be.data
              ))
            : i.texImage2D(
                3553,
                0,
                wt,
                Be.width,
                Be.height,
                0,
                ut,
                at,
                Be.data
              );
      else if (W.isCompressedTexture)
        if (W.isCompressedArrayTexture) {
          ui &&
            ei &&
            i.texStorage3D(35866, ge, wt, ii[0].width, ii[0].height, Be.depth);
          for (let Ce = 0, Ye = ii.length; Ce < Ye; Ce++)
            (xt = ii[Ce]),
              W.format !== Wr
                ? ut !== null
                  ? ui
                    ? i.compressedTexSubImage3D(
                        35866,
                        Ce,
                        0,
                        0,
                        0,
                        xt.width,
                        xt.height,
                        Be.depth,
                        ut,
                        xt.data,
                        0,
                        0
                      )
                    : i.compressedTexImage3D(
                        35866,
                        Ce,
                        wt,
                        xt.width,
                        xt.height,
                        Be.depth,
                        0,
                        xt.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ui
                ? i.texSubImage3D(
                    35866,
                    Ce,
                    0,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    Be.depth,
                    ut,
                    at,
                    xt.data
                  )
                : i.texImage3D(
                    35866,
                    Ce,
                    wt,
                    xt.width,
                    xt.height,
                    Be.depth,
                    0,
                    ut,
                    at,
                    xt.data
                  );
        } else {
          ui && ei && i.texStorage2D(3553, ge, wt, ii[0].width, ii[0].height);
          for (let Ce = 0, Ye = ii.length; Ce < Ye; Ce++)
            (xt = ii[Ce]),
              W.format !== Wr
                ? ut !== null
                  ? ui
                    ? i.compressedTexSubImage2D(
                        3553,
                        Ce,
                        0,
                        0,
                        xt.width,
                        xt.height,
                        ut,
                        xt.data
                      )
                    : i.compressedTexImage2D(
                        3553,
                        Ce,
                        wt,
                        xt.width,
                        xt.height,
                        0,
                        xt.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ui
                ? i.texSubImage2D(
                    3553,
                    Ce,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    ut,
                    at,
                    xt.data
                  )
                : i.texImage2D(
                    3553,
                    Ce,
                    wt,
                    xt.width,
                    xt.height,
                    0,
                    ut,
                    at,
                    xt.data
                  );
        }
      else if (W.isDataArrayTexture)
        ui
          ? (ei && i.texStorage3D(35866, ge, wt, Be.width, Be.height, Be.depth),
            i.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              Be.width,
              Be.height,
              Be.depth,
              ut,
              at,
              Be.data
            ))
          : i.texImage3D(
              35866,
              0,
              wt,
              Be.width,
              Be.height,
              Be.depth,
              0,
              ut,
              at,
              Be.data
            );
      else if (W.isData3DTexture)
        ui
          ? (ei && i.texStorage3D(32879, ge, wt, Be.width, Be.height, Be.depth),
            i.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              Be.width,
              Be.height,
              Be.depth,
              ut,
              at,
              Be.data
            ))
          : i.texImage3D(
              32879,
              0,
              wt,
              Be.width,
              Be.height,
              Be.depth,
              0,
              ut,
              at,
              Be.data
            );
      else if (W.isFramebufferTexture) {
        if (ei)
          if (ui) i.texStorage2D(3553, ge, wt, Be.width, Be.height);
          else {
            let Ce = Be.width,
              Ye = Be.height;
            for (let Ke = 0; Ke < ge; Ke++)
              i.texImage2D(3553, Ke, wt, Ce, Ye, 0, ut, at, null),
                (Ce >>= 1),
                (Ye >>= 1);
          }
      } else if (ii.length > 0 && Fe) {
        ui && ei && i.texStorage2D(3553, ge, wt, ii[0].width, ii[0].height);
        for (let Ce = 0, Ye = ii.length; Ce < Ye; Ce++)
          (xt = ii[Ce]),
            ui
              ? i.texSubImage2D(3553, Ce, 0, 0, ut, at, xt)
              : i.texImage2D(3553, Ce, wt, ut, at, xt);
        W.generateMipmaps = !1;
      } else
        ui
          ? (ei && i.texStorage2D(3553, ge, wt, Be.width, Be.height),
            i.texSubImage2D(3553, 0, 0, 0, ut, at, Be))
          : i.texImage2D(3553, 0, wt, ut, at, Be);
      M(W, Fe) && C(Ge),
        (ct.__version = De.version),
        W.onUpdate && W.onUpdate(W);
    }
    $.__version = W.version;
  }
  function Ae($, W, _e) {
    if (W.image.length !== 6) return;
    let Ge = Ee($, W),
      V = W.source;
    i.bindTexture(34067, $.__webglTexture, 33984 + _e);
    let De = r.get(V);
    if (V.version !== De.__version || Ge === !0) {
      i.activeTexture(33984 + _e),
        e.pixelStorei(37440, W.flipY),
        e.pixelStorei(37441, W.premultiplyAlpha),
        e.pixelStorei(3317, W.unpackAlignment),
        e.pixelStorei(37443, 0);
      let ct = W.isCompressedTexture || W.image[0].isCompressedTexture,
        We = W.image[0] && W.image[0].isDataTexture,
        Be = [];
      for (let Ce = 0; Ce < 6; Ce++)
        !ct && !We
          ? (Be[Ce] = b(W.image[Ce], !1, !0, h))
          : (Be[Ce] = We ? W.image[Ce].image : W.image[Ce]),
          (Be[Ce] = bt(W, Be[Ce]));
      let Fe = Be[0],
        ut = _(Fe) || o,
        at = a.convert(W.format, W.encoding),
        wt = a.convert(W.type),
        xt = A(W.internalFormat, at, wt, W.encoding),
        ii = o && W.isVideoTexture !== !0,
        ui = De.__version === void 0 || Ge === !0,
        ei = T(W, Fe, ut);
      ne(34067, W, ut);
      let ge;
      if (ct) {
        ii && ui && i.texStorage2D(34067, ei, xt, Fe.width, Fe.height);
        for (let Ce = 0; Ce < 6; Ce++) {
          ge = Be[Ce].mipmaps;
          for (let Ye = 0; Ye < ge.length; Ye++) {
            let Ke = ge[Ye];
            W.format !== Wr
              ? at !== null
                ? ii
                  ? i.compressedTexSubImage2D(
                      34069 + Ce,
                      Ye,
                      0,
                      0,
                      Ke.width,
                      Ke.height,
                      at,
                      Ke.data
                    )
                  : i.compressedTexImage2D(
                      34069 + Ce,
                      Ye,
                      xt,
                      Ke.width,
                      Ke.height,
                      0,
                      Ke.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : ii
              ? i.texSubImage2D(
                  34069 + Ce,
                  Ye,
                  0,
                  0,
                  Ke.width,
                  Ke.height,
                  at,
                  wt,
                  Ke.data
                )
              : i.texImage2D(
                  34069 + Ce,
                  Ye,
                  xt,
                  Ke.width,
                  Ke.height,
                  0,
                  at,
                  wt,
                  Ke.data
                );
          }
        }
      } else {
        (ge = W.mipmaps),
          ii &&
            ui &&
            (ge.length > 0 && ei++,
            i.texStorage2D(34067, ei, xt, Be[0].width, Be[0].height));
        for (let Ce = 0; Ce < 6; Ce++)
          if (We) {
            ii
              ? i.texSubImage2D(
                  34069 + Ce,
                  0,
                  0,
                  0,
                  Be[Ce].width,
                  Be[Ce].height,
                  at,
                  wt,
                  Be[Ce].data
                )
              : i.texImage2D(
                  34069 + Ce,
                  0,
                  xt,
                  Be[Ce].width,
                  Be[Ce].height,
                  0,
                  at,
                  wt,
                  Be[Ce].data
                );
            for (let Ye = 0; Ye < ge.length; Ye++) {
              let Ke = ge[Ye].image[Ce].image;
              ii
                ? i.texSubImage2D(
                    34069 + Ce,
                    Ye + 1,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    at,
                    wt,
                    Ke.data
                  )
                : i.texImage2D(
                    34069 + Ce,
                    Ye + 1,
                    xt,
                    Ke.width,
                    Ke.height,
                    0,
                    at,
                    wt,
                    Ke.data
                  );
            }
          } else {
            ii
              ? i.texSubImage2D(34069 + Ce, 0, 0, 0, at, wt, Be[Ce])
              : i.texImage2D(34069 + Ce, 0, xt, at, wt, Be[Ce]);
            for (let Ye = 0; Ye < ge.length; Ye++) {
              let Ke = ge[Ye];
              ii
                ? i.texSubImage2D(
                    34069 + Ce,
                    Ye + 1,
                    0,
                    0,
                    at,
                    wt,
                    Ke.image[Ce]
                  )
                : i.texImage2D(34069 + Ce, Ye + 1, xt, at, wt, Ke.image[Ce]);
            }
          }
      }
      M(W, ut) && C(34067),
        (De.__version = V.version),
        W.onUpdate && W.onUpdate(W);
    }
    $.__version = W.version;
  }
  function ye($, W, _e, Ge, V) {
    let De = a.convert(_e.format, _e.encoding),
      ct = a.convert(_e.type),
      We = A(_e.internalFormat, De, ct, _e.encoding);
    r.get(W).__hasExternalTextures ||
      (V === 32879 || V === 35866
        ? i.texImage3D(V, 0, We, W.width, W.height, W.depth, 0, De, ct, null)
        : i.texImage2D(V, 0, We, W.width, W.height, 0, De, ct, null)),
      i.bindFramebuffer(36160, $),
      Qe(W)
        ? d.framebufferTexture2DMultisampleEXT(
            36160,
            Ge,
            V,
            r.get(_e).__webglTexture,
            0,
            Ze(W)
          )
        : (V === 3553 || (V >= 34069 && V <= 34074)) &&
          e.framebufferTexture2D(36160, Ge, V, r.get(_e).__webglTexture, 0),
      i.bindFramebuffer(36160, null);
  }
  function Ue($, W, _e) {
    if ((e.bindRenderbuffer(36161, $), W.depthBuffer && !W.stencilBuffer)) {
      let Ge = 33189;
      if (_e || Qe(W)) {
        let V = W.depthTexture;
        V &&
          V.isDepthTexture &&
          (V.type === xr ? (Ge = 36012) : V.type === go && (Ge = 33190));
        let De = Ze(W);
        Qe(W)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              De,
              Ge,
              W.width,
              W.height
            )
          : e.renderbufferStorageMultisample(36161, De, Ge, W.width, W.height);
      } else e.renderbufferStorage(36161, Ge, W.width, W.height);
      e.framebufferRenderbuffer(36160, 36096, 36161, $);
    } else if (W.depthBuffer && W.stencilBuffer) {
      let Ge = Ze(W);
      _e && Qe(W) === !1
        ? e.renderbufferStorageMultisample(36161, Ge, 35056, W.width, W.height)
        : Qe(W)
        ? d.renderbufferStorageMultisampleEXT(
            36161,
            Ge,
            35056,
            W.width,
            W.height
          )
        : e.renderbufferStorage(36161, 34041, W.width, W.height),
        e.framebufferRenderbuffer(36160, 33306, 36161, $);
    } else {
      let Ge = W.isWebGLMultipleRenderTargets === !0 ? W.texture : [W.texture];
      for (let V = 0; V < Ge.length; V++) {
        let De = Ge[V],
          ct = a.convert(De.format, De.encoding),
          We = a.convert(De.type),
          Be = A(De.internalFormat, ct, We, De.encoding),
          Fe = Ze(W);
        _e && Qe(W) === !1
          ? e.renderbufferStorageMultisample(36161, Fe, Be, W.width, W.height)
          : Qe(W)
          ? d.renderbufferStorageMultisampleEXT(
              36161,
              Fe,
              Be,
              W.width,
              W.height
            )
          : e.renderbufferStorage(36161, Be, W.width, W.height);
      }
    }
    e.bindRenderbuffer(36161, null);
  }
  function Le($, W) {
    if (W && W.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (i.bindFramebuffer(36160, $),
      !(W.depthTexture && W.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(W.depthTexture).__webglTexture ||
      W.depthTexture.image.width !== W.width ||
      W.depthTexture.image.height !== W.height) &&
      ((W.depthTexture.image.width = W.width),
      (W.depthTexture.image.height = W.height),
      (W.depthTexture.needsUpdate = !0)),
      ce(W.depthTexture, 0);
    let _e = r.get(W.depthTexture).__webglTexture,
      Ge = Ze(W);
    if (W.depthTexture.format === eh)
      Qe(W)
        ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, _e, 0, Ge)
        : e.framebufferTexture2D(36160, 36096, 3553, _e, 0);
    else if (W.depthTexture.format === hh)
      Qe(W)
        ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, _e, 0, Ge)
        : e.framebufferTexture2D(36160, 33306, 3553, _e, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function Te($) {
    let W = r.get($),
      _e = $.isWebGLCubeRenderTarget === !0;
    if ($.depthTexture && !W.__autoAllocateDepthBuffer) {
      if (_e)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Le(W.__webglFramebuffer, $);
    } else if (_e) {
      W.__webglDepthbuffer = [];
      for (let Ge = 0; Ge < 6; Ge++)
        i.bindFramebuffer(36160, W.__webglFramebuffer[Ge]),
          (W.__webglDepthbuffer[Ge] = e.createRenderbuffer()),
          Ue(W.__webglDepthbuffer[Ge], $, !1);
    } else
      i.bindFramebuffer(36160, W.__webglFramebuffer),
        (W.__webglDepthbuffer = e.createRenderbuffer()),
        Ue(W.__webglDepthbuffer, $, !1);
    i.bindFramebuffer(36160, null);
  }
  function tt($, W, _e) {
    let Ge = r.get($);
    W !== void 0 && ye(Ge.__webglFramebuffer, $, $.texture, 36064, 3553),
      _e !== void 0 && Te($);
  }
  function Je($) {
    let W = $.texture,
      _e = r.get($),
      Ge = r.get(W);
    $.addEventListener("dispose", z),
      $.isWebGLMultipleRenderTargets !== !0 &&
        (Ge.__webglTexture === void 0 &&
          (Ge.__webglTexture = e.createTexture()),
        (Ge.__version = W.version),
        n.memory.textures++);
    let V = $.isWebGLCubeRenderTarget === !0,
      De = $.isWebGLMultipleRenderTargets === !0,
      ct = _($) || o;
    if (V) {
      _e.__webglFramebuffer = [];
      for (let We = 0; We < 6; We++)
        _e.__webglFramebuffer[We] = e.createFramebuffer();
    } else {
      if (((_e.__webglFramebuffer = e.createFramebuffer()), De))
        if (s.drawBuffers) {
          let We = $.texture;
          for (let Be = 0, Fe = We.length; Be < Fe; Be++) {
            let ut = r.get(We[Be]);
            ut.__webglTexture === void 0 &&
              ((ut.__webglTexture = e.createTexture()), n.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && $.samples > 0 && Qe($) === !1) {
        let We = De ? W : [W];
        (_e.__webglMultisampledFramebuffer = e.createFramebuffer()),
          (_e.__webglColorRenderbuffer = []),
          i.bindFramebuffer(36160, _e.__webglMultisampledFramebuffer);
        for (let Be = 0; Be < We.length; Be++) {
          let Fe = We[Be];
          (_e.__webglColorRenderbuffer[Be] = e.createRenderbuffer()),
            e.bindRenderbuffer(36161, _e.__webglColorRenderbuffer[Be]);
          let ut = a.convert(Fe.format, Fe.encoding),
            at = a.convert(Fe.type),
            wt = A(
              Fe.internalFormat,
              ut,
              at,
              Fe.encoding,
              $.isXRRenderTarget === !0
            ),
            xt = Ze($);
          e.renderbufferStorageMultisample(36161, xt, wt, $.width, $.height),
            e.framebufferRenderbuffer(
              36160,
              36064 + Be,
              36161,
              _e.__webglColorRenderbuffer[Be]
            );
        }
        e.bindRenderbuffer(36161, null),
          $.depthBuffer &&
            ((_e.__webglDepthRenderbuffer = e.createRenderbuffer()),
            Ue(_e.__webglDepthRenderbuffer, $, !0)),
          i.bindFramebuffer(36160, null);
      }
    }
    if (V) {
      i.bindTexture(34067, Ge.__webglTexture), ne(34067, W, ct);
      for (let We = 0; We < 6; We++)
        ye(_e.__webglFramebuffer[We], $, W, 36064, 34069 + We);
      M(W, ct) && C(34067), i.unbindTexture();
    } else if (De) {
      let We = $.texture;
      for (let Be = 0, Fe = We.length; Be < Fe; Be++) {
        let ut = We[Be],
          at = r.get(ut);
        i.bindTexture(3553, at.__webglTexture),
          ne(3553, ut, ct),
          ye(_e.__webglFramebuffer, $, ut, 36064 + Be, 3553),
          M(ut, ct) && C(3553);
      }
      i.unbindTexture();
    } else {
      let We = 3553;
      ($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) &&
        (o
          ? (We = $.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        i.bindTexture(We, Ge.__webglTexture),
        ne(We, W, ct),
        ye(_e.__webglFramebuffer, $, W, 36064, We),
        M(W, ct) && C(We),
        i.unbindTexture();
    }
    $.depthBuffer && Te($);
  }
  function rt($) {
    let W = _($) || o,
      _e = $.isWebGLMultipleRenderTargets === !0 ? $.texture : [$.texture];
    for (let Ge = 0, V = _e.length; Ge < V; Ge++) {
      let De = _e[Ge];
      if (M(De, W)) {
        let ct = $.isWebGLCubeRenderTarget ? 34067 : 3553,
          We = r.get(De).__webglTexture;
        i.bindTexture(ct, We), C(ct), i.unbindTexture();
      }
    }
  }
  function st($) {
    if (o && $.samples > 0 && Qe($) === !1) {
      let W = $.isWebGLMultipleRenderTargets ? $.texture : [$.texture],
        _e = $.width,
        Ge = $.height,
        V = 16384,
        De = [],
        ct = $.stencilBuffer ? 33306 : 36096,
        We = r.get($),
        Be = $.isWebGLMultipleRenderTargets === !0;
      if (Be)
        for (let Fe = 0; Fe < W.length; Fe++)
          i.bindFramebuffer(36160, We.__webglMultisampledFramebuffer),
            e.framebufferRenderbuffer(36160, 36064 + Fe, 36161, null),
            i.bindFramebuffer(36160, We.__webglFramebuffer),
            e.framebufferTexture2D(36009, 36064 + Fe, 3553, null, 0);
      i.bindFramebuffer(36008, We.__webglMultisampledFramebuffer),
        i.bindFramebuffer(36009, We.__webglFramebuffer);
      for (let Fe = 0; Fe < W.length; Fe++) {
        De.push(36064 + Fe), $.depthBuffer && De.push(ct);
        let ut =
          We.__ignoreDepthValues !== void 0 ? We.__ignoreDepthValues : !1;
        if (
          (ut === !1 &&
            ($.depthBuffer && (V |= 256), $.stencilBuffer && (V |= 1024)),
          Be &&
            e.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              We.__webglColorRenderbuffer[Fe]
            ),
          ut === !0 &&
            (e.invalidateFramebuffer(36008, [ct]),
            e.invalidateFramebuffer(36009, [ct])),
          Be)
        ) {
          let at = r.get(W[Fe]).__webglTexture;
          e.framebufferTexture2D(36009, 36064, 3553, at, 0);
        }
        e.blitFramebuffer(0, 0, _e, Ge, 0, 0, _e, Ge, V, 9728),
          p && e.invalidateFramebuffer(36008, De);
      }
      if ((i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), Be))
        for (let Fe = 0; Fe < W.length; Fe++) {
          i.bindFramebuffer(36160, We.__webglMultisampledFramebuffer),
            e.framebufferRenderbuffer(
              36160,
              36064 + Fe,
              36161,
              We.__webglColorRenderbuffer[Fe]
            );
          let ut = r.get(W[Fe]).__webglTexture;
          i.bindFramebuffer(36160, We.__webglFramebuffer),
            e.framebufferTexture2D(36009, 36064 + Fe, 3553, ut, 0);
        }
      i.bindFramebuffer(36009, We.__webglMultisampledFramebuffer);
    }
  }
  function Ze($) {
    return Math.min(c, $.samples);
  }
  function Qe($) {
    let W = r.get($);
    return (
      o &&
      $.samples > 0 &&
      t.has("WEBGL_multisampled_render_to_texture") === !0 &&
      W.__useRenderToTexture !== !1
    );
  }
  function pt($) {
    let W = n.render.frame;
    f.get($) !== W && (f.set($, W), $.update());
  }
  function bt($, W) {
    let _e = $.encoding,
      Ge = $.format,
      V = $.type;
    return (
      $.isCompressedTexture === !0 ||
        $.isVideoTexture === !0 ||
        $.format === my ||
        (_e !== Qa &&
          (_e === jt
            ? o === !1
              ? t.has("EXT_sRGB") === !0 && Ge === Wr
                ? (($.format = my),
                  ($.minFilter = Wt),
                  ($.generateMipmaps = !1))
                : (W = KE.sRGBToLinear(W))
              : (Ge !== Wr || V !== ys) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                _e
              ))),
      W
    );
  }
  (this.allocateTextureUnit = q),
    (this.resetTextureUnits = Z),
    (this.setTexture2D = ce),
    (this.setTexture2DArray = ie),
    (this.setTexture3D = te),
    (this.setTextureCube = ue),
    (this.rebindTextures = tt),
    (this.setupRenderTarget = Je),
    (this.updateRenderTargetMipmap = rt),
    (this.updateMultisampleRenderTarget = st),
    (this.setupDepthRenderbuffer = Te),
    (this.setupFrameBufferTexture = ye),
    (this.useMultisampledRTT = Qe);
}
function Gz(e, t, i) {
  let r = i.isWebGL2;
  function s(a, n = null) {
    let o;
    if (a === ys) return 5121;
    if (a === EI) return 32819;
    if (a === CI) return 32820;
    if (a === SI) return 5120;
    if (a === AI) return 5122;
    if (a === HE) return 5123;
    if (a === MI) return 5124;
    if (a === go) return 5125;
    if (a === xr) return 5126;
    if (a === lh)
      return r
        ? 5131
        : ((o = t.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (a === TI) return 6406;
    if (a === Wr) return 6408;
    if (a === PI) return 6409;
    if (a === DI) return 6410;
    if (a === eh) return 6402;
    if (a === hh) return 34041;
    if (a === my)
      return (o = t.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (a === OI) return 6403;
    if (a === II) return 36244;
    if (a === gm) return 33319;
    if (a === RI) return 33320;
    if (a === GE) return 36249;
    if (a === nv || a === ov || a === lv || a === hv)
      if (n === jt)
        if (((o = t.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (a === nv) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (a === ov) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (a === lv) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (a === hv) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = t.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (a === nv) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (a === ov) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (a === lv) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (a === hv) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (a === Ww || a === qw || a === Yw || a === Xw)
      if (((o = t.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (a === Ww) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (a === qw) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (a === Yw) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (a === Xw) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (a === LI)
      return (
        (o = t.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (a === Qw || a === Zw)
      if (((o = t.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (a === Qw)
          return n === jt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (a === Zw)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      a === Kw ||
      a === Jw ||
      a === $w ||
      a === e_ ||
      a === t_ ||
      a === i_ ||
      a === r_ ||
      a === s_ ||
      a === a_ ||
      a === n_ ||
      a === o_ ||
      a === l_ ||
      a === h_ ||
      a === c_
    )
      if (((o = t.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (a === Kw)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (a === Jw)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (a === $w)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (a === e_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (a === t_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (a === i_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (a === r_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (a === s_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (a === a_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (a === n_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (a === o_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (a === l_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (a === h_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (a === c_)
          return n === jt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (a === cv)
      if (((o = t.get("EXT_texture_compression_bptc")), o !== null)) {
        if (a === cv)
          return n === jt
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (a === BI || a === u_ || a === d_ || a === p_)
      if (((o = t.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (a === cv) return o.COMPRESSED_RED_RGTC1_EXT;
        if (a === u_) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (a === d_) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (a === p_) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return a === $l
      ? r
        ? 34042
        : ((o = t.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : e[a] !== void 0
      ? e[a]
      : null;
  }
  return { convert: s };
}
var Wz = class extends ds {
    constructor(e = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = e);
    }
  },
  Hl = class extends _i {
    constructor() {
      super(), (this.isGroup = !0), (this.type = "Group");
    }
  },
  qz = { type: "move" },
  zv = class {
    constructor() {
      (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
      return (
        this._hand === null &&
          ((this._hand = new Hl()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      );
    }
    getTargetRaySpace() {
      return (
        this._targetRay === null &&
          ((this._targetRay = new Hl()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new I()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new I())),
        this._targetRay
      );
    }
    getGripSpace() {
      return (
        this._grip === null &&
          ((this._grip = new Hl()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new I()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new I())),
        this._grip
      );
    }
    dispatchEvent(e) {
      return (
        this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
      );
    }
    connect(e) {
      if (e && e.hand) {
        let t = this._hand;
        if (t) for (let i of e.hand.values()) this._getHandJoint(t, i);
      }
      return this.dispatchEvent({ type: "connected", data: e }), this;
    }
    disconnect(e) {
      return (
        this.dispatchEvent({ type: "disconnected", data: e }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
      );
    }
    update(e, t, i) {
      let r = null,
        s = null,
        a = null,
        n = this._targetRay,
        o = this._grip,
        l = this._hand;
      if (e && t.session.visibilityState !== "visible-blurred") {
        if (l && e.hand) {
          a = !0;
          for (let f of e.hand.values()) {
            let m = t.getJointPose(f, i),
              g = this._getHandJoint(l, f);
            m !== null &&
              (g.matrix.fromArray(m.transform.matrix),
              g.matrix.decompose(g.position, g.rotation, g.scale),
              (g.jointRadius = m.radius)),
              (g.visible = m !== null);
          }
          let h = l.joints["index-finger-tip"],
            u = l.joints["thumb-tip"],
            c = h.position.distanceTo(u.position),
            d = 0.02,
            p = 0.005;
          l.inputState.pinching && c > d + p
            ? ((l.inputState.pinching = !1),
              this.dispatchEvent({
                type: "pinchend",
                handedness: e.handedness,
                target: this,
              }))
            : !l.inputState.pinching &&
              c <= d - p &&
              ((l.inputState.pinching = !0),
              this.dispatchEvent({
                type: "pinchstart",
                handedness: e.handedness,
                target: this,
              }));
        } else
          o !== null &&
            e.gripSpace &&
            ((s = t.getPose(e.gripSpace, i)),
            s !== null &&
              (o.matrix.fromArray(s.transform.matrix),
              o.matrix.decompose(o.position, o.rotation, o.scale),
              s.linearVelocity
                ? ((o.hasLinearVelocity = !0),
                  o.linearVelocity.copy(s.linearVelocity))
                : (o.hasLinearVelocity = !1),
              s.angularVelocity
                ? ((o.hasAngularVelocity = !0),
                  o.angularVelocity.copy(s.angularVelocity))
                : (o.hasAngularVelocity = !1)));
        n !== null &&
          ((r = t.getPose(e.targetRaySpace, i)),
          r === null && s !== null && (r = s),
          r !== null &&
            (n.matrix.fromArray(r.transform.matrix),
            n.matrix.decompose(n.position, n.rotation, n.scale),
            r.linearVelocity
              ? ((n.hasLinearVelocity = !0),
                n.linearVelocity.copy(r.linearVelocity))
              : (n.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((n.hasAngularVelocity = !0),
                n.angularVelocity.copy(r.angularVelocity))
              : (n.hasAngularVelocity = !1),
            this.dispatchEvent(qz)));
      }
      return (
        n !== null && (n.visible = r !== null),
        o !== null && (o.visible = s !== null),
        l !== null && (l.visible = a !== null),
        this
      );
    }
    _getHandJoint(e, t) {
      if (e.joints[t.jointName] === void 0) {
        let i = new Hl();
        (i.matrixAutoUpdate = !1),
          (i.visible = !1),
          (e.joints[t.jointName] = i),
          e.add(i);
      }
      return e.joints[t.jointName];
    }
  },
  Gc = class extends Yi {
    constructor(e, t, i, r, s, a, n, o, l, h) {
      if (((h = h !== void 0 ? h : eh), h !== eh && h !== hh))
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      i === void 0 && h === eh && (i = go),
        i === void 0 && h === hh && (i = $l),
        super(null, r, s, a, n, o, h, i, l),
        (this.isDepthTexture = !0),
        (this.image = { width: e, height: t }),
        (this.magFilter = n !== void 0 ? n : mi),
        (this.minFilter = o !== void 0 ? o : mi),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
  },
  Yz = class extends ls {
    constructor(e, t) {
      super();
      let i = this,
        r = null,
        s = 1,
        a = null,
        n = "local-floor",
        o = 1,
        l = null,
        h = null,
        u = null,
        c = null,
        d = null,
        p = null,
        f = t.getContextAttributes(),
        m = null,
        g = null,
        y = [],
        x = [],
        b = new Set(),
        _ = new Map(),
        S = new ds();
      S.layers.enable(1), (S.viewport = new Lt());
      let M = new ds();
      M.layers.enable(2), (M.viewport = new Lt());
      let C = [S, M],
        A = new Wz();
      A.layers.enable(1), A.layers.enable(2);
      let T = null,
        P = null;
      (this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (ie) {
          let te = y[ie];
          return (
            te === void 0 && ((te = new zv()), (y[ie] = te)),
            te.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (ie) {
          let te = y[ie];
          return (
            te === void 0 && ((te = new zv()), (y[ie] = te)), te.getGripSpace()
          );
        }),
        (this.getHand = function (ie) {
          let te = y[ie];
          return (
            te === void 0 && ((te = new zv()), (y[ie] = te)), te.getHandSpace()
          );
        });
      function R(ie) {
        let te = x.indexOf(ie.inputSource);
        if (te === -1) return;
        let ue = y[te];
        ue !== void 0 &&
          ue.dispatchEvent({ type: ie.type, data: ie.inputSource });
      }
      function z() {
        r.removeEventListener("select", R),
          r.removeEventListener("selectstart", R),
          r.removeEventListener("selectend", R),
          r.removeEventListener("squeeze", R),
          r.removeEventListener("squeezestart", R),
          r.removeEventListener("squeezeend", R),
          r.removeEventListener("end", z),
          r.removeEventListener("inputsourceschange", N);
        for (let ie = 0; ie < y.length; ie++) {
          let te = x[ie];
          te !== null && ((x[ie] = null), y[ie].disconnect(te));
        }
        (T = null),
          (P = null),
          e.setRenderTarget(m),
          (d = null),
          (c = null),
          (u = null),
          (r = null),
          (g = null),
          ce.stop(),
          (i.isPresenting = !1),
          i.dispatchEvent({ type: "sessionend" });
      }
      (this.setFramebufferScaleFactor = function (ie) {
        (s = ie),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
            );
      }),
        (this.setReferenceSpaceType = function (ie) {
          (n = ie),
            i.isPresenting === !0 &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting."
              );
        }),
        (this.getReferenceSpace = function () {
          return l || a;
        }),
        (this.setReferenceSpace = function (ie) {
          l = ie;
        }),
        (this.getBaseLayer = function () {
          return c !== null ? c : d;
        }),
        (this.getBinding = function () {
          return u;
        }),
        (this.getFrame = function () {
          return p;
        }),
        (this.getSession = function () {
          return r;
        }),
        (this.setSession = async function (ie) {
          if (((r = ie), r !== null)) {
            if (
              ((m = e.getRenderTarget()),
              r.addEventListener("select", R),
              r.addEventListener("selectstart", R),
              r.addEventListener("selectend", R),
              r.addEventListener("squeeze", R),
              r.addEventListener("squeezestart", R),
              r.addEventListener("squeezeend", R),
              r.addEventListener("end", z),
              r.addEventListener("inputsourceschange", N),
              f.xrCompatible !== !0 && (await t.makeXRCompatible()),
              r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
            ) {
              let te = {
                antialias: r.renderState.layers === void 0 ? f.antialias : !0,
                alpha: f.alpha,
                depth: f.depth,
                stencil: f.stencil,
                framebufferScaleFactor: s,
              };
              (d = new XRWebGLLayer(r, t, te)),
                r.updateRenderState({ baseLayer: d }),
                (g = new gi(d.framebufferWidth, d.framebufferHeight, {
                  format: Wr,
                  type: ys,
                  encoding: e.outputEncoding,
                  stencilBuffer: f.stencil,
                }));
            } else {
              let te = null,
                ue = null,
                ae = null;
              f.depth &&
                ((ae = f.stencil ? 35056 : 33190),
                (te = f.stencil ? hh : eh),
                (ue = f.stencil ? $l : go));
              let de = { colorFormat: 32856, depthFormat: ae, scaleFactor: s };
              (u = new XRWebGLBinding(r, t)),
                (c = u.createProjectionLayer(de)),
                r.updateRenderState({ layers: [c] }),
                (g = new gi(c.textureWidth, c.textureHeight, {
                  format: Wr,
                  type: ys,
                  depthTexture: new Gc(
                    c.textureWidth,
                    c.textureHeight,
                    ue,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    te
                  ),
                  stencilBuffer: f.stencil,
                  encoding: e.outputEncoding,
                  samples: f.antialias ? 4 : 0,
                }));
              let ne = e.properties.get(g);
              ne.__ignoreDepthValues = c.ignoreDepthValues;
            }
            (g.isXRRenderTarget = !0),
              this.setFoveation(o),
              (l = null),
              (a = await r.requestReferenceSpace(n)),
              ce.setContext(r),
              ce.start(),
              (i.isPresenting = !0),
              i.dispatchEvent({ type: "sessionstart" });
          }
        });
      function N(ie) {
        for (let te = 0; te < ie.removed.length; te++) {
          let ue = ie.removed[te],
            ae = x.indexOf(ue);
          ae >= 0 && ((x[ae] = null), y[ae].disconnect(ue));
        }
        for (let te = 0; te < ie.added.length; te++) {
          let ue = ie.added[te],
            ae = x.indexOf(ue);
          if (ae === -1) {
            for (let ne = 0; ne < y.length; ne++)
              if (ne >= x.length) {
                x.push(ue), (ae = ne);
                break;
              } else if (x[ne] === null) {
                (x[ne] = ue), (ae = ne);
                break;
              }
            if (ae === -1) break;
          }
          let de = y[ae];
          de && de.connect(ue);
        }
      }
      let L = new I(),
        G = new I();
      function Y(ie, te, ue) {
        L.setFromMatrixPosition(te.matrixWorld),
          G.setFromMatrixPosition(ue.matrixWorld);
        let ae = L.distanceTo(G),
          de = te.projectionMatrix.elements,
          ne = ue.projectionMatrix.elements,
          Ee = de[14] / (de[10] - 1),
          me = de[14] / (de[10] + 1),
          Ae = (de[9] + 1) / de[5],
          ye = (de[9] - 1) / de[5],
          Ue = (de[8] - 1) / de[0],
          Le = (ne[8] + 1) / ne[0],
          Te = Ee * Ue,
          tt = Ee * Le,
          Je = ae / (-Ue + Le),
          rt = Je * -Ue;
        te.matrixWorld.decompose(ie.position, ie.quaternion, ie.scale),
          ie.translateX(rt),
          ie.translateZ(Je),
          ie.matrixWorld.compose(ie.position, ie.quaternion, ie.scale),
          ie.matrixWorldInverse.copy(ie.matrixWorld).invert();
        let st = Ee + Je,
          Ze = me + Je,
          Qe = Te - rt,
          pt = tt + (ae - rt),
          bt = ((Ae * me) / Ze) * st,
          $ = ((ye * me) / Ze) * st;
        ie.projectionMatrix.makePerspective(Qe, pt, bt, $, st, Ze);
      }
      function Z(ie, te) {
        te === null
          ? ie.matrixWorld.copy(ie.matrix)
          : ie.matrixWorld.multiplyMatrices(te.matrixWorld, ie.matrix),
          ie.matrixWorldInverse.copy(ie.matrixWorld).invert();
      }
      (this.updateCamera = function (ie) {
        if (r === null) return;
        (A.near = M.near = S.near = ie.near),
          (A.far = M.far = S.far = ie.far),
          (T !== A.near || P !== A.far) &&
            (r.updateRenderState({ depthNear: A.near, depthFar: A.far }),
            (T = A.near),
            (P = A.far));
        let te = ie.parent,
          ue = A.cameras;
        Z(A, te);
        for (let de = 0; de < ue.length; de++) Z(ue[de], te);
        A.matrixWorld.decompose(A.position, A.quaternion, A.scale),
          ie.matrix.copy(A.matrix),
          ie.matrix.decompose(ie.position, ie.quaternion, ie.scale);
        let ae = ie.children;
        for (let de = 0, ne = ae.length; de < ne; de++)
          ae[de].updateMatrixWorld(!0);
        ue.length === 2
          ? Y(A, S, M)
          : A.projectionMatrix.copy(S.projectionMatrix);
      }),
        (this.getCamera = function () {
          return A;
        }),
        (this.getFoveation = function () {
          if (!(c === null && d === null)) return o;
        }),
        (this.setFoveation = function (ie) {
          (o = ie),
            c !== null && (c.fixedFoveation = ie),
            d !== null &&
              d.fixedFoveation !== void 0 &&
              (d.fixedFoveation = ie);
        }),
        (this.getPlanes = function () {
          return b;
        });
      let q = null;
      function oe(ie, te) {
        if (((h = te.getViewerPose(l || a)), (p = te), h !== null)) {
          let ue = h.views;
          d !== null &&
            (e.setRenderTargetFramebuffer(g, d.framebuffer),
            e.setRenderTarget(g));
          let ae = !1;
          ue.length !== A.cameras.length && ((A.cameras.length = 0), (ae = !0));
          for (let de = 0; de < ue.length; de++) {
            let ne = ue[de],
              Ee = null;
            if (d !== null) Ee = d.getViewport(ne);
            else {
              let Ae = u.getViewSubImage(c, ne);
              (Ee = Ae.viewport),
                de === 0 &&
                  (e.setRenderTargetTextures(
                    g,
                    Ae.colorTexture,
                    c.ignoreDepthValues ? void 0 : Ae.depthStencilTexture
                  ),
                  e.setRenderTarget(g));
            }
            let me = C[de];
            me === void 0 &&
              ((me = new ds()),
              me.layers.enable(de),
              (me.viewport = new Lt()),
              (C[de] = me)),
              me.matrix.fromArray(ne.transform.matrix),
              me.projectionMatrix.fromArray(ne.projectionMatrix),
              me.viewport.set(Ee.x, Ee.y, Ee.width, Ee.height),
              de === 0 && A.matrix.copy(me.matrix),
              ae === !0 && A.cameras.push(me);
          }
        }
        for (let ue = 0; ue < y.length; ue++) {
          let ae = x[ue],
            de = y[ue];
          ae !== null && de !== void 0 && de.update(ae, te, l || a);
        }
        if ((q && q(ie, te), te.detectedPlanes)) {
          i.dispatchEvent({ type: "planesdetected", data: te.detectedPlanes });
          let ue = null;
          for (let ae of b)
            te.detectedPlanes.has(ae) ||
              (ue === null && (ue = []), ue.push(ae));
          if (ue !== null)
            for (let ae of ue)
              b.delete(ae),
                _.delete(ae),
                i.dispatchEvent({ type: "planeremoved", data: ae });
          for (let ae of te.detectedPlanes)
            if (!b.has(ae))
              b.add(ae),
                _.set(ae, te.lastChangedTime),
                i.dispatchEvent({ type: "planeadded", data: ae });
            else {
              let de = _.get(ae);
              ae.lastChangedTime > de &&
                (_.set(ae, ae.lastChangedTime),
                i.dispatchEvent({ type: "planechanged", data: ae }));
            }
        }
        p = null;
      }
      let ce = new iC();
      ce.setAnimationLoop(oe),
        (this.setAnimationLoop = function (ie) {
          q = ie;
        }),
        (this.dispose = function () {});
    }
  };
function Xz(e, t) {
  function i(m, g) {
    g.color.getRGB(m.fogColor.value, tC(e)),
      g.isFog
        ? ((m.fogNear.value = g.near), (m.fogFar.value = g.far))
        : g.isFogExp2 && (m.fogDensity.value = g.density);
  }
  function r(m, g, y, x, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? s(m, g)
      : g.isMeshToonMaterial
      ? (s(m, g), u(m, g))
      : g.isMeshPhongMaterial
      ? (s(m, g), h(m, g))
      : g.isMeshStandardMaterial
      ? (s(m, g), c(m, g), g.isMeshPhysicalMaterial && d(m, g, b))
      : g.isMeshMatcapMaterial
      ? (s(m, g), p(m, g))
      : g.isMeshDepthMaterial
      ? s(m, g)
      : g.isMeshDistanceMaterial
      ? (s(m, g), f(m, g))
      : g.isMeshNormalMaterial
      ? s(m, g)
      : g.isLineBasicMaterial
      ? (a(m, g), g.isLineDashedMaterial && n(m, g))
      : g.isPointsMaterial
      ? o(m, g, y, x)
      : g.isSpriteMaterial
      ? l(m, g)
      : g.isShadowMaterial
      ? (m.color.value.copy(g.color), (m.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(m, g) {
    (m.opacity.value = g.opacity),
      g.color && m.diffuse.value.copy(g.color),
      g.emissive &&
        m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && (m.map.value = g.map),
      g.alphaMap && (m.alphaMap.value = g.alphaMap),
      g.bumpMap &&
        ((m.bumpMap.value = g.bumpMap),
        (m.bumpScale.value = g.bumpScale),
        g.side === Yr && (m.bumpScale.value *= -1)),
      g.displacementMap &&
        ((m.displacementMap.value = g.displacementMap),
        (m.displacementScale.value = g.displacementScale),
        (m.displacementBias.value = g.displacementBias)),
      g.emissiveMap && (m.emissiveMap.value = g.emissiveMap),
      g.normalMap &&
        ((m.normalMap.value = g.normalMap),
        m.normalScale.value.copy(g.normalScale),
        g.side === Yr && m.normalScale.value.negate()),
      g.specularMap && (m.specularMap.value = g.specularMap),
      g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
    let y = t.get(g).envMap;
    if (
      (y &&
        ((m.envMap.value = y),
        (m.flipEnvMap.value =
          y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
        (m.reflectivity.value = g.reflectivity),
        (m.ior.value = g.ior),
        (m.refractionRatio.value = g.refractionRatio)),
      g.lightMap)
    ) {
      m.lightMap.value = g.lightMap;
      let _ = e.physicallyCorrectLights !== !0 ? Math.PI : 1;
      m.lightMapIntensity.value = g.lightMapIntensity * _;
    }
    g.aoMap &&
      ((m.aoMap.value = g.aoMap), (m.aoMapIntensity.value = g.aoMapIntensity));
    let x;
    g.map
      ? (x = g.map)
      : g.specularMap
      ? (x = g.specularMap)
      : g.displacementMap
      ? (x = g.displacementMap)
      : g.normalMap
      ? (x = g.normalMap)
      : g.bumpMap
      ? (x = g.bumpMap)
      : g.roughnessMap
      ? (x = g.roughnessMap)
      : g.metalnessMap
      ? (x = g.metalnessMap)
      : g.alphaMap
      ? (x = g.alphaMap)
      : g.emissiveMap
      ? (x = g.emissiveMap)
      : g.clearcoatMap
      ? (x = g.clearcoatMap)
      : g.clearcoatNormalMap
      ? (x = g.clearcoatNormalMap)
      : g.clearcoatRoughnessMap
      ? (x = g.clearcoatRoughnessMap)
      : g.iridescenceMap
      ? (x = g.iridescenceMap)
      : g.iridescenceThicknessMap
      ? (x = g.iridescenceThicknessMap)
      : g.specularIntensityMap
      ? (x = g.specularIntensityMap)
      : g.specularColorMap
      ? (x = g.specularColorMap)
      : g.transmissionMap
      ? (x = g.transmissionMap)
      : g.thicknessMap
      ? (x = g.thicknessMap)
      : g.sheenColorMap
      ? (x = g.sheenColorMap)
      : g.sheenRoughnessMap && (x = g.sheenRoughnessMap),
      x !== void 0 &&
        (x.isWebGLRenderTarget && (x = x.texture),
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        m.uvTransform.value.copy(x.matrix));
    let b;
    g.aoMap ? (b = g.aoMap) : g.lightMap && (b = g.lightMap),
      b !== void 0 &&
        (b.isWebGLRenderTarget && (b = b.texture),
        b.matrixAutoUpdate === !0 && b.updateMatrix(),
        m.uv2Transform.value.copy(b.matrix));
  }
  function a(m, g) {
    m.diffuse.value.copy(g.color), (m.opacity.value = g.opacity);
  }
  function n(m, g) {
    (m.dashSize.value = g.dashSize),
      (m.totalSize.value = g.dashSize + g.gapSize),
      (m.scale.value = g.scale);
  }
  function o(m, g, y, x) {
    m.diffuse.value.copy(g.color),
      (m.opacity.value = g.opacity),
      (m.size.value = g.size * y),
      (m.scale.value = x * 0.5),
      g.map && (m.map.value = g.map),
      g.alphaMap && (m.alphaMap.value = g.alphaMap),
      g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
    let b;
    g.map ? (b = g.map) : g.alphaMap && (b = g.alphaMap),
      b !== void 0 &&
        (b.matrixAutoUpdate === !0 && b.updateMatrix(),
        m.uvTransform.value.copy(b.matrix));
  }
  function l(m, g) {
    m.diffuse.value.copy(g.color),
      (m.opacity.value = g.opacity),
      (m.rotation.value = g.rotation),
      g.map && (m.map.value = g.map),
      g.alphaMap && (m.alphaMap.value = g.alphaMap),
      g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
    let y;
    g.map ? (y = g.map) : g.alphaMap && (y = g.alphaMap),
      y !== void 0 &&
        (y.matrixAutoUpdate === !0 && y.updateMatrix(),
        m.uvTransform.value.copy(y.matrix));
  }
  function h(m, g) {
    m.specular.value.copy(g.specular),
      (m.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function u(m, g) {
    g.gradientMap && (m.gradientMap.value = g.gradientMap);
  }
  function c(m, g) {
    (m.roughness.value = g.roughness),
      (m.metalness.value = g.metalness),
      g.roughnessMap && (m.roughnessMap.value = g.roughnessMap),
      g.metalnessMap && (m.metalnessMap.value = g.metalnessMap),
      t.get(g).envMap && (m.envMapIntensity.value = g.envMapIntensity);
  }
  function d(m, g, y) {
    (m.ior.value = g.ior),
      g.sheen > 0 &&
        (m.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (m.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap && (m.sheenColorMap.value = g.sheenColorMap),
        g.sheenRoughnessMap &&
          (m.sheenRoughnessMap.value = g.sheenRoughnessMap)),
      g.clearcoat > 0 &&
        ((m.clearcoat.value = g.clearcoat),
        (m.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap && (m.clearcoatMap.value = g.clearcoatMap),
        g.clearcoatRoughnessMap &&
          (m.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
        g.clearcoatNormalMap &&
          (m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          (m.clearcoatNormalMap.value = g.clearcoatNormalMap),
          g.side === Yr && m.clearcoatNormalScale.value.negate())),
      g.iridescence > 0 &&
        ((m.iridescence.value = g.iridescence),
        (m.iridescenceIOR.value = g.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap && (m.iridescenceMap.value = g.iridescenceMap),
        g.iridescenceThicknessMap &&
          (m.iridescenceThicknessMap.value = g.iridescenceThicknessMap)),
      g.transmission > 0 &&
        ((m.transmission.value = g.transmission),
        (m.transmissionSamplerMap.value = y.texture),
        m.transmissionSamplerSize.value.set(y.width, y.height),
        g.transmissionMap && (m.transmissionMap.value = g.transmissionMap),
        (m.thickness.value = g.thickness),
        g.thicknessMap && (m.thicknessMap.value = g.thicknessMap),
        (m.attenuationDistance.value = g.attenuationDistance),
        m.attenuationColor.value.copy(g.attenuationColor)),
      (m.specularIntensity.value = g.specularIntensity),
      m.specularColor.value.copy(g.specularColor),
      g.specularIntensityMap &&
        (m.specularIntensityMap.value = g.specularIntensityMap),
      g.specularColorMap && (m.specularColorMap.value = g.specularColorMap);
  }
  function p(m, g) {
    g.matcap && (m.matcap.value = g.matcap);
  }
  function f(m, g) {
    m.referencePosition.value.copy(g.referencePosition),
      (m.nearDistance.value = g.nearDistance),
      (m.farDistance.value = g.farDistance);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function Qz(e, t, i, r) {
  let s = {},
    a = {},
    n = [],
    o = i.isWebGL2 ? e.getParameter(35375) : 0;
  function l(x, b) {
    let _ = b.program;
    r.uniformBlockBinding(x, _);
  }
  function h(x, b) {
    let _ = s[x.id];
    _ === void 0 &&
      (f(x), (_ = u(x)), (s[x.id] = _), x.addEventListener("dispose", g));
    let S = b.program;
    r.updateUBOMapping(x, S);
    let M = t.render.frame;
    a[x.id] !== M && (d(x), (a[x.id] = M));
  }
  function u(x) {
    let b = c();
    x.__bindingPointIndex = b;
    let _ = e.createBuffer(),
      S = x.__size,
      M = x.usage;
    return (
      e.bindBuffer(35345, _),
      e.bufferData(35345, S, M),
      e.bindBuffer(35345, null),
      e.bindBufferBase(35345, b, _),
      _
    );
  }
  function c() {
    for (let x = 0; x < o; x++) if (n.indexOf(x) === -1) return n.push(x), x;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function d(x) {
    let b = s[x.id],
      _ = x.uniforms,
      S = x.__cache;
    e.bindBuffer(35345, b);
    for (let M = 0, C = _.length; M < C; M++) {
      let A = _[M];
      if (p(A, M, S) === !0) {
        let T = A.__offset,
          P = Array.isArray(A.value) ? A.value : [A.value],
          R = 0;
        for (let z = 0; z < P.length; z++) {
          let N = P[z],
            L = m(N);
          typeof N == "number"
            ? ((A.__data[0] = N), e.bufferSubData(35345, T + R, A.__data))
            : N.isMatrix3
            ? ((A.__data[0] = N.elements[0]),
              (A.__data[1] = N.elements[1]),
              (A.__data[2] = N.elements[2]),
              (A.__data[3] = N.elements[0]),
              (A.__data[4] = N.elements[3]),
              (A.__data[5] = N.elements[4]),
              (A.__data[6] = N.elements[5]),
              (A.__data[7] = N.elements[0]),
              (A.__data[8] = N.elements[6]),
              (A.__data[9] = N.elements[7]),
              (A.__data[10] = N.elements[8]),
              (A.__data[11] = N.elements[0]))
            : (N.toArray(A.__data, R),
              (R += L.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        e.bufferSubData(35345, T, A.__data);
      }
    }
    e.bindBuffer(35345, null);
  }
  function p(x, b, _) {
    let S = x.value;
    if (_[b] === void 0) {
      if (typeof S == "number") _[b] = S;
      else {
        let M = Array.isArray(S) ? S : [S],
          C = [];
        for (let A = 0; A < M.length; A++) C.push(M[A].clone());
        _[b] = C;
      }
      return !0;
    } else if (typeof S == "number") {
      if (_[b] !== S) return (_[b] = S), !0;
    } else {
      let M = Array.isArray(_[b]) ? _[b] : [_[b]],
        C = Array.isArray(S) ? S : [S];
      for (let A = 0; A < M.length; A++) {
        let T = M[A];
        if (T.equals(C[A]) === !1) return T.copy(C[A]), !0;
      }
    }
    return !1;
  }
  function f(x) {
    let b = x.uniforms,
      _ = 0,
      S = 16,
      M = 0;
    for (let C = 0, A = b.length; C < A; C++) {
      let T = b[C],
        P = { boundary: 0, storage: 0 },
        R = Array.isArray(T.value) ? T.value : [T.value];
      for (let z = 0, N = R.length; z < N; z++) {
        let L = R[z],
          G = m(L);
        (P.boundary += G.boundary), (P.storage += G.storage);
      }
      if (
        ((T.__data = new Float32Array(
          P.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (T.__offset = _),
        C > 0)
      ) {
        M = _ % S;
        let z = S - M;
        M !== 0 && z - P.boundary < 0 && ((_ += S - M), (T.__offset = _));
      }
      _ += P.storage;
    }
    return (
      (M = _ % S), M > 0 && (_ += S - M), (x.__size = _), (x.__cache = {}), this
    );
  }
  function m(x) {
    let b = { boundary: 0, storage: 0 };
    return (
      typeof x == "number"
        ? ((b.boundary = 4), (b.storage = 4))
        : x.isVector2
        ? ((b.boundary = 8), (b.storage = 8))
        : x.isVector3 || x.isColor
        ? ((b.boundary = 16), (b.storage = 12))
        : x.isVector4
        ? ((b.boundary = 16), (b.storage = 16))
        : x.isMatrix3
        ? ((b.boundary = 48), (b.storage = 48))
        : x.isMatrix4
        ? ((b.boundary = 64), (b.storage = 64))
        : x.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            x
          ),
      b
    );
  }
  function g(x) {
    let b = x.target;
    b.removeEventListener("dispose", g);
    let _ = n.indexOf(b.__bindingPointIndex);
    n.splice(_, 1), e.deleteBuffer(s[b.id]), delete s[b.id], delete a[b.id];
  }
  function y() {
    for (let x in s) e.deleteBuffer(s[x]);
    (n = []), (s = {}), (a = {});
  }
  return { bind: l, update: h, dispose: y };
}
function Zz() {
  let e = Rd("canvas");
  return (e.style.display = "block"), e;
}
function lC(e = {}) {
  this.isWebGLRenderer = !0;
  let t = e.canvas !== void 0 ? e.canvas : Zz(),
    i = e.context !== void 0 ? e.context : null,
    r = e.depth !== void 0 ? e.depth : !0,
    s = e.stencil !== void 0 ? e.stencil : !0,
    a = e.antialias !== void 0 ? e.antialias : !1,
    n = e.premultipliedAlpha !== void 0 ? e.premultipliedAlpha : !0,
    o = e.preserveDrawingBuffer !== void 0 ? e.preserveDrawingBuffer : !1,
    l = e.powerPreference !== void 0 ? e.powerPreference : "default",
    h =
      e.failIfMajorPerformanceCaveat !== void 0
        ? e.failIfMajorPerformanceCaveat
        : !1,
    u;
  i !== null
    ? (u = i.getContextAttributes().alpha)
    : (u = e.alpha !== void 0 ? e.alpha : !1);
  let c = null,
    d = null,
    p = [],
    f = [];
  (this.domElement = t),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.outputEncoding = Qa),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = Tn),
    (this.toneMappingExposure = 1);
  let m = this,
    g = !1,
    y = 0,
    x = 0,
    b = null,
    _ = -1,
    S = null,
    M = new Lt(),
    C = new Lt(),
    A = null,
    T = t.width,
    P = t.height,
    R = 1,
    z = null,
    N = null,
    L = new Lt(0, 0, T, P),
    G = new Lt(0, 0, T, P),
    Y = !1,
    Z = new xx(),
    q = !1,
    oe = !1,
    ce = null,
    ie = new je(),
    te = new re(),
    ue = new I(),
    ae = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function de() {
    return b === null ? R : 1;
  }
  let ne = i;
  function Ee(ee, Se) {
    for (let Oe = 0; Oe < ee.length; Oe++) {
      let we = ee[Oe],
        ze = t.getContext(we, Se);
      if (ze !== null) return ze;
    }
    return null;
  }
  try {
    let ee = {
      alpha: !0,
      depth: r,
      stencil: s,
      antialias: a,
      premultipliedAlpha: n,
      preserveDrawingBuffer: o,
      powerPreference: l,
      failIfMajorPerformanceCaveat: h,
    };
    if (
      ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${ru}`),
      t.addEventListener("webglcontextlost", wt, !1),
      t.addEventListener("webglcontextrestored", xt, !1),
      t.addEventListener("webglcontextcreationerror", ii, !1),
      ne === null)
    ) {
      let Se = ["webgl2", "webgl", "experimental-webgl"];
      if (
        (m.isWebGL1Renderer === !0 && Se.shift(),
        (ne = Ee(Se, ee)),
        ne === null)
      )
        throw Ee(Se)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    ne.getShaderPrecisionFormat === void 0 &&
      (ne.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (ee) {
    throw (console.error("THREE.WebGLRenderer: " + ee.message), ee);
  }
  let me,
    Ae,
    ye,
    Ue,
    Le,
    Te,
    tt,
    Je,
    rt,
    st,
    Ze,
    Qe,
    pt,
    bt,
    $,
    W,
    _e,
    Ge,
    V,
    De,
    ct,
    We,
    Be,
    Fe;
  function ut() {
    (me = new hB(ne)),
      (Ae = new rB(ne, me, e)),
      me.init(Ae),
      (We = new Gz(ne, me, Ae)),
      (ye = new jz(ne, me, Ae)),
      (Ue = new dB()),
      (Le = new Pz()),
      (Te = new Hz(ne, me, ye, Le, Ae, We, Ue)),
      (tt = new aB(m)),
      (Je = new lB(m)),
      (rt = new wR(ne, Ae)),
      (Be = new tB(ne, me, rt, Ae)),
      (st = new cB(ne, rt, Ue, Be)),
      (Ze = new gB(ne, st, rt, Ue)),
      (V = new mB(ne, Ae, Te)),
      (W = new sB(Le)),
      (Qe = new Tz(m, tt, Je, me, Ae, Be, W)),
      (pt = new Xz(m, Le)),
      (bt = new Oz()),
      ($ = new Fz(me, Ae)),
      (Ge = new eB(m, tt, Je, ye, Ze, u, n)),
      (_e = new Vz(m, Ze, Ae)),
      (Fe = new Qz(ne, Ue, Ae, ye)),
      (De = new iB(ne, me, Ue, Ae)),
      (ct = new uB(ne, me, Ue, Ae)),
      (Ue.programs = Qe.programs),
      (m.capabilities = Ae),
      (m.extensions = me),
      (m.properties = Le),
      (m.renderLists = bt),
      (m.shadowMap = _e),
      (m.state = ye),
      (m.info = Ue);
  }
  ut();
  let at = new Yz(m, ne);
  (this.xr = at),
    (this.getContext = function () {
      return ne;
    }),
    (this.getContextAttributes = function () {
      return ne.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      let ee = me.get("WEBGL_lose_context");
      ee && ee.loseContext();
    }),
    (this.forceContextRestore = function () {
      let ee = me.get("WEBGL_lose_context");
      ee && ee.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return R;
    }),
    (this.setPixelRatio = function (ee) {
      ee !== void 0 && ((R = ee), this.setSize(T, P, !1));
    }),
    (this.getSize = function (ee) {
      return ee.set(T, P);
    }),
    (this.setSize = function (ee, Se, Oe) {
      if (at.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        );
        return;
      }
      (T = ee),
        (P = Se),
        (t.width = Math.floor(ee * R)),
        (t.height = Math.floor(Se * R)),
        Oe !== !1 &&
          ((t.style.width = ee + "px"), (t.style.height = Se + "px")),
        this.setViewport(0, 0, ee, Se);
    }),
    (this.getDrawingBufferSize = function (ee) {
      return ee.set(T * R, P * R).floor();
    }),
    (this.setDrawingBufferSize = function (ee, Se, Oe) {
      (T = ee),
        (P = Se),
        (R = Oe),
        (t.width = Math.floor(ee * Oe)),
        (t.height = Math.floor(Se * Oe)),
        this.setViewport(0, 0, ee, Se);
    }),
    (this.getCurrentViewport = function (ee) {
      return ee.copy(M);
    }),
    (this.getViewport = function (ee) {
      return ee.copy(L);
    }),
    (this.setViewport = function (ee, Se, Oe, we) {
      ee.isVector4 ? L.set(ee.x, ee.y, ee.z, ee.w) : L.set(ee, Se, Oe, we),
        ye.viewport(M.copy(L).multiplyScalar(R).floor());
    }),
    (this.getScissor = function (ee) {
      return ee.copy(G);
    }),
    (this.setScissor = function (ee, Se, Oe, we) {
      ee.isVector4 ? G.set(ee.x, ee.y, ee.z, ee.w) : G.set(ee, Se, Oe, we),
        ye.scissor(C.copy(G).multiplyScalar(R).floor());
    }),
    (this.getScissorTest = function () {
      return Y;
    }),
    (this.setScissorTest = function (ee) {
      ye.setScissorTest((Y = ee));
    }),
    (this.setOpaqueSort = function (ee) {
      z = ee;
    }),
    (this.setTransparentSort = function (ee) {
      N = ee;
    }),
    (this.getClearColor = function (ee) {
      return ee.copy(Ge.getClearColor());
    }),
    (this.setClearColor = function () {
      Ge.setClearColor.apply(Ge, arguments);
    }),
    (this.getClearAlpha = function () {
      return Ge.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      Ge.setClearAlpha.apply(Ge, arguments);
    }),
    (this.clear = function (ee = !0, Se = !0, Oe = !0) {
      let we = 0;
      ee && (we |= 16384), Se && (we |= 256), Oe && (we |= 1024), ne.clear(we);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      t.removeEventListener("webglcontextlost", wt, !1),
        t.removeEventListener("webglcontextrestored", xt, !1),
        t.removeEventListener("webglcontextcreationerror", ii, !1),
        bt.dispose(),
        $.dispose(),
        Le.dispose(),
        tt.dispose(),
        Je.dispose(),
        Ze.dispose(),
        Be.dispose(),
        Fe.dispose(),
        Qe.dispose(),
        at.dispose(),
        at.removeEventListener("sessionstart", Ke),
        at.removeEventListener("sessionend", gt),
        ce && (ce.dispose(), (ce = null)),
        Mt.stop();
    });
  function wt(ee) {
    ee.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (g = !0);
  }
  function xt() {
    console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
    let ee = Ue.autoReset,
      Se = _e.enabled,
      Oe = _e.autoUpdate,
      we = _e.needsUpdate,
      ze = _e.type;
    ut(),
      (Ue.autoReset = ee),
      (_e.enabled = Se),
      (_e.autoUpdate = Oe),
      (_e.needsUpdate = we),
      (_e.type = ze);
  }
  function ii(ee) {
    console.error(
      "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
      ee.statusMessage
    );
  }
  function ui(ee) {
    let Se = ee.target;
    Se.removeEventListener("dispose", ui), ei(Se);
  }
  function ei(ee) {
    ge(ee), Le.remove(ee);
  }
  function ge(ee) {
    let Se = Le.get(ee).programs;
    Se !== void 0 &&
      (Se.forEach(function (Oe) {
        Qe.releaseProgram(Oe);
      }),
      ee.isShaderMaterial && Qe.releaseShaderCache(ee));
  }
  (this.renderBufferDirect = function (ee, Se, Oe, we, ze, nt) {
    Se === null && (Se = ae);
    let Bt = ze.isMesh && ze.matrixWorld.determinant() < 0,
      qt = Mu(ee, Se, Oe, we, ze);
    ye.setMaterial(we, Bt);
    let kt = Oe.index,
      hi = 1;
    we.wireframe === !0 && ((kt = st.getWireframeAttribute(Oe)), (hi = 2));
    let ti = Oe.drawRange,
      Zt = Oe.attributes.position,
      pi = ti.start * hi,
      Er = (ti.start + ti.count) * hi;
    nt !== null &&
      ((pi = Math.max(pi, nt.start * hi)),
      (Er = Math.min(Er, (nt.start + nt.count) * hi))),
      kt !== null
        ? ((pi = Math.max(pi, 0)), (Er = Math.min(Er, kt.count)))
        : Zt != null && ((pi = Math.max(pi, 0)), (Er = Math.min(Er, Zt.count)));
    let Vi = Er - pi;
    if (Vi < 0 || Vi === 1 / 0) return;
    Be.setup(ze, we, qt, Oe, kt);
    let Qi,
      Li = De;
    if (
      (kt !== null && ((Qi = rt.get(kt)), (Li = ct), Li.setIndex(Qi)),
      ze.isMesh)
    )
      we.wireframe === !0
        ? (ye.setLineWidth(we.wireframeLinewidth * de()), Li.setMode(1))
        : Li.setMode(4);
    else if (ze.isLine) {
      let _t = we.linewidth;
      _t === void 0 && (_t = 1),
        ye.setLineWidth(_t * de()),
        ze.isLineSegments
          ? Li.setMode(1)
          : ze.isLineLoop
          ? Li.setMode(2)
          : Li.setMode(3);
    } else ze.isPoints ? Li.setMode(0) : ze.isSprite && Li.setMode(4);
    if (ze.isInstancedMesh) Li.renderInstances(pi, Vi, ze.count);
    else if (Oe.isInstancedBufferGeometry) {
      let _t = Oe._maxInstanceCount !== void 0 ? Oe._maxInstanceCount : 1 / 0,
        tn = Math.min(Oe.instanceCount, _t);
      Li.renderInstances(pi, Vi, tn);
    } else Li.render(pi, Vi);
  }),
    (this.compile = function (ee, Se) {
      function Oe(we, ze, nt) {
        we.transparent === !0 && we.side === js && we.forceSinglePass === !1
          ? ((we.side = Yr),
            (we.needsUpdate = !0),
            Mr(we, ze, nt),
            (we.side = Xa),
            (we.needsUpdate = !0),
            Mr(we, ze, nt),
            (we.side = js))
          : Mr(we, ze, nt);
      }
      (d = $.get(ee)),
        d.init(),
        f.push(d),
        ee.traverseVisible(function (we) {
          we.isLight &&
            we.layers.test(Se.layers) &&
            (d.pushLight(we), we.castShadow && d.pushShadow(we));
        }),
        d.setupLights(m.physicallyCorrectLights),
        ee.traverse(function (we) {
          let ze = we.material;
          if (ze)
            if (Array.isArray(ze))
              for (let nt = 0; nt < ze.length; nt++) {
                let Bt = ze[nt];
                Oe(Bt, ee, we);
              }
            else Oe(ze, ee, we);
        }),
        f.pop(),
        (d = null);
    });
  let Ce = null;
  function Ye(ee) {
    Ce && Ce(ee);
  }
  function Ke() {
    Mt.stop();
  }
  function gt() {
    Mt.start();
  }
  let Mt = new iC();
  Mt.setAnimationLoop(Ye),
    typeof self < "u" && Mt.setContext(self),
    (this.setAnimationLoop = function (ee) {
      (Ce = ee), at.setAnimationLoop(ee), ee === null ? Mt.stop() : Mt.start();
    }),
    at.addEventListener("sessionstart", Ke),
    at.addEventListener("sessionend", gt),
    (this.render = function (ee, Se) {
      if (Se !== void 0 && Se.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
        return;
      }
      if (g === !0) return;
      ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(),
        Se.parent === null &&
          Se.matrixWorldAutoUpdate === !0 &&
          Se.updateMatrixWorld(),
        at.enabled === !0 &&
          at.isPresenting === !0 &&
          (at.cameraAutoUpdate === !0 && at.updateCamera(Se),
          (Se = at.getCamera())),
        ee.isScene === !0 && ee.onBeforeRender(m, ee, Se, b),
        (d = $.get(ee, f.length)),
        d.init(),
        f.push(d),
        ie.multiplyMatrices(Se.projectionMatrix, Se.matrixWorldInverse),
        Z.setFromProjectionMatrix(ie),
        (oe = this.localClippingEnabled),
        (q = W.init(this.clippingPlanes, oe)),
        (c = bt.get(ee, p.length)),
        c.init(),
        p.push(c),
        yi(ee, Se, 0, m.sortObjects),
        c.finish(),
        m.sortObjects === !0 && c.sort(z, N),
        q === !0 && W.beginShadows();
      let Oe = d.state.shadowsArray;
      if (
        (_e.render(Oe, ee, Se),
        q === !0 && W.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        Ge.render(c, ee),
        d.setupLights(m.physicallyCorrectLights),
        Se.isArrayCamera)
      ) {
        let we = Se.cameras;
        for (let ze = 0, nt = we.length; ze < nt; ze++) {
          let Bt = we[ze];
          ki(c, ee, Bt, Bt.viewport);
        }
      } else ki(c, ee, Se);
      b !== null &&
        (Te.updateMultisampleRenderTarget(b), Te.updateRenderTargetMipmap(b)),
        ee.isScene === !0 && ee.onAfterRender(m, ee, Se),
        Be.resetDefaultState(),
        (_ = -1),
        (S = null),
        f.pop(),
        f.length > 0 ? (d = f[f.length - 1]) : (d = null),
        p.pop(),
        p.length > 0 ? (c = p[p.length - 1]) : (c = null);
    });
  function yi(ee, Se, Oe, we) {
    if (ee.visible === !1) return;
    if (ee.layers.test(Se.layers)) {
      if (ee.isGroup) Oe = ee.renderOrder;
      else if (ee.isLOD) ee.autoUpdate === !0 && ee.update(Se);
      else if (ee.isLight) d.pushLight(ee), ee.castShadow && d.pushShadow(ee);
      else if (ee.isSprite) {
        if (!ee.frustumCulled || Z.intersectsSprite(ee)) {
          we && ue.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(ie);
          let nt = Ze.update(ee),
            Bt = ee.material;
          Bt.visible && c.push(ee, nt, Bt, Oe, ue.z, null);
        }
      } else if (
        (ee.isMesh || ee.isLine || ee.isPoints) &&
        (ee.isSkinnedMesh &&
          ee.skeleton.frame !== Ue.render.frame &&
          (ee.skeleton.update(), (ee.skeleton.frame = Ue.render.frame)),
        !ee.frustumCulled || Z.intersectsObject(ee))
      ) {
        we && ue.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(ie);
        let nt = Ze.update(ee),
          Bt = ee.material;
        if (Array.isArray(Bt)) {
          let qt = nt.groups;
          for (let kt = 0, hi = qt.length; kt < hi; kt++) {
            let ti = qt[kt],
              Zt = Bt[ti.materialIndex];
            Zt && Zt.visible && c.push(ee, nt, Zt, Oe, ue.z, ti);
          }
        } else Bt.visible && c.push(ee, nt, Bt, Oe, ue.z, null);
      }
    }
    let ze = ee.children;
    for (let nt = 0, Bt = ze.length; nt < Bt; nt++) yi(ze[nt], Se, Oe, we);
  }
  function ki(ee, Se, Oe, we) {
    let ze = ee.opaque,
      nt = ee.transmissive,
      Bt = ee.transparent;
    d.setupLightsView(Oe),
      q === !0 && W.setGlobalState(m.clippingPlanes, Oe),
      nt.length > 0 && Ar(ze, Se, Oe),
      we && ye.viewport(M.copy(we)),
      ze.length > 0 && Si(ze, Se, Oe),
      nt.length > 0 && Si(nt, Se, Oe),
      Bt.length > 0 && Si(Bt, Se, Oe),
      ye.buffers.depth.setTest(!0),
      ye.buffers.depth.setMask(!0),
      ye.buffers.color.setMask(!0),
      ye.setPolygonOffset(!1);
  }
  function Ar(ee, Se, Oe) {
    let we = Ae.isWebGL2;
    ce === null &&
      (ce = new gi(1, 1, {
        generateMipmaps: !0,
        type: me.has("EXT_color_buffer_half_float") ? lh : ys,
        minFilter: jc,
        samples: we && a === !0 ? 4 : 0,
      })),
      m.getDrawingBufferSize(te),
      we ? ce.setSize(te.x, te.y) : ce.setSize(wm(te.x), wm(te.y));
    let ze = m.getRenderTarget();
    m.setRenderTarget(ce), m.clear();
    let nt = m.toneMapping;
    (m.toneMapping = Tn),
      Si(ee, Se, Oe),
      (m.toneMapping = nt),
      Te.updateMultisampleRenderTarget(ce),
      Te.updateRenderTargetMipmap(ce),
      m.setRenderTarget(ze);
  }
  function Si(ee, Se, Oe) {
    let we = Se.isScene === !0 ? Se.overrideMaterial : null;
    for (let ze = 0, nt = ee.length; ze < nt; ze++) {
      let Bt = ee[ze],
        qt = Bt.object,
        kt = Bt.geometry,
        hi = we === null ? Bt.material : we,
        ti = Bt.group;
      qt.layers.test(Oe.layers) && Jr(qt, Se, Oe, kt, hi, ti);
    }
  }
  function Jr(ee, Se, Oe, we, ze, nt) {
    ee.onBeforeRender(m, Se, Oe, we, ze, nt),
      ee.modelViewMatrix.multiplyMatrices(
        Oe.matrixWorldInverse,
        ee.matrixWorld
      ),
      ee.normalMatrix.getNormalMatrix(ee.modelViewMatrix),
      ze.onBeforeRender(m, Se, Oe, we, ee, nt),
      ze.transparent === !0 && ze.side === js && ze.forceSinglePass === !1
        ? ((ze.side = Yr),
          (ze.needsUpdate = !0),
          m.renderBufferDirect(Oe, Se, we, ze, ee, nt),
          (ze.side = Xa),
          (ze.needsUpdate = !0),
          m.renderBufferDirect(Oe, Se, we, ze, ee, nt),
          (ze.side = js))
        : m.renderBufferDirect(Oe, Se, we, ze, ee, nt),
      ee.onAfterRender(m, Se, Oe, we, ze, nt);
  }
  function Mr(ee, Se, Oe) {
    Se.isScene !== !0 && (Se = ae);
    let we = Le.get(ee),
      ze = d.state.lights,
      nt = d.state.shadowsArray,
      Bt = ze.state.version,
      qt = Qe.getParameters(ee, ze.state, nt, Se, Oe),
      kt = Qe.getProgramCacheKey(qt),
      hi = we.programs;
    (we.environment = ee.isMeshStandardMaterial ? Se.environment : null),
      (we.fog = Se.fog),
      (we.envMap = (ee.isMeshStandardMaterial ? Je : tt).get(
        ee.envMap || we.environment
      )),
      hi === void 0 &&
        (ee.addEventListener("dispose", ui),
        (hi = new Map()),
        (we.programs = hi));
    let ti = hi.get(kt);
    if (ti !== void 0) {
      if (we.currentProgram === ti && we.lightsStateVersion === Bt)
        return Po(ee, qt), ti;
    } else
      (qt.uniforms = Qe.getUniforms(ee)),
        ee.onBuild(Oe, qt, m),
        ee.onBeforeCompile(qt, m),
        (ti = Qe.acquireProgram(qt, kt)),
        hi.set(kt, ti),
        (we.uniforms = qt.uniforms);
    let Zt = we.uniforms;
    ((!ee.isShaderMaterial && !ee.isRawShaderMaterial) || ee.clipping === !0) &&
      (Zt.clippingPlanes = W.uniform),
      Po(ee, qt),
      (we.needsLights = Ch(ee)),
      (we.lightsStateVersion = Bt),
      we.needsLights &&
        ((Zt.ambientLightColor.value = ze.state.ambient),
        (Zt.lightProbe.value = ze.state.probe),
        (Zt.directionalLights.value = ze.state.directional),
        (Zt.directionalLightShadows.value = ze.state.directionalShadow),
        (Zt.spotLights.value = ze.state.spot),
        (Zt.spotLightShadows.value = ze.state.spotShadow),
        (Zt.rectAreaLights.value = ze.state.rectArea),
        (Zt.ltc_1.value = ze.state.rectAreaLTC1),
        (Zt.ltc_2.value = ze.state.rectAreaLTC2),
        (Zt.pointLights.value = ze.state.point),
        (Zt.pointLightShadows.value = ze.state.pointShadow),
        (Zt.hemisphereLights.value = ze.state.hemi),
        (Zt.directionalShadowMap.value = ze.state.directionalShadowMap),
        (Zt.directionalShadowMatrix.value = ze.state.directionalShadowMatrix),
        (Zt.spotShadowMap.value = ze.state.spotShadowMap),
        (Zt.spotLightMatrix.value = ze.state.spotLightMatrix),
        (Zt.spotLightMap.value = ze.state.spotLightMap),
        (Zt.pointShadowMap.value = ze.state.pointShadowMap),
        (Zt.pointShadowMatrix.value = ze.state.pointShadowMatrix));
    let pi = ti.getUniforms(),
      Er = sm.seqWithValue(pi.seq, Zt);
    return (we.currentProgram = ti), (we.uniformsList = Er), ti;
  }
  function Po(ee, Se) {
    let Oe = Le.get(ee);
    (Oe.outputEncoding = Se.outputEncoding),
      (Oe.instancing = Se.instancing),
      (Oe.skinning = Se.skinning),
      (Oe.morphTargets = Se.morphTargets),
      (Oe.morphNormals = Se.morphNormals),
      (Oe.morphColors = Se.morphColors),
      (Oe.morphTargetsCount = Se.morphTargetsCount),
      (Oe.numClippingPlanes = Se.numClippingPlanes),
      (Oe.numIntersection = Se.numClipIntersection),
      (Oe.vertexAlphas = Se.vertexAlphas),
      (Oe.vertexTangents = Se.vertexTangents),
      (Oe.toneMapping = Se.toneMapping);
  }
  function Mu(ee, Se, Oe, we, ze) {
    Se.isScene !== !0 && (Se = ae), Te.resetTextureUnits();
    let nt = Se.fog,
      Bt = we.isMeshStandardMaterial ? Se.environment : null,
      qt =
        b === null
          ? m.outputEncoding
          : b.isXRRenderTarget === !0
          ? b.texture.encoding
          : Qa,
      kt = (we.isMeshStandardMaterial ? Je : tt).get(we.envMap || Bt),
      hi =
        we.vertexColors === !0 &&
        !!Oe.attributes.color &&
        Oe.attributes.color.itemSize === 4,
      ti = !!we.normalMap && !!Oe.attributes.tangent,
      Zt = !!Oe.morphAttributes.position,
      pi = !!Oe.morphAttributes.normal,
      Er = !!Oe.morphAttributes.color,
      Vi = we.toneMapped ? m.toneMapping : Tn,
      Qi =
        Oe.morphAttributes.position ||
        Oe.morphAttributes.normal ||
        Oe.morphAttributes.color,
      Li = Qi !== void 0 ? Qi.length : 0,
      _t = Le.get(we),
      tn = d.state.lights;
    if (q === !0 && (oe === !0 || ee !== S)) {
      let ji = ee === S && we.id === _;
      W.setState(we, ee, ji);
    }
    let ta = !1;
    we.version === _t.__version
      ? ((_t.needsLights && _t.lightsStateVersion !== tn.state.version) ||
          _t.outputEncoding !== qt ||
          (ze.isInstancedMesh && _t.instancing === !1) ||
          (!ze.isInstancedMesh && _t.instancing === !0) ||
          (ze.isSkinnedMesh && _t.skinning === !1) ||
          (!ze.isSkinnedMesh && _t.skinning === !0) ||
          _t.envMap !== kt ||
          (we.fog === !0 && _t.fog !== nt) ||
          (_t.numClippingPlanes !== void 0 &&
            (_t.numClippingPlanes !== W.numPlanes ||
              _t.numIntersection !== W.numIntersection)) ||
          _t.vertexAlphas !== hi ||
          _t.vertexTangents !== ti ||
          _t.morphTargets !== Zt ||
          _t.morphNormals !== pi ||
          _t.morphColors !== Er ||
          _t.toneMapping !== Vi ||
          (Ae.isWebGL2 === !0 && _t.morphTargetsCount !== Li)) &&
        (ta = !0)
      : ((ta = !0), (_t.__version = we.version));
    let ia = _t.currentProgram;
    ta === !0 && (ia = Mr(we, Se, ze));
    let Jt = !1,
      pr = !1,
      Nn = !1,
      ir = ia.getUniforms(),
      ra = _t.uniforms;
    if (
      (ye.useProgram(ia.program) && ((Jt = !0), (pr = !0), (Nn = !0)),
      we.id !== _ && ((_ = we.id), (pr = !0)),
      Jt || S !== ee)
    ) {
      if (
        (ir.setValue(ne, "projectionMatrix", ee.projectionMatrix),
        Ae.logarithmicDepthBuffer &&
          ir.setValue(
            ne,
            "logDepthBufFC",
            2 / (Math.log(ee.far + 1) / Math.LN2)
          ),
        S !== ee && ((S = ee), (pr = !0), (Nn = !0)),
        we.isShaderMaterial ||
          we.isMeshPhongMaterial ||
          we.isMeshToonMaterial ||
          we.isMeshStandardMaterial ||
          we.envMap)
      ) {
        let ji = ir.map.cameraPosition;
        ji !== void 0 &&
          ji.setValue(ne, ue.setFromMatrixPosition(ee.matrixWorld));
      }
      (we.isMeshPhongMaterial ||
        we.isMeshToonMaterial ||
        we.isMeshLambertMaterial ||
        we.isMeshBasicMaterial ||
        we.isMeshStandardMaterial ||
        we.isShaderMaterial) &&
        ir.setValue(ne, "isOrthographic", ee.isOrthographicCamera === !0),
        (we.isMeshPhongMaterial ||
          we.isMeshToonMaterial ||
          we.isMeshLambertMaterial ||
          we.isMeshBasicMaterial ||
          we.isMeshStandardMaterial ||
          we.isShaderMaterial ||
          we.isShadowMaterial ||
          ze.isSkinnedMesh) &&
          ir.setValue(ne, "viewMatrix", ee.matrixWorldInverse);
    }
    if (ze.isSkinnedMesh) {
      ir.setOptional(ne, ze, "bindMatrix"),
        ir.setOptional(ne, ze, "bindMatrixInverse");
      let ji = ze.skeleton;
      ji &&
        (Ae.floatVertexTextures
          ? (ji.boneTexture === null && ji.computeBoneTexture(),
            ir.setValue(ne, "boneTexture", ji.boneTexture, Te),
            ir.setValue(ne, "boneTextureSize", ji.boneTextureSize))
          : console.warn(
              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
            ));
    }
    let Un = Oe.morphAttributes;
    if (
      ((Un.position !== void 0 ||
        Un.normal !== void 0 ||
        (Un.color !== void 0 && Ae.isWebGL2 === !0)) &&
        V.update(ze, Oe, we, ia),
      (pr || _t.receiveShadow !== ze.receiveShadow) &&
        ((_t.receiveShadow = ze.receiveShadow),
        ir.setValue(ne, "receiveShadow", ze.receiveShadow)),
      we.isMeshGouraudMaterial &&
        we.envMap !== null &&
        ((ra.envMap.value = kt),
        (ra.flipEnvMap.value =
          kt.isCubeTexture && kt.isRenderTargetTexture === !1 ? -1 : 1)),
      pr &&
        (ir.setValue(ne, "toneMappingExposure", m.toneMappingExposure),
        _t.needsLights && wl(ra, Nn),
        nt && we.fog === !0 && pt.refreshFogUniforms(ra, nt),
        pt.refreshMaterialUniforms(ra, we, R, P, ce),
        sm.upload(ne, _t.uniformsList, ra, Te)),
      we.isShaderMaterial &&
        we.uniformsNeedUpdate === !0 &&
        (sm.upload(ne, _t.uniformsList, ra, Te), (we.uniformsNeedUpdate = !1)),
      we.isSpriteMaterial && ir.setValue(ne, "center", ze.center),
      ir.setValue(ne, "modelViewMatrix", ze.modelViewMatrix),
      ir.setValue(ne, "normalMatrix", ze.normalMatrix),
      ir.setValue(ne, "modelMatrix", ze.matrixWorld),
      ze.previousModelViewMatrix &&
        ir.setValue(ne, "previousModelViewMatrix", ze.previousModelViewMatrix),
      ee.previousProjectionMatrix &&
        ir.setValue(
          ne,
          "previousProjectionMatrix",
          ee.previousProjectionMatrix
        ),
      we.isShaderMaterial || we.isRawShaderMaterial)
    ) {
      let ji = we.uniformsGroups;
      for (let Yt = 0, Eu = ji.length; Yt < Eu; Yt++)
        if (Ae.isWebGL2) {
          let Vn = ji[Yt];
          Fe.update(Vn, ia), Fe.bind(Vn, ia);
        } else
          console.warn(
            "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
          );
    }
    return ia;
  }
  function wl(ee, Se) {
    (ee.ambientLightColor.needsUpdate = Se),
      (ee.lightProbe.needsUpdate = Se),
      (ee.directionalLights.needsUpdate = Se),
      (ee.directionalLightShadows.needsUpdate = Se),
      (ee.pointLights.needsUpdate = Se),
      (ee.pointLightShadows.needsUpdate = Se),
      (ee.spotLights.needsUpdate = Se),
      (ee.spotLightShadows.needsUpdate = Se),
      (ee.rectAreaLights.needsUpdate = Se),
      (ee.hemisphereLights.needsUpdate = Se);
  }
  function Ch(ee) {
    return (
      ee.isMeshLambertMaterial ||
      ee.isMeshToonMaterial ||
      ee.isMeshPhongMaterial ||
      ee.isMeshStandardMaterial ||
      ee.isShadowMaterial ||
      (ee.isShaderMaterial && ee.lights === !0)
    );
  }
  (this.getActiveCubeFace = function () {
    return y;
  }),
    (this.getActiveMipmapLevel = function () {
      return x;
    }),
    (this.getRenderTarget = function () {
      return b;
    }),
    (this.setRenderTargetTextures = function (ee, Se, Oe) {
      (Le.get(ee.texture).__webglTexture = Se),
        (Le.get(ee.depthTexture).__webglTexture = Oe);
      let we = Le.get(ee);
      (we.__hasExternalTextures = !0),
        we.__hasExternalTextures &&
          ((we.__autoAllocateDepthBuffer = Oe === void 0),
          we.__autoAllocateDepthBuffer ||
            (me.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (we.__useRenderToTexture = !1))));
    }),
    (this.setRenderTargetFramebuffer = function (ee, Se) {
      let Oe = Le.get(ee);
      (Oe.__webglFramebuffer = Se),
        (Oe.__useDefaultFramebuffer = Se === void 0);
    }),
    (this.setRenderTarget = function (ee, Se = 0, Oe = 0) {
      (b = ee), (y = Se), (x = Oe);
      let we = !0,
        ze = null,
        nt = !1,
        Bt = !1;
      if (ee) {
        let qt = Le.get(ee);
        qt.__useDefaultFramebuffer !== void 0
          ? (ye.bindFramebuffer(36160, null), (we = !1))
          : qt.__webglFramebuffer === void 0
          ? Te.setupRenderTarget(ee)
          : qt.__hasExternalTextures &&
            Te.rebindTextures(
              ee,
              Le.get(ee.texture).__webglTexture,
              Le.get(ee.depthTexture).__webglTexture
            );
        let kt = ee.texture;
        (kt.isData3DTexture ||
          kt.isDataArrayTexture ||
          kt.isCompressedArrayTexture) &&
          (Bt = !0);
        let hi = Le.get(ee).__webglFramebuffer;
        ee.isWebGLCubeRenderTarget
          ? ((ze = hi[Se]), (nt = !0))
          : Ae.isWebGL2 && ee.samples > 0 && Te.useMultisampledRTT(ee) === !1
          ? (ze = Le.get(ee).__webglMultisampledFramebuffer)
          : (ze = hi),
          M.copy(ee.viewport),
          C.copy(ee.scissor),
          (A = ee.scissorTest);
      } else
        M.copy(L).multiplyScalar(R).floor(),
          C.copy(G).multiplyScalar(R).floor(),
          (A = Y);
      if (
        (ye.bindFramebuffer(36160, ze) &&
          Ae.drawBuffers &&
          we &&
          ye.drawBuffers(ee, ze),
        ye.viewport(M),
        ye.scissor(C),
        ye.setScissorTest(A),
        nt)
      ) {
        let qt = Le.get(ee.texture);
        ne.framebufferTexture2D(
          36160,
          36064,
          34069 + Se,
          qt.__webglTexture,
          Oe
        );
      } else if (Bt) {
        let qt = Le.get(ee.texture),
          kt = Se || 0;
        ne.framebufferTextureLayer(
          36160,
          36064,
          qt.__webglTexture,
          Oe || 0,
          kt
        );
      }
      _ = -1;
    }),
    (this.readRenderTargetPixels = function (ee, Se, Oe, we, ze, nt, Bt) {
      if (!(ee && ee.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
        return;
      }
      let qt = Le.get(ee).__webglFramebuffer;
      if ((ee.isWebGLCubeRenderTarget && Bt !== void 0 && (qt = qt[Bt]), qt)) {
        ye.bindFramebuffer(36160, qt);
        try {
          let kt = ee.texture,
            hi = kt.format,
            ti = kt.type;
          if (hi !== Wr && We.convert(hi) !== ne.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
            return;
          }
          let Zt =
            ti === lh &&
            (me.has("EXT_color_buffer_half_float") ||
              (Ae.isWebGL2 && me.has("EXT_color_buffer_float")));
          if (
            ti !== ys &&
            We.convert(ti) !== ne.getParameter(35738) &&
            !(
              ti === xr &&
              (Ae.isWebGL2 ||
                me.has("OES_texture_float") ||
                me.has("WEBGL_color_buffer_float"))
            ) &&
            !Zt
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
            return;
          }
          Se >= 0 &&
            Se <= ee.width - we &&
            Oe >= 0 &&
            Oe <= ee.height - ze &&
            ne.readPixels(Se, Oe, we, ze, We.convert(hi), We.convert(ti), nt);
        } finally {
          let kt = b !== null ? Le.get(b).__webglFramebuffer : null;
          ye.bindFramebuffer(36160, kt);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (ee, Se, Oe = 0) {
      let we = Math.pow(2, -Oe),
        ze = Math.floor(Se.image.width * we),
        nt = Math.floor(Se.image.height * we);
      Te.setTexture2D(Se, 0),
        ne.copyTexSubImage2D(3553, Oe, 0, 0, ee.x, ee.y, ze, nt),
        ye.unbindTexture();
    }),
    (this.copyTextureToTexture = function (ee, Se, Oe, we = 0) {
      let ze = Se.image.width,
        nt = Se.image.height,
        Bt = We.convert(Oe.format),
        qt = We.convert(Oe.type);
      Te.setTexture2D(Oe, 0),
        ne.pixelStorei(37440, Oe.flipY),
        ne.pixelStorei(37441, Oe.premultiplyAlpha),
        ne.pixelStorei(3317, Oe.unpackAlignment),
        Se.isDataTexture
          ? ne.texSubImage2D(
              3553,
              we,
              ee.x,
              ee.y,
              ze,
              nt,
              Bt,
              qt,
              Se.image.data
            )
          : Se.isCompressedTexture
          ? ne.compressedTexSubImage2D(
              3553,
              we,
              ee.x,
              ee.y,
              Se.mipmaps[0].width,
              Se.mipmaps[0].height,
              Bt,
              Se.mipmaps[0].data
            )
          : ne.texSubImage2D(3553, we, ee.x, ee.y, Bt, qt, Se.image),
        we === 0 && Oe.generateMipmaps && ne.generateMipmap(3553),
        ye.unbindTexture();
    }),
    (this.copyTextureToTexture3D = function (ee, Se, Oe, we, ze = 0) {
      if (m.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
        );
        return;
      }
      let nt = ee.max.x - ee.min.x + 1,
        Bt = ee.max.y - ee.min.y + 1,
        qt = ee.max.z - ee.min.z + 1,
        kt = We.convert(we.format),
        hi = We.convert(we.type),
        ti;
      if (we.isData3DTexture) Te.setTexture3D(we, 0), (ti = 32879);
      else if (we.isDataArrayTexture) Te.setTexture2DArray(we, 0), (ti = 35866);
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
        );
        return;
      }
      ne.pixelStorei(37440, we.flipY),
        ne.pixelStorei(37441, we.premultiplyAlpha),
        ne.pixelStorei(3317, we.unpackAlignment);
      let Zt = ne.getParameter(3314),
        pi = ne.getParameter(32878),
        Er = ne.getParameter(3316),
        Vi = ne.getParameter(3315),
        Qi = ne.getParameter(32877),
        Li = Oe.isCompressedTexture ? Oe.mipmaps[0] : Oe.image;
      ne.pixelStorei(3314, Li.width),
        ne.pixelStorei(32878, Li.height),
        ne.pixelStorei(3316, ee.min.x),
        ne.pixelStorei(3315, ee.min.y),
        ne.pixelStorei(32877, ee.min.z),
        Oe.isDataTexture || Oe.isData3DTexture
          ? ne.texSubImage3D(
              ti,
              ze,
              Se.x,
              Se.y,
              Se.z,
              nt,
              Bt,
              qt,
              kt,
              hi,
              Li.data
            )
          : Oe.isCompressedArrayTexture
          ? (console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
            ),
            ne.compressedTexSubImage3D(
              ti,
              ze,
              Se.x,
              Se.y,
              Se.z,
              nt,
              Bt,
              qt,
              kt,
              Li.data
            ))
          : ne.texSubImage3D(ti, ze, Se.x, Se.y, Se.z, nt, Bt, qt, kt, hi, Li),
        ne.pixelStorei(3314, Zt),
        ne.pixelStorei(32878, pi),
        ne.pixelStorei(3316, Er),
        ne.pixelStorei(3315, Vi),
        ne.pixelStorei(32877, Qi),
        ze === 0 && we.generateMipmaps && ne.generateMipmap(ti),
        ye.unbindTexture();
    }),
    (this.initTexture = function (ee) {
      ee.isCubeTexture
        ? Te.setTextureCube(ee, 0)
        : ee.isData3DTexture
        ? Te.setTexture3D(ee, 0)
        : ee.isDataArrayTexture || ee.isCompressedArrayTexture
        ? Te.setTexture2DArray(ee, 0)
        : Te.setTexture2D(ee, 0),
        ye.unbindTexture();
    }),
    (this.resetState = function () {
      (y = 0), (x = 0), (b = null), ye.reset(), Be.reset();
    }),
    typeof __THREE_DEVTOOLS__ < "u" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
var Kz = class extends lC {};
Kz.prototype.isWebGL1Renderer = !0;
var hC = class {
    constructor(e, t = 1, i = 1e3) {
      (this.isFog = !0),
        (this.name = ""),
        (this.color = new Et(e)),
        (this.near = t),
        (this.far = i);
    }
    clone() {
      return new hC(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far,
      };
    }
  },
  xo = class extends _i {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.overrideMaterial = null),
        typeof __THREE_DEVTOOLS__ < "u" &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        (this.backgroundBlurriness = e.backgroundBlurriness),
        (this.backgroundIntensity = e.backgroundIntensity),
        e.overrideMaterial !== null &&
          (this.overrideMaterial = e.overrideMaterial.clone()),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this
      );
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return (
        this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 &&
          (t.object.backgroundIntensity = this.backgroundIntensity),
        t
      );
    }
    get autoUpdate() {
      return (
        console.warn(
          "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
        ),
        this.matrixWorldAutoUpdate
      );
    }
    set autoUpdate(e) {
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
        (this.matrixWorldAutoUpdate = e);
    }
  },
  Jz = class {
    constructor(e, t) {
      (this.isInterleavedBuffer = !0),
        (this.array = e),
        (this.stride = t),
        (this.count = e !== void 0 ? e.length / t : 0),
        (this.usage = fy),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0),
        (this.uuid = Aa());
    }
    onUploadCallback() {}
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    setUsage(e) {
      return (this.usage = e), this;
    }
    copy(e) {
      return (
        (this.array = new e.array.constructor(e.array)),
        (this.count = e.count),
        (this.stride = e.stride),
        (this.usage = e.usage),
        this
      );
    }
    copyAt(e, t, i) {
      (e *= this.stride), (i *= t.stride);
      for (let r = 0, s = this.stride; r < s; r++)
        this.array[e + r] = t.array[i + r];
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    clone(e) {
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Aa()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
          (e.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      let t = new this.array.constructor(
          e.arrayBuffers[this.array.buffer._uuid]
        ),
        i = new this.constructor(t, this.stride);
      return i.setUsage(this.usage), i;
    }
    onUpload(e) {
      return (this.onUploadCallback = e), this;
    }
    toJSON(e) {
      return (
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Aa()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
          (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    }
  },
  _s = new I(),
  yy = class {
    constructor(e, t, i, r = !1) {
      (this.isInterleavedBufferAttribute = !0),
        (this.name = ""),
        (this.data = e),
        (this.itemSize = t),
        (this.offset = i),
        (this.normalized = r);
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e) {
      this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
      for (let t = 0, i = this.data.count; t < i; t++)
        _s.fromBufferAttribute(this, t),
          _s.applyMatrix4(e),
          this.setXYZ(t, _s.x, _s.y, _s.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, i = this.count; t < i; t++)
        _s.fromBufferAttribute(this, t),
          _s.applyNormalMatrix(e),
          this.setXYZ(t, _s.x, _s.y, _s.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, i = this.count; t < i; t++)
        _s.fromBufferAttribute(this, t),
          _s.transformDirection(e),
          this.setXYZ(t, _s.x, _s.y, _s.z);
      return this;
    }
    setX(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset] = t),
        this
      );
    }
    setY(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset + 1] = t),
        this
      );
    }
    setZ(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset + 2] = t),
        this
      );
    }
    setW(e, t) {
      return (
        this.normalized && (t = Ri(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset + 3] = t),
        this
      );
    }
    getX(e) {
      let t = this.data.array[e * this.data.stride + this.offset];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    getY(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 1];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    getZ(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 2];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    getW(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 3];
      return this.normalized && (t = vo(t, this.array)), t;
    }
    setXY(e, t, i) {
      return (
        (e = e * this.data.stride + this.offset),
        this.normalized && ((t = Ri(t, this.array)), (i = Ri(i, this.array))),
        (this.data.array[e + 0] = t),
        (this.data.array[e + 1] = i),
        this
      );
    }
    setXYZ(e, t, i, r) {
      return (
        (e = e * this.data.stride + this.offset),
        this.normalized &&
          ((t = Ri(t, this.array)),
          (i = Ri(i, this.array)),
          (r = Ri(r, this.array))),
        (this.data.array[e + 0] = t),
        (this.data.array[e + 1] = i),
        (this.data.array[e + 2] = r),
        this
      );
    }
    setXYZW(e, t, i, r, s) {
      return (
        (e = e * this.data.stride + this.offset),
        this.normalized &&
          ((t = Ri(t, this.array)),
          (i = Ri(i, this.array)),
          (r = Ri(r, this.array)),
          (s = Ri(s, this.array))),
        (this.data.array[e + 0] = t),
        (this.data.array[e + 1] = i),
        (this.data.array[e + 2] = r),
        (this.data.array[e + 3] = s),
        this
      );
    }
    clone(e) {
      if (e === void 0) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
        );
        let t = [];
        for (let i = 0; i < this.count; i++) {
          let r = i * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++)
            t.push(this.data.array[r + s]);
        }
        return new It(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized
        );
      } else
        return (
          e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
          e.interleavedBuffers[this.data.uuid] === void 0 &&
            (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new yy(
            e.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        );
    }
    toJSON(e) {
      if (e === void 0) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
        );
        let t = [];
        for (let i = 0; i < this.count; i++) {
          let r = i * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++)
            t.push(this.data.array[r + s]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      } else
        return (
          e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
          e.interleavedBuffers[this.data.uuid] === void 0 &&
            (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
    }
  },
  cC = class extends _i {
    constructor() {
      super(), (this.isBone = !0), (this.type = "Bone");
    }
  },
  Sa = class extends Yi {
    constructor(e = null, t = 1, i = 1, r, s, a, n, o, l = mi, h = mi, u, c) {
      super(null, a, n, o, l, h, r, s, u, c),
        (this.isDataTexture = !0),
        (this.image = { data: e, width: t, height: i }),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  },
  X_ = new je(),
  $z = new je(),
  _x = class {
    constructor(e = [], t = []) {
      (this.uuid = Aa()),
        (this.bones = e.slice(0)),
        (this.boneInverses = t),
        (this.boneMatrices = null),
        (this.boneTexture = null),
        (this.boneTextureSize = 0),
        (this.frame = -1),
        this.init();
    }
    init() {
      let e = this.bones,
        t = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0)
      )
        this.calculateInverses();
      else if (e.length !== t.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
        ),
          (this.boneInverses = []);
        for (let i = 0, r = this.bones.length; i < r; i++)
          this.boneInverses.push(new je());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        let i = new je();
        this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
          this.boneInverses.push(i);
      }
    }
    pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        let i = this.bones[e];
        i && i.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        let i = this.bones[e];
        i &&
          (i.parent && i.parent.isBone
            ? (i.matrix.copy(i.parent.matrixWorld).invert(),
              i.matrix.multiply(i.matrixWorld))
            : i.matrix.copy(i.matrixWorld),
          i.matrix.decompose(i.position, i.quaternion, i.scale));
      }
    }
    update() {
      let e = this.bones,
        t = this.boneInverses,
        i = this.boneMatrices,
        r = this.boneTexture;
      for (let s = 0, a = e.length; s < a; s++) {
        let n = e[s] ? e[s].matrixWorld : $z;
        X_.multiplyMatrices(n, t[s]), X_.toArray(i, s * 16);
      }
      r !== null && (r.needsUpdate = !0);
    }
    clone() {
      return new _x(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e = Math.sqrt(this.bones.length * 4);
      (e = XE(e)), (e = Math.max(e, 4));
      let t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      let i = new Sa(t, e, e, Wr, xr);
      return (
        (i.needsUpdate = !0),
        (this.boneMatrices = t),
        (this.boneTexture = i),
        (this.boneTextureSize = e),
        this
      );
    }
    getBoneByName(e) {
      for (let t = 0, i = this.bones.length; t < i; t++) {
        let r = this.bones[t];
        if (r.name === e) return r;
      }
    }
    dispose() {
      this.boneTexture !== null &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let i = 0, r = e.bones.length; i < r; i++) {
        let s = e.bones[i],
          a = t[s];
        a === void 0 &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", s),
          (a = new cC())),
          this.bones.push(a),
          this.boneInverses.push(new je().fromArray(e.boneInverses[i]));
      }
      return this.init(), this;
    }
    toJSON() {
      let e = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      e.uuid = this.uuid;
      let t = this.bones,
        i = this.boneInverses;
      for (let r = 0, s = t.length; r < s; r++) {
        let a = t[r];
        e.bones.push(a.uuid);
        let n = i[r];
        e.boneInverses.push(n.toArray());
      }
      return e;
    }
  },
  Ld = class extends It {
    constructor(e, t, i, r = 1) {
      super(e, t, i),
        (this.isInstancedBufferAttribute = !0),
        (this.meshPerAttribute = r);
    }
    copy(e) {
      return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.meshPerAttribute = this.meshPerAttribute),
        (e.isInstancedBufferAttribute = !0),
        e
      );
    }
  },
  Q_ = new je(),
  Z_ = new je(),
  Jp = [],
  eF = new je(),
  Uu = new br(),
  tF = class extends br {
    constructor(e, t, i) {
      super(e, t),
        (this.isInstancedMesh = !0),
        (this.instanceMatrix = new Ld(new Float32Array(i * 16), 16)),
        (this.instanceColor = null),
        (this.count = i),
        (this.frustumCulled = !1);
      for (let r = 0; r < i; r++) this.setMatrixAt(r, eF);
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null &&
          (this.instanceColor = e.instanceColor.clone()),
        (this.count = e.count),
        this
      );
    }
    getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, e * 16);
    }
    raycast(e, t) {
      let i = this.matrixWorld,
        r = this.count;
      if (
        ((Uu.geometry = this.geometry),
        (Uu.material = this.material),
        Uu.material !== void 0)
      )
        for (let s = 0; s < r; s++) {
          this.getMatrixAt(s, Q_),
            Z_.multiplyMatrices(i, Q_),
            (Uu.matrixWorld = Z_),
            Uu.raycast(e, Jp);
          for (let a = 0, n = Jp.length; a < n; a++) {
            let o = Jp[a];
            (o.instanceId = s), (o.object = this), t.push(o);
          }
          Jp.length = 0;
        }
    }
    setColorAt(e, t) {
      this.instanceColor === null &&
        (this.instanceColor = new Ld(
          new Float32Array(this.instanceMatrix.count * 3),
          3
        )),
        t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, e * 16);
    }
    updateMorphTargets() {}
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  },
  gl = class extends sp {
    constructor(e) {
      super(),
        (this.isLineBasicMaterial = !0),
        (this.type = "LineBasicMaterial"),
        (this.color = new Et(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.fog = !0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        this.color.copy(e.color),
        (this.linewidth = e.linewidth),
        (this.linecap = e.linecap),
        (this.linejoin = e.linejoin),
        (this.fog = e.fog),
        this
      );
    }
  },
  K_ = new I(),
  J_ = new I(),
  $_ = new je(),
  Fv = new su(),
  $p = new Ws(),
  _m = class extends _i {
    constructor(e = new yt(), t = new gl()) {
      super(),
        (this.isLine = !0),
        (this.type = "Line"),
        (this.geometry = e),
        (this.material = t),
        this.updateMorphTargets();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.material = e.material),
        (this.geometry = e.geometry),
        this
      );
    }
    computeLineDistances() {
      let e = this.geometry;
      if (e.index === null) {
        let t = e.attributes.position,
          i = [0];
        for (let r = 1, s = t.count; r < s; r++)
          K_.fromBufferAttribute(t, r - 1),
            J_.fromBufferAttribute(t, r),
            (i[r] = i[r - 1]),
            (i[r] += K_.distanceTo(J_));
        e.setAttribute("lineDistance", new ot(i, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
    raycast(e, t) {
      let i = this.geometry,
        r = this.matrixWorld,
        s = e.params.Line.threshold,
        a = i.drawRange;
      if (
        (i.boundingSphere === null && i.computeBoundingSphere(),
        $p.copy(i.boundingSphere),
        $p.applyMatrix4(r),
        ($p.radius += s),
        e.ray.intersectsSphere($p) === !1)
      )
        return;
      $_.copy(r).invert(), Fv.copy(e.ray).applyMatrix4($_);
      let n = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = n * n,
        l = new I(),
        h = new I(),
        u = new I(),
        c = new I(),
        d = this.isLineSegments ? 2 : 1,
        p = i.index,
        f = i.attributes.position;
      if (p !== null) {
        let m = Math.max(0, a.start),
          g = Math.min(p.count, a.start + a.count);
        for (let y = m, x = g - 1; y < x; y += d) {
          let b = p.getX(y),
            _ = p.getX(y + 1);
          if (
            (l.fromBufferAttribute(f, b),
            h.fromBufferAttribute(f, _),
            Fv.distanceSqToSegment(l, h, c, u) > o)
          )
            continue;
          c.applyMatrix4(this.matrixWorld);
          let S = e.ray.origin.distanceTo(c);
          S < e.near ||
            S > e.far ||
            t.push({
              distance: S,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: y,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        let m = Math.max(0, a.start),
          g = Math.min(f.count, a.start + a.count);
        for (let y = m, x = g - 1; y < x; y += d) {
          if (
            (l.fromBufferAttribute(f, y),
            h.fromBufferAttribute(f, y + 1),
            Fv.distanceSqToSegment(l, h, c, u) > o)
          )
            continue;
          c.applyMatrix4(this.matrixWorld);
          let b = e.ray.origin.distanceTo(c);
          b < e.near ||
            b > e.far ||
            t.push({
              distance: b,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: y,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    }
    updateMorphTargets() {
      let e = this.geometry.morphAttributes,
        t = Object.keys(e);
      if (t.length > 0) {
        let i = e[t[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, s = i.length; r < s; r++) {
            let a = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = r);
          }
        }
      }
    }
  },
  eS = new I(),
  tS = new I(),
  ap = class extends _m {
    constructor(e, t) {
      super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
    }
    computeLineDistances() {
      let e = this.geometry;
      if (e.index === null) {
        let t = e.attributes.position,
          i = [];
        for (let r = 0, s = t.count; r < s; r += 2)
          eS.fromBufferAttribute(t, r),
            tS.fromBufferAttribute(t, r + 1),
            (i[r] = r === 0 ? 0 : i[r - 1]),
            (i[r + 1] = i[r] + eS.distanceTo(tS));
        e.setAttribute("lineDistance", new ot(i, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
  },
  iF = class extends Yi {
    constructor(e, t, i, r, s, a, n, o, l) {
      super(e, t, i, r, s, a, n, o, l),
        (this.isVideoTexture = !0),
        (this.minFilter = a !== void 0 ? a : Wt),
        (this.magFilter = s !== void 0 ? s : Wt),
        (this.generateMipmaps = !1);
      let h = this;
      function u() {
        (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
      }
      "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      let e = this.image;
      !("requestVideoFrameCallback" in e) &&
        e.readyState >= e.HAVE_CURRENT_DATA &&
        (this.needsUpdate = !0);
    }
  },
  rF = class extends Yi {
    constructor(e, t, i, r, s, a, n, o, l) {
      super(e, t, i, r, s, a, n, o, l),
        (this.isCanvasTexture = !0),
        (this.needsUpdate = !0);
    }
  },
  zn = class {
    constructor() {
      (this.type = "Curve"), (this.arcLengthDivisions = 200);
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e, t) {
      let i = this.getUtoTmapping(e);
      return this.getPoint(i, t);
    }
    getPoints(e = 5) {
      let t = [];
      for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
      return t;
    }
    getSpacedPoints(e = 5) {
      let t = [];
      for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
      return t;
    }
    getLength() {
      let e = this.getLengths();
      return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
      if (
        this.cacheArcLengths &&
        this.cacheArcLengths.length === e + 1 &&
        !this.needsUpdate
      )
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      let t = [],
        i,
        r = this.getPoint(0),
        s = 0;
      t.push(0);
      for (let a = 1; a <= e; a++)
        (i = this.getPoint(a / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
      return (this.cacheArcLengths = t), t;
    }
    updateArcLengths() {
      (this.needsUpdate = !0), this.getLengths();
    }
    getUtoTmapping(e, t) {
      let i = this.getLengths(),
        r = 0,
        s = i.length,
        a;
      t ? (a = t) : (a = e * i[s - 1]);
      let n = 0,
        o = s - 1,
        l;
      for (; n <= o; )
        if (((r = Math.floor(n + (o - n) / 2)), (l = i[r] - a), l < 0))
          n = r + 1;
        else if (l > 0) o = r - 1;
        else {
          o = r;
          break;
        }
      if (((r = o), i[r] === a)) return r / (s - 1);
      let h = i[r],
        u = i[r + 1] - h,
        c = (a - h) / u;
      return (r + c) / (s - 1);
    }
    getTangent(e, t) {
      let i = e - 1e-4,
        r = e + 1e-4;
      i < 0 && (i = 0), r > 1 && (r = 1);
      let s = this.getPoint(i),
        a = this.getPoint(r),
        n = t || (s.isVector2 ? new re() : new I());
      return n.copy(a).sub(s).normalize(), n;
    }
    getTangentAt(e, t) {
      let i = this.getUtoTmapping(e);
      return this.getTangent(i, t);
    }
    computeFrenetFrames(e, t) {
      let i = new I(),
        r = [],
        s = [],
        a = [],
        n = new I(),
        o = new je();
      for (let d = 0; d <= e; d++) {
        let p = d / e;
        r[d] = this.getTangentAt(p, new I());
      }
      (s[0] = new I()), (a[0] = new I());
      let l = Number.MAX_VALUE,
        h = Math.abs(r[0].x),
        u = Math.abs(r[0].y),
        c = Math.abs(r[0].z);
      h <= l && ((l = h), i.set(1, 0, 0)),
        u <= l && ((l = u), i.set(0, 1, 0)),
        c <= l && i.set(0, 0, 1),
        n.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], n),
        a[0].crossVectors(r[0], s[0]);
      for (let d = 1; d <= e; d++) {
        if (
          ((s[d] = s[d - 1].clone()),
          (a[d] = a[d - 1].clone()),
          n.crossVectors(r[d - 1], r[d]),
          n.length() > Number.EPSILON)
        ) {
          n.normalize();
          let p = Math.acos(vr(r[d - 1].dot(r[d]), -1, 1));
          s[d].applyMatrix4(o.makeRotationAxis(n, p));
        }
        a[d].crossVectors(r[d], s[d]);
      }
      if (t === !0) {
        let d = Math.acos(vr(s[0].dot(s[e]), -1, 1));
        (d /= e), r[0].dot(n.crossVectors(s[0], s[e])) > 0 && (d = -d);
        for (let p = 1; p <= e; p++)
          s[p].applyMatrix4(o.makeRotationAxis(r[p], d * p)),
            a[p].crossVectors(r[p], s[p]);
      }
      return { tangents: r, normals: s, binormals: a };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (this.arcLengthDivisions = e.arcLengthDivisions), this;
    }
    toJSON() {
      let e = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
      };
      return (
        (e.arcLengthDivisions = this.arcLengthDivisions),
        (e.type = this.type),
        e
      );
    }
    fromJSON(e) {
      return (this.arcLengthDivisions = e.arcLengthDivisions), this;
    }
  },
  wg = class extends zn {
    constructor(
      e = 0,
      t = 0,
      i = 1,
      r = 1,
      s = 0,
      a = Math.PI * 2,
      n = !1,
      o = 0
    ) {
      super(),
        (this.isEllipseCurve = !0),
        (this.type = "EllipseCurve"),
        (this.aX = e),
        (this.aY = t),
        (this.xRadius = i),
        (this.yRadius = r),
        (this.aStartAngle = s),
        (this.aEndAngle = a),
        (this.aClockwise = n),
        (this.aRotation = o);
    }
    getPoint(e, t) {
      let i = t || new re(),
        r = Math.PI * 2,
        s = this.aEndAngle - this.aStartAngle,
        a = Math.abs(s) < Number.EPSILON;
      for (; s < 0; ) s += r;
      for (; s > r; ) s -= r;
      s < Number.EPSILON && (a ? (s = 0) : (s = r)),
        this.aClockwise === !0 && !a && (s === r ? (s = -r) : (s = s - r));
      let n = this.aStartAngle + e * s,
        o = this.aX + this.xRadius * Math.cos(n),
        l = this.aY + this.yRadius * Math.sin(n);
      if (this.aRotation !== 0) {
        let h = Math.cos(this.aRotation),
          u = Math.sin(this.aRotation),
          c = o - this.aX,
          d = l - this.aY;
        (o = c * h - d * u + this.aX), (l = c * u + d * h + this.aY);
      }
      return i.set(o, l);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.aX = e.aX),
        (this.aY = e.aY),
        (this.xRadius = e.xRadius),
        (this.yRadius = e.yRadius),
        (this.aStartAngle = e.aStartAngle),
        (this.aEndAngle = e.aEndAngle),
        (this.aClockwise = e.aClockwise),
        (this.aRotation = e.aRotation),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.aX = this.aX),
        (e.aY = this.aY),
        (e.xRadius = this.xRadius),
        (e.yRadius = this.yRadius),
        (e.aStartAngle = this.aStartAngle),
        (e.aEndAngle = this.aEndAngle),
        (e.aClockwise = this.aClockwise),
        (e.aRotation = this.aRotation),
        e
      );
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        (this.aX = e.aX),
        (this.aY = e.aY),
        (this.xRadius = e.xRadius),
        (this.yRadius = e.yRadius),
        (this.aStartAngle = e.aStartAngle),
        (this.aEndAngle = e.aEndAngle),
        (this.aClockwise = e.aClockwise),
        (this.aRotation = e.aRotation),
        this
      );
    }
  },
  sF = class extends wg {
    constructor(e, t, i, r, s, a) {
      super(e, t, i, i, r, s, a),
        (this.isArcCurve = !0),
        (this.type = "ArcCurve");
    }
  };
function Sx() {
  let e = 0,
    t = 0,
    i = 0,
    r = 0;
  function s(a, n, o, l) {
    (e = a),
      (t = o),
      (i = -3 * a + 3 * n - 2 * o - l),
      (r = 2 * a - 2 * n + o + l);
  }
  return {
    initCatmullRom: function (a, n, o, l, h) {
      s(n, o, h * (o - a), h * (l - n));
    },
    initNonuniformCatmullRom: function (a, n, o, l, h, u, c) {
      let d = (n - a) / h - (o - a) / (h + u) + (o - n) / u,
        p = (o - n) / u - (l - n) / (u + c) + (l - o) / c;
      (d *= u), (p *= u), s(n, o, d, p);
    },
    calc: function (a) {
      let n = a * a,
        o = n * a;
      return e + t * a + i * n + r * o;
    },
  };
}
var ef = new I(),
  kv = new Sx(),
  Nv = new Sx(),
  Uv = new Sx(),
  aF = class extends zn {
    constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
      super(),
        (this.isCatmullRomCurve3 = !0),
        (this.type = "CatmullRomCurve3"),
        (this.points = e),
        (this.closed = t),
        (this.curveType = i),
        (this.tension = r);
    }
    getPoint(e, t = new I()) {
      let i = t,
        r = this.points,
        s = r.length,
        a = (s - (this.closed ? 0 : 1)) * e,
        n = Math.floor(a),
        o = a - n;
      this.closed
        ? (n += n > 0 ? 0 : (Math.floor(Math.abs(n) / s) + 1) * s)
        : o === 0 && n === s - 1 && ((n = s - 2), (o = 1));
      let l, h;
      this.closed || n > 0
        ? (l = r[(n - 1) % s])
        : (ef.subVectors(r[0], r[1]).add(r[0]), (l = ef));
      let u = r[n % s],
        c = r[(n + 1) % s];
      if (
        (this.closed || n + 2 < s
          ? (h = r[(n + 2) % s])
          : (ef.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (h = ef)),
        this.curveType === "centripetal" || this.curveType === "chordal")
      ) {
        let d = this.curveType === "chordal" ? 0.5 : 0.25,
          p = Math.pow(l.distanceToSquared(u), d),
          f = Math.pow(u.distanceToSquared(c), d),
          m = Math.pow(c.distanceToSquared(h), d);
        f < 1e-4 && (f = 1),
          p < 1e-4 && (p = f),
          m < 1e-4 && (m = f),
          kv.initNonuniformCatmullRom(l.x, u.x, c.x, h.x, p, f, m),
          Nv.initNonuniformCatmullRom(l.y, u.y, c.y, h.y, p, f, m),
          Uv.initNonuniformCatmullRom(l.z, u.z, c.z, h.z, p, f, m);
      } else
        this.curveType === "catmullrom" &&
          (kv.initCatmullRom(l.x, u.x, c.x, h.x, this.tension),
          Nv.initCatmullRom(l.y, u.y, c.y, h.y, this.tension),
          Uv.initCatmullRom(l.z, u.z, c.z, h.z, this.tension));
      return i.set(kv.calc(o), Nv.calc(o), Uv.calc(o)), i;
    }
    copy(e) {
      super.copy(e), (this.points = []);
      for (let t = 0, i = e.points.length; t < i; t++) {
        let r = e.points[t];
        this.points.push(r.clone());
      }
      return (
        (this.closed = e.closed),
        (this.curveType = e.curveType),
        (this.tension = e.tension),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      e.points = [];
      for (let t = 0, i = this.points.length; t < i; t++) {
        let r = this.points[t];
        e.points.push(r.toArray());
      }
      return (
        (e.closed = this.closed),
        (e.curveType = this.curveType),
        (e.tension = this.tension),
        e
      );
    }
    fromJSON(e) {
      super.fromJSON(e), (this.points = []);
      for (let t = 0, i = e.points.length; t < i; t++) {
        let r = e.points[t];
        this.points.push(new I().fromArray(r));
      }
      return (
        (this.closed = e.closed),
        (this.curveType = e.curveType),
        (this.tension = e.tension),
        this
      );
    }
  };
function iS(e, t, i, r, s) {
  let a = (r - t) * 0.5,
    n = (s - i) * 0.5,
    o = e * e,
    l = e * o;
  return (
    (2 * i - 2 * r + a + n) * l + (-3 * i + 3 * r - 2 * a - n) * o + a * e + i
  );
}
function nF(e, t) {
  let i = 1 - e;
  return i * i * t;
}
function oF(e, t) {
  return 2 * (1 - e) * e * t;
}
function lF(e, t) {
  return e * e * t;
}
function wd(e, t, i, r) {
  return nF(e, t) + oF(e, i) + lF(e, r);
}
function hF(e, t) {
  let i = 1 - e;
  return i * i * i * t;
}
function cF(e, t) {
  let i = 1 - e;
  return 3 * i * i * e * t;
}
function uF(e, t) {
  return 3 * (1 - e) * e * e * t;
}
function dF(e, t) {
  return e * e * e * t;
}
function _d(e, t, i, r, s) {
  return hF(e, t) + cF(e, i) + uF(e, r) + dF(e, s);
}
var Ha = class extends zn {
    constructor(e = new re(), t = new re(), i = new re(), r = new re()) {
      super(),
        (this.isCubicBezierCurve = !0),
        (this.type = "CubicBezierCurve"),
        (this.v0 = e),
        (this.v1 = t),
        (this.v2 = i),
        (this.v3 = r);
    }
    getPoint(e, t = new re()) {
      let i = t,
        r = this.v0,
        s = this.v1,
        a = this.v2,
        n = this.v3;
      return i.set(_d(e, r.x, s.x, a.x, n.x), _d(e, r.y, s.y, a.y, n.y)), i;
    }
    copy(e) {
      return (
        super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        (e.v3 = this.v3.toArray()),
        e
      );
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
      );
    }
  },
  am = class extends zn {
    constructor(e = new I(), t = new I(), i = new I(), r = new I()) {
      super(),
        (this.isCubicBezierCurve3 = !0),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = e),
        (this.v1 = t),
        (this.v2 = i),
        (this.v3 = r);
    }
    getPoint(e, t = new I()) {
      let i = t,
        r = this.v0,
        s = this.v1,
        a = this.v2,
        n = this.v3;
      return (
        i.set(
          _d(e, r.x, s.x, a.x, n.x),
          _d(e, r.y, s.y, a.y, n.y),
          _d(e, r.z, s.z, a.z, n.z)
        ),
        i
      );
    }
    copy(e) {
      return (
        super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        (e.v3 = this.v3.toArray()),
        e
      );
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
      );
    }
  },
  Ya = class extends zn {
    constructor(e = new re(), t = new re()) {
      super(),
        (this.isLineCurve = !0),
        (this.type = "LineCurve"),
        (this.v1 = e),
        (this.v2 = t);
    }
    getPoint(e, t = new re()) {
      let i = t;
      return (
        e === 1
          ? i.copy(this.v2)
          : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
        i
      );
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t) {
      let i = t || new re();
      return i.copy(this.v2).sub(this.v1).normalize(), i;
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      let e = super.toJSON();
      return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }
  },
  uC = class extends zn {
    constructor(e = new I(), t = new I()) {
      super(),
        (this.isLineCurve3 = !0),
        (this.type = "LineCurve3"),
        (this.v1 = e),
        (this.v2 = t);
    }
    getPoint(e, t = new I()) {
      let i = t;
      return (
        e === 1
          ? i.copy(this.v2)
          : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
        i
      );
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      let e = super.toJSON();
      return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }
  },
  pl = class extends zn {
    constructor(e = new re(), t = new re(), i = new re()) {
      super(),
        (this.isQuadraticBezierCurve = !0),
        (this.type = "QuadraticBezierCurve"),
        (this.v0 = e),
        (this.v1 = t),
        (this.v2 = i);
    }
    getPoint(e, t = new re()) {
      let i = t,
        r = this.v0,
        s = this.v1,
        a = this.v2;
      return i.set(wd(e, r.x, s.x, a.x), wd(e, r.y, s.y, a.y)), i;
    }
    copy(e) {
      return (
        super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        e
      );
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }
  },
  pF = class extends zn {
    constructor(e = new I(), t = new I(), i = new I()) {
      super(),
        (this.isQuadraticBezierCurve3 = !0),
        (this.type = "QuadraticBezierCurve3"),
        (this.v0 = e),
        (this.v1 = t),
        (this.v2 = i);
    }
    getPoint(e, t = new I()) {
      let i = t,
        r = this.v0,
        s = this.v1,
        a = this.v2;
      return (
        i.set(wd(e, r.x, s.x, a.x), wd(e, r.y, s.y, a.y), wd(e, r.z, s.z, a.z)),
        i
      );
    }
    copy(e) {
      return (
        super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
      );
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.v0 = this.v0.toArray()),
        (e.v1 = this.v1.toArray()),
        (e.v2 = this.v2.toArray()),
        e
      );
    }
    fromJSON(e) {
      return (
        super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
      );
    }
  },
  Ax = class extends zn {
    constructor(e = []) {
      super(),
        (this.isSplineCurve = !0),
        (this.type = "SplineCurve"),
        (this.points = e);
    }
    getPoint(e, t = new re()) {
      let i = t,
        r = this.points,
        s = (r.length - 1) * e,
        a = Math.floor(s),
        n = s - a,
        o = r[a === 0 ? a : a - 1],
        l = r[a],
        h = r[a > r.length - 2 ? r.length - 1 : a + 1],
        u = r[a > r.length - 3 ? r.length - 1 : a + 2];
      return i.set(iS(n, o.x, l.x, h.x, u.x), iS(n, o.y, l.y, h.y, u.y)), i;
    }
    copy(e) {
      super.copy(e), (this.points = []);
      for (let t = 0, i = e.points.length; t < i; t++) {
        let r = e.points[t];
        this.points.push(r.clone());
      }
      return this;
    }
    toJSON() {
      let e = super.toJSON();
      e.points = [];
      for (let t = 0, i = this.points.length; t < i; t++) {
        let r = this.points[t];
        e.points.push(r.toArray());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), (this.points = []);
      for (let t = 0, i = e.points.length; t < i; t++) {
        let r = e.points[t];
        this.points.push(new re().fromArray(r));
      }
      return this;
    }
  },
  fF = Object.freeze({
    __proto__: null,
    ArcCurve: sF,
    CatmullRomCurve3: aF,
    CubicBezierCurve: Ha,
    CubicBezierCurve3: am,
    EllipseCurve: wg,
    LineCurve: Ya,
    LineCurve3: uC,
    QuadraticBezierCurve: pl,
    QuadraticBezierCurve3: pF,
    SplineCurve: Ax,
  }),
  dC = class extends zn {
    constructor() {
      super(),
        (this.type = "CurvePath"),
        (this.curves = []),
        (this.autoClose = !1);
    }
    add(e) {
      this.curves.push(e);
    }
    closePath() {
      let e = this.curves[0].getPoint(0),
        t = this.curves[this.curves.length - 1].getPoint(1);
      e.equals(t) || this.curves.push(new Ya(t, e));
    }
    getPoint(e, t) {
      let i = e * this.getLength(),
        r = this.getCurveLengths(),
        s = 0;
      for (; s < r.length; ) {
        if (r[s] >= i) {
          let a = r[s] - i,
            n = this.curves[s],
            o = n.getLength(),
            l = o === 0 ? 0 : 1 - a / o;
          return n.getPointAt(l, t);
        }
        s++;
      }
      return null;
    }
    getLength() {
      let e = this.getCurveLengths();
      return e[e.length - 1];
    }
    updateArcLengths() {
      (this.needsUpdate = !0),
        (this.cacheLengths = null),
        this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      let e = [],
        t = 0;
      for (let i = 0, r = this.curves.length; i < r; i++)
        (t += this.curves[i].getLength()), e.push(t);
      return (this.cacheLengths = e), e;
    }
    getSpacedPoints(e = 40) {
      let t = [];
      for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
      return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
      let t = [],
        i;
      for (let r = 0, s = this.curves; r < s.length; r++) {
        let a = s[r],
          n = a.isEllipseCurve
            ? e * 2
            : a.isLineCurve || a.isLineCurve3
            ? 1
            : a.isSplineCurve
            ? e * a.points.length
            : e,
          o = a.getPoints(n);
        for (let l = 0; l < o.length; l++) {
          let h = o[l];
          (i && i.equals(h)) || (t.push(h), (i = h));
        }
      }
      return (
        this.autoClose &&
          t.length > 1 &&
          !t[t.length - 1].equals(t[0]) &&
          t.push(t[0]),
        t
      );
    }
    copy(e) {
      super.copy(e), (this.curves = []);
      for (let t = 0, i = e.curves.length; t < i; t++) {
        let r = e.curves[t];
        this.curves.push(r.clone());
      }
      return (this.autoClose = e.autoClose), this;
    }
    toJSON() {
      let e = super.toJSON();
      (e.autoClose = this.autoClose), (e.curves = []);
      for (let t = 0, i = this.curves.length; t < i; t++) {
        let r = this.curves[t];
        e.curves.push(r.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
      for (let t = 0, i = e.curves.length; t < i; t++) {
        let r = e.curves[t];
        this.curves.push(new fF[r.type]().fromJSON(r));
      }
      return this;
    }
  },
  Sm = class extends dC {
    constructor(e) {
      super(),
        (this.type = "Path"),
        (this.currentPoint = new re()),
        e && this.setFromPoints(e);
    }
    setFromPoints(e) {
      this.moveTo(e[0].x, e[0].y);
      for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
      return this;
    }
    moveTo(e, t) {
      return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
      let i = new Ya(this.currentPoint.clone(), new re(e, t));
      return this.curves.push(i), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, i, r) {
      let s = new pl(this.currentPoint.clone(), new re(e, t), new re(i, r));
      return this.curves.push(s), this.currentPoint.set(i, r), this;
    }
    bezierCurveTo(e, t, i, r, s, a) {
      let n = new Ha(
        this.currentPoint.clone(),
        new re(e, t),
        new re(i, r),
        new re(s, a)
      );
      return this.curves.push(n), this.currentPoint.set(s, a), this;
    }
    splineThru(e) {
      let t = [this.currentPoint.clone()].concat(e),
        i = new Ax(t);
      return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, i, r, s, a) {
      let n = this.currentPoint.x,
        o = this.currentPoint.y;
      return this.absarc(e + n, t + o, i, r, s, a), this;
    }
    absarc(e, t, i, r, s, a) {
      return this.absellipse(e, t, i, i, r, s, a), this;
    }
    ellipse(e, t, i, r, s, a, n, o) {
      let l = this.currentPoint.x,
        h = this.currentPoint.y;
      return this.absellipse(e + l, t + h, i, r, s, a, n, o), this;
    }
    absellipse(e, t, i, r, s, a, n, o) {
      let l = new wg(e, t, i, r, s, a, n, o);
      if (this.curves.length > 0) {
        let u = l.getPoint(0);
        u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
      }
      this.curves.push(l);
      let h = l.getPoint(1);
      return this.currentPoint.copy(h), this;
    }
    copy(e) {
      return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
      let e = super.toJSON();
      return (e.currentPoint = this.currentPoint.toArray()), e;
    }
    fromJSON(e) {
      return (
        super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
      );
    }
  },
  pC = class extends yt {
    constructor(
      e = [new re(0, -0.5), new re(0.5, 0), new re(0, 0.5)],
      t = 12,
      i = 0,
      r = Math.PI * 2
    ) {
      super(),
        (this.type = "LatheGeometry"),
        (this.parameters = {
          points: e,
          segments: t,
          phiStart: i,
          phiLength: r,
        }),
        (t = Math.floor(t)),
        (r = vr(r, 0, Math.PI * 2));
      let s = [],
        a = [],
        n = [],
        o = [],
        l = [],
        h = 1 / t,
        u = new I(),
        c = new re(),
        d = new I(),
        p = new I(),
        f = new I(),
        m = 0,
        g = 0;
      for (let y = 0; y <= e.length - 1; y++)
        switch (y) {
          case 0:
            (m = e[y + 1].x - e[y].x),
              (g = e[y + 1].y - e[y].y),
              (d.x = g * 1),
              (d.y = -m),
              (d.z = g * 0),
              f.copy(d),
              d.normalize(),
              o.push(d.x, d.y, d.z);
            break;
          case e.length - 1:
            o.push(f.x, f.y, f.z);
            break;
          default:
            (m = e[y + 1].x - e[y].x),
              (g = e[y + 1].y - e[y].y),
              (d.x = g * 1),
              (d.y = -m),
              (d.z = g * 0),
              p.copy(d),
              (d.x += f.x),
              (d.y += f.y),
              (d.z += f.z),
              d.normalize(),
              o.push(d.x, d.y, d.z),
              f.copy(p);
        }
      for (let y = 0; y <= t; y++) {
        let x = i + y * h * r,
          b = Math.sin(x),
          _ = Math.cos(x);
        for (let S = 0; S <= e.length - 1; S++) {
          (u.x = e[S].x * b),
            (u.y = e[S].y),
            (u.z = e[S].x * _),
            a.push(u.x, u.y, u.z),
            (c.x = y / t),
            (c.y = S / (e.length - 1)),
            n.push(c.x, c.y);
          let M = o[3 * S + 0] * b,
            C = o[3 * S + 1],
            A = o[3 * S + 0] * _;
          l.push(M, C, A);
        }
      }
      for (let y = 0; y < t; y++)
        for (let x = 0; x < e.length - 1; x++) {
          let b = x + y * e.length,
            _ = b,
            S = b + e.length,
            M = b + e.length + 1,
            C = b + 1;
          s.push(_, S, C), s.push(M, C, S);
        }
      this.setIndex(s),
        this.setAttribute("position", new ot(a, 3)),
        this.setAttribute("uv", new ot(n, 2)),
        this.setAttribute("normal", new ot(l, 3));
    }
    static fromJSON(e) {
      return new pC(e.points, e.segments, e.phiStart, e.phiLength);
    }
  },
  Mx = class extends yt {
    constructor(
      e = 1,
      t = 1,
      i = 1,
      r = 32,
      s = 1,
      a = !1,
      n = 0,
      o = Math.PI * 2
    ) {
      super(),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: e,
          radiusBottom: t,
          height: i,
          radialSegments: r,
          heightSegments: s,
          openEnded: a,
          thetaStart: n,
          thetaLength: o,
        });
      let l = this;
      (r = Math.floor(r)), (s = Math.floor(s));
      let h = [],
        u = [],
        c = [],
        d = [],
        p = 0,
        f = [],
        m = i / 2,
        g = 0;
      y(),
        a === !1 && (e > 0 && x(!0), t > 0 && x(!1)),
        this.setIndex(h),
        this.setAttribute("position", new ot(u, 3)),
        this.setAttribute("normal", new ot(c, 3)),
        this.setAttribute("uv", new ot(d, 2));
      function y() {
        let b = new I(),
          _ = new I(),
          S = 0,
          M = (t - e) / i;
        for (let C = 0; C <= s; C++) {
          let A = [],
            T = C / s,
            P = T * (t - e) + e;
          for (let R = 0; R <= r; R++) {
            let z = R / r,
              N = z * o + n,
              L = Math.sin(N),
              G = Math.cos(N);
            (_.x = P * L),
              (_.y = -T * i + m),
              (_.z = P * G),
              u.push(_.x, _.y, _.z),
              b.set(L, M, G).normalize(),
              c.push(b.x, b.y, b.z),
              d.push(z, 1 - T),
              A.push(p++);
          }
          f.push(A);
        }
        for (let C = 0; C < r; C++)
          for (let A = 0; A < s; A++) {
            let T = f[A][C],
              P = f[A + 1][C],
              R = f[A + 1][C + 1],
              z = f[A][C + 1];
            h.push(T, P, z), h.push(P, R, z), (S += 6);
          }
        l.addGroup(g, S, 0), (g += S);
      }
      function x(b) {
        let _ = p,
          S = new re(),
          M = new I(),
          C = 0,
          A = b === !0 ? e : t,
          T = b === !0 ? 1 : -1;
        for (let R = 1; R <= r; R++)
          u.push(0, m * T, 0), c.push(0, T, 0), d.push(0.5, 0.5), p++;
        let P = p;
        for (let R = 0; R <= r; R++) {
          let z = (R / r) * o + n,
            N = Math.cos(z),
            L = Math.sin(z);
          (M.x = A * L),
            (M.y = m * T),
            (M.z = A * N),
            u.push(M.x, M.y, M.z),
            c.push(0, T, 0),
            (S.x = N * 0.5 + 0.5),
            (S.y = L * 0.5 * T + 0.5),
            d.push(S.x, S.y),
            p++;
        }
        for (let R = 0; R < r; R++) {
          let z = _ + R,
            N = P + R;
          b === !0 ? h.push(N, N + 1, z) : h.push(N + 1, N, z), (C += 3);
        }
        l.addGroup(g, C, b === !0 ? 1 : 2), (g += C);
      }
    }
    static fromJSON(e) {
      return new Mx(
        e.radiusTop,
        e.radiusBottom,
        e.height,
        e.radialSegments,
        e.heightSegments,
        e.openEnded,
        e.thetaStart,
        e.thetaLength
      );
    }
  },
  Ex = class extends Mx {
    constructor(e = 1, t = 1, i = 32, r = 1, s = !1, a = 0, n = Math.PI * 2) {
      super(0, e, t, i, r, s, a, n),
        (this.type = "ConeGeometry"),
        (this.parameters = {
          radius: e,
          height: t,
          radialSegments: i,
          heightSegments: r,
          openEnded: s,
          thetaStart: a,
          thetaLength: n,
        });
    }
    static fromJSON(e) {
      return new Ex(
        e.radius,
        e.height,
        e.radialSegments,
        e.heightSegments,
        e.openEnded,
        e.thetaStart,
        e.thetaLength
      );
    }
  },
  Cx = class extends yt {
    constructor(e = [], t = [], i = 1, r = 0) {
      super(),
        (this.type = "PolyhedronGeometry"),
        (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
      let s = [],
        a = [];
      n(r),
        l(i),
        h(),
        this.setAttribute("position", new ot(s, 3)),
        this.setAttribute("normal", new ot(s.slice(), 3)),
        this.setAttribute("uv", new ot(a, 2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
      function n(y) {
        let x = new I(),
          b = new I(),
          _ = new I();
        for (let S = 0; S < t.length; S += 3)
          d(t[S + 0], x), d(t[S + 1], b), d(t[S + 2], _), o(x, b, _, y);
      }
      function o(y, x, b, _) {
        let S = _ + 1,
          M = [];
        for (let C = 0; C <= S; C++) {
          M[C] = [];
          let A = y.clone().lerp(b, C / S),
            T = x.clone().lerp(b, C / S),
            P = S - C;
          for (let R = 0; R <= P; R++)
            R === 0 && C === S
              ? (M[C][R] = A)
              : (M[C][R] = A.clone().lerp(T, R / P));
        }
        for (let C = 0; C < S; C++)
          for (let A = 0; A < 2 * (S - C) - 1; A++) {
            let T = Math.floor(A / 2);
            A % 2 === 0
              ? (c(M[C][T + 1]), c(M[C + 1][T]), c(M[C][T]))
              : (c(M[C][T + 1]), c(M[C + 1][T + 1]), c(M[C + 1][T]));
          }
      }
      function l(y) {
        let x = new I();
        for (let b = 0; b < s.length; b += 3)
          (x.x = s[b + 0]),
            (x.y = s[b + 1]),
            (x.z = s[b + 2]),
            x.normalize().multiplyScalar(y),
            (s[b + 0] = x.x),
            (s[b + 1] = x.y),
            (s[b + 2] = x.z);
      }
      function h() {
        let y = new I();
        for (let x = 0; x < s.length; x += 3) {
          (y.x = s[x + 0]), (y.y = s[x + 1]), (y.z = s[x + 2]);
          let b = m(y) / 2 / Math.PI + 0.5,
            _ = g(y) / Math.PI + 0.5;
          a.push(b, 1 - _);
        }
        p(), u();
      }
      function u() {
        for (let y = 0; y < a.length; y += 6) {
          let x = a[y + 0],
            b = a[y + 2],
            _ = a[y + 4],
            S = Math.max(x, b, _),
            M = Math.min(x, b, _);
          S > 0.9 &&
            M < 0.1 &&
            (x < 0.2 && (a[y + 0] += 1),
            b < 0.2 && (a[y + 2] += 1),
            _ < 0.2 && (a[y + 4] += 1));
        }
      }
      function c(y) {
        s.push(y.x, y.y, y.z);
      }
      function d(y, x) {
        let b = y * 3;
        (x.x = e[b + 0]), (x.y = e[b + 1]), (x.z = e[b + 2]);
      }
      function p() {
        let y = new I(),
          x = new I(),
          b = new I(),
          _ = new I(),
          S = new re(),
          M = new re(),
          C = new re();
        for (let A = 0, T = 0; A < s.length; A += 9, T += 6) {
          y.set(s[A + 0], s[A + 1], s[A + 2]),
            x.set(s[A + 3], s[A + 4], s[A + 5]),
            b.set(s[A + 6], s[A + 7], s[A + 8]),
            S.set(a[T + 0], a[T + 1]),
            M.set(a[T + 2], a[T + 3]),
            C.set(a[T + 4], a[T + 5]),
            _.copy(y).add(x).add(b).divideScalar(3);
          let P = m(_);
          f(S, T + 0, y, P), f(M, T + 2, x, P), f(C, T + 4, b, P);
        }
      }
      function f(y, x, b, _) {
        _ < 0 && y.x === 1 && (a[x] = y.x - 1),
          b.x === 0 && b.z === 0 && (a[x] = _ / 2 / Math.PI + 0.5);
      }
      function m(y) {
        return Math.atan2(y.z, -y.x);
      }
      function g(y) {
        return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
      }
    }
    static fromJSON(e) {
      return new Cx(e.vertices, e.indices, e.radius, e.details);
    }
  },
  fC = class extends Cx {
    constructor(e = 1, t = 0) {
      let i = (1 + Math.sqrt(5)) / 2,
        r = 1 / i,
        s = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -r,
          -i,
          0,
          -r,
          i,
          0,
          r,
          -i,
          0,
          r,
          i,
          -r,
          -i,
          0,
          -r,
          i,
          0,
          r,
          -i,
          0,
          r,
          i,
          0,
          -i,
          0,
          -r,
          i,
          0,
          -r,
          -i,
          0,
          r,
          i,
          0,
          r,
        ],
        a = [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ];
      super(s, a, e, t),
        (this.type = "DodecahedronGeometry"),
        (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
      return new fC(e.radius, e.detail);
    }
  },
  Am = class extends Sm {
    constructor(e) {
      super(e), (this.uuid = Aa()), (this.type = "Shape"), (this.holes = []);
    }
    getPointsHoles(e) {
      let t = [];
      for (let i = 0, r = this.holes.length; i < r; i++)
        t[i] = this.holes[i].getPoints(e);
      return t;
    }
    extractPoints(e) {
      return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
    }
    copy(e) {
      super.copy(e), (this.holes = []);
      for (let t = 0, i = e.holes.length; t < i; t++) {
        let r = e.holes[t];
        this.holes.push(r.clone());
      }
      return this;
    }
    toJSON() {
      let e = super.toJSON();
      (e.uuid = this.uuid), (e.holes = []);
      for (let t = 0, i = this.holes.length; t < i; t++) {
        let r = this.holes[t];
        e.holes.push(r.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
      for (let t = 0, i = e.holes.length; t < i; t++) {
        let r = e.holes[t];
        this.holes.push(new Sm().fromJSON(r));
      }
      return this;
    }
  },
  mF = {
    triangulate: function (e, t, i = 2) {
      let r = t && t.length,
        s = r ? t[0] * i : e.length,
        a = mC(e, 0, s, i, !0),
        n = [];
      if (!a || a.next === a.prev) return n;
      let o, l, h, u, c, d, p;
      if ((r && (a = bF(e, t, a, i)), e.length > 80 * i)) {
        (o = h = e[0]), (l = u = e[1]);
        for (let f = i; f < s; f += i)
          (c = e[f]),
            (d = e[f + 1]),
            c < o && (o = c),
            d < l && (l = d),
            c > h && (h = c),
            d > u && (u = d);
        (p = Math.max(h - o, u - l)), (p = p !== 0 ? 32767 / p : 0);
      }
      return Bd(a, n, i, o, l, p, 0), n;
    },
  };
function mC(e, t, i, r, s) {
  let a, n;
  if (s === OF(e, t, i, r) > 0)
    for (a = t; a < i; a += r) n = rS(a, e[a], e[a + 1], n);
  else for (a = i - r; a >= t; a -= r) n = rS(a, e[a], e[a + 1], n);
  return n && _g(n, n.next) && (Fd(n), (n = n.next)), n;
}
function ch(e, t) {
  if (!e) return e;
  t || (t = e);
  let i = e,
    r;
  do
    if (
      ((r = !1), !i.steiner && (_g(i, i.next) || qi(i.prev, i, i.next) === 0))
    ) {
      if ((Fd(i), (i = t = i.prev), i === i.next)) break;
      r = !0;
    } else i = i.next;
  while (r || i !== t);
  return t;
}
function Bd(e, t, i, r, s, a, n) {
  if (!e) return;
  !n && a && MF(e, r, s, a);
  let o = e,
    l,
    h;
  for (; e.prev !== e.next; ) {
    if (((l = e.prev), (h = e.next), a ? vF(e, r, s, a) : gF(e))) {
      t.push((l.i / i) | 0),
        t.push((e.i / i) | 0),
        t.push((h.i / i) | 0),
        Fd(e),
        (e = h.next),
        (o = h.next);
      continue;
    }
    if (((e = h), e === o)) {
      n
        ? n === 1
          ? ((e = yF(ch(e), t, i)), Bd(e, t, i, r, s, a, 2))
          : n === 2 && xF(e, t, i, r, s, a)
        : Bd(ch(e), t, i, r, s, a, 1);
      break;
    }
  }
}
function gF(e) {
  let t = e.prev,
    i = e,
    r = e.next;
  if (qi(t, i, r) >= 0) return !1;
  let s = t.x,
    a = i.x,
    n = r.x,
    o = t.y,
    l = i.y,
    h = r.y,
    u = s < a ? (s < n ? s : n) : a < n ? a : n,
    c = o < l ? (o < h ? o : h) : l < h ? l : h,
    d = s > a ? (s > n ? s : n) : a > n ? a : n,
    p = o > l ? (o > h ? o : h) : l > h ? l : h,
    f = r.next;
  for (; f !== t; ) {
    if (
      f.x >= u &&
      f.x <= d &&
      f.y >= c &&
      f.y <= p &&
      _c(s, o, a, l, n, h, f.x, f.y) &&
      qi(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.next;
  }
  return !0;
}
function vF(e, t, i, r) {
  let s = e.prev,
    a = e,
    n = e.next;
  if (qi(s, a, n) >= 0) return !1;
  let o = s.x,
    l = a.x,
    h = n.x,
    u = s.y,
    c = a.y,
    d = n.y,
    p = o < l ? (o < h ? o : h) : l < h ? l : h,
    f = u < c ? (u < d ? u : d) : c < d ? c : d,
    m = o > l ? (o > h ? o : h) : l > h ? l : h,
    g = u > c ? (u > d ? u : d) : c > d ? c : d,
    y = xy(p, f, t, i, r),
    x = xy(m, g, t, i, r),
    b = e.prevZ,
    _ = e.nextZ;
  for (; b && b.z >= y && _ && _.z <= x; ) {
    if (
      (b.x >= p &&
        b.x <= m &&
        b.y >= f &&
        b.y <= g &&
        b !== s &&
        b !== n &&
        _c(o, u, l, c, h, d, b.x, b.y) &&
        qi(b.prev, b, b.next) >= 0) ||
      ((b = b.prevZ),
      _.x >= p &&
        _.x <= m &&
        _.y >= f &&
        _.y <= g &&
        _ !== s &&
        _ !== n &&
        _c(o, u, l, c, h, d, _.x, _.y) &&
        qi(_.prev, _, _.next) >= 0)
    )
      return !1;
    _ = _.nextZ;
  }
  for (; b && b.z >= y; ) {
    if (
      b.x >= p &&
      b.x <= m &&
      b.y >= f &&
      b.y <= g &&
      b !== s &&
      b !== n &&
      _c(o, u, l, c, h, d, b.x, b.y) &&
      qi(b.prev, b, b.next) >= 0
    )
      return !1;
    b = b.prevZ;
  }
  for (; _ && _.z <= x; ) {
    if (
      _.x >= p &&
      _.x <= m &&
      _.y >= f &&
      _.y <= g &&
      _ !== s &&
      _ !== n &&
      _c(o, u, l, c, h, d, _.x, _.y) &&
      qi(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.nextZ;
  }
  return !0;
}
function yF(e, t, i) {
  let r = e;
  do {
    let s = r.prev,
      a = r.next.next;
    !_g(s, a) &&
      gC(s, r, r.next, a) &&
      zd(s, a) &&
      zd(a, s) &&
      (t.push((s.i / i) | 0),
      t.push((r.i / i) | 0),
      t.push((a.i / i) | 0),
      Fd(r),
      Fd(r.next),
      (r = e = a)),
      (r = r.next);
  } while (r !== e);
  return ch(r);
}
function xF(e, t, i, r, s, a) {
  let n = e;
  do {
    let o = n.next.next;
    for (; o !== n.prev; ) {
      if (n.i !== o.i && TF(n, o)) {
        let l = vC(n, o);
        (n = ch(n, n.next)),
          (l = ch(l, l.next)),
          Bd(n, t, i, r, s, a, 0),
          Bd(l, t, i, r, s, a, 0);
        return;
      }
      o = o.next;
    }
    n = n.next;
  } while (n !== e);
}
function bF(e, t, i, r) {
  let s = [],
    a,
    n,
    o,
    l,
    h;
  for (a = 0, n = t.length; a < n; a++)
    (o = t[a] * r),
      (l = a < n - 1 ? t[a + 1] * r : e.length),
      (h = mC(e, o, l, r, !1)),
      h === h.next && (h.steiner = !0),
      s.push(CF(h));
  for (s.sort(wF), a = 0; a < s.length; a++) i = _F(s[a], i);
  return i;
}
function wF(e, t) {
  return e.x - t.x;
}
function _F(e, t) {
  let i = SF(e, t);
  if (!i) return t;
  let r = vC(i, e);
  return ch(r, r.next), ch(i, i.next);
}
function SF(e, t) {
  let i = t,
    r = -1 / 0,
    s,
    a = e.x,
    n = e.y;
  do {
    if (n <= i.y && n >= i.next.y && i.next.y !== i.y) {
      let d = i.x + ((n - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
      if (
        d <= a &&
        d > r &&
        ((r = d), (s = i.x < i.next.x ? i : i.next), d === a)
      )
        return s;
    }
    i = i.next;
  } while (i !== t);
  if (!s) return null;
  let o = s,
    l = s.x,
    h = s.y,
    u = 1 / 0,
    c;
  i = s;
  do
    a >= i.x &&
      i.x >= l &&
      a !== i.x &&
      _c(n < h ? a : r, n, l, h, n < h ? r : a, n, i.x, i.y) &&
      ((c = Math.abs(n - i.y) / (a - i.x)),
      zd(i, e) &&
        (c < u || (c === u && (i.x > s.x || (i.x === s.x && AF(s, i))))) &&
        ((s = i), (u = c))),
      (i = i.next);
  while (i !== o);
  return s;
}
function AF(e, t) {
  return qi(e.prev, e, t.prev) < 0 && qi(t.next, e, e.next) < 0;
}
function MF(e, t, i, r) {
  let s = e;
  do
    s.z === 0 && (s.z = xy(s.x, s.y, t, i, r)),
      (s.prevZ = s.prev),
      (s.nextZ = s.next),
      (s = s.next);
  while (s !== e);
  (s.prevZ.nextZ = null), (s.prevZ = null), EF(s);
}
function EF(e) {
  let t,
    i,
    r,
    s,
    a,
    n,
    o,
    l,
    h = 1;
  do {
    for (i = e, e = null, a = null, n = 0; i; ) {
      for (n++, r = i, o = 0, t = 0; t < h && (o++, (r = r.nextZ), !!r); t++);
      for (l = h; o > 0 || (l > 0 && r); )
        o !== 0 && (l === 0 || !r || i.z <= r.z)
          ? ((s = i), (i = i.nextZ), o--)
          : ((s = r), (r = r.nextZ), l--),
          a ? (a.nextZ = s) : (e = s),
          (s.prevZ = a),
          (a = s);
      i = r;
    }
    (a.nextZ = null), (h *= 2);
  } while (n > 1);
  return e;
}
function xy(e, t, i, r, s) {
  return (
    (e = ((e - i) * s) | 0),
    (t = ((t - r) * s) | 0),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    e | (t << 1)
  );
}
function CF(e) {
  let t = e,
    i = e;
  do (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
  while (t !== e);
  return i;
}
function _c(e, t, i, r, s, a, n, o) {
  return (
    (s - n) * (t - o) >= (e - n) * (a - o) &&
    (e - n) * (r - o) >= (i - n) * (t - o) &&
    (i - n) * (a - o) >= (s - n) * (r - o)
  );
}
function TF(e, t) {
  return (
    e.next.i !== t.i &&
    e.prev.i !== t.i &&
    !PF(e, t) &&
    ((zd(e, t) &&
      zd(t, e) &&
      DF(e, t) &&
      (qi(e.prev, e, t.prev) || qi(e, t.prev, t))) ||
      (_g(e, t) && qi(e.prev, e, e.next) > 0 && qi(t.prev, t, t.next) > 0))
  );
}
function qi(e, t, i) {
  return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
}
function _g(e, t) {
  return e.x === t.x && e.y === t.y;
}
function gC(e, t, i, r) {
  let s = rf(qi(e, t, i)),
    a = rf(qi(e, t, r)),
    n = rf(qi(i, r, e)),
    o = rf(qi(i, r, t));
  return !!(
    (s !== a && n !== o) ||
    (s === 0 && tf(e, i, t)) ||
    (a === 0 && tf(e, r, t)) ||
    (n === 0 && tf(i, e, r)) ||
    (o === 0 && tf(i, t, r))
  );
}
function tf(e, t, i) {
  return (
    t.x <= Math.max(e.x, i.x) &&
    t.x >= Math.min(e.x, i.x) &&
    t.y <= Math.max(e.y, i.y) &&
    t.y >= Math.min(e.y, i.y)
  );
}
function rf(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}
function PF(e, t) {
  let i = e;
  do {
    if (
      i.i !== e.i &&
      i.next.i !== e.i &&
      i.i !== t.i &&
      i.next.i !== t.i &&
      gC(i, i.next, e, t)
    )
      return !0;
    i = i.next;
  } while (i !== e);
  return !1;
}
function zd(e, t) {
  return qi(e.prev, e, e.next) < 0
    ? qi(e, t, e.next) >= 0 && qi(e, e.prev, t) >= 0
    : qi(e, t, e.prev) < 0 || qi(e, e.next, t) < 0;
}
function DF(e, t) {
  let i = e,
    r = !1,
    s = (e.x + t.x) / 2,
    a = (e.y + t.y) / 2;
  do
    i.y > a != i.next.y > a &&
      i.next.y !== i.y &&
      s < ((i.next.x - i.x) * (a - i.y)) / (i.next.y - i.y) + i.x &&
      (r = !r),
      (i = i.next);
  while (i !== e);
  return r;
}
function vC(e, t) {
  let i = new by(e.i, e.x, e.y),
    r = new by(t.i, t.x, t.y),
    s = e.next,
    a = t.prev;
  return (
    (e.next = t),
    (t.prev = e),
    (i.next = s),
    (s.prev = i),
    (r.next = i),
    (i.prev = r),
    (a.next = r),
    (r.prev = a),
    r
  );
}
function rS(e, t, i, r) {
  let s = new by(e, t, i);
  return (
    r
      ? ((s.next = r.next), (s.prev = r), (r.next.prev = s), (r.next = s))
      : ((s.prev = s), (s.next = s)),
    s
  );
}
function Fd(e) {
  (e.next.prev = e.prev),
    (e.prev.next = e.next),
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function by(e, t, i) {
  (this.i = e),
    (this.x = t),
    (this.y = i),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function OF(e, t, i, r) {
  let s = 0;
  for (let a = t, n = i - r; a < i; a += r)
    (s += (e[n] - e[a]) * (e[a + 1] + e[n + 1])), (n = a);
  return s;
}
var yC = class {
  static area(e) {
    let t = e.length,
      i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return yC.area(e) < 0;
  }
  static triangulateShape(e, t) {
    let i = [],
      r = [],
      s = [];
    sS(e), aS(i, e);
    let a = e.length;
    t.forEach(sS);
    for (let o = 0; o < t.length; o++)
      r.push(a), (a += t[o].length), aS(i, t[o]);
    let n = mF.triangulate(i, r);
    for (let o = 0; o < n.length; o += 3) s.push(n.slice(o, o + 3));
    return s;
  }
};
function sS(e) {
  let t = e.length;
  t > 2 && e[t - 1].equals(e[0]) && e.pop();
}
function aS(e, t) {
  for (let i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y);
}
var xC = class extends Cx {
    constructor(e = 1, t = 0) {
      let i = (1 + Math.sqrt(5)) / 2,
        r = [
          -1,
          i,
          0,
          1,
          i,
          0,
          -1,
          -i,
          0,
          1,
          -i,
          0,
          0,
          -1,
          i,
          0,
          1,
          i,
          0,
          -1,
          -i,
          0,
          1,
          -i,
          i,
          0,
          -1,
          i,
          0,
          1,
          -i,
          0,
          -1,
          -i,
          0,
          1,
        ],
        s = [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ];
      super(r, s, e, t),
        (this.type = "IcosahedronGeometry"),
        (this.parameters = { radius: e, detail: t });
    }
    static fromJSON(e) {
      return new xC(e.radius, e.detail);
    }
  },
  Cc = class extends yt {
    constructor(
      e = 1,
      t = 32,
      i = 16,
      r = 0,
      s = Math.PI * 2,
      a = 0,
      n = Math.PI
    ) {
      super(),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: e,
          widthSegments: t,
          heightSegments: i,
          phiStart: r,
          phiLength: s,
          thetaStart: a,
          thetaLength: n,
        }),
        (t = Math.max(3, Math.floor(t))),
        (i = Math.max(2, Math.floor(i)));
      let o = Math.min(a + n, Math.PI),
        l = 0,
        h = [],
        u = new I(),
        c = new I(),
        d = [],
        p = [],
        f = [],
        m = [];
      for (let g = 0; g <= i; g++) {
        let y = [],
          x = g / i,
          b = 0;
        g == 0 && a == 0
          ? (b = 0.5 / t)
          : g == i && o == Math.PI && (b = -0.5 / t);
        for (let _ = 0; _ <= t; _++) {
          let S = _ / t;
          (u.x = -e * Math.cos(r + S * s) * Math.sin(a + x * n)),
            (u.y = e * Math.cos(a + x * n)),
            (u.z = e * Math.sin(r + S * s) * Math.sin(a + x * n)),
            p.push(u.x, u.y, u.z),
            c.copy(u).normalize(),
            f.push(c.x, c.y, c.z),
            m.push(S + b, 1 - x),
            y.push(l++);
        }
        h.push(y);
      }
      for (let g = 0; g < i; g++)
        for (let y = 0; y < t; y++) {
          let x = h[g][y + 1],
            b = h[g][y],
            _ = h[g + 1][y],
            S = h[g + 1][y + 1];
          (g !== 0 || a > 0) && d.push(x, b, S),
            (g !== i - 1 || o < Math.PI) && d.push(b, _, S);
        }
      this.setIndex(d),
        this.setAttribute("position", new ot(p, 3)),
        this.setAttribute("normal", new ot(f, 3)),
        this.setAttribute("uv", new ot(m, 2));
    }
    static fromJSON(e) {
      return new Cc(
        e.radius,
        e.widthSegments,
        e.heightSegments,
        e.phiStart,
        e.phiLength,
        e.thetaStart,
        e.thetaLength
      );
    }
  },
  bC = class extends yt {
    constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
      super(),
        (this.type = "TorusGeometry"),
        (this.parameters = {
          radius: e,
          tube: t,
          radialSegments: i,
          tubularSegments: r,
          arc: s,
        }),
        (i = Math.floor(i)),
        (r = Math.floor(r));
      let a = [],
        n = [],
        o = [],
        l = [],
        h = new I(),
        u = new I(),
        c = new I();
      for (let d = 0; d <= i; d++)
        for (let p = 0; p <= r; p++) {
          let f = (p / r) * s,
            m = (d / i) * Math.PI * 2;
          (u.x = (e + t * Math.cos(m)) * Math.cos(f)),
            (u.y = (e + t * Math.cos(m)) * Math.sin(f)),
            (u.z = t * Math.sin(m)),
            n.push(u.x, u.y, u.z),
            (h.x = e * Math.cos(f)),
            (h.y = e * Math.sin(f)),
            c.subVectors(u, h).normalize(),
            o.push(c.x, c.y, c.z),
            l.push(p / r),
            l.push(d / i);
        }
      for (let d = 1; d <= i; d++)
        for (let p = 1; p <= r; p++) {
          let f = (r + 1) * d + p - 1,
            m = (r + 1) * (d - 1) + p - 1,
            g = (r + 1) * (d - 1) + p,
            y = (r + 1) * d + p;
          a.push(f, m, y), a.push(m, g, y);
        }
      this.setIndex(a),
        this.setAttribute("position", new ot(n, 3)),
        this.setAttribute("normal", new ot(o, 3)),
        this.setAttribute("uv", new ot(l, 2));
    }
    static fromJSON(e) {
      return new bC(
        e.radius,
        e.tube,
        e.radialSegments,
        e.tubularSegments,
        e.arc
      );
    }
  },
  wC = class extends yt {
    constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, a = 3) {
      super(),
        (this.type = "TorusKnotGeometry"),
        (this.parameters = {
          radius: e,
          tube: t,
          tubularSegments: i,
          radialSegments: r,
          p: s,
          q: a,
        }),
        (i = Math.floor(i)),
        (r = Math.floor(r));
      let n = [],
        o = [],
        l = [],
        h = [],
        u = new I(),
        c = new I(),
        d = new I(),
        p = new I(),
        f = new I(),
        m = new I(),
        g = new I();
      for (let x = 0; x <= i; ++x) {
        let b = (x / i) * s * Math.PI * 2;
        y(b, s, a, e, d),
          y(b + 0.01, s, a, e, p),
          m.subVectors(p, d),
          g.addVectors(p, d),
          f.crossVectors(m, g),
          g.crossVectors(f, m),
          f.normalize(),
          g.normalize();
        for (let _ = 0; _ <= r; ++_) {
          let S = (_ / r) * Math.PI * 2,
            M = -t * Math.cos(S),
            C = t * Math.sin(S);
          (u.x = d.x + (M * g.x + C * f.x)),
            (u.y = d.y + (M * g.y + C * f.y)),
            (u.z = d.z + (M * g.z + C * f.z)),
            o.push(u.x, u.y, u.z),
            c.subVectors(u, d).normalize(),
            l.push(c.x, c.y, c.z),
            h.push(x / i),
            h.push(_ / r);
        }
      }
      for (let x = 1; x <= i; x++)
        for (let b = 1; b <= r; b++) {
          let _ = (r + 1) * (x - 1) + (b - 1),
            S = (r + 1) * x + (b - 1),
            M = (r + 1) * x + b,
            C = (r + 1) * (x - 1) + b;
          n.push(_, S, C), n.push(S, M, C);
        }
      this.setIndex(n),
        this.setAttribute("position", new ot(o, 3)),
        this.setAttribute("normal", new ot(l, 3)),
        this.setAttribute("uv", new ot(h, 2));
      function y(x, b, _, S, M) {
        let C = Math.cos(x),
          A = Math.sin(x),
          T = (_ / b) * x,
          P = Math.cos(T);
        (M.x = S * (2 + P) * 0.5 * C),
          (M.y = S * (2 + P) * A * 0.5),
          (M.z = S * Math.sin(T) * 0.5);
      }
    }
    static fromJSON(e) {
      return new wC(
        e.radius,
        e.tube,
        e.tubularSegments,
        e.radialSegments,
        e.p,
        e.q
      );
    }
  };
function Fo(e, t, i) {
  return _C(e)
    ? new e.constructor(e.subarray(t, i !== void 0 ? i : e.length))
    : e.slice(t, i);
}
function sf(e, t, i) {
  return !e || (!i && e.constructor === t)
    ? e
    : typeof t.BYTES_PER_ELEMENT == "number"
    ? new t(e)
    : Array.prototype.slice.call(e);
}
function _C(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function IF(e) {
  function t(s, a) {
    return e[s] - e[a];
  }
  let i = e.length,
    r = new Array(i);
  for (let s = 0; s !== i; ++s) r[s] = s;
  return r.sort(t), r;
}
function nS(e, t, i) {
  let r = e.length,
    s = new e.constructor(r);
  for (let a = 0, n = 0; n !== r; ++a) {
    let o = i[a] * t;
    for (let l = 0; l !== t; ++l) s[n++] = e[o + l];
  }
  return s;
}
function SC(e, t, i, r) {
  let s = 1,
    a = e[0];
  for (; a !== void 0 && a[r] === void 0; ) a = e[s++];
  if (a === void 0) return;
  let n = a[r];
  if (n !== void 0)
    if (Array.isArray(n))
      do
        (n = a[r]),
          n !== void 0 && (t.push(a.time), i.push.apply(i, n)),
          (a = e[s++]);
      while (a !== void 0);
    else if (n.toArray !== void 0)
      do
        (n = a[r]),
          n !== void 0 && (t.push(a.time), n.toArray(i, i.length)),
          (a = e[s++]);
      while (a !== void 0);
    else
      do (n = a[r]), n !== void 0 && (t.push(a.time), i.push(n)), (a = e[s++]);
      while (a !== void 0);
}
var Sg = class {
    constructor(e, t, i, r) {
      (this.parameterPositions = e),
        (this._cachedIndex = 0),
        (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
        (this.sampleValues = t),
        (this.valueSize = i),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(e) {
      let t = this.parameterPositions,
        i = this._cachedIndex,
        r = t[i],
        s = t[i - 1];
      e: {
        t: {
          let a;
          i: {
            r: if (!(e < r)) {
              for (let n = i + 2; ; ) {
                if (r === void 0) {
                  if (e < s) break r;
                  return (
                    (i = t.length),
                    (this._cachedIndex = i),
                    this.copySampleValue_(i - 1)
                  );
                }
                if (i === n) break;
                if (((s = r), (r = t[++i]), e < r)) break t;
              }
              a = t.length;
              break i;
            }
            if (!(e >= s)) {
              let n = t[1];
              e < n && ((i = 2), (s = n));
              for (let o = i - 2; ; ) {
                if (s === void 0)
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (i === o) break;
                if (((r = s), (s = t[--i - 1]), e >= s)) break t;
              }
              (a = i), (i = 0);
              break i;
            }
            break e;
          }
          for (; i < a; ) {
            let n = (i + a) >>> 1;
            e < t[n] ? (a = n) : (i = n + 1);
          }
          if (((r = t[i]), (s = t[i - 1]), s === void 0))
            return (this._cachedIndex = 0), this.copySampleValue_(0);
          if (r === void 0)
            return (
              (i = t.length),
              (this._cachedIndex = i),
              this.copySampleValue_(i - 1)
            );
        }
        (this._cachedIndex = i), this.intervalChanged_(i, s, r);
      }
      return this.interpolate_(i, s, e, r);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
      let t = this.resultBuffer,
        i = this.sampleValues,
        r = this.valueSize,
        s = e * r;
      for (let a = 0; a !== r; ++a) t[a] = i[s + a];
      return t;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  },
  RF = class extends Sg {
    constructor(e, t, i, r) {
      super(e, t, i, r),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: xc, endingEnd: xc });
    }
    intervalChanged_(e, t, i) {
      let r = this.parameterPositions,
        s = e - 2,
        a = e + 1,
        n = r[s],
        o = r[a];
      if (n === void 0)
        switch (this.getSettings_().endingStart) {
          case bc:
            (s = e), (n = 2 * t - i);
            break;
          case xm:
            (s = r.length - 2), (n = t + r[s] - r[s + 1]);
            break;
          default:
            (s = e), (n = i);
        }
      if (o === void 0)
        switch (this.getSettings_().endingEnd) {
          case bc:
            (a = e), (o = 2 * i - t);
            break;
          case xm:
            (a = 1), (o = i + r[1] - r[0]);
            break;
          default:
            (a = e - 1), (o = t);
        }
      let l = (i - t) * 0.5,
        h = this.valueSize;
      (this._weightPrev = l / (t - n)),
        (this._weightNext = l / (o - i)),
        (this._offsetPrev = s * h),
        (this._offsetNext = a * h);
    }
    interpolate_(e, t, i, r) {
      let s = this.resultBuffer,
        a = this.sampleValues,
        n = this.valueSize,
        o = e * n,
        l = o - n,
        h = this._offsetPrev,
        u = this._offsetNext,
        c = this._weightPrev,
        d = this._weightNext,
        p = (i - t) / (r - t),
        f = p * p,
        m = f * p,
        g = -c * m + 2 * c * f - c * p,
        y = (1 + c) * m + (-1.5 - 2 * c) * f + (-0.5 + c) * p + 1,
        x = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        b = d * m - d * f;
      for (let _ = 0; _ !== n; ++_)
        s[_] = g * a[h + _] + y * a[l + _] + x * a[o + _] + b * a[u + _];
      return s;
    }
  },
  AC = class extends Sg {
    constructor(e, t, i, r) {
      super(e, t, i, r);
    }
    interpolate_(e, t, i, r) {
      let s = this.resultBuffer,
        a = this.sampleValues,
        n = this.valueSize,
        o = e * n,
        l = o - n,
        h = (i - t) / (r - t),
        u = 1 - h;
      for (let c = 0; c !== n; ++c) s[c] = a[l + c] * u + a[o + c] * h;
      return s;
    }
  },
  LF = class extends Sg {
    constructor(e, t, i, r) {
      super(e, t, i, r);
    }
    interpolate_(e) {
      return this.copySampleValue_(e - 1);
    }
  },
  Fn = class {
    constructor(e, t, i, r) {
      if (e === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (t === void 0 || t.length === 0)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + e
        );
      (this.name = e),
        (this.times = sf(t, this.TimeBufferType)),
        (this.values = sf(i, this.ValueBufferType)),
        this.setInterpolation(r || this.DefaultInterpolation);
    }
    static toJSON(e) {
      let t = e.constructor,
        i;
      if (t.toJSON !== this.toJSON) i = t.toJSON(e);
      else {
        i = {
          name: e.name,
          times: sf(e.times, Array),
          values: sf(e.values, Array),
        };
        let r = e.getInterpolation();
        r !== e.DefaultInterpolation && (i.interpolation = r);
      }
      return (i.type = e.ValueTypeName), i;
    }
    InterpolantFactoryMethodDiscrete(e) {
      return new LF(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
      return new AC(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
      return new RF(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
      let t;
      switch (e) {
        case vm:
          t = this.InterpolantFactoryMethodDiscrete;
          break;
        case ym:
          t = this.InterpolantFactoryMethodLinear;
          break;
        case uv:
          t = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (t === void 0) {
        let i =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (this.createInterpolant === void 0)
          if (e !== this.DefaultInterpolation)
            this.setInterpolation(this.DefaultInterpolation);
          else throw new Error(i);
        return console.warn("THREE.KeyframeTrack:", i), this;
      }
      return (this.createInterpolant = t), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return vm;
        case this.InterpolantFactoryMethodLinear:
          return ym;
        case this.InterpolantFactoryMethodSmooth:
          return uv;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e) {
      if (e !== 0) {
        let t = this.times;
        for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
      }
      return this;
    }
    scale(e) {
      if (e !== 1) {
        let t = this.times;
        for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
      }
      return this;
    }
    trim(e, t) {
      let i = this.times,
        r = i.length,
        s = 0,
        a = r - 1;
      for (; s !== r && i[s] < e; ) ++s;
      for (; a !== -1 && i[a] > t; ) --a;
      if ((++a, s !== 0 || a !== r)) {
        s >= a && ((a = Math.max(a, 1)), (s = a - 1));
        let n = this.getValueSize();
        (this.times = Fo(i, s, a)),
          (this.values = Fo(this.values, s * n, a * n));
      }
      return this;
    }
    validate() {
      let e = !0,
        t = this.getValueSize();
      t - Math.floor(t) !== 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (e = !1));
      let i = this.times,
        r = this.values,
        s = i.length;
      s === 0 &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
      let a = null;
      for (let n = 0; n !== s; n++) {
        let o = i[n];
        if (typeof o == "number" && isNaN(o)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            n,
            o
          ),
            (e = !1);
          break;
        }
        if (a !== null && a > o) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            n,
            o,
            a
          ),
            (e = !1);
          break;
        }
        a = o;
      }
      if (r !== void 0 && _C(r))
        for (let n = 0, o = r.length; n !== o; ++n) {
          let l = r[n];
          if (isNaN(l)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              n,
              l
            ),
              (e = !1);
            break;
          }
        }
      return e;
    }
    optimize() {
      let e = Fo(this.times),
        t = Fo(this.values),
        i = this.getValueSize(),
        r = this.getInterpolation() === uv,
        s = e.length - 1,
        a = 1;
      for (let n = 1; n < s; ++n) {
        let o = !1,
          l = e[n],
          h = e[n + 1];
        if (l !== h && (n !== 1 || l !== e[0]))
          if (r) o = !0;
          else {
            let u = n * i,
              c = u - i,
              d = u + i;
            for (let p = 0; p !== i; ++p) {
              let f = t[u + p];
              if (f !== t[c + p] || f !== t[d + p]) {
                o = !0;
                break;
              }
            }
          }
        if (o) {
          if (n !== a) {
            e[a] = e[n];
            let u = n * i,
              c = a * i;
            for (let d = 0; d !== i; ++d) t[c + d] = t[u + d];
          }
          ++a;
        }
      }
      if (s > 0) {
        e[a] = e[s];
        for (let n = s * i, o = a * i, l = 0; l !== i; ++l) t[o + l] = t[n + l];
        ++a;
      }
      return (
        a !== e.length
          ? ((this.times = Fo(e, 0, a)), (this.values = Fo(t, 0, a * i)))
          : ((this.times = e), (this.values = t)),
        this
      );
    }
    clone() {
      let e = Fo(this.times, 0),
        t = Fo(this.values, 0),
        i = this.constructor,
        r = new i(this.name, e, t);
      return (r.createInterpolant = this.createInterpolant), r;
    }
  };
Fn.prototype.TimeBufferType = Float32Array;
Fn.prototype.ValueBufferType = Float32Array;
Fn.prototype.DefaultInterpolation = ym;
var ou = class extends Fn {};
ou.prototype.ValueTypeName = "bool";
ou.prototype.ValueBufferType = Array;
ou.prototype.DefaultInterpolation = vm;
ou.prototype.InterpolantFactoryMethodLinear = void 0;
ou.prototype.InterpolantFactoryMethodSmooth = void 0;
var MC = class extends Fn {};
MC.prototype.ValueTypeName = "color";
var Mm = class extends Fn {};
Mm.prototype.ValueTypeName = "number";
var BF = class extends Sg {
    constructor(e, t, i, r) {
      super(e, t, i, r);
    }
    interpolate_(e, t, i, r) {
      let s = this.resultBuffer,
        a = this.sampleValues,
        n = this.valueSize,
        o = (i - t) / (r - t),
        l = e * n;
      for (let h = l + n; l !== h; l += 4)
        Rt.slerpFlat(s, 0, a, l - n, a, l, o);
      return s;
    }
  },
  np = class extends Fn {
    InterpolantFactoryMethodLinear(e) {
      return new BF(this.times, this.values, this.getValueSize(), e);
    }
  };
np.prototype.ValueTypeName = "quaternion";
np.prototype.DefaultInterpolation = ym;
np.prototype.InterpolantFactoryMethodSmooth = void 0;
var lu = class extends Fn {};
lu.prototype.ValueTypeName = "string";
lu.prototype.ValueBufferType = Array;
lu.prototype.DefaultInterpolation = vm;
lu.prototype.InterpolantFactoryMethodLinear = void 0;
lu.prototype.InterpolantFactoryMethodSmooth = void 0;
var Em = class extends Fn {};
Em.prototype.ValueTypeName = "vector";
var wy = class {
  constructor(e, t = -1, i, r = mx) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = Aa()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    let t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let a = 0, n = i.length; a !== n; ++a) t.push(FF(i[a]).scale(r));
    let s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    let t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, a = i.length; s !== a; ++s) t.push(Fn.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    let s = t.length,
      a = [];
    for (let n = 0; n < s; n++) {
      let o = [],
        l = [];
      o.push((n + s - 1) % s, n, (n + 1) % s), l.push(0, 1, 0);
      let h = IF(o);
      (o = nS(o, 1, h)),
        (l = nS(l, 1, h)),
        !r && o[0] === 0 && (o.push(s), l.push(l[0])),
        a.push(
          new Mm(".morphTargetInfluences[" + t[n].name + "]", o, l).scale(1 / i)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      let r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    let r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let n = 0, o = e.length; n < o; n++) {
      let l = e[n],
        h = l.name.match(s);
      if (h && h.length > 1) {
        let u = h[1],
          c = r[u];
        c || (r[u] = c = []), c.push(l);
      }
    }
    let a = [];
    for (let n in r) a.push(this.CreateFromMorphTargetSequence(n, r[n], t, i));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    let i = function (h, u, c, d, p) {
        if (c.length !== 0) {
          let f = [],
            m = [];
          SC(c, f, m, d), f.length !== 0 && p.push(new h(u, f, m));
        }
      },
      r = [],
      s = e.name || "default",
      a = e.fps || 30,
      n = e.blendMode,
      o = e.length || -1,
      l = e.hierarchy || [];
    for (let h = 0; h < l.length; h++) {
      let u = l[h].keys;
      if (!(!u || u.length === 0))
        if (u[0].morphTargets) {
          let c = {},
            d;
          for (d = 0; d < u.length; d++)
            if (u[d].morphTargets)
              for (let p = 0; p < u[d].morphTargets.length; p++)
                c[u[d].morphTargets[p]] = -1;
          for (let p in c) {
            let f = [],
              m = [];
            for (let g = 0; g !== u[d].morphTargets.length; ++g) {
              let y = u[d];
              f.push(y.time), m.push(y.morphTarget === p ? 1 : 0);
            }
            r.push(new Mm(".morphTargetInfluence[" + p + "]", f, m));
          }
          o = c.length * a;
        } else {
          let c = ".bones[" + t[h].name + "]";
          i(Em, c + ".position", u, "pos", r),
            i(np, c + ".quaternion", u, "rot", r),
            i(Em, c + ".scale", u, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, o, r, n);
  }
  resetDuration() {
    let e = this.tracks,
      t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      let s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    let e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function zF(e) {
  switch (e.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Mm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Em;
    case "color":
      return MC;
    case "quaternion":
      return np;
    case "bool":
    case "boolean":
      return ou;
    case "string":
      return lu;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
}
function FF(e) {
  if (e.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  let t = zF(e.type);
  if (e.times === void 0) {
    let i = [],
      r = [];
    SC(e.keys, i, r, "value"), (e.times = i), (e.values = r);
  }
  return t.parse !== void 0
    ? t.parse(e)
    : new t(e.name, e.times, e.values, e.interpolation);
}
var Cm = {
    enabled: !1,
    files: {},
    add: function (e, t) {
      this.enabled !== !1 && (this.files[e] = t);
    },
    get: function (e) {
      if (this.enabled !== !1) return this.files[e];
    },
    remove: function (e) {
      delete this.files[e];
    },
    clear: function () {
      this.files = {};
    },
  },
  EC = class {
    constructor(e, t, i) {
      let r = this,
        s = !1,
        a = 0,
        n = 0,
        o,
        l = [];
      (this.onStart = void 0),
        (this.onLoad = e),
        (this.onProgress = t),
        (this.onError = i),
        (this.itemStart = function (h) {
          n++, s === !1 && r.onStart !== void 0 && r.onStart(h, a, n), (s = !0);
        }),
        (this.itemEnd = function (h) {
          a++,
            r.onProgress !== void 0 && r.onProgress(h, a, n),
            a === n && ((s = !1), r.onLoad !== void 0 && r.onLoad());
        }),
        (this.itemError = function (h) {
          r.onError !== void 0 && r.onError(h);
        }),
        (this.resolveURL = function (h) {
          return o ? o(h) : h;
        }),
        (this.setURLModifier = function (h) {
          return (o = h), this;
        }),
        (this.addHandler = function (h, u) {
          return l.push(h, u), this;
        }),
        (this.removeHandler = function (h) {
          let u = l.indexOf(h);
          return u !== -1 && l.splice(u, 2), this;
        }),
        (this.getHandler = function (h) {
          for (let u = 0, c = l.length; u < c; u += 2) {
            let d = l[u],
              p = l[u + 1];
            if ((d.global && (d.lastIndex = 0), d.test(h))) return p;
          }
          return null;
        });
    }
  },
  kF = new EC(),
  op = class {
    constructor(e) {
      (this.manager = e !== void 0 ? e : kF),
        (this.crossOrigin = "anonymous"),
        (this.withCredentials = !1),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    load() {}
    loadAsync(e, t) {
      let i = this;
      return new Promise(function (r, s) {
        i.load(e, r, t, s);
      });
    }
    parse() {}
    setCrossOrigin(e) {
      return (this.crossOrigin = e), this;
    }
    setWithCredentials(e) {
      return (this.withCredentials = e), this;
    }
    setPath(e) {
      return (this.path = e), this;
    }
    setResourcePath(e) {
      return (this.resourcePath = e), this;
    }
    setRequestHeader(e) {
      return (this.requestHeader = e), this;
    }
  },
  Zn = {},
  NF = class extends Error {
    constructor(e, t) {
      super(e), (this.response = t);
    }
  },
  _y = class extends op {
    constructor(e) {
      super(e);
    }
    load(e, t, i, r) {
      e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      let s = Cm.get(e);
      if (s !== void 0)
        return (
          this.manager.itemStart(e),
          setTimeout(() => {
            t && t(s), this.manager.itemEnd(e);
          }, 0),
          s
        );
      if (Zn[e] !== void 0) {
        Zn[e].push({ onLoad: t, onProgress: i, onError: r });
        return;
      }
      (Zn[e] = []), Zn[e].push({ onLoad: t, onProgress: i, onError: r });
      let a = new Request(e, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        n = this.mimeType,
        o = this.responseType;
      fetch(a)
        .then((l) => {
          if (l.status === 200 || l.status === 0) {
            if (
              (l.status === 0 &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
              typeof ReadableStream > "u" ||
                l.body === void 0 ||
                l.body.getReader === void 0)
            )
              return l;
            let h = Zn[e],
              u = l.body.getReader(),
              c =
                l.headers.get("Content-Length") || l.headers.get("X-File-Size"),
              d = c ? parseInt(c) : 0,
              p = d !== 0,
              f = 0,
              m = new ReadableStream({
                start(g) {
                  y();
                  function y() {
                    u.read().then(({ done: x, value: b }) => {
                      if (x) g.close();
                      else {
                        f += b.byteLength;
                        let _ = new ProgressEvent("progress", {
                          lengthComputable: p,
                          loaded: f,
                          total: d,
                        });
                        for (let S = 0, M = h.length; S < M; S++) {
                          let C = h[S];
                          C.onProgress && C.onProgress(_);
                        }
                        g.enqueue(b), y();
                      }
                    });
                  }
                },
              });
            return new Response(m);
          } else
            throw new NF(
              `fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`,
              l
            );
        })
        .then((l) => {
          switch (o) {
            case "arraybuffer":
              return l.arrayBuffer();
            case "blob":
              return l.blob();
            case "document":
              return l
                .text()
                .then((h) => new DOMParser().parseFromString(h, n));
            case "json":
              return l.json();
            default:
              if (n === void 0) return l.text();
              {
                let h = /charset="?([^;"\s]*)"?/i.exec(n),
                  u = h && h[1] ? h[1].toLowerCase() : void 0,
                  c = new TextDecoder(u);
                return l.arrayBuffer().then((d) => c.decode(d));
              }
          }
        })
        .then((l) => {
          Cm.add(e, l);
          let h = Zn[e];
          delete Zn[e];
          for (let u = 0, c = h.length; u < c; u++) {
            let d = h[u];
            d.onLoad && d.onLoad(l);
          }
        })
        .catch((l) => {
          let h = Zn[e];
          if (h === void 0) throw (this.manager.itemError(e), l);
          delete Zn[e];
          for (let u = 0, c = h.length; u < c; u++) {
            let d = h[u];
            d.onError && d.onError(l);
          }
          this.manager.itemError(e);
        })
        .finally(() => {
          this.manager.itemEnd(e);
        }),
        this.manager.itemStart(e);
    }
    setResponseType(e) {
      return (this.responseType = e), this;
    }
    setMimeType(e) {
      return (this.mimeType = e), this;
    }
  },
  UF = class extends op {
    constructor(e) {
      super(e);
    }
    load(e, t, i, r) {
      this.path !== void 0 && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      let s = this,
        a = Cm.get(e);
      if (a !== void 0)
        return (
          s.manager.itemStart(e),
          setTimeout(function () {
            t && t(a), s.manager.itemEnd(e);
          }, 0),
          a
        );
      let n = Rd("img");
      function o() {
        h(), Cm.add(e, this), t && t(this), s.manager.itemEnd(e);
      }
      function l(u) {
        h(), r && r(u), s.manager.itemError(e), s.manager.itemEnd(e);
      }
      function h() {
        n.removeEventListener("load", o, !1),
          n.removeEventListener("error", l, !1);
      }
      return (
        n.addEventListener("load", o, !1),
        n.addEventListener("error", l, !1),
        e.slice(0, 5) !== "data:" &&
          this.crossOrigin !== void 0 &&
          (n.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        (n.src = e),
        n
      );
    }
  },
  VF = class extends op {
    constructor(e) {
      super(e);
    }
    load(e, t, i, r) {
      let s = new Yi(),
        a = new UF(this.manager);
      return (
        a.setCrossOrigin(this.crossOrigin),
        a.setPath(this.path),
        a.load(
          e,
          function (n) {
            (s.image = n), (s.needsUpdate = !0), t !== void 0 && t(s);
          },
          i,
          r
        ),
        s
      );
    }
  },
  lp = class extends _i {
    constructor(e, t = 1) {
      super(),
        (this.isLight = !0),
        (this.type = "Light"),
        (this.color = new Et(e)),
        (this.intensity = t);
    }
    dispose() {}
    copy(e, t) {
      return (
        super.copy(e, t),
        this.color.copy(e.color),
        (this.intensity = e.intensity),
        this
      );
    }
    toJSON(e) {
      let t = super.toJSON(e);
      return (
        (t.object.color = this.color.getHex()),
        (t.object.intensity = this.intensity),
        this.groundColor !== void 0 &&
          (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
      );
    }
  },
  jF = class extends lp {
    constructor(e, t, i) {
      super(e, i),
        (this.isHemisphereLight = !0),
        (this.type = "HemisphereLight"),
        this.position.copy(_i.DEFAULT_UP),
        this.updateMatrix(),
        (this.groundColor = new Et(t));
    }
    copy(e, t) {
      return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
    }
  },
  Vv = new je(),
  oS = new I(),
  lS = new I(),
  Tx = class {
    constructor(e) {
      (this.camera = e),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new re(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new je()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new xx()),
        (this._frameExtents = new re(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new Lt(0, 0, 1, 1)]);
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e) {
      let t = this.camera,
        i = this.matrix;
      oS.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(oS),
        lS.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(lS),
        t.updateMatrixWorld(),
        Vv.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Vv),
        i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        i.multiply(Vv);
    }
    getViewport(e) {
      return this._viewports[e];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
      return (
        (this.camera = e.camera.clone()),
        (this.bias = e.bias),
        (this.radius = e.radius),
        this.mapSize.copy(e.mapSize),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      let e = {};
      return (
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
          (e.mapSize = this.mapSize.toArray()),
        (e.camera = this.camera.toJSON(!1).object),
        delete e.camera.matrix,
        e
      );
    }
  },
  HF = class extends Tx {
    constructor() {
      super(new ds(50, 1, 0.5, 500)),
        (this.isSpotLightShadow = !0),
        (this.focus = 1);
    }
    updateMatrices(e) {
      let t = this.camera,
        i = Id * 2 * e.angle * this.focus,
        r = this.mapSize.width / this.mapSize.height,
        s = e.distance || t.far;
      (i !== t.fov || r !== t.aspect || s !== t.far) &&
        ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
        super.updateMatrices(e);
    }
    copy(e) {
      return super.copy(e), (this.focus = e.focus), this;
    }
  },
  GF = class extends lp {
    constructor(e, t, i = 0, r = Math.PI / 3, s = 0, a = 2) {
      super(e, t),
        (this.isSpotLight = !0),
        (this.type = "SpotLight"),
        this.position.copy(_i.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new _i()),
        (this.distance = i),
        (this.angle = r),
        (this.penumbra = s),
        (this.decay = a),
        (this.map = null),
        (this.shadow = new HF());
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.distance = e.distance),
        (this.angle = e.angle),
        (this.penumbra = e.penumbra),
        (this.decay = e.decay),
        (this.target = e.target.clone()),
        (this.shadow = e.shadow.clone()),
        this
      );
    }
  },
  hS = new je(),
  Vu = new I(),
  jv = new I(),
  WF = class extends Tx {
    constructor() {
      super(new ds(90, 1, 0.5, 500)),
        (this.isPointLightShadow = !0),
        (this._frameExtents = new re(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new Lt(2, 1, 1, 1),
          new Lt(0, 1, 1, 1),
          new Lt(3, 1, 1, 1),
          new Lt(1, 1, 1, 1),
          new Lt(3, 0, 1, 1),
          new Lt(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new I(1, 0, 0),
          new I(-1, 0, 0),
          new I(0, 0, 1),
          new I(0, 0, -1),
          new I(0, 1, 0),
          new I(0, -1, 0),
        ]),
        (this._cubeUps = [
          new I(0, 1, 0),
          new I(0, 1, 0),
          new I(0, 1, 0),
          new I(0, 1, 0),
          new I(0, 0, 1),
          new I(0, 0, -1),
        ]);
    }
    updateMatrices(e, t = 0) {
      let i = this.camera,
        r = this.matrix,
        s = e.distance || i.far;
      s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
        Vu.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(Vu),
        jv.copy(i.position),
        jv.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(jv),
        i.updateMatrixWorld(),
        r.makeTranslation(-Vu.x, -Vu.y, -Vu.z),
        hS.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(hS);
    }
  },
  qF = class extends lp {
    constructor(e, t, i = 0, r = 2) {
      super(e, t),
        (this.isPointLight = !0),
        (this.type = "PointLight"),
        (this.distance = i),
        (this.decay = r),
        (this.shadow = new WF());
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(e) {
      this.intensity = e / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.distance = e.distance),
        (this.decay = e.decay),
        (this.shadow = e.shadow.clone()),
        this
      );
    }
  },
  YF = class extends Tx {
    constructor() {
      super(new bx(-5, 5, 5, -5, 0.5, 500)),
        (this.isDirectionalLightShadow = !0);
    }
  },
  XF = class extends lp {
    constructor(e, t) {
      super(e, t),
        (this.isDirectionalLight = !0),
        (this.type = "DirectionalLight"),
        this.position.copy(_i.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new _i()),
        (this.shadow = new YF());
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e) {
      return (
        super.copy(e),
        (this.target = e.target.clone()),
        (this.shadow = e.shadow.clone()),
        this
      );
    }
  },
  CC = class extends yt {
    constructor() {
      super(),
        (this.isInstancedBufferGeometry = !0),
        (this.type = "InstancedBufferGeometry"),
        (this.instanceCount = 1 / 0);
    }
    copy(e) {
      return super.copy(e), (this.instanceCount = e.instanceCount), this;
    }
    toJSON() {
      let e = super.toJSON();
      return (
        (e.instanceCount = this.instanceCount),
        (e.isInstancedBufferGeometry = !0),
        e
      );
    }
  },
  TC = class extends op {
    constructor(e) {
      super(e);
    }
    load(e, t, i, r) {
      let s = this,
        a = new _y(s.manager);
      a.setPath(s.path),
        a.setRequestHeader(s.requestHeader),
        a.setWithCredentials(s.withCredentials),
        a.load(
          e,
          function (n) {
            try {
              t(s.parse(JSON.parse(n)));
            } catch (o) {
              r ? r(o) : console.error(o), s.manager.itemError(e);
            }
          },
          i,
          r
        );
    }
    parse(e) {
      let t = {},
        i = {};
      function r(c, d) {
        if (t[d] !== void 0) return t[d];
        let p = c.interleavedBuffers[d],
          f = s(c, p.buffer),
          m = Rp(p.type, f),
          g = new Jz(m, p.stride);
        return (g.uuid = p.uuid), (t[d] = g), g;
      }
      function s(c, d) {
        if (i[d] !== void 0) return i[d];
        let p = c.arrayBuffers[d],
          f = new Uint32Array(p).buffer;
        return (i[d] = f), f;
      }
      let a = e.isInstancedBufferGeometry ? new CC() : new yt(),
        n = e.data.index;
      if (n !== void 0) {
        let c = Rp(n.type, n.array);
        a.setIndex(new It(c, 1));
      }
      let o = e.data.attributes;
      for (let c in o) {
        let d = o[c],
          p;
        if (d.isInterleavedBufferAttribute) {
          let f = r(e.data, d.data);
          p = new yy(f, d.itemSize, d.offset, d.normalized);
        } else {
          let f = Rp(d.type, d.array),
            m = d.isInstancedBufferAttribute ? Ld : It;
          p = new m(f, d.itemSize, d.normalized);
        }
        d.name !== void 0 && (p.name = d.name),
          d.usage !== void 0 && p.setUsage(d.usage),
          d.updateRange !== void 0 &&
            ((p.updateRange.offset = d.updateRange.offset),
            (p.updateRange.count = d.updateRange.count)),
          a.setAttribute(c, p);
      }
      let l = e.data.morphAttributes;
      if (l)
        for (let c in l) {
          let d = l[c],
            p = [];
          for (let f = 0, m = d.length; f < m; f++) {
            let g = d[f],
              y;
            if (g.isInterleavedBufferAttribute) {
              let x = r(e.data, g.data);
              y = new yy(x, g.itemSize, g.offset, g.normalized);
            } else {
              let x = Rp(g.type, g.array);
              y = new It(x, g.itemSize, g.normalized);
            }
            g.name !== void 0 && (y.name = g.name), p.push(y);
          }
          a.morphAttributes[c] = p;
        }
      e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
      let h = e.data.groups || e.data.drawcalls || e.data.offsets;
      if (h !== void 0)
        for (let c = 0, d = h.length; c !== d; ++c) {
          let p = h[c];
          a.addGroup(p.start, p.count, p.materialIndex);
        }
      let u = e.data.boundingSphere;
      if (u !== void 0) {
        let c = new I();
        u.center !== void 0 && c.fromArray(u.center),
          (a.boundingSphere = new Ws(c, u.radius));
      }
      return (
        e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
      );
    }
  },
  QF = class {
    constructor(e = !0) {
      (this.autoStart = e),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = cS()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        let t = cS();
        (e = (t - this.oldTime) / 1e3),
          (this.oldTime = t),
          (this.elapsedTime += e);
      }
      return e;
    }
  };
function cS() {
  return (typeof performance > "u" ? Date : performance).now();
}
var ZF = class {
    constructor(e, t, i) {
      (this.binding = e), (this.valueSize = i);
      let r, s, a;
      switch (t) {
        case "quaternion":
          (r = this._slerp),
            (s = this._slerpAdditive),
            (a = this._setAdditiveIdentityQuaternion),
            (this.buffer = new Float64Array(i * 6)),
            (this._workIndex = 5);
          break;
        case "string":
        case "bool":
          (r = this._select),
            (s = this._select),
            (a = this._setAdditiveIdentityOther),
            (this.buffer = new Array(i * 5));
          break;
        default:
          (r = this._lerp),
            (s = this._lerpAdditive),
            (a = this._setAdditiveIdentityNumeric),
            (this.buffer = new Float64Array(i * 5));
      }
      (this._mixBufferRegion = r),
        (this._mixBufferRegionAdditive = s),
        (this._setIdentity = a),
        (this._origIndex = 3),
        (this._addIndex = 4),
        (this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0),
        (this.useCount = 0),
        (this.referenceCount = 0);
    }
    accumulate(e, t) {
      let i = this.buffer,
        r = this.valueSize,
        s = e * r + r,
        a = this.cumulativeWeight;
      if (a === 0) {
        for (let n = 0; n !== r; ++n) i[s + n] = i[n];
        a = t;
      } else {
        a += t;
        let n = t / a;
        this._mixBufferRegion(i, s, 0, n, r);
      }
      this.cumulativeWeight = a;
    }
    accumulateAdditive(e) {
      let t = this.buffer,
        i = this.valueSize,
        r = i * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        (this.cumulativeWeightAdditive += e);
    }
    apply(e) {
      let t = this.valueSize,
        i = this.buffer,
        r = e * t + t,
        s = this.cumulativeWeight,
        a = this.cumulativeWeightAdditive,
        n = this.binding;
      if (
        ((this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0),
        s < 1)
      ) {
        let o = t * this._origIndex;
        this._mixBufferRegion(i, r, o, 1 - s, t);
      }
      a > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
      for (let o = t, l = t + t; o !== l; ++o)
        if (i[o] !== i[o + t]) {
          n.setValue(i, r);
          break;
        }
    }
    saveOriginalState() {
      let e = this.binding,
        t = this.buffer,
        i = this.valueSize,
        r = i * this._origIndex;
      e.getValue(t, r);
      for (let s = i, a = r; s !== a; ++s) t[s] = t[r + (s % i)];
      this._setIdentity(),
        (this.cumulativeWeight = 0),
        (this.cumulativeWeightAdditive = 0);
    }
    restoreOriginalState() {
      let e = this.valueSize * 3;
      this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
      let e = this._addIndex * this.valueSize,
        t = e + this.valueSize;
      for (let i = e; i < t; i++) this.buffer[i] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(),
        (this.buffer[this._addIndex * this.valueSize + 3] = 1);
    }
    _setAdditiveIdentityOther() {
      let e = this._origIndex * this.valueSize,
        t = this._addIndex * this.valueSize;
      for (let i = 0; i < this.valueSize; i++)
        this.buffer[t + i] = this.buffer[e + i];
    }
    _select(e, t, i, r, s) {
      if (r >= 0.5) for (let a = 0; a !== s; ++a) e[t + a] = e[i + a];
    }
    _slerp(e, t, i, r) {
      Rt.slerpFlat(e, t, e, t, e, i, r);
    }
    _slerpAdditive(e, t, i, r, s) {
      let a = this._workIndex * s;
      Rt.multiplyQuaternionsFlat(e, a, e, t, e, i),
        Rt.slerpFlat(e, t, e, t, e, a, r);
    }
    _lerp(e, t, i, r, s) {
      let a = 1 - r;
      for (let n = 0; n !== s; ++n) {
        let o = t + n;
        e[o] = e[o] * a + e[i + n] * r;
      }
    }
    _lerpAdditive(e, t, i, r, s) {
      for (let a = 0; a !== s; ++a) {
        let n = t + a;
        e[n] = e[n] + e[i + a] * r;
      }
    }
  },
  Px = "\\[\\]\\.:\\/",
  KF = new RegExp("[" + Px + "]", "g"),
  Dx = "[^" + Px + "]",
  JF = "[^" + Px.replace("\\.", "") + "]",
  $F = /((?:WC+[\/:])*)/.source.replace("WC", Dx),
  ek = /(WCOD+)?/.source.replace("WCOD", JF),
  tk = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dx),
  ik = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dx),
  rk = new RegExp("^" + $F + ek + tk + ik + "$"),
  sk = ["material", "materials", "bones", "map"],
  ak = class {
    constructor(e, t, i) {
      let r = i || Di.parseTrackName(t);
      (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
    }
    getValue(e, t) {
      this.bind();
      let i = this._targetGroup.nCachedObjects_,
        r = this._bindings[i];
      r !== void 0 && r.getValue(e, t);
    }
    setValue(e, t) {
      let i = this._bindings;
      for (
        let r = this._targetGroup.nCachedObjects_, s = i.length;
        r !== s;
        ++r
      )
        i[r].setValue(e, t);
    }
    bind() {
      let e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, i = e.length;
        t !== i;
        ++t
      )
        e[t].bind();
    }
    unbind() {
      let e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, i = e.length;
        t !== i;
        ++t
      )
        e[t].unbind();
    }
  },
  Di = class {
    constructor(e, t, i) {
      (this.path = t),
        (this.parsedPath = i || Di.parseTrackName(t)),
        (this.node = Di.findNode(e, this.parsedPath.nodeName) || e),
        (this.rootNode = e),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(e, t, i) {
      return e && e.isAnimationObjectGroup
        ? new Di.Composite(e, t, i)
        : new Di(e, t, i);
    }
    static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(KF, "");
    }
    static parseTrackName(e) {
      let t = rk.exec(e);
      if (t === null)
        throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      let i = {
          nodeName: t[2],
          objectName: t[3],
          objectIndex: t[4],
          propertyName: t[5],
          propertyIndex: t[6],
        },
        r = i.nodeName && i.nodeName.lastIndexOf(".");
      if (r !== void 0 && r !== -1) {
        let s = i.nodeName.substring(r + 1);
        sk.indexOf(s) !== -1 &&
          ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
      }
      if (i.propertyName === null || i.propertyName.length === 0)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + e
        );
      return i;
    }
    static findNode(e, t) {
      if (
        t === void 0 ||
        t === "" ||
        t === "." ||
        t === -1 ||
        t === e.name ||
        t === e.uuid
      )
        return e;
      if (e.skeleton) {
        let i = e.skeleton.getBoneByName(t);
        if (i !== void 0) return i;
      }
      if (e.children) {
        let i = function (s) {
            for (let a = 0; a < s.length; a++) {
              let n = s[a];
              if (n.name === t || n.uuid === t) return n;
              let o = i(n.children);
              if (o) return o;
            }
            return null;
          },
          r = i(e.children);
        if (r) return r;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
      let i = this.resolvedProperty;
      for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
    }
    _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
      (this.targetObject[this.propertyName] = e[t]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      (this.targetObject[this.propertyName] = e[t]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(e, t) {
      let i = this.resolvedProperty;
      for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
      let i = this.resolvedProperty;
      for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      let i = this.resolvedProperty;
      for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
      (this.resolvedProperty[this.propertyIndex] = e[t]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      (this.resolvedProperty[this.propertyIndex] = e[t]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t);
    }
    bind() {
      let e = this.node,
        t = this.parsedPath,
        i = t.objectName,
        r = t.propertyName,
        s = t.propertyIndex;
      if (
        (e ||
          ((e = Di.findNode(this.rootNode, t.nodeName) || this.rootNode),
          (this.node = e)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !e)
      ) {
        console.error(
          "THREE.PropertyBinding: Trying to update node for track: " +
            this.path +
            " but it wasn't found."
        );
        return;
      }
      if (i) {
        let l = t.objectIndex;
        switch (i) {
          case "materials":
            if (!e.material) {
              console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
              return;
            }
            if (!e.material.materials) {
              console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
              return;
            }
            e = e.material.materials;
            break;
          case "bones":
            if (!e.skeleton) {
              console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
              return;
            }
            e = e.skeleton.bones;
            for (let h = 0; h < e.length; h++)
              if (e[h].name === l) {
                l = h;
                break;
              }
            break;
          case "map":
            if ("map" in e) {
              e = e.map;
              break;
            }
            if (!e.material) {
              console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
              return;
            }
            if (!e.material.map) {
              console.error(
                "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                this
              );
              return;
            }
            e = e.material.map;
            break;
          default:
            if (e[i] === void 0) {
              console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
              return;
            }
            e = e[i];
        }
        if (l !== void 0) {
          if (e[l] === void 0) {
            console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              e
            );
            return;
          }
          e = e[l];
        }
      }
      let a = e[r];
      if (a === void 0) {
        let l = t.nodeName;
        console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            l +
            "." +
            r +
            " but it wasn't found.",
          e
        );
        return;
      }
      let n = this.Versioning.None;
      (this.targetObject = e),
        e.needsUpdate !== void 0
          ? (n = this.Versioning.NeedsUpdate)
          : e.matrixWorldNeedsUpdate !== void 0 &&
            (n = this.Versioning.MatrixWorldNeedsUpdate);
      let o = this.BindingType.Direct;
      if (s !== void 0) {
        if (r === "morphTargetInfluences") {
          if (!e.geometry) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
            return;
          }
          if (!e.geometry.morphAttributes) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
            return;
          }
          e.morphTargetDictionary[s] !== void 0 &&
            (s = e.morphTargetDictionary[s]);
        }
        (o = this.BindingType.ArrayElement),
          (this.resolvedProperty = a),
          (this.propertyIndex = s);
      } else
        a.fromArray !== void 0 && a.toArray !== void 0
          ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
          : Array.isArray(a)
          ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = a))
          : (this.propertyName = r);
      (this.getValue = this.GetterByBindingType[o]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[o][n]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  };
Di.Composite = ak;
Di.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Di.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Di.prototype.GetterByBindingType = [
  Di.prototype._getValue_direct,
  Di.prototype._getValue_array,
  Di.prototype._getValue_arrayElement,
  Di.prototype._getValue_toArray,
];
Di.prototype.SetterByBindingTypeAndVersioning = [
  [
    Di.prototype._setValue_direct,
    Di.prototype._setValue_direct_setNeedsUpdate,
    Di.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Di.prototype._setValue_array,
    Di.prototype._setValue_array_setNeedsUpdate,
    Di.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Di.prototype._setValue_arrayElement,
    Di.prototype._setValue_arrayElement_setNeedsUpdate,
    Di.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Di.prototype._setValue_fromArray,
    Di.prototype._setValue_fromArray_setNeedsUpdate,
    Di.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
var nk = class {
    constructor(e, t, i = null, r = t.blendMode) {
      (this._mixer = e),
        (this._clip = t),
        (this._localRoot = i),
        (this.blendMode = r);
      let s = t.tracks,
        a = s.length,
        n = new Array(a),
        o = { endingStart: xc, endingEnd: xc };
      for (let l = 0; l !== a; ++l) {
        let h = s[l].createInterpolant(null);
        (n[l] = h), (h.settings = o);
      }
      (this._interpolantSettings = o),
        (this._interpolants = n),
        (this._propertyBindings = new Array(a)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = qE),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return (
        (this.paused = !1),
        (this.enabled = !0),
        (this.time = 0),
        (this._loopCount = -1),
        (this._startTime = null),
        this.stopFading().stopWarping()
      );
    }
    isRunning() {
      return (
        this.enabled &&
        !this.paused &&
        this.timeScale !== 0 &&
        this._startTime === null &&
        this._mixer._isActiveAction(this)
      );
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e) {
      return (this._startTime = e), this;
    }
    setLoop(e, t) {
      return (this.loop = e), (this.repetitions = t), this;
    }
    setEffectiveWeight(e) {
      return (
        (this.weight = e),
        (this._effectiveWeight = this.enabled ? e : 0),
        this.stopFading()
      );
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e) {
      return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
      return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, i) {
      if ((e.fadeOut(t), this.fadeIn(t), i)) {
        let r = this._clip.duration,
          s = e._clip.duration,
          a = s / r,
          n = r / s;
        e.warp(1, a, t), this.warp(n, 1, t);
      }
      return this;
    }
    crossFadeTo(e, t, i) {
      return e.crossFadeFrom(this, t, i);
    }
    stopFading() {
      let e = this._weightInterpolant;
      return (
        e !== null &&
          ((this._weightInterpolant = null),
          this._mixer._takeBackControlInterpolant(e)),
        this
      );
    }
    setEffectiveTimeScale(e) {
      return (
        (this.timeScale = e),
        (this._effectiveTimeScale = this.paused ? 0 : e),
        this.stopWarping()
      );
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e) {
      return (this.timeScale = this._clip.duration / e), this.stopWarping();
    }
    syncWith(e) {
      return (
        (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
      );
    }
    halt(e) {
      return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, i) {
      let r = this._mixer,
        s = r.time,
        a = this.timeScale,
        n = this._timeScaleInterpolant;
      n === null &&
        ((n = r._lendControlInterpolant()), (this._timeScaleInterpolant = n));
      let o = n.parameterPositions,
        l = n.sampleValues;
      return (o[0] = s), (o[1] = s + i), (l[0] = e / a), (l[1] = t / a), this;
    }
    stopWarping() {
      let e = this._timeScaleInterpolant;
      return (
        e !== null &&
          ((this._timeScaleInterpolant = null),
          this._mixer._takeBackControlInterpolant(e)),
        this
      );
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e, t, i, r) {
      if (!this.enabled) {
        this._updateWeight(e);
        return;
      }
      let s = this._startTime;
      if (s !== null) {
        let o = (e - s) * i;
        o < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * o));
      }
      t *= this._updateTimeScale(e);
      let a = this._updateTime(t),
        n = this._updateWeight(e);
      if (n > 0) {
        let o = this._interpolants,
          l = this._propertyBindings;
        switch (this.blendMode) {
          case zI:
            for (let h = 0, u = o.length; h !== u; ++h)
              o[h].evaluate(a), l[h].accumulateAdditive(n);
            break;
          case mx:
          default:
            for (let h = 0, u = o.length; h !== u; ++h)
              o[h].evaluate(a), l[h].accumulate(r, n);
        }
      }
    }
    _updateWeight(e) {
      let t = 0;
      if (this.enabled) {
        t = this.weight;
        let i = this._weightInterpolant;
        if (i !== null) {
          let r = i.evaluate(e)[0];
          (t *= r),
            e > i.parameterPositions[1] &&
              (this.stopFading(), r === 0 && (this.enabled = !1));
        }
      }
      return (this._effectiveWeight = t), t;
    }
    _updateTimeScale(e) {
      let t = 0;
      if (!this.paused) {
        t = this.timeScale;
        let i = this._timeScaleInterpolant;
        if (i !== null) {
          let r = i.evaluate(e)[0];
          (t *= r),
            e > i.parameterPositions[1] &&
              (this.stopWarping(),
              t === 0 ? (this.paused = !0) : (this.timeScale = t));
        }
      }
      return (this._effectiveTimeScale = t), t;
    }
    _updateTime(e) {
      let t = this._clip.duration,
        i = this.loop,
        r = this.time + e,
        s = this._loopCount,
        a = i === fx;
      if (e === 0) return s === -1 ? r : a && (s & 1) === 1 ? t - r : r;
      if (i === WE) {
        s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
        e: {
          if (r >= t) r = t;
          else if (r < 0) r = 0;
          else {
            this.time = r;
            break e;
          }
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e < 0 ? -1 : 1,
            });
        }
      } else {
        if (
          (s === -1 &&
            (e >= 0
              ? ((s = 0), this._setEndings(!0, this.repetitions === 0, a))
              : this._setEndings(this.repetitions === 0, !0, a)),
          r >= t || r < 0)
        ) {
          let n = Math.floor(r / t);
          (r -= t * n), (s += Math.abs(n));
          let o = this.repetitions - s;
          if (o <= 0)
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (r = e > 0 ? t : 0),
              (this.time = r),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e > 0 ? 1 : -1,
              });
          else {
            if (o === 1) {
              let l = e < 0;
              this._setEndings(l, !l, a);
            } else this._setEndings(!1, !1, a);
            (this._loopCount = s),
              (this.time = r),
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: n,
              });
          }
        } else this.time = r;
        if (a && (s & 1) === 1) return t - r;
      }
      return r;
    }
    _setEndings(e, t, i) {
      let r = this._interpolantSettings;
      i
        ? ((r.endingStart = bc), (r.endingEnd = bc))
        : (e
            ? (r.endingStart = this.zeroSlopeAtStart ? bc : xc)
            : (r.endingStart = xm),
          t
            ? (r.endingEnd = this.zeroSlopeAtEnd ? bc : xc)
            : (r.endingEnd = xm));
    }
    _scheduleFading(e, t, i) {
      let r = this._mixer,
        s = r.time,
        a = this._weightInterpolant;
      a === null &&
        ((a = r._lendControlInterpolant()), (this._weightInterpolant = a));
      let n = a.parameterPositions,
        o = a.sampleValues;
      return (n[0] = s), (o[0] = t), (n[1] = s + e), (o[1] = i), this;
    }
  },
  ok = new Float32Array(1),
  lk = class extends ls {
    constructor(e) {
      super(),
        (this._root = e),
        this._initMemoryManager(),
        (this._accuIndex = 0),
        (this.time = 0),
        (this.timeScale = 1);
    }
    _bindAction(e, t) {
      let i = e._localRoot || this._root,
        r = e._clip.tracks,
        s = r.length,
        a = e._propertyBindings,
        n = e._interpolants,
        o = i.uuid,
        l = this._bindingsByRootAndName,
        h = l[o];
      h === void 0 && ((h = {}), (l[o] = h));
      for (let u = 0; u !== s; ++u) {
        let c = r[u],
          d = c.name,
          p = h[d];
        if (p !== void 0) ++p.referenceCount, (a[u] = p);
        else {
          if (((p = a[u]), p !== void 0)) {
            p._cacheIndex === null &&
              (++p.referenceCount, this._addInactiveBinding(p, o, d));
            continue;
          }
          let f = t && t._propertyBindings[u].binding.parsedPath;
          (p = new ZF(Di.create(i, d, f), c.ValueTypeName, c.getValueSize())),
            ++p.referenceCount,
            this._addInactiveBinding(p, o, d),
            (a[u] = p);
        }
        n[u].resultBuffer = p.buffer;
      }
    }
    _activateAction(e) {
      if (!this._isActiveAction(e)) {
        if (e._cacheIndex === null) {
          let i = (e._localRoot || this._root).uuid,
            r = e._clip.uuid,
            s = this._actionsByClip[r];
          this._bindAction(e, s && s.knownActions[0]),
            this._addInactiveAction(e, r, i);
        }
        let t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
          let s = t[i];
          s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
        }
        this._lendAction(e);
      }
    }
    _deactivateAction(e) {
      if (this._isActiveAction(e)) {
        let t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
          let s = t[i];
          --s.useCount === 0 &&
            (s.restoreOriginalState(), this._takeBackBinding(s));
        }
        this._takeBackAction(e);
      }
    }
    _initMemoryManager() {
      (this._actions = []),
        (this._nActiveActions = 0),
        (this._actionsByClip = {}),
        (this._bindings = []),
        (this._nActiveBindings = 0),
        (this._bindingsByRootAndName = {}),
        (this._controlInterpolants = []),
        (this._nActiveControlInterpolants = 0);
      let e = this;
      this.stats = {
        actions: {
          get total() {
            return e._actions.length;
          },
          get inUse() {
            return e._nActiveActions;
          },
        },
        bindings: {
          get total() {
            return e._bindings.length;
          },
          get inUse() {
            return e._nActiveBindings;
          },
        },
        controlInterpolants: {
          get total() {
            return e._controlInterpolants.length;
          },
          get inUse() {
            return e._nActiveControlInterpolants;
          },
        },
      };
    }
    _isActiveAction(e) {
      let t = e._cacheIndex;
      return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, i) {
      let r = this._actions,
        s = this._actionsByClip,
        a = s[t];
      if (a === void 0)
        (a = { knownActions: [e], actionByRoot: {} }),
          (e._byClipCacheIndex = 0),
          (s[t] = a);
      else {
        let n = a.knownActions;
        (e._byClipCacheIndex = n.length), n.push(e);
      }
      (e._cacheIndex = r.length), r.push(e), (a.actionByRoot[i] = e);
    }
    _removeInactiveAction(e) {
      let t = this._actions,
        i = t[t.length - 1],
        r = e._cacheIndex;
      (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
      let s = e._clip.uuid,
        a = this._actionsByClip,
        n = a[s],
        o = n.knownActions,
        l = o[o.length - 1],
        h = e._byClipCacheIndex;
      (l._byClipCacheIndex = h),
        (o[h] = l),
        o.pop(),
        (e._byClipCacheIndex = null);
      let u = n.actionByRoot,
        c = (e._localRoot || this._root).uuid;
      delete u[c],
        o.length === 0 && delete a[s],
        this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
      let t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        let s = t[i];
        --s.referenceCount === 0 && this._removeInactiveBinding(s);
      }
    }
    _lendAction(e) {
      let t = this._actions,
        i = e._cacheIndex,
        r = this._nActiveActions++,
        s = t[r];
      (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _takeBackAction(e) {
      let t = this._actions,
        i = e._cacheIndex,
        r = --this._nActiveActions,
        s = t[r];
      (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _addInactiveBinding(e, t, i) {
      let r = this._bindingsByRootAndName,
        s = this._bindings,
        a = r[t];
      a === void 0 && ((a = {}), (r[t] = a)),
        (a[i] = e),
        (e._cacheIndex = s.length),
        s.push(e);
    }
    _removeInactiveBinding(e) {
      let t = this._bindings,
        i = e.binding,
        r = i.rootNode.uuid,
        s = i.path,
        a = this._bindingsByRootAndName,
        n = a[r],
        o = t[t.length - 1],
        l = e._cacheIndex;
      (o._cacheIndex = l),
        (t[l] = o),
        t.pop(),
        delete n[s],
        Object.keys(n).length === 0 && delete a[r];
    }
    _lendBinding(e) {
      let t = this._bindings,
        i = e._cacheIndex,
        r = this._nActiveBindings++,
        s = t[r];
      (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _takeBackBinding(e) {
      let t = this._bindings,
        i = e._cacheIndex,
        r = --this._nActiveBindings,
        s = t[r];
      (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
    }
    _lendControlInterpolant() {
      let e = this._controlInterpolants,
        t = this._nActiveControlInterpolants++,
        i = e[t];
      return (
        i === void 0 &&
          ((i = new AC(new Float32Array(2), new Float32Array(2), 1, ok)),
          (i.__cacheIndex = t),
          (e[t] = i)),
        i
      );
    }
    _takeBackControlInterpolant(e) {
      let t = this._controlInterpolants,
        i = e.__cacheIndex,
        r = --this._nActiveControlInterpolants,
        s = t[r];
      (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
    }
    clipAction(e, t, i) {
      let r = t || this._root,
        s = r.uuid,
        a = typeof e == "string" ? wy.findByName(r, e) : e,
        n = a !== null ? a.uuid : e,
        o = this._actionsByClip[n],
        l = null;
      if (
        (i === void 0 && (a !== null ? (i = a.blendMode) : (i = mx)),
        o !== void 0)
      ) {
        let u = o.actionByRoot[s];
        if (u !== void 0 && u.blendMode === i) return u;
        (l = o.knownActions[0]), a === null && (a = l._clip);
      }
      if (a === null) return null;
      let h = new nk(this, a, t, i);
      return this._bindAction(h, l), this._addInactiveAction(h, n, s), h;
    }
    existingAction(e, t) {
      let i = t || this._root,
        r = i.uuid,
        s = typeof e == "string" ? wy.findByName(i, e) : e,
        a = s ? s.uuid : e,
        n = this._actionsByClip[a];
      return (n !== void 0 && n.actionByRoot[r]) || null;
    }
    stopAllAction() {
      let e = this._actions,
        t = this._nActiveActions;
      for (let i = t - 1; i >= 0; --i) e[i].stop();
      return this;
    }
    update(e) {
      e *= this.timeScale;
      let t = this._actions,
        i = this._nActiveActions,
        r = (this.time += e),
        s = Math.sign(e),
        a = (this._accuIndex ^= 1);
      for (let l = 0; l !== i; ++l) t[l]._update(r, e, s, a);
      let n = this._bindings,
        o = this._nActiveBindings;
      for (let l = 0; l !== o; ++l) n[l].apply(a);
      return this;
    }
    setTime(e) {
      this.time = 0;
      for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
      return this.update(e);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e) {
      let t = this._actions,
        i = e.uuid,
        r = this._actionsByClip,
        s = r[i];
      if (s !== void 0) {
        let a = s.knownActions;
        for (let n = 0, o = a.length; n !== o; ++n) {
          let l = a[n];
          this._deactivateAction(l);
          let h = l._cacheIndex,
            u = t[t.length - 1];
          (l._cacheIndex = null),
            (l._byClipCacheIndex = null),
            (u._cacheIndex = h),
            (t[h] = u),
            t.pop(),
            this._removeInactiveBindingsForAction(l);
        }
        delete r[i];
      }
    }
    uncacheRoot(e) {
      let t = e.uuid,
        i = this._actionsByClip;
      for (let a in i) {
        let n = i[a].actionByRoot,
          o = n[t];
        o !== void 0 &&
          (this._deactivateAction(o), this._removeInactiveAction(o));
      }
      let r = this._bindingsByRootAndName,
        s = r[t];
      if (s !== void 0)
        for (let a in s) {
          let n = s[a];
          n.restoreOriginalState(), this._removeInactiveBinding(n);
        }
    }
    uncacheAction(e, t) {
      let i = this.existingAction(e, t);
      i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
    }
  },
  Ve = class {
    constructor(e) {
      this.value = e;
    }
    clone() {
      return new Ve(
        this.value.clone === void 0 ? this.value : this.value.clone()
      );
    }
  },
  PC = class {
    constructor(e, t, i = 0, r = 1 / 0) {
      (this.ray = new su(e, t)),
        (this.near = i),
        (this.far = r),
        (this.camera = null),
        (this.layers = new vx()),
        (this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {},
        });
    }
    set(e, t) {
      this.ray.set(e, t);
    }
    setFromCamera(e, t) {
      t.isPerspectiveCamera
        ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
          this.ray.direction
            .set(e.x, e.y, 0.5)
            .unproject(t)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = t))
        : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    intersectObject(e, t = !0, i = []) {
      return Sy(e, this, i, t), i.sort(uS), i;
    }
    intersectObjects(e, t = !0, i = []) {
      for (let r = 0, s = e.length; r < s; r++) Sy(e[r], this, i, t);
      return i.sort(uS), i;
    }
  };
function uS(e, t) {
  return e.distance - t.distance;
}
function Sy(e, t, i, r) {
  if ((e.layers.test(t.layers) && e.raycast(t, i), r === !0)) {
    let s = e.children;
    for (let a = 0, n = s.length; a < n; a++) Sy(s[a], t, i, !0);
  }
}
var dS = class {
    constructor(e = 1, t = 0, i = 0) {
      return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    set(e, t, i) {
      return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    copy(e) {
      return (
        (this.radius = e.radius),
        (this.phi = e.phi),
        (this.theta = e.theta),
        this
      );
    }
    makeSafe() {
      return (
        (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
      );
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, i) {
      return (
        (this.radius = Math.sqrt(e * e + t * t + i * i)),
        this.radius === 0
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(e, i)),
            (this.phi = Math.acos(vr(t / this.radius, -1, 1)))),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  pS = new re(),
  DC = class {
    constructor(e = new re(1 / 0, 1 / 0), t = new re(-1 / 0, -1 / 0)) {
      (this.isBox2 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      let i = pS.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = 1 / 0),
        (this.max.x = this.max.y = -1 / 0),
        this
      );
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
      return this.isEmpty()
        ? e.set(0, 0)
        : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
      return !(
        e.x < this.min.x ||
        e.x > this.max.x ||
        e.y < this.min.y ||
        e.y > this.max.y
      );
    }
    containsBox(e) {
      return (
        this.min.x <= e.min.x &&
        e.max.x <= this.max.x &&
        this.min.y <= e.min.y &&
        e.max.y <= this.max.y
      );
    }
    getParameter(e, t) {
      return t.set(
        (e.x - this.min.x) / (this.max.x - this.min.x),
        (e.y - this.min.y) / (this.max.y - this.min.y)
      );
    }
    intersectsBox(e) {
      return !(
        e.max.x < this.min.x ||
        e.min.x > this.max.x ||
        e.max.y < this.min.y ||
        e.min.y > this.max.y
      );
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return pS.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  },
  fS = new I(),
  af = new I(),
  Ma = class {
    constructor(e = new I(), t = new I()) {
      (this.start = e), (this.end = t);
    }
    set(e, t) {
      return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
      return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
      return e.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e) {
      return e.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(e, t) {
      return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
      fS.subVectors(e, this.start), af.subVectors(this.end, this.start);
      let i = af.dot(af),
        r = af.dot(fS) / i;
      return t && (r = vr(r, 0, 1)), r;
    }
    closestPointToPoint(e, t, i) {
      let r = this.closestPointToPointParameter(e, t);
      return this.delta(i).multiplyScalar(r).add(this.start);
    }
    applyMatrix4(e) {
      return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
      return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  },
  mS = new I(),
  hk = class extends _i {
    constructor(e, t) {
      super(),
        (this.light = e),
        (this.matrix = e.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = t),
        (this.type = "SpotLightHelper");
      let i = new yt(),
        r = [
          0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1,
          1, 0, 0, 0, 0, -1, 1,
        ];
      for (let a = 0, n = 1, o = 32; a < o; a++, n++) {
        let l = (a / o) * Math.PI * 2,
          h = (n / o) * Math.PI * 2;
        r.push(Math.cos(l), Math.sin(l), 1, Math.cos(h), Math.sin(h), 1);
      }
      i.setAttribute("position", new ot(r, 3));
      let s = new gl({ fog: !1, toneMapped: !1 });
      (this.cone = new ap(i, s)), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1);
      let e = this.light.distance ? this.light.distance : 1e3,
        t = e * Math.tan(this.light.angle);
      this.cone.scale.set(t, t, e),
        mS.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(mS),
        this.color !== void 0
          ? this.cone.material.color.set(this.color)
          : this.cone.material.color.copy(this.light.color);
    }
  },
  ck = class extends br {
    constructor(e, t, i) {
      let r = new Cc(t, 4, 2),
        s = new mh({ wireframe: !0, fog: !1, toneMapped: !1 });
      super(r, s),
        (this.light = e),
        (this.color = i),
        (this.type = "PointLightHelper"),
        (this.matrix = this.light.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
    }
  },
  gS = new I(),
  nf = new I(),
  vS = new I(),
  uk = class extends _i {
    constructor(e, t, i) {
      super(),
        (this.light = e),
        (this.matrix = e.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = i),
        (this.type = "DirectionalLightHelper"),
        t === void 0 && (t = 1);
      let r = new yt();
      r.setAttribute(
        "position",
        new ot([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
      );
      let s = new gl({ fog: !1, toneMapped: !1 });
      (this.lightPlane = new _m(r, s)),
        this.add(this.lightPlane),
        (r = new yt()),
        r.setAttribute("position", new ot([0, 0, 0, 0, 0, 1], 3)),
        (this.targetLine = new _m(r, s)),
        this.add(this.targetLine),
        this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        gS.setFromMatrixPosition(this.light.matrixWorld),
        nf.setFromMatrixPosition(this.light.target.matrixWorld),
        vS.subVectors(nf, gS),
        this.lightPlane.lookAt(nf),
        this.color !== void 0
          ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color))
          : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(nf),
        (this.targetLine.scale.z = vS.length());
    }
  },
  of = new I(),
  Zi = new gh(),
  Tm = class extends ap {
    constructor(e) {
      let t = new yt(),
        i = new gl({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
        r = [],
        s = [],
        a = {};
      n("n1", "n2"),
        n("n2", "n4"),
        n("n4", "n3"),
        n("n3", "n1"),
        n("f1", "f2"),
        n("f2", "f4"),
        n("f4", "f3"),
        n("f3", "f1"),
        n("n1", "f1"),
        n("n2", "f2"),
        n("n3", "f3"),
        n("n4", "f4"),
        n("p", "n1"),
        n("p", "n2"),
        n("p", "n3"),
        n("p", "n4"),
        n("u1", "u2"),
        n("u2", "u3"),
        n("u3", "u1"),
        n("c", "t"),
        n("p", "c"),
        n("cn1", "cn2"),
        n("cn3", "cn4"),
        n("cf1", "cf2"),
        n("cf3", "cf4");
      function n(p, f) {
        o(p), o(f);
      }
      function o(p) {
        r.push(0, 0, 0),
          s.push(0, 0, 0),
          a[p] === void 0 && (a[p] = []),
          a[p].push(r.length / 3 - 1);
      }
      t.setAttribute("position", new ot(r, 3)),
        t.setAttribute("color", new ot(s, 3)),
        super(t, i),
        (this.type = "CameraHelper"),
        (this.camera = e),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = e.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = a),
        this.update();
      let l = new Et(16755200),
        h = new Et(16711680),
        u = new Et(43775),
        c = new Et(16777215),
        d = new Et(3355443);
      this.setColors(l, h, u, c, d);
    }
    setColors(e, t, i, r, s) {
      let a = this.geometry.getAttribute("color");
      a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, i.r, i.g, i.b),
        a.setXYZ(33, i.r, i.g, i.b),
        a.setXYZ(34, i.r, i.g, i.b),
        a.setXYZ(35, i.r, i.g, i.b),
        a.setXYZ(36, i.r, i.g, i.b),
        a.setXYZ(37, i.r, i.g, i.b),
        a.setXYZ(38, r.r, r.g, r.b),
        a.setXYZ(39, r.r, r.g, r.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        (a.needsUpdate = !0);
    }
    update() {
      let e = this.geometry,
        t = this.pointMap,
        i = 1,
        r = 1;
      Zi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        sr("c", t, e, Zi, 0, 0, -1),
        sr("t", t, e, Zi, 0, 0, 1),
        sr("n1", t, e, Zi, -i, -r, -1),
        sr("n2", t, e, Zi, i, -r, -1),
        sr("n3", t, e, Zi, -i, r, -1),
        sr("n4", t, e, Zi, i, r, -1),
        sr("f1", t, e, Zi, -i, -r, 1),
        sr("f2", t, e, Zi, i, -r, 1),
        sr("f3", t, e, Zi, -i, r, 1),
        sr("f4", t, e, Zi, i, r, 1),
        sr("u1", t, e, Zi, i * 0.7, r * 1.1, -1),
        sr("u2", t, e, Zi, -i * 0.7, r * 1.1, -1),
        sr("u3", t, e, Zi, 0, r * 2, -1),
        sr("cf1", t, e, Zi, -i, 0, 1),
        sr("cf2", t, e, Zi, i, 0, 1),
        sr("cf3", t, e, Zi, 0, -r, 1),
        sr("cf4", t, e, Zi, 0, r, 1),
        sr("cn1", t, e, Zi, -i, 0, -1),
        sr("cn2", t, e, Zi, i, 0, -1),
        sr("cn3", t, e, Zi, 0, -r, -1),
        sr("cn4", t, e, Zi, 0, r, -1),
        (e.getAttribute("position").needsUpdate = !0);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
function sr(e, t, i, r, s, a, n) {
  of.set(s, a, n).unproject(r);
  let o = t[e];
  if (o !== void 0) {
    let l = i.getAttribute("position");
    for (let h = 0, u = o.length; h < u; h++) l.setXYZ(o[h], of.x, of.y, of.z);
  }
}
var Pm = class extends ap {
    constructor(e, t = 16776960) {
      let i = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        r = [
          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
          -1, 1, -1, -1,
        ],
        s = new yt();
      s.setIndex(new It(i, 1)),
        s.setAttribute("position", new ot(r, 3)),
        super(s, new gl({ color: t, toneMapped: !1 })),
        (this.box = e),
        (this.type = "Box3Helper"),
        this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
      let t = this.box;
      t.isEmpty() ||
        (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(0.5),
        super.updateMatrixWorld(e));
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  },
  dk = class extends ap {
    constructor(e = 1) {
      let t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
        i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
        r = new yt();
      r.setAttribute("position", new ot(t, 3)),
        r.setAttribute("color", new ot(i, 3));
      let s = new gl({ vertexColors: !0, toneMapped: !1 });
      super(r, s), (this.type = "AxesHelper");
    }
    setColors(e, t, i) {
      let r = new Et(),
        s = this.geometry.attributes.color.array;
      return (
        r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        (this.geometry.attributes.color.needsUpdate = !0),
        this
      );
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  },
  po = pk();
function pk() {
  let e = new ArrayBuffer(4),
    t = new Float32Array(e),
    i = new Uint32Array(e),
    r = new Uint32Array(512),
    s = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    let h = l - 127;
    h < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (s[l] = 24), (s[l | 256] = 24))
      : h < -14
      ? ((r[l] = 1024 >> (-h - 14)),
        (r[l | 256] = (1024 >> (-h - 14)) | 32768),
        (s[l] = -h - 1),
        (s[l | 256] = -h - 1))
      : h <= 15
      ? ((r[l] = (h + 15) << 10),
        (r[l | 256] = ((h + 15) << 10) | 32768),
        (s[l] = 13),
        (s[l | 256] = 13))
      : h < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (s[l] = 24), (s[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (s[l] = 13), (s[l | 256] = 13));
  }
  let a = new Uint32Array(2048),
    n = new Uint32Array(64),
    o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let h = l << 13,
      u = 0;
    for (; (h & 8388608) === 0; ) (h <<= 1), (u -= 8388608);
    (h &= -8388609), (u += 947912704), (a[l] = h | u);
  }
  for (let l = 1024; l < 2048; ++l) a[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) n[l] = l << 23;
  (n[31] = 1199570944), (n[32] = 2147483648);
  for (let l = 33; l < 63; ++l) n[l] = 2147483648 + ((l - 32) << 23);
  n[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (o[l] = 1024);
  return {
    floatView: t,
    uint32View: i,
    baseTable: r,
    shiftTable: s,
    mantissaTable: a,
    exponentTable: n,
    offsetTable: o,
  };
}
function fk(e) {
  Math.abs(e) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (e = vr(e, -65504, 65504)),
    (po.floatView[0] = e);
  let t = po.uint32View[0],
    i = (t >> 23) & 511;
  return po.baseTable[i] + ((t & 8388607) >> po.shiftTable[i]);
}
function mk(e) {
  let t = e >> 10;
  return (
    (po.uint32View[0] =
      po.mantissaTable[po.offsetTable[t] + (e & 1023)] + po.exponentTable[t]),
    po.floatView[0]
  );
}
var gk = Object.freeze({ __proto__: null, fromHalfFloat: mk, toHalfFloat: fk });
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: ru } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = ru));
var ju = ".",
  Ox = Symbol("target"),
  OC = Symbol("unsubscribe");
function Ay(e) {
  return (
    e instanceof Date ||
    e instanceof Set ||
    e instanceof Map ||
    e instanceof WeakSet ||
    e instanceof WeakMap ||
    ArrayBuffer.isView(e)
  );
}
function vk(e) {
  return (
    (typeof e == "object" ? e === null : typeof e != "function") ||
    e instanceof RegExp
  );
}
var _n = Array.isArray;
function Ix(e) {
  return typeof e == "symbol";
}
var yk = {
    after: (e, t) =>
      _n(e) ? e.slice(t.length) : t === "" ? e : e.slice(t.length + 1),
    concat: (e, t) =>
      _n(e)
        ? ((e = [...e]), t && e.push(t), e)
        : t && t.toString !== void 0
        ? (e !== "" && (e += ju), Ix(t) ? e + t.toString() : e + t)
        : e,
    initial: (e) => {
      if (_n(e)) return e.slice(0, -1);
      if (e === "") return e;
      let t = e.lastIndexOf(ju);
      return t === -1 ? "" : e.slice(0, t);
    },
    last: (e) => {
      if (_n(e)) return e[e.length - 1] || "";
      if (e === "") return e;
      let t = e.lastIndexOf(ju);
      return t === -1 ? e : e.slice(t + 1);
    },
    walk: (e, t) => {
      if (_n(e)) for (let i of e) t(i);
      else if (e !== "") {
        let i = 0,
          r = e.indexOf(ju);
        if (r === -1) t(e);
        else
          for (; i < e.length; )
            r === -1 && (r = e.length),
              t(e.slice(i, r)),
              (i = r + 1),
              (r = e.indexOf(ju, i));
      }
    },
    get(e, t) {
      return (
        this.walk(t, (i) => {
          e && (e = e[i]);
        }),
        e
      );
    },
  },
  xa = yk;
function xk(e) {
  return typeof e == "object" && typeof e.next == "function";
}
function bk(e, t, i, r, s) {
  let a = e.next;
  if (t.name === "entries")
    e.next = function () {
      let n = a.call(this);
      return (
        n.done === !1 &&
          ((n.value[0] = s(n.value[0], t, n.value[0], r)),
          (n.value[1] = s(n.value[1], t, n.value[0], r))),
        n
      );
    };
  else if (t.name === "values") {
    let n = i[Ox].keys();
    e.next = function () {
      let o = a.call(this);
      return o.done === !1 && (o.value = s(o.value, t, n.next().value, r)), o;
    };
  } else
    e.next = function () {
      let n = a.call(this);
      return n.done === !1 && (n.value = s(n.value, t, n.value, r)), n;
    };
  return e;
}
function yS(e, t, i) {
  return (
    e.isUnsubscribed ||
    (t.ignoreSymbols && Ix(i)) ||
    (t.ignoreUnderscores && i.charAt(0) === "_") ||
    ("ignoreKeys" in t && t.ignoreKeys.includes(i))
  );
}
var wk = class {
  constructor(e) {
    (this._equals = e),
      (this._proxyCache = new WeakMap()),
      (this._pathCache = new WeakMap()),
      (this.isUnsubscribed = !1);
  }
  _getDescriptorCache() {
    return (
      this._descriptorCache === void 0 &&
        (this._descriptorCache = new WeakMap()),
      this._descriptorCache
    );
  }
  _getProperties(e) {
    let t = this._getDescriptorCache(),
      i = t.get(e);
    return i === void 0 && ((i = {}), t.set(e, i)), i;
  }
  _getOwnPropertyDescriptor(e, t) {
    if (this.isUnsubscribed) return Reflect.getOwnPropertyDescriptor(e, t);
    let i = this._getProperties(e),
      r = i[t];
    return (
      r === void 0 &&
        ((r = Reflect.getOwnPropertyDescriptor(e, t)), (i[t] = r)),
      r
    );
  }
  getProxy(e, t, i, r) {
    if (this.isUnsubscribed) return e;
    let s = e[r],
      a = s || e;
    this._pathCache.set(a, t);
    let n = this._proxyCache.get(a);
    return (
      n === void 0 &&
        ((n = s === void 0 ? new Proxy(e, i) : e), this._proxyCache.set(a, n)),
      n
    );
  }
  getPath(e) {
    return this.isUnsubscribed ? void 0 : this._pathCache.get(e);
  }
  isDetached(e, t) {
    return !Object.is(e, xa.get(t, this.getPath(e)));
  }
  defineProperty(e, t, i) {
    return Reflect.defineProperty(e, t, i)
      ? (this.isUnsubscribed || (this._getProperties(e)[t] = i), !0)
      : !1;
  }
  setProperty(e, t, i, r, s) {
    if (!this._equals(s, i) || !(t in e)) {
      let a = this._getOwnPropertyDescriptor(e, t);
      return a !== void 0 && "set" in a
        ? Reflect.set(e, t, i, r)
        : Reflect.set(e, t, i);
    }
    return !0;
  }
  deleteProperty(e, t, i) {
    if (Reflect.deleteProperty(e, t)) {
      if (!this.isUnsubscribed) {
        let r = this._getDescriptorCache().get(e);
        r && (delete r[t], this._pathCache.delete(i));
      }
      return !0;
    }
    return !1;
  }
  isSameDescriptor(e, t, i) {
    let r = this._getOwnPropertyDescriptor(t, i);
    return (
      e !== void 0 &&
      r !== void 0 &&
      Object.is(e.value, r.value) &&
      (e.writable || !1) === (r.writable || !1) &&
      (e.enumerable || !1) === (r.enumerable || !1) &&
      (e.configurable || !1) === (r.configurable || !1) &&
      e.get === r.get &&
      e.set === r.set
    );
  }
  isGetInvariant(e, t) {
    let i = this._getOwnPropertyDescriptor(e, t);
    return i !== void 0 && i.configurable !== !0 && i.writable !== !0;
  }
  unsubscribe() {
    (this._descriptorCache = null),
      (this._pathCache = null),
      (this._proxyCache = null),
      (this.isUnsubscribed = !0);
  }
};
function My(e) {
  return toString.call(e) === "[object Object]";
}
function lf() {
  return !0;
}
function Yh(e, t) {
  return e.length !== t.length || e.some((i, r) => t[r] !== i);
}
var IC = new Set([
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf",
  ]),
  _k = new Set([
    "concat",
    "includes",
    "indexOf",
    "join",
    "keys",
    "lastIndexOf",
  ]),
  RC = {
    push: lf,
    pop: lf,
    shift: lf,
    unshift: lf,
    copyWithin: Yh,
    reverse: Yh,
    sort: Yh,
    splice: Yh,
    flat: Yh,
    fill: Yh,
  },
  Sk = new Set([...IC, ..._k, ...Object.keys(RC)]);
function hf(e, t) {
  if (e.size !== t.size) return !0;
  for (let i of e) if (!t.has(i)) return !0;
  return !1;
}
var LC = ["keys", "values", "entries"],
  BC = new Set(["has", "toString"]),
  zC = { add: hf, clear: hf, delete: hf, forEach: hf },
  Ak = new Set([...BC, ...Object.keys(zC), ...LC]);
function cf(e, t) {
  if (e.size !== t.size) return !0;
  let i;
  for (let [r, s] of e)
    if (((i = t.get(r)), i !== s || (i === void 0 && !t.has(r)))) return !0;
  return !1;
}
var Mk = new Set([...BC, "get"]),
  FC = { set: cf, clear: cf, delete: cf, forEach: cf },
  Ek = new Set([...Mk, ...Object.keys(FC), ...LC]),
  fl = class {
    constructor(e, t, i, r) {
      (this._path = t),
        (this._isChanged = !1),
        (this._clonedCache = new Set()),
        (this._hasOnValidate = r),
        (this._changes = r ? [] : null),
        (this.clone = t === void 0 ? e : this._shallowClone(e));
    }
    static isHandledMethod(e) {
      return IC.has(e);
    }
    _shallowClone(e) {
      let t = e;
      if (My(e)) t = { ...e };
      else if (_n(e)) t = [...e];
      else if (e instanceof Date) t = new Date(e);
      else if (e instanceof Set)
        t = new Set([...e].map((i) => this._shallowClone(i)));
      else if (e instanceof Map) {
        t = new Map();
        for (let [i, r] of e.entries()) t.set(i, this._shallowClone(r));
      }
      return this._clonedCache.add(t), t;
    }
    preferredThisArg(e, t, i, r) {
      return e
        ? (_n(r)
            ? (this._onIsChanged = RC[t])
            : r instanceof Set
            ? (this._onIsChanged = zC[t])
            : r instanceof Map && (this._onIsChanged = FC[t]),
          r)
        : i;
    }
    update(e, t, i) {
      let r = xa.after(e, this._path);
      if (t !== "length") {
        let s = this.clone;
        xa.walk(r, (a) => {
          s &&
            s[a] &&
            (this._clonedCache.has(s[a]) || (s[a] = this._shallowClone(s[a])),
            (s = s[a]));
        }),
          this._hasOnValidate &&
            this._changes.push({ path: r, property: t, previous: i }),
          s && s[t] && (s[t] = i);
      }
      this._isChanged = !0;
    }
    undo(e) {
      let t;
      for (let i = this._changes.length - 1; i !== -1; i--)
        (t = this._changes[i]), (xa.get(e, t.path)[t.property] = t.previous);
    }
    isChanged(e) {
      return this._onIsChanged === void 0
        ? this._isChanged
        : this._onIsChanged(this.clone, e);
    }
  },
  xS = class extends fl {
    static isHandledMethod(e) {
      return Sk.has(e);
    }
  },
  Ck = class extends fl {
    undo(e) {
      e.setTime(this.clone.getTime());
    }
    isChanged(e, t) {
      return !t(this.clone.valueOf(), e.valueOf());
    }
  },
  bS = class extends fl {
    static isHandledMethod(e) {
      return Ak.has(e);
    }
    undo(e) {
      for (let t of this.clone) e.add(t);
      for (let t of e) this.clone.has(t) || e.delete(t);
    }
  },
  wS = class extends fl {
    static isHandledMethod(e) {
      return Ek.has(e);
    }
    undo(e) {
      for (let [t, i] of this.clone.entries()) e.set(t, i);
      for (let t of e.keys()) this.clone.has(t) || e.delete(t);
    }
  },
  Tk = class extends fl {
    constructor(e, t, i, r) {
      super(void 0, t, i, r),
        (this._arg1 = i[0]),
        (this._weakValue = e.has(this._arg1));
    }
    isChanged(e) {
      return this._weakValue !== e.has(this._arg1);
    }
    undo(e) {
      this._weakValue && !e.has(this._arg1)
        ? e.add(this._arg1)
        : e.delete(this._arg1);
    }
  },
  Pk = class extends fl {
    constructor(e, t, i, r) {
      super(void 0, t, i, r),
        (this._weakKey = i[0]),
        (this._weakHas = e.has(this._weakKey)),
        (this._weakValue = e.get(this._weakKey));
    }
    isChanged(e) {
      return this._weakValue !== e.get(this._weakKey);
    }
    undo(e) {
      let t = e.has(this._weakKey);
      this._weakHas && !t
        ? e.set(this._weakKey, this._weakValue)
        : !this._weakHas && t
        ? e.delete(this._weakKey)
        : this._weakValue !== e.get(this._weakKey) &&
          e.set(this._weakKey, this._weakValue);
    }
  },
  fc = class {
    constructor(e) {
      (this._stack = []), (this._hasOnValidate = e);
    }
    static isHandledType(e) {
      return My(e) || _n(e) || Ay(e);
    }
    static isHandledMethod(e, t) {
      return My(e)
        ? fl.isHandledMethod(t)
        : _n(e)
        ? xS.isHandledMethod(t)
        : e instanceof Set
        ? bS.isHandledMethod(t)
        : e instanceof Map
        ? wS.isHandledMethod(t)
        : Ay(e);
    }
    get isCloning() {
      return this._stack.length > 0;
    }
    start(e, t, i) {
      let r = fl;
      _n(e)
        ? (r = xS)
        : e instanceof Date
        ? (r = Ck)
        : e instanceof Set
        ? (r = bS)
        : e instanceof Map
        ? (r = wS)
        : e instanceof WeakSet
        ? (r = Tk)
        : e instanceof WeakMap && (r = Pk),
        this._stack.push(new r(e, t, i, this._hasOnValidate));
    }
    update(e, t, i) {
      this._stack[this._stack.length - 1].update(e, t, i);
    }
    preferredThisArg(e, t, i) {
      let { name: r } = e,
        s = fc.isHandledMethod(i, r);
      return this._stack[this._stack.length - 1].preferredThisArg(s, r, t, i);
    }
    isChanged(e, t, i) {
      return this._stack[this._stack.length - 1].isChanged(e, t, i);
    }
    undo(e) {
      this._previousClone !== void 0 && this._previousClone.undo(e);
    }
    stop() {
      return (
        (this._previousClone = this._stack.pop()), this._previousClone.clone
      );
    }
  },
  Dk = {
    equals: Object.is,
    isShallow: !1,
    pathAsArray: !1,
    ignoreSymbols: !1,
    ignoreUnderscores: !1,
    ignoreDetached: !1,
    details: !1,
  },
  Rx = (e, t, i = {}) => {
    i = { ...Dk, ...i };
    let r = Symbol("ProxyTarget"),
      { equals: s, isShallow: a, ignoreDetached: n, details: o } = i,
      l = new wk(s),
      h = typeof i.onValidate == "function",
      u = new fc(h),
      c = (x, b, _, S, M) =>
        !h ||
        u.isCloning ||
        i.onValidate(xa.concat(l.getPath(x), b), _, S, M) === !0,
      d = (x, b, _, S) => {
        !yS(l, i, b) && !(n && l.isDetached(x, e)) && p(l.getPath(x), b, _, S);
      },
      p = (x, b, _, S, M) => {
        u.isCloning ? u.update(x, b, S) : t(xa.concat(x, b), _, S, M);
      },
      f = (x) => x && (x[r] || x),
      m = (x, b, _, S) =>
        vk(x) ||
        _ === "constructor" ||
        (a && !fc.isHandledMethod(b, _)) ||
        yS(l, i, _) ||
        l.isGetInvariant(b, _) ||
        (n && l.isDetached(b, e))
          ? x
          : (S === void 0 && (S = l.getPath(b)),
            l.getProxy(x, xa.concat(S, _), g, r)),
      g = {
        get(x, b, _) {
          if (Ix(b)) {
            if (b === r || b === Ox) return x;
            if (b === OC && !l.isUnsubscribed && l.getPath(x).length === 0)
              return l.unsubscribe(), x;
          }
          let S = Ay(x) ? Reflect.get(x, b) : Reflect.get(x, b, _);
          return m(S, x, b);
        },
        set(x, b, _, S) {
          _ = f(_);
          let M = x[r] || x,
            C = M[b];
          if (s(C, _) && b in x) return !0;
          let A = c(x, b, _, C);
          return A && l.setProperty(M, b, _, S, C)
            ? (d(x, b, x[b], C), !0)
            : !A;
        },
        defineProperty(x, b, _) {
          if (!l.isSameDescriptor(_, x, b)) {
            let S = x[b];
            c(x, b, _.value, S) &&
              l.defineProperty(x, b, _, S) &&
              d(x, b, _.value, S);
          }
          return !0;
        },
        deleteProperty(x, b) {
          if (!Reflect.has(x, b)) return !0;
          let _ = Reflect.get(x, b),
            S = c(x, b, void 0, _);
          return S && l.deleteProperty(x, b, _) ? (d(x, b, void 0, _), !0) : !S;
        },
        apply(x, b, _) {
          let S = b[r] || b;
          if (l.isUnsubscribed) return Reflect.apply(x, S, _);
          if (
            (o === !1 || (o !== !0 && !o.includes(x.name))) &&
            fc.isHandledType(S)
          ) {
            let M = xa.initial(l.getPath(x)),
              C = fc.isHandledMethod(S, x.name);
            u.start(S, M, _);
            let A = Reflect.apply(
                x,
                u.preferredThisArg(x, b, S),
                C ? _.map((R) => f(R)) : _
              ),
              T = u.isChanged(S, s),
              P = u.stop();
            if (
              (fc.isHandledType(A) &&
                C &&
                (b instanceof Map &&
                  x.name === "get" &&
                  (M = xa.concat(M, _[0])),
                (A = l.getProxy(A, M, g))),
              T)
            ) {
              let R = { name: x.name, args: _, result: A },
                z = u.isCloning ? xa.initial(M) : M,
                N = u.isCloning ? xa.last(M) : "";
              c(xa.get(e, z), N, S, P, R) ? p(z, N, S, P, R) : u.undo(S);
            }
            return (b instanceof Map || b instanceof Set) && xk(A)
              ? bk(A, x, b, M, m)
              : A;
          }
          return Reflect.apply(x, b, _);
        },
      },
      y = l.getProxy(e, i.pathAsArray ? [] : "", g);
    return (t = t.bind(y)), h && (i.onValidate = i.onValidate.bind(y)), y;
  };
Rx.target = (e) => (e && e[Ox]) || e;
Rx.unsubscribe = (e) => e[OC] || e;
var _S = Rx,
  Ok =
    typeof global == "object" && global && global.Object === Object && global,
  kC = Ok,
  Ik = typeof self == "object" && self && self.Object === Object && self,
  Rk = kC || Ik || Function("return this")(),
  Ja = Rk,
  Lk = Ja.Symbol,
  Ca = Lk,
  NC = Object.prototype,
  Bk = NC.hasOwnProperty,
  zk = NC.toString,
  Hu = Ca ? Ca.toStringTag : void 0;
function Fk(e) {
  var t = Bk.call(e, Hu),
    i = e[Hu];
  try {
    e[Hu] = void 0;
    var r = !0;
  } catch {}
  var s = zk.call(e);
  return r && (t ? (e[Hu] = i) : delete e[Hu]), s;
}
var kk = Fk,
  Nk = Object.prototype,
  Uk = Nk.toString;
function Vk(e) {
  return Uk.call(e);
}
var jk = Vk,
  Hk = "[object Null]",
  Gk = "[object Undefined]",
  SS = Ca ? Ca.toStringTag : void 0;
function Wk(e) {
  return e == null
    ? e === void 0
      ? Gk
      : Hk
    : SS && SS in Object(e)
    ? kk(e)
    : jk(e);
}
var yh = Wk;
function qk(e) {
  return e != null && typeof e == "object";
}
var So = qk,
  Yk = "[object Symbol]";
function Xk(e) {
  return typeof e == "symbol" || (So(e) && yh(e) == Yk);
}
var Ag = Xk;
function Qk(e, t) {
  for (var i = -1, r = e == null ? 0 : e.length, s = Array(r); ++i < r; )
    s[i] = t(e[i], i, e);
  return s;
}
var UC = Qk,
  Zk = Array.isArray,
  On = Zk,
  Kk = 1 / 0,
  AS = Ca ? Ca.prototype : void 0,
  MS = AS ? AS.toString : void 0;
function VC(e) {
  if (typeof e == "string") return e;
  if (On(e)) return UC(e, VC) + "";
  if (Ag(e)) return MS ? MS.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -Kk ? "-0" : t;
}
var Jk = VC,
  $k = /\s/;
function e5(e) {
  for (var t = e.length; t-- && $k.test(e.charAt(t)); );
  return t;
}
var t5 = e5,
  i5 = /^\s+/;
function r5(e) {
  return e && e.slice(0, t5(e) + 1).replace(i5, "");
}
var s5 = r5;
function a5(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Ka = a5,
  ES = 0 / 0,
  n5 = /^[-+]0x[0-9a-f]+$/i,
  o5 = /^0b[01]+$/i,
  l5 = /^0o[0-7]+$/i,
  h5 = parseInt;
function c5(e) {
  if (typeof e == "number") return e;
  if (Ag(e)) return ES;
  if (Ka(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ka(t) ? t + "" : t;
  }
  if (typeof e != "string") return e === 0 ? e : +e;
  e = s5(e);
  var i = o5.test(e);
  return i || l5.test(e) ? h5(e.slice(2), i ? 2 : 8) : n5.test(e) ? ES : +e;
}
var CS = c5;
function u5(e) {
  return e;
}
var d5 = u5,
  p5 = "[object AsyncFunction]",
  f5 = "[object Function]",
  m5 = "[object GeneratorFunction]",
  g5 = "[object Proxy]";
function v5(e) {
  if (!Ka(e)) return !1;
  var t = yh(e);
  return t == f5 || t == m5 || t == p5 || t == g5;
}
var jC = v5,
  y5 = Ja["__core-js_shared__"],
  Hv = y5,
  TS = (function () {
    var e = /[^.]+$/.exec((Hv && Hv.keys && Hv.keys.IE_PROTO) || "");
    return e ? "Symbol(src)_1." + e : "";
  })();
function x5(e) {
  return !!TS && TS in e;
}
var b5 = x5,
  w5 = Function.prototype,
  _5 = w5.toString;
function S5(e) {
  if (e != null) {
    try {
      return _5.call(e);
    } catch {}
    try {
      return e + "";
    } catch {}
  }
  return "";
}
var xh = S5,
  A5 = /[\\^$.*+?()[\]{}|]/g,
  M5 = /^\[object .+?Constructor\]$/,
  E5 = Function.prototype,
  C5 = Object.prototype,
  T5 = E5.toString,
  P5 = C5.hasOwnProperty,
  D5 = RegExp(
    "^" +
      T5.call(P5)
        .replace(A5, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function O5(e) {
  if (!Ka(e) || b5(e)) return !1;
  var t = jC(e) ? D5 : M5;
  return t.test(xh(e));
}
var I5 = O5;
function R5(e, t) {
  return e?.[t];
}
var L5 = R5;
function B5(e, t) {
  var i = L5(e, t);
  return I5(i) ? i : void 0;
}
var bh = B5,
  z5 = bh(Ja, "WeakMap"),
  Ey = z5,
  PS = Object.create,
  F5 = (function () {
    function e() {}
    return function (t) {
      if (!Ka(t)) return {};
      if (PS) return PS(t);
      e.prototype = t;
      var i = new e();
      return (e.prototype = void 0), i;
    };
  })(),
  k5 = F5;
function N5(e, t, i) {
  switch (i.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, i[0]);
    case 2:
      return e.call(t, i[0], i[1]);
    case 3:
      return e.call(t, i[0], i[1], i[2]);
  }
  return e.apply(t, i);
}
var U5 = N5;
function V5(e, t) {
  var i = -1,
    r = e.length;
  for (t || (t = Array(r)); ++i < r; ) t[i] = e[i];
  return t;
}
var j5 = V5,
  H5 = 800,
  G5 = 16,
  W5 = Date.now;
function q5(e) {
  var t = 0,
    i = 0;
  return function () {
    var r = W5(),
      s = G5 - (r - i);
    if (((i = r), s > 0)) {
      if (++t >= H5) return arguments[0];
    } else t = 0;
    return e.apply(void 0, arguments);
  };
}
var Y5 = q5;
function X5(e) {
  return function () {
    return e;
  };
}
var Q5 = X5,
  Z5 = (function () {
    try {
      var e = bh(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {}
  })(),
  Dm = Z5,
  K5 = Dm
    ? function (e, t) {
        return Dm(e, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Q5(t),
          writable: !0,
        });
      }
    : d5,
  J5 = K5,
  $5 = Y5(J5),
  eN = $5;
function tN(e, t) {
  for (
    var i = -1, r = e == null ? 0 : e.length;
    ++i < r && t(e[i], i, e) !== !1;

  );
  return e;
}
var iN = tN,
  rN = 9007199254740991,
  sN = /^(?:0|[1-9]\d*)$/;
function aN(e, t) {
  var i = typeof e;
  return (
    (t = t ?? rN),
    !!t &&
      (i == "number" || (i != "symbol" && sN.test(e))) &&
      e > -1 &&
      e % 1 == 0 &&
      e < t
  );
}
var Lx = aN;
function nN(e, t, i) {
  t == "__proto__" && Dm
    ? Dm(e, t, { configurable: !0, enumerable: !0, value: i, writable: !0 })
    : (e[t] = i);
}
var HC = nN;
function oN(e, t) {
  return e === t || (e !== e && t !== t);
}
var Bx = oN,
  lN = Object.prototype,
  hN = lN.hasOwnProperty;
function cN(e, t, i) {
  var r = e[t];
  (!(hN.call(e, t) && Bx(r, i)) || (i === void 0 && !(t in e))) && HC(e, t, i);
}
var zx = cN;
function uN(e, t, i, r) {
  var s = !i;
  i || (i = {});
  for (var a = -1, n = t.length; ++a < n; ) {
    var o = t[a],
      l = r ? r(i[o], e[o], o, i, e) : void 0;
    l === void 0 && (l = e[o]), s ? HC(i, o, l) : zx(i, o, l);
  }
  return i;
}
var hp = uN,
  DS = Math.max;
function dN(e, t, i) {
  return (
    (t = DS(t === void 0 ? e.length - 1 : t, 0)),
    function () {
      for (
        var r = arguments, s = -1, a = DS(r.length - t, 0), n = Array(a);
        ++s < a;

      )
        n[s] = r[t + s];
      s = -1;
      for (var o = Array(t + 1); ++s < t; ) o[s] = r[s];
      return (o[t] = i(n)), U5(e, this, o);
    }
  );
}
var pN = dN,
  fN = 9007199254740991;
function mN(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= fN;
}
var Fx = mN;
function gN(e) {
  return e != null && Fx(e.length) && !jC(e);
}
var GC = gN,
  vN = Object.prototype;
function yN(e) {
  var t = e && e.constructor,
    i = (typeof t == "function" && t.prototype) || vN;
  return e === i;
}
var kx = yN;
function xN(e, t) {
  for (var i = -1, r = Array(e); ++i < e; ) r[i] = t(i);
  return r;
}
var bN = xN,
  wN = "[object Arguments]";
function _N(e) {
  return So(e) && yh(e) == wN;
}
var OS = _N,
  WC = Object.prototype,
  SN = WC.hasOwnProperty,
  AN = WC.propertyIsEnumerable,
  MN = OS(
    (function () {
      return arguments;
    })()
  )
    ? OS
    : function (e) {
        return So(e) && SN.call(e, "callee") && !AN.call(e, "callee");
      },
  Nx = MN;
function EN() {
  return !1;
}
var CN = EN,
  qC = typeof exports == "object" && exports && !exports.nodeType && exports,
  IS = qC && typeof module == "object" && module && !module.nodeType && module,
  TN = IS && IS.exports === qC,
  RS = TN ? Ja.Buffer : void 0,
  PN = RS ? RS.isBuffer : void 0,
  DN = PN || CN,
  Om = DN,
  ON = "[object Arguments]",
  IN = "[object Array]",
  RN = "[object Boolean]",
  LN = "[object Date]",
  BN = "[object Error]",
  zN = "[object Function]",
  FN = "[object Map]",
  kN = "[object Number]",
  NN = "[object Object]",
  UN = "[object RegExp]",
  VN = "[object Set]",
  jN = "[object String]",
  HN = "[object WeakMap]",
  GN = "[object ArrayBuffer]",
  WN = "[object DataView]",
  qN = "[object Float32Array]",
  YN = "[object Float64Array]",
  XN = "[object Int8Array]",
  QN = "[object Int16Array]",
  ZN = "[object Int32Array]",
  KN = "[object Uint8Array]",
  JN = "[object Uint8ClampedArray]",
  $N = "[object Uint16Array]",
  eU = "[object Uint32Array]",
  Ni = {};
Ni[qN] =
  Ni[YN] =
  Ni[XN] =
  Ni[QN] =
  Ni[ZN] =
  Ni[KN] =
  Ni[JN] =
  Ni[$N] =
  Ni[eU] =
    !0;
Ni[ON] =
  Ni[IN] =
  Ni[GN] =
  Ni[RN] =
  Ni[WN] =
  Ni[LN] =
  Ni[BN] =
  Ni[zN] =
  Ni[FN] =
  Ni[kN] =
  Ni[NN] =
  Ni[UN] =
  Ni[VN] =
  Ni[jN] =
  Ni[HN] =
    !1;
function tU(e) {
  return So(e) && Fx(e.length) && !!Ni[yh(e)];
}
var iU = tU;
function rU(e) {
  return function (t) {
    return e(t);
  };
}
var Ux = rU,
  YC = typeof exports == "object" && exports && !exports.nodeType && exports,
  Sd = YC && typeof module == "object" && module && !module.nodeType && module,
  sU = Sd && Sd.exports === YC,
  Gv = sU && kC.process,
  aU = (function () {
    try {
      var e = Sd && Sd.require && Sd.require("util").types;
      return e || (Gv && Gv.binding && Gv.binding("util"));
    } catch {}
  })(),
  Wc = aU,
  LS = Wc && Wc.isTypedArray,
  nU = LS ? Ux(LS) : iU,
  XC = nU,
  oU = Object.prototype,
  lU = oU.hasOwnProperty;
function hU(e, t) {
  var i = On(e),
    r = !i && Nx(e),
    s = !i && !r && Om(e),
    a = !i && !r && !s && XC(e),
    n = i || r || s || a,
    o = n ? bN(e.length, String) : [],
    l = o.length;
  for (var h in e)
    (t || lU.call(e, h)) &&
      !(
        n &&
        (h == "length" ||
          (s && (h == "offset" || h == "parent")) ||
          (a && (h == "buffer" || h == "byteLength" || h == "byteOffset")) ||
          Lx(h, l))
      ) &&
      o.push(h);
  return o;
}
var QC = hU;
function cU(e, t) {
  return function (i) {
    return e(t(i));
  };
}
var ZC = cU,
  uU = ZC(Object.keys, Object),
  dU = uU,
  pU = Object.prototype,
  fU = pU.hasOwnProperty;
function mU(e) {
  if (!kx(e)) return dU(e);
  var t = [];
  for (var i in Object(e)) fU.call(e, i) && i != "constructor" && t.push(i);
  return t;
}
var gU = mU;
function vU(e) {
  return GC(e) ? QC(e) : gU(e);
}
var Vx = vU;
function yU(e) {
  var t = [];
  if (e != null) for (var i in Object(e)) t.push(i);
  return t;
}
var xU = yU,
  bU = Object.prototype,
  wU = bU.hasOwnProperty;
function _U(e) {
  if (!Ka(e)) return xU(e);
  var t = kx(e),
    i = [];
  for (var r in e) (r == "constructor" && (t || !wU.call(e, r))) || i.push(r);
  return i;
}
var SU = _U;
function AU(e) {
  return GC(e) ? QC(e, !0) : SU(e);
}
var Gl = AU,
  MU = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  EU = /^\w*$/;
function CU(e, t) {
  if (On(e)) return !1;
  var i = typeof e;
  return i == "number" || i == "symbol" || i == "boolean" || e == null || Ag(e)
    ? !0
    : EU.test(e) || !MU.test(e) || (t != null && e in Object(t));
}
var TU = CU,
  PU = bh(Object, "create"),
  kd = PU;
function DU() {
  (this.__data__ = kd ? kd(null) : {}), (this.size = 0);
}
var OU = DU;
function IU(e) {
  var t = this.has(e) && delete this.__data__[e];
  return (this.size -= t ? 1 : 0), t;
}
var RU = IU,
  LU = "__lodash_hash_undefined__",
  BU = Object.prototype,
  zU = BU.hasOwnProperty;
function FU(e) {
  var t = this.__data__;
  if (kd) {
    var i = t[e];
    return i === LU ? void 0 : i;
  }
  return zU.call(t, e) ? t[e] : void 0;
}
var kU = FU,
  NU = Object.prototype,
  UU = NU.hasOwnProperty;
function VU(e) {
  var t = this.__data__;
  return kd ? t[e] !== void 0 : UU.call(t, e);
}
var jU = VU,
  HU = "__lodash_hash_undefined__";
function GU(e, t) {
  var i = this.__data__;
  return (
    (this.size += this.has(e) ? 0 : 1),
    (i[e] = kd && t === void 0 ? HU : t),
    this
  );
}
var WU = GU;
function hu(e) {
  var t = -1,
    i = e == null ? 0 : e.length;
  for (this.clear(); ++t < i; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
hu.prototype.clear = OU;
hu.prototype.delete = RU;
hu.prototype.get = kU;
hu.prototype.has = jU;
hu.prototype.set = WU;
var BS = hu;
function qU() {
  (this.__data__ = []), (this.size = 0);
}
var YU = qU;
function XU(e, t) {
  for (var i = e.length; i--; ) if (Bx(e[i][0], t)) return i;
  return -1;
}
var Mg = XU,
  QU = Array.prototype,
  ZU = QU.splice;
function KU(e) {
  var t = this.__data__,
    i = Mg(t, e);
  if (i < 0) return !1;
  var r = t.length - 1;
  return i == r ? t.pop() : ZU.call(t, i, 1), --this.size, !0;
}
var JU = KU;
function $U(e) {
  var t = this.__data__,
    i = Mg(t, e);
  return i < 0 ? void 0 : t[i][1];
}
var e6 = $U;
function t6(e) {
  return Mg(this.__data__, e) > -1;
}
var i6 = t6;
function r6(e, t) {
  var i = this.__data__,
    r = Mg(i, e);
  return r < 0 ? (++this.size, i.push([e, t])) : (i[r][1] = t), this;
}
var s6 = r6;
function cu(e) {
  var t = -1,
    i = e == null ? 0 : e.length;
  for (this.clear(); ++t < i; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
cu.prototype.clear = YU;
cu.prototype.delete = JU;
cu.prototype.get = e6;
cu.prototype.has = i6;
cu.prototype.set = s6;
var Eg = cu,
  a6 = bh(Ja, "Map"),
  Nd = a6;
function n6() {
  (this.size = 0),
    (this.__data__ = {
      hash: new BS(),
      map: new (Nd || Eg)(),
      string: new BS(),
    });
}
var o6 = n6;
function l6(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean"
    ? e !== "__proto__"
    : e === null;
}
var h6 = l6;
function c6(e, t) {
  var i = e.__data__;
  return h6(t) ? i[typeof t == "string" ? "string" : "hash"] : i.map;
}
var Cg = c6;
function u6(e) {
  var t = Cg(this, e).delete(e);
  return (this.size -= t ? 1 : 0), t;
}
var d6 = u6;
function p6(e) {
  return Cg(this, e).get(e);
}
var f6 = p6;
function m6(e) {
  return Cg(this, e).has(e);
}
var g6 = m6;
function v6(e, t) {
  var i = Cg(this, e),
    r = i.size;
  return i.set(e, t), (this.size += i.size == r ? 0 : 1), this;
}
var y6 = v6;
function uu(e) {
  var t = -1,
    i = e == null ? 0 : e.length;
  for (this.clear(); ++t < i; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
uu.prototype.clear = o6;
uu.prototype.delete = d6;
uu.prototype.get = f6;
uu.prototype.has = g6;
uu.prototype.set = y6;
var Tg = uu,
  x6 = "Expected a function";
function jx(e, t) {
  if (typeof e != "function" || (t != null && typeof t != "function"))
    throw new TypeError(x6);
  var i = function () {
    var r = arguments,
      s = t ? t.apply(this, r) : r[0],
      a = i.cache;
    if (a.has(s)) return a.get(s);
    var n = e.apply(this, r);
    return (i.cache = a.set(s, n) || a), n;
  };
  return (i.cache = new (jx.Cache || Tg)()), i;
}
jx.Cache = Tg;
var b6 = jx,
  w6 = 500;
function _6(e) {
  var t = b6(e, function (r) {
      return i.size === w6 && i.clear(), r;
    }),
    i = t.cache;
  return t;
}
var S6 = _6,
  A6 =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  M6 = /\\(\\)?/g,
  E6 = S6(function (e) {
    var t = [];
    return (
      e.charCodeAt(0) === 46 && t.push(""),
      e.replace(A6, function (i, r, s, a) {
        t.push(s ? a.replace(M6, "$1") : r || i);
      }),
      t
    );
  }),
  C6 = E6;
function T6(e) {
  return e == null ? "" : Jk(e);
}
var P6 = T6;
function D6(e, t) {
  return On(e) ? e : TU(e, t) ? [e] : C6(P6(e));
}
var du = D6,
  O6 = 1 / 0;
function I6(e) {
  if (typeof e == "string" || Ag(e)) return e;
  var t = e + "";
  return t == "0" && 1 / e == -O6 ? "-0" : t;
}
var Pg = I6;
function R6(e, t) {
  t = du(t, e);
  for (var i = 0, r = t.length; e != null && i < r; ) e = e[Pg(t[i++])];
  return i && i == r ? e : void 0;
}
var KC = R6;
function L6(e, t) {
  for (var i = -1, r = t.length, s = e.length; ++i < r; ) e[s + i] = t[i];
  return e;
}
var Hx = L6,
  zS = Ca ? Ca.isConcatSpreadable : void 0;
function B6(e) {
  return On(e) || Nx(e) || !!(zS && e && e[zS]);
}
var z6 = B6;
function JC(e, t, i, r, s) {
  var a = -1,
    n = e.length;
  for (i || (i = z6), s || (s = []); ++a < n; ) {
    var o = e[a];
    t > 0 && i(o)
      ? t > 1
        ? JC(o, t - 1, i, r, s)
        : Hx(s, o)
      : r || (s[s.length] = o);
  }
  return s;
}
var F6 = JC;
function k6(e) {
  var t = e == null ? 0 : e.length;
  return t ? F6(e, 1) : [];
}
var N6 = k6;
function U6(e) {
  return eN(pN(e, void 0, N6), e + "");
}
var $C = U6,
  V6 = ZC(Object.getPrototypeOf, Object),
  Gx = V6,
  j6 = "[object Object]",
  H6 = Function.prototype,
  G6 = Object.prototype,
  eT = H6.toString,
  W6 = G6.hasOwnProperty,
  q6 = eT.call(Object);
function Y6(e) {
  if (!So(e) || yh(e) != j6) return !1;
  var t = Gx(e);
  if (t === null) return !0;
  var i = W6.call(t, "constructor") && t.constructor;
  return typeof i == "function" && i instanceof i && eT.call(i) == q6;
}
var X6 = Y6;
function Q6(e, t, i) {
  var r = -1,
    s = e.length;
  t < 0 && (t = -t > s ? 0 : s + t),
    (i = i > s ? s : i),
    i < 0 && (i += s),
    (s = t > i ? 0 : (i - t) >>> 0),
    (t >>>= 0);
  for (var a = Array(s); ++r < s; ) a[r] = e[r + t];
  return a;
}
var Z6 = Q6;
function K6() {
  (this.__data__ = new Eg()), (this.size = 0);
}
var J6 = K6;
function $6(e) {
  var t = this.__data__,
    i = t.delete(e);
  return (this.size = t.size), i;
}
var eV = $6;
function tV(e) {
  return this.__data__.get(e);
}
var iV = tV;
function rV(e) {
  return this.__data__.has(e);
}
var sV = rV,
  aV = 200;
function nV(e, t) {
  var i = this.__data__;
  if (i instanceof Eg) {
    var r = i.__data__;
    if (!Nd || r.length < aV - 1)
      return r.push([e, t]), (this.size = ++i.size), this;
    i = this.__data__ = new Tg(r);
  }
  return i.set(e, t), (this.size = i.size), this;
}
var oV = nV;
function pu(e) {
  var t = (this.__data__ = new Eg(e));
  this.size = t.size;
}
pu.prototype.clear = J6;
pu.prototype.delete = eV;
pu.prototype.get = iV;
pu.prototype.has = sV;
pu.prototype.set = oV;
var nm = pu;
function lV(e, t) {
  return e && hp(t, Vx(t), e);
}
var hV = lV;
function cV(e, t) {
  return e && hp(t, Gl(t), e);
}
var uV = cV,
  tT = typeof exports == "object" && exports && !exports.nodeType && exports,
  FS = tT && typeof module == "object" && module && !module.nodeType && module,
  dV = FS && FS.exports === tT,
  kS = dV ? Ja.Buffer : void 0,
  NS = kS ? kS.allocUnsafe : void 0;
function pV(e, t) {
  if (t) return e.slice();
  var i = e.length,
    r = NS ? NS(i) : new e.constructor(i);
  return e.copy(r), r;
}
var fV = pV;
function mV(e, t) {
  for (var i = -1, r = e == null ? 0 : e.length, s = 0, a = []; ++i < r; ) {
    var n = e[i];
    t(n, i, e) && (a[s++] = n);
  }
  return a;
}
var gV = mV;
function vV() {
  return [];
}
var iT = vV,
  yV = Object.prototype,
  xV = yV.propertyIsEnumerable,
  US = Object.getOwnPropertySymbols,
  bV = US
    ? function (e) {
        return e == null
          ? []
          : ((e = Object(e)),
            gV(US(e), function (t) {
              return xV.call(e, t);
            }));
      }
    : iT,
  Wx = bV;
function wV(e, t) {
  return hp(e, Wx(e), t);
}
var _V = wV,
  SV = Object.getOwnPropertySymbols,
  AV = SV
    ? function (e) {
        for (var t = []; e; ) Hx(t, Wx(e)), (e = Gx(e));
        return t;
      }
    : iT,
  rT = AV;
function MV(e, t) {
  return hp(e, rT(e), t);
}
var EV = MV;
function CV(e, t, i) {
  var r = t(e);
  return On(e) ? r : Hx(r, i(e));
}
var sT = CV;
function TV(e) {
  return sT(e, Vx, Wx);
}
var Cy = TV;
function PV(e) {
  return sT(e, Gl, rT);
}
var aT = PV,
  DV = bh(Ja, "DataView"),
  Ty = DV,
  OV = bh(Ja, "Promise"),
  Py = OV,
  IV = bh(Ja, "Set"),
  Dy = IV,
  VS = "[object Map]",
  RV = "[object Object]",
  jS = "[object Promise]",
  HS = "[object Set]",
  GS = "[object WeakMap]",
  WS = "[object DataView]",
  LV = xh(Ty),
  BV = xh(Nd),
  zV = xh(Py),
  FV = xh(Dy),
  kV = xh(Ey),
  Ll = yh;
((Ty && Ll(new Ty(new ArrayBuffer(1))) != WS) ||
  (Nd && Ll(new Nd()) != VS) ||
  (Py && Ll(Py.resolve()) != jS) ||
  (Dy && Ll(new Dy()) != HS) ||
  (Ey && Ll(new Ey()) != GS)) &&
  (Ll = function (e) {
    var t = yh(e),
      i = t == RV ? e.constructor : void 0,
      r = i ? xh(i) : "";
    if (r)
      switch (r) {
        case LV:
          return WS;
        case BV:
          return VS;
        case zV:
          return jS;
        case FV:
          return HS;
        case kV:
          return GS;
      }
    return t;
  });
var Ud = Ll,
  NV = Object.prototype,
  UV = NV.hasOwnProperty;
function VV(e) {
  var t = e.length,
    i = new e.constructor(t);
  return (
    t &&
      typeof e[0] == "string" &&
      UV.call(e, "index") &&
      ((i.index = e.index), (i.input = e.input)),
    i
  );
}
var jV = VV,
  HV = Ja.Uint8Array,
  Im = HV;
function GV(e) {
  var t = new e.constructor(e.byteLength);
  return new Im(t).set(new Im(e)), t;
}
var qx = GV;
function WV(e, t) {
  var i = t ? qx(e.buffer) : e.buffer;
  return new e.constructor(i, e.byteOffset, e.byteLength);
}
var qV = WV,
  YV = /\w*$/;
function XV(e) {
  var t = new e.constructor(e.source, YV.exec(e));
  return (t.lastIndex = e.lastIndex), t;
}
var QV = XV,
  qS = Ca ? Ca.prototype : void 0,
  YS = qS ? qS.valueOf : void 0;
function ZV(e) {
  return YS ? Object(YS.call(e)) : {};
}
var KV = ZV;
function JV(e, t) {
  var i = t ? qx(e.buffer) : e.buffer;
  return new e.constructor(i, e.byteOffset, e.length);
}
var $V = JV,
  ej = "[object Boolean]",
  tj = "[object Date]",
  ij = "[object Map]",
  rj = "[object Number]",
  sj = "[object RegExp]",
  aj = "[object Set]",
  nj = "[object String]",
  oj = "[object Symbol]",
  lj = "[object ArrayBuffer]",
  hj = "[object DataView]",
  cj = "[object Float32Array]",
  uj = "[object Float64Array]",
  dj = "[object Int8Array]",
  pj = "[object Int16Array]",
  fj = "[object Int32Array]",
  mj = "[object Uint8Array]",
  gj = "[object Uint8ClampedArray]",
  vj = "[object Uint16Array]",
  yj = "[object Uint32Array]";
function xj(e, t, i) {
  var r = e.constructor;
  switch (t) {
    case lj:
      return qx(e);
    case ej:
    case tj:
      return new r(+e);
    case hj:
      return qV(e, i);
    case cj:
    case uj:
    case dj:
    case pj:
    case fj:
    case mj:
    case gj:
    case vj:
    case yj:
      return $V(e, i);
    case ij:
      return new r();
    case rj:
    case nj:
      return new r(e);
    case sj:
      return QV(e);
    case aj:
      return new r();
    case oj:
      return KV(e);
  }
}
var bj = xj;
function wj(e) {
  return typeof e.constructor == "function" && !kx(e) ? k5(Gx(e)) : {};
}
var _j = wj,
  Sj = "[object Map]";
function Aj(e) {
  return So(e) && Ud(e) == Sj;
}
var Mj = Aj,
  XS = Wc && Wc.isMap,
  Ej = XS ? Ux(XS) : Mj,
  Cj = Ej,
  Tj = "[object Set]";
function Pj(e) {
  return So(e) && Ud(e) == Tj;
}
var Dj = Pj,
  QS = Wc && Wc.isSet,
  Oj = QS ? Ux(QS) : Dj,
  Ij = Oj,
  Rj = 1,
  Lj = 2,
  Bj = 4,
  nT = "[object Arguments]",
  zj = "[object Array]",
  Fj = "[object Boolean]",
  kj = "[object Date]",
  Nj = "[object Error]",
  oT = "[object Function]",
  Uj = "[object GeneratorFunction]",
  Vj = "[object Map]",
  jj = "[object Number]",
  lT = "[object Object]",
  Hj = "[object RegExp]",
  Gj = "[object Set]",
  Wj = "[object String]",
  qj = "[object Symbol]",
  Yj = "[object WeakMap]",
  Xj = "[object ArrayBuffer]",
  Qj = "[object DataView]",
  Zj = "[object Float32Array]",
  Kj = "[object Float64Array]",
  Jj = "[object Int8Array]",
  $j = "[object Int16Array]",
  e8 = "[object Int32Array]",
  t8 = "[object Uint8Array]",
  i8 = "[object Uint8ClampedArray]",
  r8 = "[object Uint16Array]",
  s8 = "[object Uint32Array]",
  zi = {};
zi[nT] =
  zi[zj] =
  zi[Xj] =
  zi[Qj] =
  zi[Fj] =
  zi[kj] =
  zi[Zj] =
  zi[Kj] =
  zi[Jj] =
  zi[$j] =
  zi[e8] =
  zi[Vj] =
  zi[jj] =
  zi[lT] =
  zi[Hj] =
  zi[Gj] =
  zi[Wj] =
  zi[qj] =
  zi[t8] =
  zi[i8] =
  zi[r8] =
  zi[s8] =
    !0;
zi[Nj] = zi[oT] = zi[Yj] = !1;
function om(e, t, i, r, s, a) {
  var n,
    o = t & Rj,
    l = t & Lj,
    h = t & Bj;
  if ((i && (n = s ? i(e, r, s, a) : i(e)), n !== void 0)) return n;
  if (!Ka(e)) return e;
  var u = On(e);
  if (u) {
    if (((n = jV(e)), !o)) return j5(e, n);
  } else {
    var c = Ud(e),
      d = c == oT || c == Uj;
    if (Om(e)) return fV(e, o);
    if (c == lT || c == nT || (d && !s)) {
      if (((n = l || d ? {} : _j(e)), !o))
        return l ? EV(e, uV(n, e)) : _V(e, hV(n, e));
    } else {
      if (!zi[c]) return s ? e : {};
      n = bj(e, c, o);
    }
  }
  a || (a = new nm());
  var p = a.get(e);
  if (p) return p;
  a.set(e, n),
    Ij(e)
      ? e.forEach(function (g) {
          n.add(om(g, t, i, g, e, a));
        })
      : Cj(e) &&
        e.forEach(function (g, y) {
          n.set(y, om(g, t, i, y, e, a));
        });
  var f = h ? (l ? aT : Cy) : l ? Gl : Vx,
    m = u ? void 0 : f(e);
  return (
    iN(m || e, function (g, y) {
      m && ((y = g), (g = e[y])), zx(n, y, om(g, t, i, y, e, a));
    }),
    n
  );
}
var hT = om,
  a8 = 1,
  n8 = 4;
function o8(e) {
  return hT(e, a8 | n8);
}
var Dg = o8,
  l8 = "__lodash_hash_undefined__";
function h8(e) {
  return this.__data__.set(e, l8), this;
}
var c8 = h8;
function u8(e) {
  return this.__data__.has(e);
}
var d8 = u8;
function Rm(e) {
  var t = -1,
    i = e == null ? 0 : e.length;
  for (this.__data__ = new Tg(); ++t < i; ) this.add(e[t]);
}
Rm.prototype.add = Rm.prototype.push = c8;
Rm.prototype.has = d8;
var p8 = Rm;
function f8(e, t) {
  for (var i = -1, r = e == null ? 0 : e.length; ++i < r; )
    if (t(e[i], i, e)) return !0;
  return !1;
}
var m8 = f8;
function g8(e, t) {
  return e.has(t);
}
var v8 = g8,
  y8 = 1,
  x8 = 2;
function b8(e, t, i, r, s, a) {
  var n = i & y8,
    o = e.length,
    l = t.length;
  if (o != l && !(n && l > o)) return !1;
  var h = a.get(e),
    u = a.get(t);
  if (h && u) return h == t && u == e;
  var c = -1,
    d = !0,
    p = i & x8 ? new p8() : void 0;
  for (a.set(e, t), a.set(t, e); ++c < o; ) {
    var f = e[c],
      m = t[c];
    if (r) var g = n ? r(m, f, c, t, e, a) : r(f, m, c, e, t, a);
    if (g !== void 0) {
      if (g) continue;
      d = !1;
      break;
    }
    if (p) {
      if (
        !m8(t, function (y, x) {
          if (!v8(p, x) && (f === y || s(f, y, i, r, a))) return p.push(x);
        })
      ) {
        d = !1;
        break;
      }
    } else if (!(f === m || s(f, m, i, r, a))) {
      d = !1;
      break;
    }
  }
  return a.delete(e), a.delete(t), d;
}
var cT = b8;
function w8(e) {
  var t = -1,
    i = Array(e.size);
  return (
    e.forEach(function (r, s) {
      i[++t] = [s, r];
    }),
    i
  );
}
var _8 = w8;
function S8(e) {
  var t = -1,
    i = Array(e.size);
  return (
    e.forEach(function (r) {
      i[++t] = r;
    }),
    i
  );
}
var A8 = S8,
  M8 = 1,
  E8 = 2,
  C8 = "[object Boolean]",
  T8 = "[object Date]",
  P8 = "[object Error]",
  D8 = "[object Map]",
  O8 = "[object Number]",
  I8 = "[object RegExp]",
  R8 = "[object Set]",
  L8 = "[object String]",
  B8 = "[object Symbol]",
  z8 = "[object ArrayBuffer]",
  F8 = "[object DataView]",
  ZS = Ca ? Ca.prototype : void 0,
  Wv = ZS ? ZS.valueOf : void 0;
function k8(e, t, i, r, s, a, n) {
  switch (i) {
    case F8:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      (e = e.buffer), (t = t.buffer);
    case z8:
      return !(e.byteLength != t.byteLength || !a(new Im(e), new Im(t)));
    case C8:
    case T8:
    case O8:
      return Bx(+e, +t);
    case P8:
      return e.name == t.name && e.message == t.message;
    case I8:
    case L8:
      return e == t + "";
    case D8:
      var o = _8;
    case R8:
      var l = r & M8;
      if ((o || (o = A8), e.size != t.size && !l)) return !1;
      var h = n.get(e);
      if (h) return h == t;
      (r |= E8), n.set(e, t);
      var u = cT(o(e), o(t), r, s, a, n);
      return n.delete(e), u;
    case B8:
      if (Wv) return Wv.call(e) == Wv.call(t);
  }
  return !1;
}
var N8 = k8,
  U8 = 1,
  V8 = Object.prototype,
  j8 = V8.hasOwnProperty;
function H8(e, t, i, r, s, a) {
  var n = i & U8,
    o = Cy(e),
    l = o.length,
    h = Cy(t),
    u = h.length;
  if (l != u && !n) return !1;
  for (var c = l; c--; ) {
    var d = o[c];
    if (!(n ? d in t : j8.call(t, d))) return !1;
  }
  var p = a.get(e),
    f = a.get(t);
  if (p && f) return p == t && f == e;
  var m = !0;
  a.set(e, t), a.set(t, e);
  for (var g = n; ++c < l; ) {
    d = o[c];
    var y = e[d],
      x = t[d];
    if (r) var b = n ? r(x, y, d, t, e, a) : r(y, x, d, e, t, a);
    if (!(b === void 0 ? y === x || s(y, x, i, r, a) : b)) {
      m = !1;
      break;
    }
    g || (g = d == "constructor");
  }
  if (m && !g) {
    var _ = e.constructor,
      S = t.constructor;
    _ != S &&
      "constructor" in e &&
      "constructor" in t &&
      !(
        typeof _ == "function" &&
        _ instanceof _ &&
        typeof S == "function" &&
        S instanceof S
      ) &&
      (m = !1);
  }
  return a.delete(e), a.delete(t), m;
}
var G8 = H8,
  W8 = 1,
  KS = "[object Arguments]",
  JS = "[object Array]",
  uf = "[object Object]",
  q8 = Object.prototype,
  $S = q8.hasOwnProperty;
function Y8(e, t, i, r, s, a) {
  var n = On(e),
    o = On(t),
    l = n ? JS : Ud(e),
    h = o ? JS : Ud(t);
  (l = l == KS ? uf : l), (h = h == KS ? uf : h);
  var u = l == uf,
    c = h == uf,
    d = l == h;
  if (d && Om(e)) {
    if (!Om(t)) return !1;
    (n = !0), (u = !1);
  }
  if (d && !u)
    return (
      a || (a = new nm()),
      n || XC(e) ? cT(e, t, i, r, s, a) : N8(e, t, l, i, r, s, a)
    );
  if (!(i & W8)) {
    var p = u && $S.call(e, "__wrapped__"),
      f = c && $S.call(t, "__wrapped__");
    if (p || f) {
      var m = p ? e.value() : e,
        g = f ? t.value() : t;
      return a || (a = new nm()), s(m, g, i, r, a);
    }
  }
  return d ? (a || (a = new nm()), G8(e, t, i, r, s, a)) : !1;
}
var X8 = Y8;
function uT(e, t, i, r, s) {
  return e === t
    ? !0
    : e == null || t == null || (!So(e) && !So(t))
    ? e !== e && t !== t
    : X8(e, t, i, r, uT, s);
}
var Q8 = uT;
function Z8(e, t) {
  return e != null && t in Object(e);
}
var K8 = Z8;
function J8(e, t, i) {
  t = du(t, e);
  for (var r = -1, s = t.length, a = !1; ++r < s; ) {
    var n = Pg(t[r]);
    if (!(a = e != null && i(e, n))) break;
    e = e[n];
  }
  return a || ++r != s
    ? a
    : ((s = e == null ? 0 : e.length),
      !!s && Fx(s) && Lx(n, s) && (On(e) || Nx(e)));
}
var $8 = J8;
function eH(e, t) {
  return e != null && $8(e, t, K8);
}
var tH = eH,
  iH = function () {
    return Ja.Date.now();
  },
  qv = iH,
  rH = "Expected a function",
  sH = Math.max,
  aH = Math.min;
function nH(e, t, i) {
  var r,
    s,
    a,
    n,
    o,
    l,
    h = 0,
    u = !1,
    c = !1,
    d = !0;
  if (typeof e != "function") throw new TypeError(rH);
  (t = CS(t) || 0),
    Ka(i) &&
      ((u = !!i.leading),
      (c = "maxWait" in i),
      (a = c ? sH(CS(i.maxWait) || 0, t) : a),
      (d = "trailing" in i ? !!i.trailing : d));
  function p(M) {
    var C = r,
      A = s;
    return (r = s = void 0), (h = M), (n = e.apply(A, C)), n;
  }
  function f(M) {
    return (h = M), (o = setTimeout(y, t)), u ? p(M) : n;
  }
  function m(M) {
    var C = M - l,
      A = M - h,
      T = t - C;
    return c ? aH(T, a - A) : T;
  }
  function g(M) {
    var C = M - l,
      A = M - h;
    return l === void 0 || C >= t || C < 0 || (c && A >= a);
  }
  function y() {
    var M = qv();
    if (g(M)) return x(M);
    o = setTimeout(y, m(M));
  }
  function x(M) {
    return (o = void 0), d && r ? p(M) : ((r = s = void 0), n);
  }
  function b() {
    o !== void 0 && clearTimeout(o), (h = 0), (r = l = s = o = void 0);
  }
  function _() {
    return o === void 0 ? n : x(qv());
  }
  function S() {
    var M = qv(),
      C = g(M);
    if (((r = arguments), (s = this), (l = M), C)) {
      if (o === void 0) return f(l);
      if (c) return clearTimeout(o), (o = setTimeout(y, t)), p(l);
    }
    return o === void 0 && (o = setTimeout(y, t)), n;
  }
  return (S.cancel = b), (S.flush = _), S;
}
var Yx = nH;
function oH(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var lH = oH;
function hH(e, t) {
  return t.length < 2 ? e : KC(e, Z6(t, 0, -1));
}
var cH = hH;
function uH(e, t) {
  return Q8(e, t);
}
var dT = uH;
function dH(e, t) {
  return (t = du(t, e)), (e = cH(e, t)), e == null || delete e[Pg(lH(t))];
}
var pH = dH;
function fH(e) {
  return X6(e) ? void 0 : e;
}
var mH = fH,
  gH = 1,
  vH = 2,
  yH = 4,
  xH = $C(function (e, t) {
    var i = {};
    if (e == null) return i;
    var r = !1;
    (t = UC(t, function (a) {
      return (a = du(a, e)), r || (r = a.length > 1), a;
    })),
      hp(e, aT(e), i),
      r && (i = hT(i, gH | vH | yH, mH));
    for (var s = t.length; s--; ) pH(i, t[s]);
    return i;
  }),
  Oy = xH;
function bH(e, t, i, r) {
  if (!Ka(e)) return e;
  t = du(t, e);
  for (var s = -1, a = t.length, n = a - 1, o = e; o != null && ++s < a; ) {
    var l = Pg(t[s]),
      h = i;
    if (l === "__proto__" || l === "constructor" || l === "prototype") return e;
    if (s != n) {
      var u = o[l];
      (h = r ? r(u, l, o) : void 0),
        h === void 0 && (h = Ka(u) ? u : Lx(t[s + 1]) ? [] : {});
    }
    zx(o, l, h), (o = o[l]);
  }
  return e;
}
var wH = bH;
function _H(e, t, i) {
  for (var r = -1, s = t.length, a = {}; ++r < s; ) {
    var n = t[r],
      o = KC(e, n);
    i(o, n) && wH(a, du(n, e), o);
  }
  return a;
}
var SH = _H;
function AH(e, t) {
  return SH(e, t, function (i, r) {
    return tH(e, r);
  });
}
var MH = AH,
  EH = $C(function (e, t) {
    return e == null ? {} : MH(e, t);
  }),
  bo = EH,
  CH = "Expected a function";
function TH(e, t, i) {
  var r = !0,
    s = !0;
  if (typeof e != "function") throw new TypeError(CH);
  return (
    Ka(i) &&
      ((r = "leading" in i ? !!i.leading : r),
      (s = "trailing" in i ? !!i.trailing : s)),
    Yx(e, t, { leading: r, maxWait: t, trailing: s })
  );
}
var PH = TH;
function pT(e) {
  for (let t of Object.keys(e)) e[t] === void 0 && delete e[t];
  return e;
}
function In(e, t) {
  return Object.setPrototypeOf(e, t), e;
}
var DH = () =>
    typeof window > "u"
      ? !1
      : window.navigator.userAgent.toLowerCase().includes(" electron/"),
  OH = () =>
    typeof window > "u"
      ? !1
      : window.navigator.platform.toUpperCase().includes("MAC"),
  IH = () =>
    typeof window > "u"
      ? !1
      : /iPad|iPhone|iPod/.test(window.navigator.userAgent) ||
        (Og && "ontouchend" in document),
  RH = () =>
    typeof window > "u"
      ? !1
      : window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1,
  LH = () =>
    typeof window > "u"
      ? !1
      : "ontouchstart" in window || navigator.maxTouchPoints > 0,
  BH = () => {
    if (typeof window > "u") return !1;
    let e = navigator.userAgent,
      t = navigator.vendor;
    return /Safari/i.test(e) && /Apple Computer/.test(t);
  },
  zH = () => {
    if (typeof window > "u") return null;
    let e = navigator.userAgent.match(/Version\/(\d+\.\d)/);
    return e && e[1];
  },
  FH = () => {
    if (typeof window > "u") return;
    let e = new URLSearchParams(window.location.search).get(
      "desktop-app-version"
    );
    return e
      ? (window.localStorage.setItem("desktop-app-version", e), e)
      : window.localStorage.getItem("desktop-app-version") ?? "0.0.6";
  },
  kH = DH(),
  Bee = kH ? FH() : void 0,
  Og = OH(),
  Xx = IH(),
  NH = RH(),
  Js = LH(),
  e2 = BH(),
  t2 = Number(zH());
function fT(e) {
  return Array.isArray(e) ? e : [e];
}
function mT(e, t) {
  let i = 0;
  for (; i < e.length && i < t.length; ) {
    if (e[i] < t[i]) return -1;
    if (e[i] > t[i]) return 1;
    i += 1;
  }
  return i !== t.length ? -1 : i !== e.length ? 1 : 0;
}
function df(e) {
  return Og ? e.metaKey : e.ctrlKey;
}
function UH(e) {
  return e.wheelDeltaY === 0 || e.deltaY === 0
    ? Og && e.shiftKey && Math.abs(e.wheelDeltaX) >= 120
      ? !1
      : e.wheelDeltaX
      ? e.wheelDeltaX === -3 * e.deltaX ||
        e.wheelDeltaX === -3 * window.devicePixelRatio * e.deltaX
      : e.deltaMode === 0
    : e.wheelDeltaY
    ? e.wheelDeltaY === -3 * e.deltaY ||
      e.wheelDeltaY === -3 * window.devicePixelRatio * e.deltaY
    : e.deltaMode === 0;
}
var Pt = [],
  Lm = {},
  ud = {},
  lm = {};
function gT(e) {
  Pt.includes(e) || Pt.push(e);
}
function Tc(e) {
  delete Lm[e.pointerId];
  for (let t = 0; t < Pt.length; t++)
    if (Pt[t].pointerId === e.pointerId) {
      Pt.splice(t, 1);
      break;
    }
}
function VH() {
  Pt.splice(0, Pt.length);
}
function Bm(e) {
  if (e.pointerType !== "touch") return;
  let t = Lm[e.pointerId];
  t === void 0 && ((t = { x: 0, y: 0 }), (Lm[e.pointerId] = t)),
    (t.x = e.pageX),
    (t.y = e.pageY);
}
function Yv(e) {
  let t = e.pointerId === Pt[0].pointerId ? Pt[1] : Pt[0];
  return Lm[t.pointerId];
}
function vT(e) {
  (ud[e.key] = !0), (lm[e.key] = lm[e.key] === void 0 ? 1 : lm[e.key] + 1);
}
function yT(e) {
  if (Og && ud.Meta) for (let t in ud) ud[t] = !1;
  else ud[e.key] = !1;
  lm = {};
}
function jH(e) {
  e.addEventListener("pointerdown", gT, !0),
    e.addEventListener("pointerdown", Bm, !0),
    e.addEventListener("pointermove", Bm, !0),
    e.addEventListener("pointerup", Tc, !0),
    e.addEventListener("pointercancel", Tc, !0),
    e.addEventListener("pointerleave", Tc, !0),
    window.addEventListener("keydown", vT, !0),
    window.addEventListener("keyup", yT, !0);
}
function HH(e) {
  e.removeEventListener("pointerdown", gT, !0),
    e.removeEventListener("pointerdown", Bm, !0),
    e.removeEventListener("pointermove", Bm, !0),
    e.removeEventListener("pointerup", Tc, !0),
    e.removeEventListener("pointercancel", Tc, !0),
    e.removeEventListener("pointerleave", Tc, !0),
    window.removeEventListener("keydown", vT, !0),
    window.removeEventListener("keyup", yT, !0);
}
var xT,
  GH = new Promise((e) => {
    xT = e;
  }),
  pf;
function WH() {
  if (pf) return pf;
  async function e() {
    let t = "https://unpkg.com/@splinetool/navmesh-wasm@1.0.31/build",
      i = import("./navmesh.js"),
      [r, s] = await Promise.all([
        i,
        fetch(`${t}/navmesh.wasm`).then((o) => o.arrayBuffer()),
      ]),
      a = r.default,
      n = await a({ wasmBinary: s });
    xT(n);
  }
  return (pf = e()), pf;
}
var bT,
  qH = new Promise((e) => {
    bT = e;
  }),
  ff;
function YH() {
  if (ff) return ff;
  async function e() {
    let t = await import("./physics.js");
    await t.init(), bT(t);
  }
  return (ff = e()), ff;
}
var Ft = class {
  modifyById(e, t) {
    let i = this;
    if (i[e] === void 0) throw new Error("not expected");
    {
      let r = { ...i, [e]: t };
      return Object.setPrototypeOf(r, Ft.prototype), r;
    }
  }
  add(e, t) {
    return this.runOp({ type: 1, id: e, data: t })?.data ?? this;
  }
  runOp(e) {
    let t = this;
    if (e.type === 1) {
      let i = t[e.id],
        r;
      i === void 0
        ? (r = { type: 2, id: e.id })
        : (r = { type: 1, id: e.id, data: i });
      let { id: s, data: a } = e,
        n = { ...t, [s]: a };
      return (
        Object.setPrototypeOf(n, Ft.prototype),
        { data: n, actual: e, reverse: r }
      );
    } else if (e.type === 2) {
      let { id: i } = e,
        r = t[i];
      if (r === void 0) return null;
      {
        let s = { ...t };
        return (
          Object.setPrototypeOf(s, Ft.prototype),
          delete s[i],
          { data: s, actual: e, reverse: { type: 1, id: i, data: r } }
        );
      }
    }
    return null;
  }
};
function Qx(e) {
  if (e.deepFreeze !== void 0) {
    e.deepFreeze(e);
    return;
  }
  let t = Object.getOwnPropertyNames(e);
  for (let i of t) {
    let r = e[i];
    r && typeof r == "object" && Qx(r);
  }
  return Object.freeze(e);
}
function XH(e, t) {
  let i = 0;
  for (; i < e.length && i < t.length; ) {
    if (e[i] < t[i]) return -1;
    if (e[i] > t[i]) return 1;
    i += 1;
  }
  return i !== t.length ? -1 : i !== e.length ? 1 : 0;
}
var wT = class extends Error {};
function Xv(e) {
  let t = { ...e };
  return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), t;
}
function $o(e, t, i) {
  if (
    (e === void 0
      ? t === void 0
        ? ((e = 0), (t = 10))
        : (e = t - 10)
      : t === void 0 && (t = e + 10),
    e > t)
  ) {
    let a = e;
    (e = t), (t = a);
  }
  let r = [],
    s = 1 / (i + 1);
  for (let a = 0; a < i; a++) {
    let n = e + (t - e) * (a + 0.75 + Math.random() * 0.5) * s;
    r.push(n);
  }
  return r;
}
function Zx(e) {
  return (
    e instanceof Uint8Array ||
    e instanceof Uint16Array ||
    e instanceof Uint32Array ||
    e instanceof Int8Array ||
    e instanceof Int16Array ||
    e instanceof Int32Array ||
    e instanceof Float32Array ||
    e instanceof Float64Array
  );
}
function QH() {
  return typeof process < "u";
}
function _T(e, t) {
  for (let i of e) t(i.id, i.data) !== !0 && _T(i.children, t);
}
function ST(e, t) {
  if (t(e.id, e.data) !== !0) for (let i of e.children) ST(i, t);
}
var as = class extends Array {
    constructor(...e) {
      super(...e), Object.setPrototypeOf(this, as.prototype);
    }
    deepFreeze() {
      let e = 0;
      for (; e < this.length; ) Qx(this[e]), e++;
    }
    fillCaches0(e, t) {
      this.objCaches.set(e.id, e), this.parentCaches.set(e.id, t);
      for (let i of e.children) this.fillCaches0(i, e.id);
    }
    fillCaches() {
      if (this.objCaches === void 0) {
        (this.objCaches = new Map()), (this.parentCaches = new Map());
        for (let e of this) this.fillCaches0(e, null);
      }
    }
    randomId() {
      this.fillCaches();
      let e = Array.from(this.objCaches.keys());
      if (e.length !== 0)
        return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
    }
    nonExistOrDescendantOf(e, t) {
      if (!this.has(e)) return !0;
      for (; e; ) {
        let i = this.parent(e);
        if (i === t) return !0;
        e = i;
      }
      return !1;
    }
    rootAcestor(e) {
      for (; e; ) {
        let t = this.parent(e);
        if (t) e = t;
        else return e;
      }
      return e;
    }
    isDescendantOf(e, t) {
      for (; e; ) {
        let i = this.parent(e);
        if (i === t) return !0;
        e = i;
      }
      return !1;
    }
    data(e) {
      return this.get(e)?.data;
    }
    has(e) {
      return this.childrenOf(e) !== void 0;
    }
    get(e) {
      return this.fillCaches(), this.objCaches.get(e);
    }
    childrenOf(e) {
      return e === null ? this : this.get(e)?.children;
    }
    traverseFrom(e, t) {
      if (e === null) this.traverse(t);
      else {
        let i = this.get(e);
        i && ST(i, t);
      }
    }
    traverse(e) {
      _T(this, e);
    }
    totalSize() {
      return this.fillCaches(), this.objCaches.size;
    }
    parent(e) {
      return this.fillCaches(), this.parentCaches.get(e);
    }
    childrenArray(e) {
      return e === null ? this : this.get(e).children;
    }
    modifyById(e, t) {
      if (this.get(e) === void 0) throw new Error("not expected");
      {
        let i = this.parent(e),
          r = this.childrenArray(i),
          s = r.findIndex((n) => n.id === e);
        if (s < 0) throw new Error("not expected");
        let a = r[s];
        return (
          (r = [...r]), (r[s] = { ...a, data: t }), this.modifyArrayBy(i, r)
        );
      }
    }
    modifyArrayBy(e, t) {
      let i = e,
        r = t;
      for (; i !== null; ) {
        let a = r,
          n = i;
        if (((i = this.parent(i)), i === void 0)) throw new Error();
        r = this.childrenArray(i);
        let o = r.findIndex((l) => l.id === n);
        if (o < 0) throw new Error();
        (r = [...r]), (r[o] = { ...r[o], children: a });
      }
      Object.setPrototypeOf(r, as.prototype);
      let s = r;
      return s.fillCaches(), s;
    }
    runOp(e) {
      switch (e.type) {
        case 7:
          return this.addOp(e);
        case 8:
          return this.deleteOp(e);
        case 9:
          return this.moveOp(e);
      }
      return null;
    }
    checkDuplicatedIdRec({ id: e, children: t }) {
      if (this.get(e) !== void 0) return !0;
      for (let i of t) if (this.checkDuplicatedIdRec(i)) return !0;
      return !1;
    }
    addOp(e) {
      let { parent: t, fi: i, id: r, data: s, children: a } = e;
      if (
        (t !== null && this.get(t) === void 0) ||
        this.checkDuplicatedIdRec(e)
      )
        return null;
      {
        let n = t,
          o = this.childrenArray(n),
          l = { fi: i, id: r, data: s, children: a };
        return (
          (o = [...o, l]),
          o.sort((h, u) => h.fi - u.fi),
          (e.localIndex = o.indexOf(l)),
          {
            data: this.modifyArrayBy(n, o),
            actual: e,
            reverse: { type: 8, id: r },
          }
        );
      }
    }
    deleteOp(e) {
      let { id: t } = e;
      if (this.get(t) === null) return null;
      {
        let i = this.parent(t);
        if (i === void 0) return null;
        let r = this.childrenArray(i),
          s = r.findIndex((n) => n.id === t);
        (e.localIndex = s), (r = [...r]);
        let a = r.splice(s, 1)[0];
        return {
          data: this.modifyArrayBy(i, r),
          actual: e,
          reverse: { type: 7, ...a, parent: i },
        };
      }
    }
    moveOp(e) {
      let { parent: t, fi: i, id: r } = e;
      if (t !== null && this.get(t) === void 0)
        return this.deleteOp({ type: 8, id: r });
      if (t !== null) {
        let c = t;
        for (; c !== null; ) {
          if (c === void 0) throw new Error();
          if (c === r) throw new wT("cyclic tree");
          c = this.parent(c);
        }
      }
      let s = this.parent(r);
      if (s === void 0) return null;
      let a = s,
        n = this.childrenArray(s),
        o = n.findIndex((c) => c.id === r);
      n = [...n];
      let l = n.splice(o, 1)[0],
        h = this.modifyArrayBy(s, n);
      (s = t), (n = h.childrenArray(s));
      let u = l.fi;
      return (
        (l = { ...l, fi: i }),
        (n = [...n, l]),
        n.sort((c, d) => c.fi - d.fi),
        (e.localIndex = n.indexOf(l)),
        (h = h.modifyArrayBy(s, n)),
        { data: h, actual: e, reverse: { type: 9, parent: a, fi: u, id: r } }
      );
    }
    previous(e, t) {
      if (t === null) {
        let r = this.childrenArray(e);
        return r.length === 0 ? null : r[r.length - 1].id;
      }
      let i = null;
      for (let r of this.childrenArray(e)) {
        if (r.id === t) return i;
        i = r.id;
      }
      return null;
    }
    traverseSortNext(e) {
      let t = this.parent(e);
      if (t !== void 0) {
        let i = this.childrenArray(t),
          r = i.findIndex((s) => s.id === e) + 1;
        if (r < i.length) return i[r].id;
        if (t) return this.traverseSortNext(t);
      }
    }
    sortNext(e) {
      let t = this.childrenArray(e);
      return t.length > 0 ? t[0].id : this.traverseSortNext(e);
    }
    traverseSortPrevious(e) {
      let t = this.childrenArray(e);
      return t.length > 0 ? this.traverseSortPrevious(t[t.length - 1].id) : e;
    }
    sortPrevious(e) {
      let t = this.parent(e);
      if (t !== void 0) {
        let i = this.childrenArray(t),
          r = i.findIndex((s) => s.id === e) - 1;
        return r >= 0 ? this.traverseSortPrevious(i[r].id) : t;
      }
    }
    getAllSorted(e) {
      let t = [];
      for (let i of e) {
        let r = this.getWithSortKey(i.id);
        r !== void 0 && t.push({ ...i, ...r });
      }
      t.sort((i, r) => XH(i.sortKey, r.sortKey));
      for (let i of t) delete i.sortKey;
      return t;
    }
    getWithSortKey(e) {
      var t = e;
      let i = [],
        r = this.get(t),
        s = r;
      if (r !== void 0) {
        for (; t; )
          i.splice(0, 0, r.fi),
            (t = this.parent(t)),
            t !== null && (r = this.get(t));
        return { ...s, sortKey: i };
      }
    }
    insertBeforeHelper(e, t, i) {
      return this.insertAfterHelper(e, this.previous(e, t), i);
    }
    insertAfterHelper(e, t, i) {
      let r = this.childrenArray(e);
      if (t === null) {
        if (r.length === 0) return $o(0, i, i);
        {
          let s = r[0].fi;
          return $o(s - i, s, i);
        }
      } else {
        let s = this.get(t);
        if (s === void 0 || this.parent(t) !== e)
          throw new Error("illegal args");
        let a = r.find((n) => n.fi > s.fi);
        if (a === void 0) {
          let n = r[r.length - 1].fi;
          return $o(n, n + i, i);
        } else return $o(s.fi, a.fi, i);
      }
    }
  },
  zm;
((e) => {
  function t(i, r) {
    if (r.type !== 0) return null;
    if (Array.isArray(i)) {
      let s = r.props,
        a = {},
        n = [...i],
        o = !1;
      if (s)
        for (let l of Object.keys(s)) {
          let h = parseInt(l);
          if (isNaN(h)) throw new Error("wrong index");
          (a[l] = n[h]), (n[h] = s[l]), (o = !0);
        }
      return o ? { data: n, actual: r, reverse: { type: 0, props: a } } : null;
    } else {
      let s = r.props,
        a = {},
        n = { ...i },
        o = !1;
      if (s)
        for (let l of Object.keys(s)) {
          a[l] = n[l];
          let h = s[l];
          h === void 0 ? delete n[l] : (n[l] = h), (o = !0);
        }
      return o ? { data: n, actual: r, reverse: { type: 0, props: a } } : null;
    }
  }
  e.runOp = t;
})(zm || (zm = {}));
var At = class extends Array {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, At.prototype);
  }
  deepFreeze() {
    let e = 0;
    for (; e < this.length; ) Qx(this[e]), e++;
  }
  fillCaches0(e) {
    this.objCaches.set(e.id, e);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      (this.objCaches = new Map()),
        (Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = !1);
      for (let e of this) this.fillCaches0(e);
    }
  }
  randomId() {
    this.fillCaches();
    let e = Array.from(this.objCaches.keys());
    if (e.length !== 0)
      return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)];
  }
  data(e) {
    return this.get(e)?.data;
  }
  get(e) {
    return this.fillCaches(), this.objCaches.get(e);
  }
  modifyById(e, t) {
    if (this.get(e) === void 0) throw new Error("not expected");
    {
      let i = this,
        r = i.findIndex((a) => a.id === e);
      if (r < 0) throw new Error("not expected");
      let s = i[r];
      return (i = [...i]), (i[r] = { ...s, data: t }), this.modifyArrayBy(i);
    }
  }
  modifyArrayBy(e) {
    Object.setPrototypeOf(e, At.prototype);
    let t = e;
    return QH() || t.fillCaches(), t;
  }
  runOp(e) {
    switch (e.type) {
      case 4:
        return this.addOp(e);
      case 5:
        return this.deleteOp(e);
      case 6:
        return this.moveOp(e);
    }
    return null;
  }
  addOp(e) {
    let { fi: t, id: i, data: r } = e,
      s = this,
      a = { fi: t, id: i, data: r };
    return (
      (s = [...s, a]),
      s.sort((n, o) => n.fi - o.fi),
      (e.localIndex = s.indexOf(a)),
      { data: this.modifyArrayBy(s), actual: e, reverse: { type: 5, id: i } }
    );
  }
  deleteOp(e) {
    let { id: t } = e,
      i = this,
      r = i.findIndex((a) => a.id === t);
    if (r === -1) return null;
    (e.localIndex = r), (i = [...i]);
    let s = i.splice(r, 1)[0];
    return {
      data: this.modifyArrayBy(i),
      actual: e,
      reverse: { type: 4, ...s },
    };
  }
  moveOp(e) {
    let { fi: t, id: i } = e,
      r = this;
    r = [...r];
    let s = r.findIndex((o) => o.id === i);
    if (s === -1) return null;
    let a = r[s].fi,
      n = { ...r[s], fi: t };
    return (
      (r[s] = n),
      r.sort((o, l) => o.fi - l.fi),
      (e.localIndex = r.indexOf(n)),
      {
        data: this.modifyArrayBy(r),
        actual: e,
        reverse: { type: 6, fi: a, id: i },
      }
    );
  }
  previous(e) {
    if (e === null) return this.length === 0 ? null : this[this.length - 1].id;
    let t = null;
    for (let i of this) {
      if (i.id === e) return t;
      t = i.id;
    }
    return null;
  }
  insertBeforeHelper(e, t) {
    return this.insertAfterHelper(this.previous(e), t);
  }
  insertAfterHelper(e, t) {
    let i = this;
    if (e === null) {
      if (i.length === 0) return $o(0, t, t);
      {
        let r = i[0].fi;
        return $o(r - t, r, t);
      }
    } else {
      let r = this.get(e);
      if (r === void 0) throw new Error("illegal args");
      let s = i.find((a) => a.fi > r.fi);
      if (s === void 0) {
        let a = i[i.length - 1].fi;
        return $o(a, a + t, t);
      } else return $o(r.fi, s.fi, t);
    }
  }
};
function qc(e) {
  return e && typeof e == "object" && e instanceof _r;
}
var _r = class {
    unusedFunOverridesTable(e) {}
    runOp(e) {
      let t = [],
        i = this,
        r = 0,
        s = {};
      for (; r < e.path.length; ) {
        if (
          (t.push(i),
          (i = i === void 0 ? void 0 : i[e.path[r]]),
          i !== void 0 && !qc(i))
        )
          return null;
        r += 1;
      }
      i = i ? Xv(i) : new _r();
      for (let [o, l] of Object.entries(e.props)) {
        let h = i[o];
        (s[o] = h), l === void 0 ? delete i[o] : (i[o] = l);
      }
      for (; r > 0; ) {
        if (Object.keys(i).length === 0) {
          let o = t[r - 1];
          o && ((i = Xv(o)), delete i[e.path[r - 1]]);
        } else {
          let o = t[r - 1];
          if (o) {
            let l = Xv(o);
            (l[e.path[r - 1]] = i), (i = l);
          } else {
            let l = new _r();
            (l[e.path[r - 1]] = i), (i = l);
          }
        }
        r -= 1;
      }
      let a = Object.setPrototypeOf(i, _r.prototype),
        n = { ...e, props: s };
      return { data: a, actual: e, reverse: n };
    }
  },
  hl;
((e) => {
  function t(s, a) {
    return Vd(s, a) ?? s;
  }
  e.apply = t;
  function i(s, a) {
    return Jx(s, a);
  }
  e.merge = i;
  function r(s, a) {
    let n = 0,
      o = a.path,
      l = s;
    for (; n < o.length && l !== void 0; ) {
      if (((l = ss.zoomOnce(l, o[n])), l === void 0)) return a;
      if (!qc(l)) return;
      n += 1;
    }
    if (l === void 0) return a;
    if (qc(l))
      if (a.type === 0) {
        let h = { ...a.props };
        for (let u of Object.keys(l)) delete h[u];
        return { ...a, props: h };
      } else if (a.type === 1 || a.type === 4 || a.type === 7) {
        let h = Kx([a], l);
        return h ? (console.log(h), h) : a;
      } else return a;
  }
  e.filterOp = r;
})(hl || (hl = {}));
function Kx(e, t) {
  if (t === void 0) return;
  let i = !1,
    r = e.map((s) => {
      let a = s.id,
        n = Vd(s.data, t[a]);
      if (((i = i || n !== void 0), n === void 0 && (n = s.data), s.children)) {
        let o = Kx(s.children, t);
        return (
          o !== void 0 ? (i = !0) : (o = s.children),
          { ...s, id: a, data: n, children: o }
        );
      } else return { ...s, id: a, data: n };
    });
  if (i) return r;
}
function ZH(e, t) {
  if (t === void 0) return;
  let i = !1,
    r = e.map((s) => {
      let a = s.id,
        n = Vd(s.data, t[a]);
      return (
        (i = i || n !== void 0),
        n === void 0 && (n = s.data),
        { ...s, id: a, data: n }
      );
    });
  if (i) return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), r;
}
function Vd(e, t) {
  if (!qc(t)) return t;
  if (e instanceof as) {
    let i = Kx(e, t);
    return (
      i !== void 0 && Object.setPrototypeOf(i, Object.getPrototypeOf(e)), i
    );
  } else {
    if (e instanceof At) return ZH(e, t);
    if (Array.isArray(e)) {
      let i = !1,
        r = e.map((s, a) => {
          let n = Vd(s, t[a]);
          return (i = i || n !== void 0), n === void 0 && (n = s), n;
        });
      return i
        ? (Object.setPrototypeOf(r, Object.getPrototypeOf(e)), r)
        : void 0;
    } else {
      if (e instanceof _r) return Jx(e, t);
      if (e && typeof e == "object") {
        let i = {},
          r = !1;
        for (let [s, a] of Object.entries(e)) {
          let n = Vd(a, t[s]);
          (r = r || n !== void 0), n === void 0 && (n = a), (i[s] = n);
        }
        return r
          ? (Object.setPrototypeOf(i, Object.getPrototypeOf(e)), i)
          : void 0;
      }
    }
  }
}
function Jx(e, t) {
  if (e === void 0) return t;
  if (t === void 0) return e;
  if (!qc(t)) return t;
  if (!qc(e)) return hl.apply(e, t);
  let i = new Set();
  for (let s of Object.keys(e)) i.add(s);
  for (let s of Object.keys(t)) i.add(s);
  let r = new _r();
  for (let s of i) {
    let a = Jx(e === void 0 ? void 0 : e[s], t === void 0 ? void 0 : t[s]);
    r[s] = a;
  }
  return r;
}
function KH(e, t) {
  let i = { cur: [], result: [], len: 0 };
  return (e = jd(e, t, i) ?? e), [e, i.result];
}
function Fm(e, t) {
  return e === null ? null : ((e.cur[e.len] = t), (e.len += 1), e);
}
function km(e) {
  e && (e.len -= 1);
}
function JH(e) {
  if (e === null) return null;
  e.result.push(e.cur.slice(0, e.len));
}
function AT(e, t, i) {
  let r = !1,
    s = e.map((a) => {
      let n = a.id,
        o = t[n];
      if (
        o !== void 0 &&
        typeof o == "string" &&
        ((r = !0), (n = o), i !== null)
      )
        throw new Error("not supported");
      let l = jd(a.data, t, Fm(i, n));
      km(i), (r = r || l !== void 0), l === void 0 && (l = a.data);
      let h = AT(a.children, t, i);
      return (
        h !== void 0 ? (r = !0) : (h = a.children),
        { ...a, id: n, data: l, children: h }
      );
    });
  if (r) return s;
}
function $H(e, t, i) {
  let r = !1,
    s = e.map((a) => {
      let n = a.id,
        o = t[n];
      if (
        o !== void 0 &&
        typeof o == "string" &&
        ((r = !0), (n = o), i !== null)
      )
        throw new Error("not supported");
      let l = jd(a.data, t, Fm(i, n));
      return (
        km(i),
        (r = r || l !== void 0),
        l === void 0 && (l = a.data),
        { ...a, id: n, data: l }
      );
    });
  if (r) return Object.setPrototypeOf(s, Object.getPrototypeOf(e)), s;
}
function jd(e, t, i) {
  if (e instanceof as) {
    let r = AT(e, t, i);
    return (
      r !== void 0 && Object.setPrototypeOf(r, Object.getPrototypeOf(e)), r
    );
  } else {
    if (e instanceof At) return $H(e, t, i);
    if (Array.isArray(e)) {
      let r = !1,
        s = e.map((a, n) => {
          let o = jd(a, t, Fm(i, n));
          return km(i), (r = r || o !== void 0), o === void 0 && (o = a), o;
        });
      return r
        ? (Object.setPrototypeOf(s, Object.getPrototypeOf(e)), s)
        : void 0;
    } else if (e && typeof e == "object" && !Zx(e)) {
      let r = {},
        s = !1;
      for (let [a, n] of Object.entries(e))
        if (a !== "name") {
          let o = t[a];
          if (typeof o == "string") {
            if (i !== null) throw new Error("not supported");
            (s = !0), (a = o);
          }
          let l = jd(n, t, Fm(i, a));
          km(i), (s = s || l !== void 0), l === void 0 && (l = n), (r[a] = l);
        } else r[a] = n;
      return s
        ? (Object.setPrototypeOf(r, Object.getPrototypeOf(e)), r)
        : void 0;
    } else if (typeof e == "string") {
      let r = t[e];
      return r !== void 0 && JH(i), r;
    } else return;
  }
}
var Nm;
((e) => {
  function t(i, r) {
    let s = ss.zoom(r, i.path);
    if (typeof s == "object") {
      let a = {};
      for (let n of Object.keys(i.props)) a[n] = s[n];
      return { ...i, props: a };
    } else return { ...i, props: {} };
  }
  e.replaceProps = t;
})(Nm || (Nm = {}));
var qr;
((e) => {
  function t(l, h) {
    return { ...l, path: l.path.slice(h) };
  }
  e.drop = t;
  function i(l, h) {
    return r(l, h)?.data ?? l;
  }
  e.applySimple = i;
  function r(l, h) {
    let u = h.path;
    for (var c = []; ; ) {
      let d;
      if (
        (l instanceof _r &&
          h.type === 0 &&
          ((d = l.runOp({ ...h, path: u.slice(c.length) })),
          d === null && (d = void 0)),
        d === void 0 &&
          c.length === u.length &&
          (l instanceof as || l instanceof At || l instanceof Ft
            ? (d = l.runOp(h))
            : (d = zm.runOp(l, h))),
        d !== void 0)
      )
        if (d !== null) {
          let m = d.data;
          for (let g = c.length - 1; g >= 0; g--) {
            let y = u[g],
              x = c[g];
            if (x instanceof as) {
              if (typeof y == "number") throw new Error("illegal arg");
              m = x.modifyById(y, m);
            } else if (x instanceof At) {
              if (typeof y == "number") throw new Error("illegal arg");
              m = x.modifyById(y, m);
            } else if (x instanceof Ft) {
              if (typeof y == "number") throw new Error("illegal arg");
              m = x.modifyById(y, m);
            } else if (x instanceof _r) {
              let b = { ...x, [y]: m };
              m = Object.setPrototypeOf(b, _r.prototype);
            } else if (typeof x == "object")
              if (Array.isArray(x)) {
                if (typeof y == "string" && ((y = parseInt(y)), isNaN(y)))
                  throw new Error("Invalid path");
                let b = m;
                (m = [...x]), (m[y] = b);
              } else m = { ...x, [y]: m };
            else return null;
          }
          return {
            data: m,
            actual: { ...d.actual, path: u },
            reverse: { ...d.reverse, path: u },
          };
        } else return null;
      let p = u[c.length],
        f;
      if (l instanceof as) {
        if (typeof p == "number") throw new Error("");
        f = l.get(p)?.data;
      } else if (l instanceof At) {
        if (typeof p == "number") throw new Error("");
        f = l.get(p)?.data;
      } else l !== null && (f = l[p]);
      if (f !== void 0) c.push(l), (l = f);
      else return null;
    }
  }
  e.apply = r;
  function s(l, h) {
    for (let u = 0; u < l.length && u < h.length; u++)
      if (l[u] !== h[u]) return !0;
    return !1;
  }
  e.pathDisjoint = s;
  function a(l, h) {
    if (l.length !== h.length) return !1;
    for (let u = 0; u < l.length; u++) if (l[u] !== h[u]) return !1;
    return !0;
  }
  e.pathEq = a;
  function n(l, h) {
    return s(l.path, h.path);
  }
  e.commutative = n;
  function o(l, h) {
    return l.type === 0 && h.type === 0 && a(l.path, h.path)
      ? Object.keys(l.props).every((u) => h.props[u] !== void 0)
      : !1;
  }
  e.subsumed = o;
})(qr || (qr = {}));
var Iy;
((e) => {
  function t() {
    return [];
  }
  e.empty = t;
  function i(h, u) {
    let c = [];
    for (let d of h) {
      let [p, ...f] = d.path;
      p === u && c.push({ ...d, path: f });
    }
    return c;
  }
  e.removePrefix = i;
  function r(h, u) {
    return h.map((c) => ({ ...c, path: [u, ...c.path] }));
  }
  e.addPrefix = r;
  function s(h, u) {
    return [...h, ...u];
  }
  e.concat = s;
  function a(h, u) {
    return [...h.filter((c) => !u.some((d) => qr.subsumed(c, d))), ...u];
  }
  e.compress = a;
  function n(h, u) {
    return h.every((c) => u.every((d) => qr.commutative(c, d)));
  }
  e.commutative = n;
  function o(h, u) {
    for (let c of u) {
      let d = l(h, c);
      d !== null && (h = d.data);
    }
    return h;
  }
  e.applyAll = o;
  function l(h, u) {
    var c = h;
    let d = [],
      p = [];
    for (let f of u)
      try {
        if (
          f.type === 3 ||
          (f.type === 5 && f.path[f.path.length - 1] === "variables")
        ) {
          let m, g, y;
          if (
            (f.type === 3
              ? ((m = ss.zoom(c, [...f.path, f.id])),
                (y = qr.apply(c, { ...f, type: 2 })))
              : ((m = ss.zoom(c, [...f.path, f.id, "value"])),
                (y = qr.apply(c, f))),
            y !== null)
          ) {
            c = y.data;
            let [x, b] = KH(c, { [f.id]: m });
            c = x;
            for (let _ = 0; _ < b.length; _++) {
              let S = b[_],
                M = S.pop();
              if (typeof M == "number") {
                let C = [M];
                for (let T = _ + 1; T < b.length; T++) {
                  let P = b[T],
                    R = P[P.length - 1];
                  if (
                    typeof R == "number" &&
                    ss.equal(S, P.slice(0, P.length - 1))
                  )
                    C.push(R), b.splice(T, 1);
                  else break;
                }
                let A = ss.zoom(c, S);
                (g = A.map((T, P) => (C.includes(P) ? f.id : T))),
                  (m = A),
                  (M = S.pop());
              } else {
                if (M === "alphaOverride" || M === "alpha") {
                  m /= 100;
                  let C = m,
                    A = ss.zoom(c, S.slice(0, S.length - 2)),
                    T = A.layers.map((P) =>
                      P.id === S[S.length - 1]
                        ? { ...P, data: { ...P.data, [M]: C } }
                        : P
                    );
                  Object.setPrototypeOf(T, Object.getPrototypeOf(A.layers)),
                    (A.layers = T);
                }
                g = f.id;
              }
              d.push({ type: 0, path: S, props: { [M]: m } }),
                p.push({ type: 0, path: S, props: { [M]: g } });
            }
            p.push(y.reverse), d.push(y.actual);
          }
        } else {
          let m = qr.apply(c, f);
          m !== null && (d.push(m.actual), (c = m.data), p.push(m.reverse));
        }
      } catch (m) {
        if (m instanceof wT) return null;
        throw m;
      }
    return { data: c, actual: d, reverse: p.reverse() };
  }
  e.apply = l;
})(Iy || (Iy = {}));
var MT = Symbol(),
  eG = Symbol(),
  Ig = Symbol(),
  cp = class {
    reportOp(e, t, i = []) {
      let r = this;
      if (t === null) return;
      r._current = t.data;
      let s = i;
      for (; !(r instanceof CT); ) {
        let a = r._path,
          n = r._current;
        if ((a !== "" && s.splice(0, 0, a), (r = r._parent), r === null))
          return;
        r.update(a, n);
      }
      r.push(s, e, t.actual, t.reverse);
    }
    deleteChildren(e) {
      if (this._children) {
        let t = this._children[e];
        if (t) {
          let i = t[Ig];
          i && i(), delete this._children[e];
        }
      }
    }
  },
  tG = class extends cp {
    constructor(e, t, i) {
      super(), (this._parent = e), (this._path = t), (this._current = i);
    }
    update(e, t) {
      if (Array.isArray(this._current)) {
        if (typeof e == "string" && ((e = parseInt(e)), isNaN(e)))
          throw new Error("Invalid path");
        (this._current = [...this._current]), (this._current[e] = t);
      } else this._current = { ...this._current, [e]: t };
    }
    runOp(e) {
      this.reportOp(e, zm.runOp(this._current, e), e.path);
    }
  },
  iG = class extends cp {
    constructor(e, t, i) {
      super(), (this._parent = e), (this._path = t), (this._current = i);
    }
    update(e, t) {
      (this._current = { ...this._current, [e]: t }),
        Object.setPrototypeOf(this._current, Ft.prototype);
    }
    runOp(e) {
      this.reportOp(e, this._current.runOp(e));
    }
  },
  ET = {
    get(e, t) {
      if (t === Ig)
        return () => {
          e._parent = null;
        };
      if (t === MT) return e._current;
      if (t === eG) return e;
      let { _current: i, _children: r } = e;
      if (t === "push" && Array.isArray(i))
        throw new Error("not supported to expand array");
      let s = r === void 0 ? void 0 : r[t];
      if (s !== void 0) return s;
      let a = i[t],
        n = Rg(e, t, a);
      return n !== a
        ? (r === void 0 && ((r = {}), (e._children = r)), (r[t] = n), n)
        : a;
    },
    has(e, t) {
      return t in e._current;
    },
    ownKeys(e) {
      return Reflect.ownKeys(e._current);
    },
    defineProperty() {
      throw Error("not supported");
    },
    getPrototypeOf(e) {
      return Object.getPrototypeOf(e._current);
    },
    setPrototypeOf() {
      throw Error("not supported");
    },
    getOwnPropertyDescriptor(e, t) {
      let i = e._current,
        r = Reflect.getOwnPropertyDescriptor(i, t);
      return (
        r && {
          writable: !0,
          configurable: !0,
          enumerable: r.enumerable,
          value: i[t],
        }
      );
    },
  },
  rG = {
    ...ET,
    set(e, t, i) {
      let r = { type: 0, props: { [t]: hr(i) ?? i } };
      return e.deleteChildren(t), e.runOp(r), !0;
    },
    deleteProperty(e, t) {
      let i = { type: 0, props: { [t]: void 0 } };
      return e.deleteChildren(t), e.runOp(i), !0;
    },
  },
  sG = {
    ...ET,
    set(e, t, i) {
      return (
        i === void 0
          ? this.deleteProperty(e, t)
          : (e.deleteChildren(t), e.runOp({ type: 1, id: t, data: i })),
        !0
      );
    },
    deleteProperty(e, t) {
      return e.runOp({ type: 2, id: t }), !0;
    },
  },
  $x = class extends cp {
    constructor(e, t, i) {
      super(),
        (this._children = {}),
        (this._parent = e),
        (this._path = t),
        (this._current = i),
        (this[Ig] = () => {
          this._parent = null;
        });
    }
    unproxy() {
      return this._current;
    }
    update(e, t) {
      this._current = this._current.modifyById(e, t);
    }
    runOp(e) {
      this.reportOp(e, this._current.runOp(e));
    }
    randomId() {
      return this._current.randomId();
    }
    isDescendantOf(e, t) {
      return this._current.isDescendantOf(e, t);
    }
    childrenOf(e) {
      return this._current.childrenOf(e);
    }
    traverse(e) {
      return this._current.traverse(e);
    }
    get(e) {
      return this._current.get(e);
    }
    parent(e) {
      return this._current.parent(e);
    }
    traverse(e) {
      this._current.traverse((t, i) => {
        e(t, this.data(t));
      });
    }
    data(e) {
      let { _current: t, _children: i } = this,
        r = i === void 0 ? void 0 : i[e];
      if (r !== void 0) return r;
      let s = t.get(e)?.data,
        a = Rg(this, e, s);
      return a !== s
        ? (i === void 0 && ((i = {}), (this._children = i)), (i[e] = a), a)
        : s;
    }
    add(e, t, i, r, s) {
      this.runOp({ type: 7, parent: e, fi: t, id: i, data: r, children: s });
    }
    move(e, t, i) {
      this.runOp({ type: 9, parent: e, fi: t, id: i });
    }
    insertAfter(e, t, i) {
      let r = this._current.insertAfterHelper(e, t, i.length);
      for (let s = 0; s < i.length; s++) {
        let a = i[s];
        this.add(e, r[s], a.id, a.data, a.children);
      }
    }
    insertBefore(e, t, i) {
      let r = this._current.insertBeforeHelper(e, t, i.length);
      for (let s = 0; s < i.length; s++) {
        let a = i[s];
        this.add(e, r[s], a.id, a.data, a.children);
      }
    }
    moveAfter(e, t, i) {
      let r = this._current.insertAfterHelper(e, t, i.length);
      for (let s = 0; s < i.length; s++) {
        let a = i[s];
        this.move(e, r[s], a);
      }
    }
    moveBefore(e, t, i) {
      let r = this._current.insertBeforeHelper(e, t, i.length);
      for (let s = 0; s < i.length; s++) {
        let a = i[s];
        this.move(e, r[s], a);
      }
    }
    delete(e) {
      this.deleteChildren(e), this.runOp({ type: 8, id: e });
    }
    sortNext(e) {
      return this._current.sortNext(e);
    }
    sortPrevious(e) {
      return this._current.sortPrevious(e);
    }
    getAllSorted(e) {
      return this._current.getAllSorted(e);
    }
  },
  eb = class extends cp {
    constructor(e, t, i) {
      super(),
        (this._children = {}),
        (this._parent = e),
        (this._path = t),
        (this._current = i),
        (this[Ig] = () => {
          this._parent = null;
        });
    }
    unproxy() {
      return this._current;
    }
    get length() {
      return this._current.length;
    }
    forEach(e) {
      let t = this.length;
      for (let i = 0; i < t; i++) {
        let r = this._current[i].id,
          s = this._current[i].fi;
        e(this.data(this._current[i].id), r, s);
      }
    }
    find(e) {
      let t = this.length;
      for (let i = 0; i < t; i++) {
        let r = this._current[i].id;
        if (e(this.data(r), r)) return this.get(r);
      }
    }
    update(e, t) {
      this._current = this._current.modifyById(e, t);
    }
    randomId() {
      return this._current.randomId();
    }
    get(e) {
      return { ...this._current.get(e), data: this.data(e) };
    }
    data(e) {
      let { _current: t, _children: i } = this,
        r = i === void 0 ? void 0 : i[e];
      if (r !== void 0) return r;
      let s = t.get(e)?.data,
        a = Rg(this, e, s);
      return a !== s
        ? (i === void 0 && ((i = {}), (this._children = i)), (i[e] = a), a)
        : s;
    }
    runOp(e) {
      this.reportOp(e, this._current.runOp(e));
    }
    add(e, t, i) {
      this.runOp({ type: 4, fi: e, id: t, data: i });
    }
    move(e, t) {
      this.runOp({ type: 6, fi: e, id: t });
    }
    insertAfter(e, t) {
      let i = this._current.insertAfterHelper(e, t.length);
      for (let r = 0; r < t.length; r++) {
        let s = t[r];
        this.add(i[r], s.id, s.data);
      }
    }
    insertBefore(e, t) {
      let i = this._current.insertBeforeHelper(e, t.length);
      for (let r = 0; r < t.length; r++) {
        let s = t[r];
        this.add(i[r], s.id, s.data);
      }
    }
    moveAfter(e, t) {
      let i = this._current.insertAfterHelper(e, t.length);
      for (let r = 0; r < t.length; r++) {
        let s = t[r];
        this.move(i[r], s);
      }
    }
    moveBefore(e, t) {
      let i = this._current.insertBeforeHelper(e, t.length);
      for (let r = 0; r < t.length; r++) {
        let s = t[r];
        this.move(i[r], s);
      }
    }
    delete(e) {
      this.deleteChildren(e), this.runOp({ type: 5, id: e });
    }
  };
function Qv(e, t, i) {
  if (e.length > 0) {
    let r = e[e.length - 1];
    if (r.type === 0 && t.type === 0 && ss.equal(r.path, i)) {
      Object.assign(r.props, t.props);
      return;
    }
  }
  e.push({ ...t, path: i });
}
var CT = class extends cp {
  constructor(e) {
    super(),
      (this.ts = []),
      (this.actual = []),
      (this.reverse = []),
      (this._current = e);
  }
  update(e, t) {
    if (e !== "") throw new Error("");
    this._current = t;
  }
  push(e, t, i, r) {
    Qv(this.ts, t, e), Qv(this.actual, i, e), Qv(this.reverse, r, e);
  }
  result() {
    return {
      data: this._current,
      ts: this.ts,
      actual: this.actual,
      reverse: this.reverse.reverse(),
    };
  }
};
function Rg(e, t, i) {
  return i instanceof as
    ? new $x(e, t, i)
    : i instanceof At
    ? new eb(e, t, i)
    : i instanceof Ft
    ? new Proxy(new iG(e, t, i), sG)
    : i !== null && typeof i == "object"
    ? Zx(i)
      ? i
      : new Proxy(new tG(e, t, i), rG)
    : i;
}
function TT(e) {
  let t = new CT(e);
  return [Rg(t, "", e), t];
}
function Hd(e, t) {
  let [i, r] = TT(e);
  return t(i), r.result();
}
function hr(e) {
  return e instanceof $x || e instanceof eb
    ? e._current
    : e !== null && typeof e == "object"
    ? e[MT]
    : e;
}
var ss;
((e) => {
  function t(a, n) {
    if (n.length === a.length)
      for (var o = 0; o < a.length; ) {
        if (a[o] !== n[o]) return !1;
        o += 1;
      }
    else return !1;
    return !0;
  }
  e.equal = t;
  function i(a, n, o) {
    let l = s(o, a);
    if (l !== void 0 && typeof l == "object" && l !== null) {
      let h = { ...n };
      return (
        Object.keys(l).forEach((u) => {
          delete h[u];
        }),
        h
      );
    } else return n;
  }
  e.removeOverridden = i;
  function r(a, n) {
    if (
      ((a instanceof as || a instanceof $x) && typeof n == "string") ||
      ((a instanceof At || a instanceof eb) && typeof n == "string")
    )
      return a.data(n);
    if (
      (typeof n == "number" && Array.isArray(a)) ||
      (typeof n == "string" && typeof a == "object" && a !== null)
    )
      return a[n];
  }
  e.zoomOnce = r;
  function s(a, n, o = 0) {
    for (; o < n.length && a !== void 0; ) (a = r(a, n[o])), (o += 1);
    return a;
  }
  e.zoom = s;
})(ss || (ss = {}));
function aG(e, t) {
  let i = [];
  if (t.length === e.length)
    for (var r = 0; r < e.length; ) {
      if (t[r] === "*") i.push(e[r]);
      else if (e[r] !== t[r]) return null;
      r += 1;
    }
  else return null;
  return i;
}
function Ii(e, t) {
  let i = [];
  if (t.length <= e.length)
    for (var r = 0; r < t.length; ) {
      if (t[r] === "*") i.push(e[r]);
      else if (e[r] !== t[r]) return null;
      r += 1;
    }
  else return null;
  return i;
}
var PT = class {},
  i2 = class extends PT {
    constructor(e) {
      super(), (this.id = e);
    }
  },
  r2 = class extends PT {
    constructor(e) {
      super(), (this.data = e);
    }
  },
  Ry;
try {
  Ry = new TextDecoder();
} catch {}
var ht,
  cl,
  be = 0,
  DT = [],
  Ly = DT,
  By = 0,
  Us = {},
  di,
  el,
  ba = 0,
  Sn = 0,
  Zs,
  wo,
  Os = [],
  wi,
  s2 = { useRecords: !1, mapsAsObjects: !0 },
  OT = class {},
  IT = new OT();
IT.name = "MessagePack 0xC1";
var Yc = !1,
  Um = class {
    constructor(e) {
      e &&
        (e.useRecords === !1 &&
          e.mapsAsObjects === void 0 &&
          (e.mapsAsObjects = !0),
        e.structures
          ? (e.structures.sharedLength = e.structures.length)
          : e.getStructures &&
            (((e.structures = []).uninitialized = !0),
            (e.structures.sharedLength = 0))),
        Object.assign(this, e);
    }
    unpack(e, t) {
      if (ht)
        return kT(
          () => (
            Fy(), this ? this.unpack(e, t) : Um.prototype.unpack.call(s2, e, t)
          )
        );
      (cl = t > -1 ? t : e.length),
        (be = 0),
        (By = 0),
        (Sn = 0),
        (el = null),
        (Ly = DT),
        (Zs = null),
        (ht = e);
      try {
        wi =
          e.dataView ||
          (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength));
      } catch (i) {
        throw (
          ((ht = null),
          e instanceof Uint8Array
            ? i
            : new Error(
                "Source must be a Uint8Array or Buffer but was a " +
                  (e && typeof e == "object" ? e.constructor.name : typeof e)
              ))
        );
      }
      if (this instanceof Um) {
        if (((Us = this), this.structures)) return (di = this.structures), mf();
        (!di || di.length > 0) && (di = []);
      } else (Us = s2), (!di || di.length > 0) && (di = []);
      return mf();
    }
    unpackMultiple(e, t) {
      let i,
        r = 0;
      try {
        Yc = !0;
        let s = e.length,
          a = this ? this.unpack(e, s) : Bg.unpack(e, s);
        if (t) {
          for (t(a); be < s; ) if (((r = be), t(mf()) === !1)) return;
        } else {
          for (i = [a]; be < s; ) (r = be), i.push(mf());
          return i;
        }
      } catch (s) {
        throw ((s.lastPosition = r), (s.values = i), s);
      } finally {
        (Yc = !1), Fy();
      }
    }
    _mergeStructures(e, t) {
      e = e || [];
      for (let i = 0, r = e.length; i < r; i++) {
        let s = e[i];
        s && ((s.isShared = !0), i >= 32 && (s.highByte = (i - 32) >> 5));
      }
      e.sharedLength = e.length;
      for (let i in t || [])
        if (i >= 0) {
          let r = e[i],
            s = t[i];
          s &&
            (r && ((e.restoreStructures || (e.restoreStructures = []))[i] = r),
            (e[i] = s));
        }
      return (this.structures = e);
    }
    decode(e, t) {
      return this.unpack(e, t);
    }
  };
function mf() {
  try {
    if (!Us.trusted && !Yc) {
      let t = di.sharedLength || 0;
      t < di.length && (di.length = t);
    }
    let e = $i();
    if (be == cl)
      di.restoreStructures && a2(), (di = null), (ht = null), wo && (wo = null);
    else if (be > cl) {
      let t = new Error("Unexpected end of MessagePack data");
      throw ((t.incomplete = !0), t);
    } else if (!Yc) throw new Error("Data read, but end of buffer not reached");
    return e;
  } catch (e) {
    throw (
      (di.restoreStructures && a2(),
      Fy(),
      (e instanceof RangeError ||
        e.message.startsWith("Unexpected end of buffer")) &&
        (e.incomplete = !0),
      e)
    );
  }
}
function a2() {
  for (let e in di.restoreStructures) di[e] = di.restoreStructures[e];
  di.restoreStructures = null;
}
function $i() {
  let e = ht[be++];
  if (e < 160)
    if (e < 128) {
      if (e < 64) return e;
      {
        let t = di[e & 63] || (Us.getStructures && RT()[e & 63]);
        return t ? (t.read || (t.read = tb(t, e & 63)), t.read()) : e;
      }
    } else if (e < 144)
      if (((e -= 128), Us.mapsAsObjects)) {
        let t = {};
        for (let i = 0; i < e; i++) t[BT()] = $i();
        return t;
      } else {
        let t = new Map();
        for (let i = 0; i < e; i++) t.set($i(), $i());
        return t;
      }
    else {
      e -= 144;
      let t = new Array(e);
      for (let i = 0; i < e; i++) t[i] = $i();
      return t;
    }
  else if (e < 192) {
    let t = e - 160;
    if (Sn >= be) return el.slice(be - ba, (be += t) - ba);
    if (Sn == 0 && cl < 140) {
      let i = t < 16 ? ib(t) : LT(t);
      if (i != null) return i;
    }
    return zy(t);
  } else {
    let t;
    switch (e) {
      case 192:
        return null;
      case 193:
        return Zs
          ? ((t = $i()),
            t > 0
              ? Zs[1].slice(Zs.position1, (Zs.position1 += t))
              : Zs[0].slice(Zs.position0, (Zs.position0 -= t)))
          : IT;
      case 194:
        return !1;
      case 195:
        return !0;
      case 196:
        return Zv(ht[be++]);
      case 197:
        return (t = wi.getUint16(be)), (be += 2), Zv(t);
      case 198:
        return (t = wi.getUint32(be)), (be += 4), Zv(t);
      case 199:
        return Pl(ht[be++]);
      case 200:
        return (t = wi.getUint16(be)), (be += 2), Pl(t);
      case 201:
        return (t = wi.getUint32(be)), (be += 4), Pl(t);
      case 202:
        if (((t = wi.getFloat32(be)), Us.useFloat32 > 2)) {
          let i = rb[((ht[be] & 127) << 1) | (ht[be + 1] >> 7)];
          return (be += 4), ((i * t + (t > 0 ? 0.5 : -0.5)) >> 0) / i;
        }
        return (be += 4), t;
      case 203:
        return (t = wi.getFloat64(be)), (be += 8), t;
      case 204:
        return ht[be++];
      case 205:
        return (t = wi.getUint16(be)), (be += 2), t;
      case 206:
        return (t = wi.getUint32(be)), (be += 4), t;
      case 207:
        return (
          Us.int64AsNumber
            ? ((t = wi.getUint32(be) * 4294967296), (t += wi.getUint32(be + 4)))
            : (t = wi.getBigUint64(be)),
          (be += 8),
          t
        );
      case 208:
        return wi.getInt8(be++);
      case 209:
        return (t = wi.getInt16(be)), (be += 2), t;
      case 210:
        return (t = wi.getInt32(be)), (be += 4), t;
      case 211:
        return (
          Us.int64AsNumber
            ? ((t = wi.getInt32(be) * 4294967296), (t += wi.getUint32(be + 4)))
            : (t = wi.getBigInt64(be)),
          (be += 8),
          t
        );
      case 212:
        if (((t = ht[be++]), t == 114)) return c2(ht[be++] & 63);
        {
          let i = Os[t];
          if (i)
            return i.read
              ? (be++, i.read($i()))
              : i.noBuffer
              ? (be++, i())
              : i(ht.subarray(be, ++be));
          throw new Error("Unknown extension " + t);
        }
      case 213:
        return (
          (t = ht[be]), t == 114 ? (be++, c2(ht[be++] & 63, ht[be++])) : Pl(2)
        );
      case 214:
        return Pl(4);
      case 215:
        return Pl(8);
      case 216:
        return Pl(16);
      case 217:
        return (
          (t = ht[be++]), Sn >= be ? el.slice(be - ba, (be += t) - ba) : oG(t)
        );
      case 218:
        return (
          (t = wi.getUint16(be)),
          (be += 2),
          Sn >= be ? el.slice(be - ba, (be += t) - ba) : lG(t)
        );
      case 219:
        return (
          (t = wi.getUint32(be)),
          (be += 4),
          Sn >= be ? el.slice(be - ba, (be += t) - ba) : hG(t)
        );
      case 220:
        return (t = wi.getUint16(be)), (be += 2), o2(t);
      case 221:
        return (t = wi.getUint32(be)), (be += 4), o2(t);
      case 222:
        return (t = wi.getUint16(be)), (be += 2), l2(t);
      case 223:
        return (t = wi.getUint32(be)), (be += 4), l2(t);
      default:
        if (e >= 224) return e - 256;
        if (e === void 0) {
          let i = new Error("Unexpected end of MessagePack data");
          throw ((i.incomplete = !0), i);
        }
        throw new Error("Unknown MessagePack token " + e);
    }
  }
}
var nG = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function tb(e, t) {
  function i() {
    if (i.count++ > 2) {
      let s = (e.read = new Function(
        "r",
        "return function(){return {" +
          e
            .map((a) =>
              nG.test(a) ? a + ":r()" : "[" + JSON.stringify(a) + "]:r()"
            )
            .join(",") +
          "}}"
      )($i));
      return e.highByte === 0 && (e.read = n2(t, e.read)), s();
    }
    let r = {};
    for (let s = 0, a = e.length; s < a; s++) {
      let n = e[s];
      r[n] = $i();
    }
    return r;
  }
  return (i.count = 0), e.highByte === 0 ? n2(t, i) : i;
}
var n2 = (e, t) =>
  function () {
    let i = ht[be++];
    if (i === 0) return t();
    let r = e < 32 ? -(e + (i << 5)) : e + (i << 5),
      s = di[r] || RT()[r];
    if (!s) throw new Error("Record id is not defined for " + r);
    return s.read || (s.read = tb(s, e)), s.read();
  };
function RT() {
  let e = kT(() => ((ht = null), Us.getStructures()));
  return (di = Us._mergeStructures(e, di));
}
var zy = Lg,
  oG = Lg,
  lG = Lg,
  hG = Lg;
function Lg(e) {
  let t;
  if (e < 16 && (t = ib(e))) return t;
  if (e > 64 && Ry) return Ry.decode(ht.subarray(be, (be += e)));
  let i = be + e,
    r = [];
  for (t = ""; be < i; ) {
    let s = ht[be++];
    if ((s & 128) === 0) r.push(s);
    else if ((s & 224) === 192) {
      let a = ht[be++] & 63;
      r.push(((s & 31) << 6) | a);
    } else if ((s & 240) === 224) {
      let a = ht[be++] & 63,
        n = ht[be++] & 63;
      r.push(((s & 31) << 12) | (a << 6) | n);
    } else if ((s & 248) === 240) {
      let a = ht[be++] & 63,
        n = ht[be++] & 63,
        o = ht[be++] & 63,
        l = ((s & 7) << 18) | (a << 12) | (n << 6) | o;
      l > 65535 &&
        ((l -= 65536),
        r.push(((l >>> 10) & 1023) | 55296),
        (l = 56320 | (l & 1023))),
        r.push(l);
    } else r.push(s);
    r.length >= 4096 && ((t += Vr.apply(String, r)), (r.length = 0));
  }
  return r.length > 0 && (t += Vr.apply(String, r)), t;
}
function o2(e) {
  let t = new Array(e);
  for (let i = 0; i < e; i++) t[i] = $i();
  return t;
}
function l2(e) {
  if (Us.mapsAsObjects) {
    let t = {};
    for (let i = 0; i < e; i++) t[BT()] = $i();
    return t;
  } else {
    let t = new Map();
    for (let i = 0; i < e; i++) t.set($i(), $i());
    return t;
  }
}
var Vr = String.fromCharCode;
function LT(e) {
  let t = be,
    i = new Array(e);
  for (let r = 0; r < e; r++) {
    let s = ht[be++];
    if ((s & 128) > 0) {
      be = t;
      return;
    }
    i[r] = s;
  }
  return Vr.apply(String, i);
}
function ib(e) {
  if (e < 4)
    if (e < 2) {
      if (e === 0) return "";
      {
        let t = ht[be++];
        if ((t & 128) > 1) {
          be -= 1;
          return;
        }
        return Vr(t);
      }
    } else {
      let t = ht[be++],
        i = ht[be++];
      if ((t & 128) > 0 || (i & 128) > 0) {
        be -= 2;
        return;
      }
      if (e < 3) return Vr(t, i);
      let r = ht[be++];
      if ((r & 128) > 0) {
        be -= 3;
        return;
      }
      return Vr(t, i, r);
    }
  else {
    let t = ht[be++],
      i = ht[be++],
      r = ht[be++],
      s = ht[be++];
    if ((t & 128) > 0 || (i & 128) > 0 || (r & 128) > 0 || (s & 128) > 0) {
      be -= 4;
      return;
    }
    if (e < 6) {
      if (e === 4) return Vr(t, i, r, s);
      {
        let a = ht[be++];
        if ((a & 128) > 0) {
          be -= 5;
          return;
        }
        return Vr(t, i, r, s, a);
      }
    } else if (e < 8) {
      let a = ht[be++],
        n = ht[be++];
      if ((a & 128) > 0 || (n & 128) > 0) {
        be -= 6;
        return;
      }
      if (e < 7) return Vr(t, i, r, s, a, n);
      let o = ht[be++];
      if ((o & 128) > 0) {
        be -= 7;
        return;
      }
      return Vr(t, i, r, s, a, n, o);
    } else {
      let a = ht[be++],
        n = ht[be++],
        o = ht[be++],
        l = ht[be++];
      if ((a & 128) > 0 || (n & 128) > 0 || (o & 128) > 0 || (l & 128) > 0) {
        be -= 8;
        return;
      }
      if (e < 10) {
        if (e === 8) return Vr(t, i, r, s, a, n, o, l);
        {
          let h = ht[be++];
          if ((h & 128) > 0) {
            be -= 9;
            return;
          }
          return Vr(t, i, r, s, a, n, o, l, h);
        }
      } else if (e < 12) {
        let h = ht[be++],
          u = ht[be++];
        if ((h & 128) > 0 || (u & 128) > 0) {
          be -= 10;
          return;
        }
        if (e < 11) return Vr(t, i, r, s, a, n, o, l, h, u);
        let c = ht[be++];
        if ((c & 128) > 0) {
          be -= 11;
          return;
        }
        return Vr(t, i, r, s, a, n, o, l, h, u, c);
      } else {
        let h = ht[be++],
          u = ht[be++],
          c = ht[be++],
          d = ht[be++];
        if ((h & 128) > 0 || (u & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
          be -= 12;
          return;
        }
        if (e < 14) {
          if (e === 12) return Vr(t, i, r, s, a, n, o, l, h, u, c, d);
          {
            let p = ht[be++];
            if ((p & 128) > 0) {
              be -= 13;
              return;
            }
            return Vr(t, i, r, s, a, n, o, l, h, u, c, d, p);
          }
        } else {
          let p = ht[be++],
            f = ht[be++];
          if ((p & 128) > 0 || (f & 128) > 0) {
            be -= 14;
            return;
          }
          if (e < 15) return Vr(t, i, r, s, a, n, o, l, h, u, c, d, p, f);
          let m = ht[be++];
          if ((m & 128) > 0) {
            be -= 15;
            return;
          }
          return Vr(t, i, r, s, a, n, o, l, h, u, c, d, p, f, m);
        }
      }
    }
  }
}
function Zv(e) {
  return Us.copyBuffers
    ? Uint8Array.prototype.slice.call(ht, be, (be += e))
    : ht.subarray(be, (be += e));
}
function Pl(e) {
  let t = ht[be++];
  if (Os[t]) return Os[t](ht.subarray(be, (be += e)));
  throw new Error("Unknown extension type " + t);
}
var h2 = new Array(4096);
function BT() {
  let e = ht[be++];
  if (e >= 160 && e < 192) {
    if (((e = e - 160), Sn >= be)) return el.slice(be - ba, (be += e) - ba);
    if (!(Sn == 0 && cl < 180)) return zy(e);
  } else return be--, $i();
  let t = ((e << 5) ^ (e > 1 ? wi.getUint16(be) : e > 0 ? ht[be] : 0)) & 4095,
    i = h2[t],
    r = be,
    s = be + e - 3,
    a,
    n = 0;
  if (i && i.bytes == e) {
    for (; r < s; ) {
      if (((a = wi.getUint32(r)), a != i[n++])) {
        r = 1879048192;
        break;
      }
      r += 4;
    }
    for (s += 3; r < s; )
      if (((a = ht[r++]), a != i[n++])) {
        r = 1879048192;
        break;
      }
    if (r === s) return (be = r), i.string;
    (s -= 3), (r = be);
  }
  for (i = [], h2[t] = i, i.bytes = e; r < s; )
    (a = wi.getUint32(r)), i.push(a), (r += 4);
  for (s += 3; r < s; ) (a = ht[r++]), i.push(a);
  let o = e < 16 ? ib(e) : LT(e);
  return o != null ? (i.string = o) : (i.string = zy(e));
}
var c2 = (e, t) => {
    var i = $i();
    let r = e;
    t !== void 0 &&
      ((e = e < 32 ? -((t << 5) + e) : (t << 5) + e), (i.highByte = t));
    let s = di[e];
    return (
      s &&
        s.isShared &&
        ((di.restoreStructures || (di.restoreStructures = []))[e] = s),
      (di[e] = i),
      (i.read = tb(i, r)),
      i.read()
    );
  },
  zT = typeof self == "object" ? self : global;
Os[0] = () => {};
Os[0].noBuffer = !0;
Os[101] = () => {
  let e = $i();
  return (zT[e[0]] || Error)(e[1]);
};
Os[105] = (e) => {
  let t = wi.getUint32(be - 4);
  wo || (wo = new Map());
  let i = ht[be],
    r;
  (i >= 144 && i < 160) || i == 220 || i == 221 ? (r = []) : (r = {});
  let s = { target: r };
  wo.set(t, s);
  let a = $i();
  return s.used ? Object.assign(r, a) : ((s.target = a), a);
};
Os[112] = (e) => {
  let t = wi.getUint32(be - 4),
    i = wo.get(t);
  return (i.used = !0), i.target;
};
Os[115] = () => new Set($i());
var FT = [
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64",
  "BigInt64",
  "BigUint64",
].map((e) => e + "Array");
Os[116] = (e) => {
  let t = e[0],
    i = FT[t];
  if (!i) throw new Error("Could not find typed array for code " + t);
  return new zT[i](Uint8Array.prototype.slice.call(e, 1).buffer);
};
Os[120] = () => {
  let e = $i();
  return new RegExp(e[0], e[1]);
};
Os[98] = (e) => {
  let t = (e[0] << 24) + (e[1] << 16) + (e[2] << 8) + e[3],
    i = be;
  (be += t - 4), (Zs = [$i(), $i()]), (Zs.position0 = 0), (Zs.position1 = 0);
  let r = be;
  be = i;
  try {
    return $i();
  } finally {
    be = r;
  }
};
Os[255] = (e) =>
  e.length == 4
    ? new Date((e[0] * 16777216 + (e[1] << 16) + (e[2] << 8) + e[3]) * 1e3)
    : e.length == 8
    ? new Date(
        ((e[0] << 22) + (e[1] << 14) + (e[2] << 6) + (e[3] >> 2)) / 1e6 +
          ((e[3] & 3) * 4294967296 +
            e[4] * 16777216 +
            (e[5] << 16) +
            (e[6] << 8) +
            e[7]) *
            1e3
      )
    : e.length == 12
    ? new Date(
        ((e[0] << 24) + (e[1] << 16) + (e[2] << 8) + e[3]) / 1e6 +
          ((e[4] & 128 ? -281474976710656 : 0) +
            e[6] * 1099511627776 +
            e[7] * 4294967296 +
            e[8] * 16777216 +
            (e[9] << 16) +
            (e[10] << 8) +
            e[11]) *
            1e3
      )
    : new Date("invalid");
function kT(e) {
  let t = cl,
    i = be,
    r = By,
    s = ba,
    a = Sn,
    n = el,
    o = Ly,
    l = wo,
    h = Zs,
    u = new Uint8Array(ht.slice(0, cl)),
    c = di,
    d = di.slice(0, di.length),
    p = Us,
    f = Yc,
    m = e();
  return (
    (cl = t),
    (be = i),
    (By = r),
    (ba = s),
    (Sn = a),
    (el = n),
    (Ly = o),
    (wo = l),
    (Zs = h),
    (ht = u),
    (Yc = f),
    (di = c),
    di.splice(0, di.length, ...d),
    (Us = p),
    (wi = new DataView(ht.buffer, ht.byteOffset, ht.byteLength)),
    m
  );
}
function Fy() {
  (ht = null), (wo = null), (di = null);
}
function cG(e) {
  e.unpack ? (Os[e.type] = e.unpack) : (Os[e.type] = e);
}
var rb = new Array(147);
for (let e = 0; e < 256; e++) rb[e] = +("1e" + Math.floor(45.15 - e * 0.30103));
var Bg = new Um({ useRecords: !1 }),
  zee = Bg.unpack,
  Fee = Bg.unpackMultiple,
  kee = Bg.unpack,
  uG = { NEVER: 0, ALWAYS: 1, DECIMAL_ROUND: 3, DECIMAL_FIT: 4 },
  dG = new Float32Array(1),
  Nee = new Uint8Array(dG.buffer, 0, 4),
  hm;
try {
  hm = new TextEncoder();
} catch {}
var Vm,
  sb,
  zg = typeof Buffer < "u",
  Kv = zg ? Buffer.allocUnsafeSlow : Uint8Array,
  NT = zg ? Buffer : Uint8Array,
  u2 = zg ? 4294967296 : 2144337920,
  ke,
  ar,
  Me = 0,
  an,
  nn = null,
  pG = /[\u0080-\uFFFF]/,
  Gu = Symbol("record-id"),
  UT = class extends Um {
    constructor(e) {
      super(e), (this.offset = 0);
      let t,
        i,
        r,
        s,
        a,
        n,
        o = 0,
        l = NT.prototype.utf8Write
          ? function (C, A, T) {
              return ke.utf8Write(C, A, T);
            }
          : hm && hm.encodeInto
          ? function (C, A) {
              return hm.encodeInto(C, ke.subarray(A)).written;
            }
          : !1,
        h = this;
      e || (e = {});
      let u = e && e.sequential,
        c = e.structures || e.saveStructures,
        d = e.maxSharedStructures;
      if ((d == null && (d = c ? 32 : 0), d > 8160))
        throw new Error("Maximum maxSharedStructure is 8160");
      let p = e.maxOwnStructures;
      p == null && (p = c ? 32 : 64),
        u && !e.saveStructures && (this.structures = []);
      let f = d > 32 || p + d > 64,
        m = d + 64,
        g = d + p + 64;
      if (g > 8256)
        throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
      let y = [],
        x = 0,
        b = 0;
      this.pack = this.encode = function (C, A) {
        if (
          (ke ||
            ((ke = new Kv(8192)),
            (ar = new DataView(ke.buffer, 0, 8192)),
            (Me = 0)),
          (an = ke.length - 10),
          an - Me < 2048
            ? ((ke = new Kv(ke.length)),
              (ar = new DataView(ke.buffer, 0, ke.length)),
              (an = ke.length - 10),
              (Me = 0))
            : (Me = (Me + 7) & 2147483640),
          (i = Me),
          (n = h.structuredClone ? new Map() : null),
          h.bundleStrings
            ? ((nn = ["", ""]),
              (ke[Me++] = 214),
              (ke[Me++] = 98),
              (nn.position = Me - i),
              (Me += 4))
            : (nn = null),
          (r = h.structures),
          r)
        ) {
          r.uninitialized && (r = h._mergeStructures(h.getStructures()));
          let T = r.sharedLength || 0;
          if (T > d)
            throw new Error(
              "Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " +
                r.sharedLength
            );
          if (!r.transitions) {
            r.transitions = Object.create(null);
            for (let P = 0; P < T; P++) {
              let R = r[P];
              if (!R) continue;
              let z,
                N = r.transitions;
              for (let L = 0, G = R.length; L < G; L++) {
                let Y = R[L];
                (z = N[Y]), z || (z = N[Y] = Object.create(null)), (N = z);
              }
              N[Gu] = P + 64;
            }
            o = T;
          }
          u || (r.nextId = T + 64);
        }
        s && (s = !1), (a = r || []);
        try {
          if ((_(C), nn)) {
            ar.setUint32(nn.position + i, Me - nn.position - i);
            let T = nn;
            (nn = null), _(T[0]), _(T[1]);
          }
          if (((h.offset = Me), n && n.idsToInsert)) {
            (Me += n.idsToInsert.length * 6), Me > an && M(Me), (h.offset = Me);
            let T = mG(ke.subarray(i, Me), n.idsToInsert);
            return (n = null), T;
          }
          return A & gG
            ? ((ke.start = i), (ke.end = Me), ke)
            : ke.subarray(i, Me);
        } finally {
          if (r) {
            if ((b < 10 && b++, x > 1e4))
              (r.transitions = null),
                (b = 0),
                (x = 0),
                y.length > 0 && (y = []);
            else if (y.length > 0 && !u) {
              for (let T = 0, P = y.length; T < P; T++) y[T][Gu] = 0;
              y = [];
            }
            if (s && h.saveStructures) {
              let T = r.sharedLength || d;
              r.length > T && (r = r.slice(0, T));
              let P = ke.subarray(i, Me);
              return h.saveStructures(r, o) === !1
                ? (h._mergeStructures(h.getStructures()), h.pack(C))
                : ((o = T), P);
            }
          }
          A & vG && (Me = i);
        }
      };
      let _ = (C) => {
          Me > an && (ke = M(Me));
          var A = typeof C,
            T;
          if (A === "string") {
            let P = C.length;
            if (nn && P >= 8 && P < 4096) {
              let N = pG.test(C);
              (nn[N ? 0 : 1] += C), (ke[Me++] = 193), _(N ? -P : P);
              return;
            }
            let R;
            P < 32
              ? (R = 1)
              : P < 256
              ? (R = 2)
              : P < 65536
              ? (R = 3)
              : (R = 5);
            let z = P * 3;
            if ((Me + z > an && (ke = M(Me + z)), P < 64 || !l)) {
              let N,
                L,
                G,
                Y = Me + R;
              for (N = 0; N < P; N++)
                (L = C.charCodeAt(N)),
                  L < 128
                    ? (ke[Y++] = L)
                    : L < 2048
                    ? ((ke[Y++] = (L >> 6) | 192), (ke[Y++] = (L & 63) | 128))
                    : (L & 64512) === 55296 &&
                      ((G = C.charCodeAt(N + 1)) & 64512) === 56320
                    ? ((L = 65536 + ((L & 1023) << 10) + (G & 1023)),
                      N++,
                      (ke[Y++] = (L >> 18) | 240),
                      (ke[Y++] = ((L >> 12) & 63) | 128),
                      (ke[Y++] = ((L >> 6) & 63) | 128),
                      (ke[Y++] = (L & 63) | 128))
                    : ((ke[Y++] = (L >> 12) | 224),
                      (ke[Y++] = ((L >> 6) & 63) | 128),
                      (ke[Y++] = (L & 63) | 128));
              T = Y - Me - R;
            } else T = l(C, Me + R, z);
            T < 32
              ? (ke[Me++] = 160 | T)
              : T < 256
              ? (R < 2 && ke.copyWithin(Me + 2, Me + 1, Me + 1 + T),
                (ke[Me++] = 217),
                (ke[Me++] = T))
              : T < 65536
              ? (R < 3 && ke.copyWithin(Me + 3, Me + 2, Me + 2 + T),
                (ke[Me++] = 218),
                (ke[Me++] = T >> 8),
                (ke[Me++] = T & 255))
              : (R < 5 && ke.copyWithin(Me + 5, Me + 3, Me + 3 + T),
                (ke[Me++] = 219),
                ar.setUint32(Me, T),
                (Me += 4)),
              (Me += T);
          } else if (A === "number")
            if (C >>> 0 === C)
              C < 64
                ? (ke[Me++] = C)
                : C < 256
                ? ((ke[Me++] = 204), (ke[Me++] = C))
                : C < 65536
                ? ((ke[Me++] = 205), (ke[Me++] = C >> 8), (ke[Me++] = C & 255))
                : ((ke[Me++] = 206), ar.setUint32(Me, C), (Me += 4));
            else if (C >> 0 === C)
              C >= -32
                ? (ke[Me++] = 256 + C)
                : C >= -128
                ? ((ke[Me++] = 208), (ke[Me++] = C + 256))
                : C >= -32768
                ? ((ke[Me++] = 209), ar.setInt16(Me, C), (Me += 2))
                : ((ke[Me++] = 210), ar.setInt32(Me, C), (Me += 4));
            else {
              let P;
              if (
                (P = this.useFloat32) > 0 &&
                C < 4294967296 &&
                C >= -2147483648
              ) {
                (ke[Me++] = 202), ar.setFloat32(Me, C);
                let R;
                if (
                  P < 4 ||
                  (R = C * rb[((ke[Me] & 127) << 1) | (ke[Me + 1] >> 7)]) >>
                    0 ===
                    R
                ) {
                  Me += 4;
                  return;
                } else Me--;
              }
              (ke[Me++] = 203), ar.setFloat64(Me, C), (Me += 8);
            }
          else if (A === "object")
            if (!C) ke[Me++] = 192;
            else {
              if (n) {
                let R = n.get(C);
                if (R) {
                  if (!R.id) {
                    let z = n.idsToInsert || (n.idsToInsert = []);
                    R.id = z.push(R);
                  }
                  (ke[Me++] = 214),
                    (ke[Me++] = 112),
                    ar.setUint32(Me, R.id),
                    (Me += 4);
                  return;
                } else n.set(C, { offset: Me - i });
              }
              let P = C.constructor;
              if (P === Object) S(C, !0);
              else if (P === Array) {
                (T = C.length),
                  T < 16
                    ? (ke[Me++] = 144 | T)
                    : T < 65536
                    ? ((ke[Me++] = 220),
                      (ke[Me++] = T >> 8),
                      (ke[Me++] = T & 255))
                    : ((ke[Me++] = 221), ar.setUint32(Me, T), (Me += 4));
                for (let R = 0; R < T; R++) _(C[R]);
              } else if (P === Map) {
                (T = C.size),
                  T < 16
                    ? (ke[Me++] = 128 | T)
                    : T < 65536
                    ? ((ke[Me++] = 222),
                      (ke[Me++] = T >> 8),
                      (ke[Me++] = T & 255))
                    : ((ke[Me++] = 223), ar.setUint32(Me, T), (Me += 4));
                for (let [R, z] of C) _(R), _(z);
              } else {
                for (let R = 0, z = Vm.length; R < z; R++) {
                  let N = sb[R];
                  if (C instanceof N) {
                    let L = Vm[R];
                    if (L.write) {
                      L.type &&
                        ((ke[Me++] = 212), (ke[Me++] = L.type), (ke[Me++] = 0)),
                        _(L.write.call(this, C));
                      return;
                    }
                    let G = ke,
                      Y = ar,
                      Z = Me;
                    ke = null;
                    let q;
                    try {
                      q = L.pack.call(
                        this,
                        C,
                        (oe) => (
                          (ke = G),
                          (G = null),
                          (Me += oe),
                          Me > an && M(Me),
                          { target: ke, targetView: ar, position: Me - oe }
                        ),
                        _
                      );
                    } finally {
                      G &&
                        ((ke = G), (ar = Y), (Me = Z), (an = ke.length - 10));
                    }
                    q &&
                      (q.length + Me > an && M(q.length + Me),
                      (Me = fG(q, ke, Me, L.type)));
                    return;
                  }
                }
                S(C, !C.hasOwnProperty);
              }
            }
          else if (A === "boolean") ke[Me++] = C ? 195 : 194;
          else if (A === "bigint") {
            if (C < BigInt(1) << BigInt(63) && C >= -(BigInt(1) << BigInt(63)))
              (ke[Me++] = 211), ar.setBigInt64(Me, C);
            else if (C < BigInt(1) << BigInt(64) && C > 0)
              (ke[Me++] = 207), ar.setBigUint64(Me, C);
            else if (this.largeBigIntToFloat)
              (ke[Me++] = 203), ar.setFloat64(Me, Number(C));
            else
              throw new RangeError(
                C +
                  " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64"
              );
            Me += 8;
          } else if (A === "undefined")
            this.encodeUndefinedAsNil
              ? (ke[Me++] = 192)
              : ((ke[Me++] = 212), (ke[Me++] = 0), (ke[Me++] = 0));
          else if (A === "function")
            _(this.writeFunction && this.writeFunction());
          else throw new Error("Unknown type: " + A);
        },
        S =
          this.useRecords === !1
            ? this.variableMapSize
              ? (C) => {
                  let A = Object.keys(C),
                    T = A.length;
                  T < 16
                    ? (ke[Me++] = 128 | T)
                    : T < 65536
                    ? ((ke[Me++] = 222),
                      (ke[Me++] = T >> 8),
                      (ke[Me++] = T & 255))
                    : ((ke[Me++] = 223), ar.setUint32(Me, T), (Me += 4));
                  let P;
                  for (let R = 0; R < T; R++) _((P = A[R])), _(C[P]);
                }
              : (C, A) => {
                  ke[Me++] = 222;
                  let T = Me - i;
                  Me += 2;
                  let P = 0;
                  for (let R in C)
                    (A || C.hasOwnProperty(R)) && (_(R), _(C[R]), P++);
                  (ke[T++ + i] = P >> 8), (ke[T + i] = P & 255);
                }
            : (C) => {
                let A = Object.keys(C),
                  T,
                  P = a.transitions || (a.transitions = Object.create(null)),
                  R = 0;
                for (let N = 0, L = A.length; N < L; N++) {
                  let G = A[N];
                  (T = P[G]),
                    T || ((T = P[G] = Object.create(null)), R++),
                    (P = T);
                }
                let z = P[Gu];
                if (z)
                  z >= 96 && f
                    ? ((ke[Me++] = ((z -= 96) & 31) + 96), (ke[Me++] = z >> 5))
                    : (ke[Me++] = z);
                else {
                  (z = a.nextId),
                    z || (z = 64),
                    z < m &&
                    this.shouldShareStructure &&
                    !this.shouldShareStructure(A)
                      ? ((z = a.nextOwnId),
                        z < g || (z = m),
                        (a.nextOwnId = z + 1))
                      : (z >= g && (z = m), (a.nextId = z + 1));
                  let N = (A.highByte = z >= 96 && f ? (z - 96) >> 5 : -1);
                  (P[Gu] = z),
                    (a[z - 64] = A),
                    z < m
                      ? ((A.isShared = !0),
                        (a.sharedLength = z - 63),
                        (s = !0),
                        N >= 0
                          ? ((ke[Me++] = (z & 31) + 96), (ke[Me++] = N))
                          : (ke[Me++] = z))
                      : (N >= 0
                          ? ((ke[Me++] = 213),
                            (ke[Me++] = 114),
                            (ke[Me++] = (z & 31) + 96),
                            (ke[Me++] = N))
                          : ((ke[Me++] = 212),
                            (ke[Me++] = 114),
                            (ke[Me++] = z)),
                        R && (x += b * R),
                        y.length >= p && (y.shift()[Gu] = 0),
                        y.push(P),
                        _(A));
                }
                for (let N = 0, L = A.length; N < L; N++) _(C[A[N]]);
              },
        M = (C) => {
          let A;
          if (C > 16777216) {
            if (C - i > u2)
              throw new Error(
                "Packed buffer would be larger than maximum buffer size"
              );
            A = Math.min(
              u2,
              Math.round(
                Math.max((C - i) * (C > 67108864 ? 1.25 : 2), 4194304) / 4096
              ) * 4096
            );
          } else A = ((Math.max((C - i) << 2, ke.length - 1) >> 12) + 1) << 12;
          let T = new Kv(A);
          return (
            (ar = new DataView(T.buffer, 0, A)),
            ke.copy ? ke.copy(T, 0, i, C) : T.set(ke.slice(i, C)),
            (Me -= i),
            (i = 0),
            (an = T.length - 10),
            (ke = T)
          );
        };
    }
    useBuffer(e) {
      (ke = e),
        (ar = new DataView(ke.buffer, ke.byteOffset, ke.byteLength)),
        (Me = 0);
    }
  };
sb = [
  Date,
  Set,
  Error,
  RegExp,
  ArrayBuffer,
  Object.getPrototypeOf(Uint8Array.prototype).constructor,
  OT,
];
Vm = [
  {
    pack(e, t, i) {
      let r = e.getTime() / 1e3;
      if (
        (this.useTimestamp32 || e.getMilliseconds() === 0) &&
        r >= 0 &&
        r < 4294967296
      ) {
        let { target: s, targetView: a, position: n } = t(6);
        (s[n++] = 214), (s[n++] = 255), a.setUint32(n, r);
      } else if (r > 0 && r < 17179869184) {
        let { target: s, targetView: a, position: n } = t(10);
        (s[n++] = 215),
          (s[n++] = 255),
          a.setUint32(
            n,
            e.getMilliseconds() * 4e6 + ((r / 1e3 / 4294967296) >> 0)
          ),
          a.setUint32(n + 4, r);
      } else if (isNaN(r)) {
        if (this.onInvalidDate) return t(0), i(this.onInvalidDate());
        let { target: s, targetView: a, position: n } = t(3);
        (s[n++] = 212), (s[n++] = 255), (s[n++] = 255);
      } else {
        let { target: s, targetView: a, position: n } = t(15);
        (s[n++] = 199),
          (s[n++] = 12),
          (s[n++] = 255),
          a.setUint32(n, e.getMilliseconds() * 1e6),
          a.setBigInt64(n + 4, BigInt(Math.floor(r)));
      }
    },
  },
  {
    pack(e, t, i) {
      let r = Array.from(e),
        { target: s, position: a } = t(this.structuredClone ? 3 : 0);
      this.structuredClone && ((s[a++] = 212), (s[a++] = 115), (s[a++] = 0)),
        i(r);
    },
  },
  {
    pack(e, t, i) {
      let { target: r, position: s } = t(this.structuredClone ? 3 : 0);
      this.structuredClone && ((r[s++] = 212), (r[s++] = 101), (r[s++] = 0)),
        i([e.name, e.message]);
    },
  },
  {
    pack(e, t, i) {
      let { target: r, position: s } = t(this.structuredClone ? 3 : 0);
      this.structuredClone && ((r[s++] = 212), (r[s++] = 120), (r[s++] = 0)),
        i([e.source, e.flags]);
    },
  },
  {
    pack(e, t) {
      this.structuredClone
        ? d2(e, 16, t)
        : p2(zg ? Buffer.from(e) : new Uint8Array(e), t);
    },
  },
  {
    pack(e, t) {
      let i = e.constructor;
      i !== NT && this.structuredClone
        ? d2(e, FT.indexOf(i.name), t)
        : p2(e, t);
    },
  },
  {
    pack(e, t) {
      let { target: i, position: r } = t(1);
      i[r] = 193;
    },
  },
];
function d2(e, t, i, r) {
  let s = e.byteLength;
  if (s + 1 < 256) {
    var { target: a, position: n } = i(4 + s);
    (a[n++] = 199), (a[n++] = s + 1);
  } else if (s + 1 < 65536) {
    var { target: a, position: n } = i(5 + s);
    (a[n++] = 200), (a[n++] = (s + 1) >> 8), (a[n++] = (s + 1) & 255);
  } else {
    var { target: a, position: n, targetView: o } = i(7 + s);
    (a[n++] = 201), o.setUint32(n, s + 1), (n += 4);
  }
  (a[n++] = 116),
    (a[n++] = t),
    a.set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), n);
}
function p2(e, t) {
  let i = e.byteLength;
  var r, s;
  if (i < 256) {
    var { target: r, position: s } = t(i + 2);
    (r[s++] = 196), (r[s++] = i);
  } else if (i < 65536) {
    var { target: r, position: s } = t(i + 3);
    (r[s++] = 197), (r[s++] = i >> 8), (r[s++] = i & 255);
  } else {
    var { target: r, position: s, targetView: a } = t(i + 5);
    (r[s++] = 198), a.setUint32(s, i), (s += 4);
  }
  r.set(e, s);
}
function fG(e, t, i, r) {
  let s = e.length;
  switch (s) {
    case 1:
      t[i++] = 212;
      break;
    case 2:
      t[i++] = 213;
      break;
    case 4:
      t[i++] = 214;
      break;
    case 8:
      t[i++] = 215;
      break;
    case 16:
      t[i++] = 216;
      break;
    default:
      s < 256
        ? ((t[i++] = 199), (t[i++] = s))
        : s < 65536
        ? ((t[i++] = 200), (t[i++] = s >> 8), (t[i++] = s & 255))
        : ((t[i++] = 201),
          (t[i++] = s >> 24),
          (t[i++] = (s >> 16) & 255),
          (t[i++] = (s >> 8) & 255),
          (t[i++] = s & 255));
  }
  return (t[i++] = r), t.set(e, i), (i += s), i;
}
function mG(e, t) {
  let i,
    r = t.length * 6,
    s = e.length - r;
  for (t.sort((a, n) => (a.offset > n.offset ? 1 : -1)); (i = t.pop()); ) {
    let a = i.offset,
      n = i.id;
    e.copyWithin(a + r, a, s), (r -= 6);
    let o = a + r;
    (e[o++] = 214),
      (e[o++] = 105),
      (e[o++] = n >> 24),
      (e[o++] = (n >> 16) & 255),
      (e[o++] = (n >> 8) & 255),
      (e[o++] = n & 255),
      (s = a);
  }
  return e;
}
function fu(e) {
  if (e.Class) {
    if (!e.pack && !e.write)
      throw new Error("Extension has no pack or write function");
    if (e.pack && !e.type)
      throw new Error(
        "Extension has no type (numeric code to identify the extension)"
      );
    sb.unshift(e.Class), Vm.unshift(e);
  }
  cG(e);
}
var VT = new UT({ useRecords: !1 }),
  Uee = VT.pack,
  Vee = VT.pack,
  { NEVER: jee, ALWAYS: Hee, DECIMAL_ROUND: Gee, DECIMAL_FIT: Wee } = uG,
  gG = 512,
  vG = 1024,
  f2 = new UT({ structuredClone: !0 });
fu({
  Class: Ft.prototype.constructor,
  type: 1,
  write(e) {
    return { ...e };
  },
  read(e) {
    return Object.setPrototypeOf(e, Ft.prototype), e;
  },
});
fu({
  Class: At.prototype.constructor,
  type: 2,
  write(e) {
    return [...e];
  },
  read(e) {
    return Object.setPrototypeOf(e, At.prototype), e;
  },
});
fu({
  Class: as.prototype.constructor,
  type: 3,
  write(e) {
    return [...e];
  },
  read(e) {
    return Object.setPrototypeOf(e, as.prototype), e;
  },
});
fu({
  Class: i2.prototype.constructor,
  type: 4,
  write(e) {
    return e.id;
  },
  read(e) {
    return new i2(e);
  },
});
fu({
  Class: r2.prototype.constructor,
  type: 5,
  write(e) {
    return e.data;
  },
  read(e) {
    return new r2(e);
  },
});
fu({
  Class: _r.prototype.constructor,
  type: 6,
  write(e) {
    return { ...e };
  },
  read(e) {
    return Object.setPrototypeOf(e, _r.prototype), e;
  },
});
function yG(e) {
  var t = 0;
  if (e.length === 0) return t;
  for (let i = 0; i < e.length; i++) {
    let r = e[i];
    (t = (t << 5) - t + r), (t = t & t);
  }
  return t;
}
function ky(e) {
  if (Zx(e)) return e;
  if (Array.isArray(e)) return e.map(ky);
  if (typeof e == "object" && e !== null) {
    let t = {};
    for (let i of Object.keys(e).sort()) t[i] = ky(e[i]);
    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), t;
  } else return e;
}
var Ny;
((e) => {
  function t(s) {
    return f2.pack(s);
  }
  e.serialize = t;
  function i(s) {
    return f2.unpack(s);
  }
  e.deserialize = i;
  function r(s) {
    return yG(t(ky(s))).toString();
  }
  e.checksum = r;
})(Ny || (Ny = {}));
var m2;
((e) => {
  function t(r) {
    return r.type === "Conditional"
      ? r.condition.type === "Distance"
        ? "Distance"
        : "StateChange"
      : r.type;
  }
  e.toEventUIType = t;
  function i(r) {
    return r === "Distance" || r === "StateChange" ? "Conditional" : r;
  }
  e.fromEventUIType = i;
})(m2 || (m2 = {}));
var zs = {
    LookAt: [],
    Follow: ["Create"],
    DragDrop: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Create",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    MouseHover: [
      "Transition",
      "Animation",
      "Particles",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    Scroll: [
      "Transition",
      "Animation",
      "Create",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    Start: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    Conditional: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    MouseDown: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    MouseUp: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    MousePress: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    KeyDown: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    KeyUp: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    KeyPress: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "SwitchCamera",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    GameControl: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Create",
      "Conditional",
    ],
    Collision: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Create",
      "Destroy",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    Trigger: [
      "Transition",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    Resize: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
    VariableChange: [
      "Transition",
      "Animation",
      "Audio",
      "Particles",
      "Video",
      "Link",
      "Create",
      "Destroy",
      "SwitchCamera",
      "SceneTransition",
      "Reset",
      "SetVariable",
      "DynamicVariablePlay",
      "Conditional",
    ],
  },
  g2;
((e) => {
  function t(r) {
    return (
      r.type === "MouseDown" ||
      r.type === "MouseUp" ||
      r.type === "MousePress" ||
      r.type === "KeyDown" ||
      r.type === "KeyUp" ||
      r.type === "KeyPress"
    );
  }
  e.is = t;
  function i(r) {
    return r === "MouseDown" || r === "MouseUp" || r === "MousePress"
      ? {
          type: r,
          mode: "Object",
          disabled: !1,
          runMode: "Once",
          actions: new At(),
        }
      : {
          type: r,
          disabled: !1,
          key: void 0,
          runMode: "Once",
          actions: new At(),
        };
  }
  e.defaultData = i;
})(g2 || (g2 = {}));
var jm;
((e) => {
  function t(i) {
    return { type: "Property", value: [i ?? null, "position", "x"] };
  }
  (e.propertyDefaultData = t),
    (e.valueDefaultData = { type: "Literal", value: 0 });
})(jm || (jm = {}));
var Uy;
((e) => {
  function t(s) {
    return {
      type: "Comparison",
      operator: "==",
      lOperand: jm.propertyDefaultData(s),
      rOperand: { ...jm.valueDefaultData },
    };
  }
  e.comparisonDefaultData = t;
  function i(s) {
    return {
      type: "Distance",
      toObject: s ?? null,
      fromObject: s ?? null,
      distance: 200,
    };
  }
  e.distanceDefaultData = i;
  function r(s, a) {
    return { type: "State", object: s ?? null, state: a ?? null };
  }
  e.stateDefaultData = r;
})(Uy || (Uy = {}));
var v2;
((e) => {
  function t(r) {
    return r.type === "Conditional";
  }
  e.is = t;
  function i(r) {
    return {
      type: "Conditional",
      disabled: !1,
      inActions: new At(),
      outActions: new At(),
      condition: Uy.distanceDefaultData(r),
    };
  }
  e.defaultData = i;
})(v2 || (v2 = {}));
var y2;
((e) =>
  (e.defaultData = {
    type: "DragDrop",
    cursor: "hand",
    disabled: !1,
    dampingFactor: 1,
    objects: [],
    snapTo: "center",
    snapSurfaceMode: "bbox",
    snapSurfaceOffset: 0,
    dropOn: "all",
    autoOrient: !0,
    dropDestinations: [],
    plane: "adaptive",
    planeMode: "locked",
    referenceFrame: "global",
    limits: [-1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0],
    drop: !1,
    resetOnSnapFail: !1,
    snapSpeed: 20,
    resetSpeed: 20,
    dragDropActions: { drag: new At(), drop: new At() },
  }))(y2 || (y2 = {}));
var Vy;
((e) =>
  (e.defaultData = {
    type: "Follow",
    disabled: !1,
    maxDelta: 0,
    dampingFactor: 1,
    target: "cursor",
    plane: "custom",
    resetOnPointerLeave: !0,
    resetAfterDistanceLimit: !0,
    enabledTranslation: [!0, !0, !0],
    limitDistanceEnabled: !1,
    limitDistance: 1e3,
    snapDelay: 0,
    resetSpeed: 5,
    actions: new At(),
  }))(Vy || (Vy = {}));
var jy;
((e) =>
  (e.defaultData = {
    type: "LookAt",
    disabled: !1,
    distance: 1e3,
    dampingFactor: 1,
    target: "cursor",
    tilt: "up",
    axis: "z",
    plane: "custom",
    resetOnPointerLeave: !0,
    resetAfterDistanceLimit: !0,
    enabledRotation: [!0, !0, !0],
    limitDistanceEnabled: !1,
    limitDistance: 1e3,
    snapDelay: 0,
    resetSpeed: 5,
  }))(jy || (jy = {}));
var x2;
((e) => {
  function t(r) {
    return r.type === "MouseHover";
  }
  e.is = t;
  function i() {
    return { type: "MouseHover", disabled: !1, actions: new At() };
  }
  e.defaultData = i;
})(x2 || (x2 = {}));
var b2;
((e) => {
  function t(r) {
    return r.type === "Scroll";
  }
  e.is = t;
  function i() {
    return {
      type: "Scroll",
      disabled: !1,
      steps: 100,
      trigger: "load",
      startFrom: "enter",
      enterAnchor: "top",
      startOffset: 0,
      endAfter: 400,
      actions: new At(),
    };
  }
  e.defaultData = i;
})(b2 || (b2 = {}));
var w2;
((e) => {
  function t(r) {
    return r.type === "Start";
  }
  e.is = t;
  function i() {
    return { type: "Start", disabled: !1, actions: new At() };
  }
  e.defaultData = i;
})(w2 || (w2 = {}));
var _2;
((e) => {
  function t(r) {
    return r.type === "Collision";
  }
  e.is = t;
  function i() {
    return {
      type: "Collision",
      disabled: !1,
      runMode: "Once",
      target: "character",
      actions: new At(),
    };
  }
  e.defaultData = i;
})(_2 || (_2 = {}));
var S2;
((e) => {
  function t(r) {
    return r.type === "Trigger";
  }
  e.is = t;
  function i(r, s) {
    return {
      type: "Trigger",
      disabled: !1,
      runMode: "Once",
      target: "all",
      triggeringObjects: [],
      actions: new At(),
      triggerZone: "box",
      position: s.toArray(),
      rotation: [0, 0, 0],
      size: r.toArray(),
      radius: r.length() / 2,
      helperVisible: !0,
    };
  }
  e.defaultData = i;
})(S2 || (S2 = {}));
var Hy;
((e) => {
  e.defaultSizes = {
    mobile: [480, 480],
    tablet: [768, 768],
    desktop: [1200, 1200],
    custom: [769, 1200],
  };
  function t(n) {
    return n.type === "Resize";
  }
  e.is = t;
  function i(n) {
    return typeof n == "string" ? n : "custom";
  }
  e.sizeToDevice = i;
  function r(n) {
    return typeof n == "string" ? [...e.defaultSizes[n]] : [...n];
  }
  e.deviceToSize = r;
  function s() {
    let n = { size: "mobile", operator: "<", actions: new At() },
      o = { size: "tablet", operator: "<", actions: new At() },
      l = {
        size: [...e.defaultSizes.custom],
        operator: "<>",
        actions: new At(),
      },
      h = new At();
    return (
      h.push(
        { id: dt.generateUUID(), fi: 0, data: n },
        { id: dt.generateUUID(), fi: 1, data: o },
        { id: dt.generateUUID(), fi: 2, data: l }
      ),
      {
        type: "Resize",
        disabled: !1,
        orientation: "horizontal",
        breakpoints: h,
      }
    );
  }
  e.defaultData = s;
  function a() {
    return {
      size: [...e.defaultSizes.custom],
      operator: "<>",
      actions: new At(),
    };
  }
  e.defaultBreakpointData = a;
})(Hy || (Hy = {}));
var Gy;
((e) => {
  e.propertyPaths = {
    Position: ["position"],
    "Position X": ["position", "x"],
    "Position Y": ["position", "y"],
    "Position Z": ["position", "z"],
    Rotation: ["rotation"],
    "Rotation X": ["rotation", "x"],
    "Rotation Y": ["rotation", "y"],
    "Rotation Z": ["rotation", "z"],
    Scale: ["scale"],
    "Scale X": ["scale", "x"],
    "Scale Y": ["scale", "y"],
    "Scale Z": ["scale", "z"],
    Width: ["width"],
    Height: ["height"],
    Depth: ["depth"],
    "Mouse Position X": ["mouse", "x"],
    "Mouse Position Y": ["mouse", "y"],
    "Mouse Pressed": ["mouse", "pressed"],
    "Screen Width": ["mouse", "width"],
    "Screen Height": ["mouse", "height"],
    "Hit Position X": ["raycast", "x"],
    "Hit Position Y": ["raycast", "y"],
    "Hit Position Z": ["raycast", "z"],
    "Hit Object Position X": ["raycast", "objX"],
    "Hit Object Position Y": ["raycast", "objY"],
    "Hit Object Position Z": ["raycast", "objZ"],
  };
  function t(r) {
    return r.type === "VariableChange";
  }
  e.is = t;
  function i() {
    return {
      disabled: !1,
      type: "VariableChange",
      actions: new At(),
      variableId: "",
      objectId: null,
      property: "Position X",
    };
  }
  e.defaultData = i;
})(Gy || (Gy = {}));
var mu = "personal camera",
  Ad = "a218fcc3-276b-49b9-b485-49037fd14f5f",
  xG = 2960946,
  ea = 5526619,
  tl;
((e) => {
  function t(d, p) {
    return d[0] === p[0] && d[1] === p[1];
  }
  e.isEqual = t;
  function i(d, p, f) {
    return [d[0] + (p[0] - d[0]) * f, d[1] + (p[1] - d[1]) * f];
  }
  e.lerp = i;
  function r(d, p) {
    return [d[0] + p[0], d[1] + p[1]];
  }
  e.add = r;
  function s(d, p) {
    return [d[0] - p[0], d[1] - p[1]];
  }
  e.sub = s;
  function a(d, p) {
    return Math.pow(p[0] - d[0], 2) + Math.pow(p[1] - d[1], 2);
  }
  e.distanceSquared = a;
  function n(d, p) {
    return Math.sqrt(a(d, p));
  }
  e.distance = n;
  function o(d, p) {
    return d[0] * p[0] + d[1] * p[1];
  }
  e.dot = o;
  function l(d, p) {
    return [d[0] * p, d[1] * p];
  }
  e.scalarMultiply = l;
  function h(d, p, f) {
    let m = e.sub(p, d),
      g = e.sub(f, d),
      y = e.dot(m, g) / e.dot(m, m),
      x = e.scalarMultiply(m, y);
    return e.add(d, x);
  }
  e.projectionOnto = h;
  function u(d, p, f) {
    return n(d, h(d, p, f));
  }
  e.projectionOntoDistance = u;
  function c(d, p) {
    return [(d[0] + p[0]) * 0.5, (d[1] + p[1]) * 0.5];
  }
  e.center = c;
})(tl || (tl = {}));
var ih;
((e) => {
  function t(l, h) {
    return l[0] === h[0] && l[1] === h[1] && l[2] === h[2];
  }
  e.isEqual = t;
  function i(l, h) {
    return [l[0] + h[0], l[1] + h[1], l[2] + h[2]];
  }
  e.add = i;
  function r(l, h) {
    return [l[0] - h[0], l[1] - h[1], l[2] - h[2]];
  }
  e.sub = r;
  function s(l, h) {
    return [l[0] / h[0], l[1] / h[1], l[2] / h[2]];
  }
  e.div = s;
  function a(l, h) {
    return [l[0] * h[0], l[1] * h[1], l[2] * h[2]];
  }
  e.mul = a;
  function n(l, h) {
    return Math.hypot(l[0] - h[0], l[1] - h[1], l[2] - h[2]);
  }
  e.dist = n;
  function o(l, h, u) {
    return [
      l[0] + (h[0] - l[0]) * u,
      l[1] + (h[1] - l[1]) * u,
      l[2] + (h[2] - l[2]) * u,
    ];
  }
  e.lerp = o;
})(ih || (ih = {}));
var Hm;
((e) => {
  function t(r, s) {
    return r[0] === s[0] && r[1] === s[1] && r[2] === s[2] && r[3] === s[3];
  }
  e.isEqual = t;
  function i(r, s, a) {
    return [
      r[0] + (s[0] - r[0]) * a,
      r[1] + (s[1] - r[1]) * a,
      r[2] + (s[2] - r[2]) * a,
      r[3] + (s[3] - r[3]) * a,
    ];
  }
  e.lerp = i;
})(Hm || (Hm = {}));
var Xc;
((e) => {
  e.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  function t(s, a) {
    for (let n = 0; n < 16; n++) if (s[n] !== a[n]) return !1;
    return !0;
  }
  e.isEqual = t;
  function i(s) {
    return s ?? e.identity;
  }
  e.simplify = i;
  function r(s, a) {
    let n = a.slice(0);
    for (var o = 0, l = a.length; o < l; o += 3) {
      let h = s[3] * a[o] + s[7] * a[o + 1] + s[11] * a[o + 2] + s[15];
      (n[o] = (s[0] * a[o] + s[4] * a[o + 1] + s[8] * a[o + 2] + s[12]) / h),
        (n[o + 1] =
          (s[1] * a[o] + s[5] * a[o + 1] + s[9] * a[o + 2] + s[13]) / h),
        (n[o + 2] =
          (s[2] * a[o] + s[6] * a[o + 1] + s[10] * a[o + 2] + s[14]) / h);
    }
    return n;
  }
  e.applyMatrix4 = r;
})(Xc || (Xc = {}));
var us;
((e) => {
  function t(h) {
    return (
      typeof h == "object" &&
      typeof h.r == "number" &&
      typeof h.g == "number" &&
      typeof h.b == "number"
    );
  }
  (e.isRGB = t),
    (e.white = { r: 1, g: 1, b: 1 }),
    (e.red = { r: 1, g: 0, b: 0 }),
    (e.black = { r: 0, g: 0, b: 0 });
  function i(h) {
    return {
      r: Math.round(h.r * 255),
      g: Math.round(h.g * 255),
      b: Math.round(h.b * 255),
      a: 1,
    };
  }
  e.toRgb255a1 = i;
  function r(h) {
    return { r: h.r, g: h.g, b: h.b };
  }
  e.clone = r;
  function s(h) {
    return (
      (h = Math.floor(h)),
      {
        r: ((h >> 16) & 255) / 255,
        g: ((h >> 8) & 255) / 255,
        b: (h & 255) / 255,
      }
    );
  }
  e.fromHex = s;
  function a(h) {
    return (
      Math.round(h.r * 255) * 65536 +
      Math.round(h.g * 255) * 256 +
      Math.round(h.b * 255)
    );
  }
  e.toHex = a;
  function n(h, u) {
    return h.r === u.r && h.g === u.g && h.b === u.b;
  }
  e.equals = n;
  function o(h, u) {
    return (
      h.r.toFixed(2) === u.r.toFixed(2) &&
      h.g.toFixed(2) === u.g.toFixed(2) &&
      h.b.toFixed(2) === u.b.toFixed(2)
    );
  }
  e.equalsFixed = o;
  function l(h, u, c) {
    return {
      r: h.r + (u.r - h.r) * c,
      g: h.g + (u.g - h.g) * c,
      b: h.b + (u.b - h.b) * c,
    };
  }
  e.lerp = l;
})(us || (us = {}));
var Ti;
((e) => {
  (e.white = { ...us.white, a: 1 }), (e.transparent = { ...us.white, a: 0 });
  function t(l) {
    return { r: l[0], g: l[1], b: l[2], a: l[3] };
  }
  e.from0to1 = t;
  function i(l, h) {
    return { ...us.fromHex(l), a: h };
  }
  e.fromHexAndA = i;
  function r(l) {
    return {
      r: Math.round(l.r * 255),
      g: Math.round(l.g * 255),
      b: Math.round(l.b * 255),
      a: l.a,
    };
  }
  e.toRgb255a1 = r;
  function s(l, h) {
    return us.equals(l, h) && l.a === h.a;
  }
  e.equals = s;
  function a(l, h) {
    return us.equalsFixed(l, h) && l.a.toFixed(2) === h.a.toFixed(2);
  }
  e.equalsFixed = a;
  function n(l, h, u) {
    return {
      r: l.r + (h.r - l.r) * u,
      g: l.g + (h.g - l.g) * u,
      b: l.b + (h.b - l.b) * u,
      a: l.a + (h.a - l.a) * u,
    };
  }
  e.lerp = n;
  function o({ r: l, g: h, b: u, a: c } = e.white) {
    return `rgba(${l * 255}, ${h * 255}, ${u * 255}, ${c})`;
  }
  e.toStyle = o;
})(Ti || (Ti = {}));
var Wy;
((e) =>
  (e.identity = {
    position: [0, 0, 0],
    rotation: [0, 0, 0],
    scale: [1, 1, 1],
  }))(Wy || (Wy = {}));
var A2;
((e) => (e.defaultData = { mass: 1, stiffness: 80, damping: 10, velocity: 0 }))(
  A2 || (A2 = {})
);
var M2;
((e) => (e.defaultData = { control1: [0.5, 0], control2: [0.5, 1] }))(
  M2 || (M2 = {})
);
var Xo;
((e) => (
  (e.linear = [0, 0, 1, 1]),
  (e.ease = [0.25, 0.1, 0.25, 1]),
  (e.easeIn = [0.42, 0, 1, 1]),
  (e.easeOut = [0, 0, 0.58, 1]),
  (e.easeInOut = [0.42, 0, 0.58, 1])
))(Xo || (Xo = {}));
function E2(e) {
  return typeof e == "string" && e.length === 36
    ? /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(e)
    : !1;
}
var uh;
((e) => {
  e.all = ["PerspectiveCamera", "OrthographicCamera"];
  function t(i) {
    return e.all.includes(i);
  }
  e.is = t;
})(uh || (uh = {}));
var Qc;
((e) => {
  (e.DefaultUp = [0, 1, 0]),
    (e.DefaultTargetOffset = 1e3),
    (e.defaultData = {
      far: 1e5,
      type: "OrthographicCamera",
      perspective: { near: 70, fov: 45, zoom: 1 },
      orthographic: { near: -1e5, zoom: 1 },
      up: e.DefaultUp,
      isUpVectorFlipped: !1,
      targetOffset: e.DefaultTargetOffset,
    });
  function t(i) {
    return i.type === "PerspectiveCamera"
      ? i.perspective.zoom
      : i.orthographic.zoom;
  }
  e.getZoom = t;
})(Qc || (Qc = {}));
var il;
((e) => {
  function t(r, s = 0.1) {
    return {
      disabled: !1,
      type: "linear",
      hideBase: !1,
      count: 3,
      radial: {
        radius: Math.max(r[0], r[1]) * 2,
        start: 0,
        end: 360,
        alignment: !1,
        axis: "y",
        scale: [1, 1, 1],
        rotation: [0, 0, 0],
        position: [0, 0, 0],
      },
      toObject: {
        object: "",
        spreadType: "random",
        scale: [0, 0, 0],
        rotation: [0, 0, 0],
        position: [0, 0, 0],
        axis: "x",
        seed: 0,
        count: 99,
        align: "normal",
      },
      linear: {
        scale: [1, 1, 1],
        rotation: [0, 0, 0],
        position: [r[0] + r[0] * s, 0, 0],
      },
      grid: {
        count: [2, 2, 2],
        size: r.map((a) => a * (1 + s)),
        useCenter: !0,
      },
      randomness: !1,
      randomnessObject: {
        strength: 100,
        scale: [0, 0, 0],
        rotation: [0, 0, 0],
        position: [0, 0, 0],
        movement: 1,
        seed: 0,
        freqScale: 10,
        noiseType: "perlin",
      },
    };
  }
  e.defaultData = t;
  function i(r, s) {
    let a = { ...r };
    if (
      (jT.forEach((n) => {
        Object.assign(a, { [n]: s[n] ?? r[n] });
      }),
      (a.radial = { ...r.radial }),
      s.radial)
    ) {
      let n = r.radial,
        o = s.radial;
      HT.forEach((l) => {
        Object.assign(a.radial, { [l]: o[l] ?? n[l] });
      });
    }
    if (((a.linear = { ...r.linear }), s.linear)) {
      let n = r.linear,
        o = s.linear;
      GT.forEach((l) => {
        Object.assign(a.linear, { [l]: o[l] ?? n[l] });
      });
    }
    if (((a.grid = { ...r.grid }), s.grid)) {
      let n = r.grid,
        o = s.grid;
      WT.forEach((l) => {
        Object.assign(a.grid, { [l]: o[l] ?? n[l] });
      });
    }
    if (((a.toObject = { ...r.toObject }), s.toObject)) {
      let n = r.toObject,
        o = s.toObject;
      qT.forEach((l) => {
        Object.assign(a.toObject, { [l]: o[l] ?? n[l] });
      });
    }
    if (
      ((a.randomnessObject = { ...r.randomnessObject }), s.randomnessObject)
    ) {
      let n = r.randomnessObject,
        o = s.randomnessObject;
      YT.forEach((l) => {
        Object.assign(a.randomnessObject, { [l]: o[l] ?? n[l] });
      });
    }
    return a;
  }
  e.merge = i;
})(il || (il = {}));
var qy;
((e) => {
  e.defaultData = {
    radial: {},
    linear: {},
    grid: {},
    toObject: {},
    randomnessObject: {},
  };
  let t = ["radial", "linear", "grid", "toObject", "randomnessObject"];
  function i(r, s) {
    let a = [];
    r.count !== void 0 &&
      a.push({ type: 0, path: s, props: { count: r.count } });
    for (let n of t) {
      let o = r[n];
      o &&
        Object.keys(o).length > 0 &&
        a.push({ type: 0, path: [...s, n], props: o });
    }
    return a;
  }
  e.toOps = i;
})(qy || (qy = {}));
var jT = ["count"],
  HT = ["radius", "start", "end", "position", "scale", "rotation"],
  GT = ["position", "scale", "rotation"],
  WT = ["count", "size"],
  qT = ["count", "position", "scale", "rotation"],
  YT = [
    "strength",
    "scale",
    "rotation",
    "position",
    "movement",
    "seed",
    "freqScale",
  ],
  Yy;
((e) => {
  e.all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"];
  function t(i) {
    return e.all.includes(i);
  }
  e.is = t;
})(Yy || (Yy = {}));
var Xy;
((e) => {
  function t(r) {
    return i(r);
  }
  e.defaultData = t;
  function i(r) {
    if (r === "PointLight")
      return {
        type: r,
        color: Ti.white,
        intensity: 1,
        distance: 2e3,
        decay: 1,
        shadows: !0,
        shadowResolution: 1024,
        shadowRadius: 1,
        penumbraSize: 0.5,
        depth: 1e5,
      };
    if (r === "SpotLight")
      return {
        type: r,
        color: Ti.white,
        intensity: 1,
        distance: 2e3,
        decay: 1,
        shadows: !0,
        penumbra: 0,
        angle: (30 / 180) * Math.PI,
        depth: 1e5,
        penumbraSize: 0.5,
        shadowResolution: 1024,
        shadowRadius: 1,
      };
    if (r === "DirectionalLight")
      return {
        type: r,
        color: Ti.white,
        intensity: 1,
        shadows: !0,
        size: 2e3,
        depth: 1e5,
        penumbraSize: 0.5,
        shadowResolution: 1024,
        shadowRadius: 1,
      };
    throw new Error("not implemented");
  }
})(Xy || (Xy = {}));
var Gm;
((e) => (
  (e.defaultShapeData = { type: "PlaneEmitterShape", size: [100, 100, 100] }),
  (e.defaultCollisionData = { colliderEntityId: null, collisionBounce: 0.75 }),
  (e.defaultData = {
    renderMaterial: {
      type: "particleMaterial",
      color: { r: 1, g: 0.2, b: 0.545, a: 1 },
      color2: { r: 0.945, g: 0.714, b: 0.184, a: 1 },
      coloring: "gradient",
      ease: "linearFadeOut",
      easeSize: "linearFadeOut",
      transparent: !0,
      size: [40, 40],
      texture: "pt_default_particle",
      spriteRotation: [0, 0],
    },
    birthRatePerSec: 50,
    gravity: 1,
    noiseStrength: 0,
    noiseScale: 0,
    noiseSeed: 1,
    noiseType: "curl",
    randomRotation: 0,
    randomScale: 0.2,
    randomMass: 0.5,
    rootObjectType: "instancedMesh",
    life: 1,
    direction: [0, 0, 0],
    directionMode: "axis",
    speed: 10,
    shape: e.defaultShapeData,
    autoPlay: !0,
    emitTimeDelay: 0,
    emitTimeCycle: "infinity",
    emitTimeLoopDelayStart: "end",
    emitTimeDuration: 1,
    ...e.defaultCollisionData,
  })
))(Gm || (Gm = {}));
var Zc;
((e) =>
  (e.defaultData = {
    enabled: "visibility",
    fusedBody: !0,
    rigidBody: "positioned",
    density: 1,
    pointMass: 0,
    gravityScale: 1,
    friction: 0.5,
    damping: 0,
    restitution: 0.2,
    colliderType: "convex",
    enabledRotation: [!0, !0, !0],
    enabledTranslation: [!0, !0, !0],
  }))(Zc || (Zc = {}));
var Qy;
((e) => {
  e.defaultData = { castShadow: !0, receiveShadow: !0 };
  function t(i, r) {
    return i.castShadow === r.castShadow && i.receiveShadow === r.receiveShadow;
  }
  e.equals = t;
})(Qy || (Qy = {}));
var Zy;
((e) => {
  e.defaultData = { flatShading: !1, wireframe: !1, side: 0 };
  function t(i, r) {
    return (
      i.flatShading === r.flatShading &&
      i.side === r.side &&
      i.wireframe === r.wireframe
    );
  }
  e.equals = t;
})(Zy || (Zy = {}));
var Ky;
((e) => (e.defaultData = { ...Zy.defaultData, ...Qy.defaultData }))(
  Ky || (Ky = {})
);
var C2;
((e) => {
  function t(i, r) {
    let s = [];
    if ("material" in i) {
      let a =
        typeof i.material == "string"
          ? r.materials[i.material] ?? r.lib.materials[i.material]?.asset
          : i.material;
      a && s.push(a);
    } else if ("materials" in i)
      for (let a of i.materials) {
        let n =
          typeof a == "string"
            ? r.materials[a] ?? r.lib.materials[a]?.asset
            : a;
        n && s.push(n);
      }
    return s;
  }
  e.getMaterialData = t;
})(C2 || (C2 = {}));
var Wm;
((e) => (
  (e.defaultVideo = {
    data: "",
    thumb: "/_assets/_videos/catThumb.png",
    type: "video",
    name: "Cat video",
  }),
  (e.maxSize = 3e7)
))(Wm || (Wm = {}));
var T2;
((e) => {
  function t(i) {
    return (
      i === "texture" ||
      i === "video" ||
      i === "color" ||
      i === "depth" ||
      i === "normal" ||
      i === "gradient" ||
      i === "noise" ||
      i === "fresnel" ||
      i === "rainbow" ||
      i === "toon" ||
      i === "outline" ||
      i === "particle" ||
      i === "transmission" ||
      i === "matcap" ||
      i === "displace" ||
      i === "pattern" ||
      i === "light"
    );
  }
  e.is = t;
})(T2 || (T2 = {}));
function bG(e) {
  return e.type !== "displace";
}
var P2;
((e) => {
  function t(i) {
    return i === "phong" || i === "toon" || i === "lambert" || i === "physical";
  }
  e.is = t;
})(P2 || (P2 = {}));
var XT = [
    "mode",
    "gradientType",
    "noiseType",
    "displacementType",
    "projection",
    "cnormal",
    "crop",
    "axis",
    "side",
  ],
  wG = ["wrapping", "image", "video", "name", "minFilter"],
  jr;
((e) => {
  function t(a, n) {
    let { texture: o, ...l } = n;
    if ((Object.assign(a, l), o)) {
      let h = a.texture;
      h && Object.assign(h, o);
    }
  }
  e.patch = t;
  function i(a, n) {
    return a === "light" && n ? r(n) : s(a);
  }
  e.defaultData = i;
  function r(a) {
    let n = {
      mode: 0,
      isMask: !1,
      visible: !0,
      bumpMap: void 0,
      bumpMapIntensity: 5,
      roughnessMap: void 0,
      alphaOverride: 1,
    };
    switch (a) {
      case "phong":
        return {
          ...n,
          category: "phong",
          specular: { r: 0.2, g: 0.2, b: 0.2 },
          shininess: 5,
          type: "light",
          visible: !0,
          mode: 0,
          occlusion: !0,
          alpha: 0.6,
        };
      case "toon":
        return {
          ...n,
          category: "toon",
          specular: { r: 0.2, g: 0.2, b: 0.2 },
          shininess: 10,
          type: "light",
          alpha: 1,
        };
      case "lambert":
        return {
          ...n,
          category: "lambert",
          emissive: { r: 0, g: 0, b: 0 },
          type: "light",
          alpha: 1,
          visible: !0,
          mode: 0,
          occlusion: !0,
        };
      case "physical":
        return {
          ...n,
          category: "physical",
          roughness: 0.2,
          metalness: 0.2,
          reflectivity: 0.2,
          type: "light",
          alpha: 1,
          visible: !0,
          mode: 0,
          occlusion: !0,
        };
    }
  }
  function s(a) {
    let n = { alpha: 1, mode: 0, isMask: !1, visible: !0 };
    switch (a) {
      case "texture":
        return {
          ...n,
          type: "texture",
          size: [128, 128],
          blending: 0,
          axis: "x",
          side: 2,
          projection: 0,
          texture: {
            image: "image_0",
            wrapping: 1e3,
            repeat: [1, 1],
            offset: [0, 0],
            minFilter: 1008,
          },
          crop: !1,
        };
      case "video":
        return {
          ...n,
          type: "video",
          size: [128, 128],
          blending: 0,
          axis: "x",
          side: 2,
          projection: 0,
          texture: {
            video: Wm.defaultVideo,
            wrapping: 1001,
            repeat: [1, 1],
            offset: [0, 0],
            minFilter: 1008,
          },
          crop: !1,
        };
      case "color":
        return { ...n, type: "color", color: us.fromHex(ea) };
      case "depth":
        return {
          ...n,
          type: "depth",
          gradientType: 1,
          smooth: !1,
          isVector: !0,
          isWorldSpace: !1,
          origin: [0, 0, 0],
          direction: [1, 0, 0],
          colors: [
            [1, 1, 1, 1],
            [0, 0, 0, 1],
          ],
          steps: [0, 1],
          near: 50,
          far: 200,
        };
      case "normal":
        return { ...n, type: "normal", cnormal: [1, 1, 1] };
      case "gradient":
        return {
          ...n,
          type: "gradient",
          gradientType: 0,
          smooth: !1,
          colors: [
            [0, 0, 0, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
          ],
          steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          num: 2,
          angle: 0,
          offset: [0, 0],
          morph: [0, 0],
        };
      case "noise":
        return {
          ...n,
          type: "noise",
          size: [100, 100, 100],
          noiseType: 0,
          scale: 1,
          move: 1,
          colorA: { ...us.fromHex(6710886), a: 1 },
          colorB: { ...us.fromHex(6710886), a: 1 },
          colorC: { ...us.fromHex(16777215), a: 1 },
          colorD: { ...us.fromHex(16777215), a: 1 },
          distortion: [1, 1],
          fA: [1.7, 9.2],
          fB: [8.3, 2.8],
          voronoiStyle: 0,
          highCut: 1,
          lowCut: 0,
          smoothness: 0.3,
          seed: 0,
          quality: 1,
        };
      case "fresnel":
        return {
          ...n,
          type: "fresnel",
          color: Ti.fromHexAndA(16777215, 1),
          bias: 0.1,
          scale: 1,
          intensity: 2,
          factor: 1,
        };
      case "rainbow":
        return {
          ...n,
          type: "rainbow",
          filmThickness: 30,
          movement: 0,
          wavelengths: [0, 0, 0],
          noiseStrength: 0,
          noiseScale: 1,
          offset: [0, 0, 0],
        };
      case "toon":
        return {
          ...n,
          type: "toon",
          positioning: 2,
          colors: [
            [0, 0, 0, 1],
            [0.5, 0.5, 0.5, 1],
            [0.5, 0.5, 0.5, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
          ],
          steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1],
          num: 4,
          source: [0, 1e3, 0],
          isWorldSpace: !0,
          noiseStrength: 0,
          noiseScale: 1,
          shadowColor: Ti.fromHexAndA(0, 0),
          offset: [0, 0, 0],
        };
      case "outline":
        return {
          ...n,
          type: "outline",
          outlineColor: Ti.fromHexAndA(0, 1),
          contourColor: Ti.fromHexAndA(0, 1),
          outlineWidth: 2,
          contourWidth: 5,
          outlineThreshold: 0.4,
          contourThreshold: 0,
          outlineSmoothing: 0,
          contourFrequency: 10,
          contourDirection: [0, 1, 0],
          positionalLines: !1,
          compensation: !0,
        };
      case "matcap":
        return {
          ...n,
          type: "matcap",
          texture: {
            image: "matcap_0",
            wrapping: 1001,
            repeat: [1, 1],
            offset: [0, 0],
            minFilter: 1008,
          },
        };
      case "transmission":
        return {
          ...n,
          type: "transmission",
          thickness: 10,
          ior: 1.5,
          roughness: 1,
        };
      case "displace":
        return {
          visible: !0,
          type: "displace",
          displacementType: "noise",
          noiseType: 0,
          scale: 10,
          movement: 1,
          offset: [0, 0, 0],
          intensity: 8,
          voronoiStyle: 0,
          smoothness: 0.3,
          seed: 0,
          highCut: 1,
          lowCut: 0,
          quality: 1,
        };
      case "pattern":
        return {
          ...n,
          type: "pattern",
          style: 0,
          projection: 0,
          axis: "y",
          blending: 0,
          offset: [0, 0],
          colorA: { ...us.fromHex(0), a: 1 },
          colorB: { ...us.fromHex(16777215), a: 1 },
          frequency: [10, 10],
          size: 0.5,
          variation: 0,
          smoothness: 0.5,
          zigzag: 0,
          rotation: 0,
          vertical: [0, 1],
          horizontal: [0, 1],
          sides: 6,
        };
    }
  }
})(jr || (jr = {}));
var gs;
((e) => {
  function t(u) {
    return !u.layers.some(
      (c) =>
        (c.data.type === "texture" && c.data.projection !== 0) ||
        (c.data.type === "depth" && !c.data.isWorldSpace) ||
        c.data.type === "noise" ||
        c.data.type === "displace"
    );
  }
  e.isMergable = t;
  function i(u) {
    let c = "";
    return (
      u.layers.forEach((d) => {
        Object.entries(d.data).forEach(([p, f]) => {
          (c += `${p}${f}`),
            Array.isArray(f)
              ? f.forEach((m) => (c += `${m}`))
              : typeof f == "object"
              ? Object.values(f).forEach((m) => {
                  typeof m == "number"
                    ? (c += `${m.toFixed(4)}`)
                    : (c += `${m}`);
                })
              : (c += `${f}`);
        });
      }),
      c
    );
  }
  e.getHash = i;
  function r() {
    return { layers: new At() };
  }
  e.defaultEmptyData = r;
  function s(u = "layer1", c = "layer2") {
    return n("phong", u, c);
  }
  e.defaultData = s;
  function a(u, c) {
    return { ...u, name: c };
  }
  e.withName = a;
  function n(u, c = "layer1", d = "layer2") {
    let p = new At();
    return (
      p.push({ fi: 0, data: jr.defaultData("light", u), id: c }),
      p.push({ fi: 1, data: jr.defaultData("color"), id: d }),
      { layers: p }
    );
  }
  e.defaultTwoLayerData = n;
  function o(u) {
    let c = jr.defaultData("texture");
    u && Object.assign(c.texture, { image: u });
    let d = new At();
    return (
      d.push({ fi: 0, data: c, id: "layer1" }),
      d.push({
        fi: 1,
        data: { ...jr.defaultData("transmission"), alpha: 1 },
        id: "layer2",
      }),
      d.push({
        fi: 2,
        data: { ...jr.defaultData("light", "lambert"), alpha: 0 },
        id: "layer3",
      }),
      { layers: d }
    );
  }
  e.defaultUIObjectMaterial = o;
  function l(u, c = "phong", d = "layer1", p = "layer2") {
    let f = jr.defaultData("texture");
    Object.assign(f.texture, { image: u });
    let m = new At();
    return (
      m.push({ fi: 0, data: f, id: d }),
      m.push({ fi: 1, data: jr.defaultData("light", c), id: p }),
      { layers: m }
    );
  }
  e.defaultTwoLayerTextureData = l;
  function h(u, c = "phong", d = "layer1", p = "layer2") {
    let f = jr.defaultData("video");
    Object.assign(f.texture, { video: u });
    let m = new At();
    return (
      m.push({ fi: 0, data: f, id: d }),
      m.push({ fi: 1, data: jr.defaultData("light", c), id: p }),
      { layers: m }
    );
  }
  e.defaultTwoLayerVideoTextureData = h;
})(gs || (gs = {}));
var qm;
((e) => {
  function t() {
    return { points: new At(), roundness: 0, shapeHoles: [], isClosed: !1 };
  }
  e.defaultData = t;
})(qm || (qm = {}));
var Ym;
((e) => {
  function t() {
    return {
      points: new At(),
      lastInsertionPlane: null,
      subdivisions: 12,
      isClosed: !1,
    };
  }
  e.defaultData = t;
})(Ym || (Ym = {}));
var QT = {
    type: "Ellipse",
    width: 50,
    height: 50,
    spikes: 16,
    angle: 360,
    innerRadius: 0,
  },
  Jy;
((e) => {
  function t(i, r) {
    let s = { ...i };
    return (
      KT.forEach((a) => {
        Object.assign(s, { [a]: r[a] ?? i[a] });
      }),
      s
    );
  }
  e.merge = t;
})(Jy || (Jy = {}));
var ZT = {
    shape: QT,
    depth: 1,
    offset: 0,
    bevel: 50,
    bevelSides: 6,
    angle: 0,
    twist: 0,
    startScale: 1,
    endScale: 1,
    capType: "flat",
  },
  KT = ["depth", "offset", "angle", "twist", "startScale", "endScale"],
  Xm;
((e) => {
  function t(r) {
    return (
      r === "PolygonGeometry" ||
      r === "RectangleGeometry" ||
      r === "StarGeometry" ||
      r === "TriangleGeometry" ||
      r === "EllipseGeometry" ||
      r === "UIGeometry"
    );
  }
  e.is2DParametricMesh = t;
  function i(r) {
    return (
      r === "PolygonGeometry" ||
      r === "PolygonGeometry" ||
      r === "RectangleGeometry" ||
      r === "StarGeometry" ||
      r === "TriangleGeometry" ||
      r === "EllipseGeometry" ||
      r === "PathGeometry" ||
      r === "VectorGeometry" ||
      r === "ConeGeometry" ||
      r === "CubeGeometry" ||
      r === "CylinderGeometry" ||
      r === "DodecahedronGeometry" ||
      r === "HelixGeometry" ||
      r === "IcosahedronGeometry" ||
      r === "LatheGeometry" ||
      r === "PyramidGeometry" ||
      r === "SphereGeometry" ||
      r === "PlaneGeometry" ||
      r === "BackdropGeometry" ||
      r === "TorusGeometry" ||
      r === "TorusKnotGeometry" ||
      r === "BooleanGeometry" ||
      r === "TextGeometry"
    );
  }
  e.isParametricMesh = i;
})(Xm || (Xm = {}));
var $y;
((e) => {
  function t(i, r) {
    let s = { ...i };
    return (
      Object.assign(s, r),
      s.type === "PathGeometry" &&
        "extrusion" in r &&
        r.extrusion &&
        ((s.extrusion = { ...i.extrusion }),
        Object.assign(s.extrusion, Jy.merge(s.extrusion, r.extrusion))),
      s
    );
  }
  e.merge = t;
})($y || ($y = {}));
var Pc;
((e) => {
  function t(i) {
    if (i === "RectangleGeometry")
      return {
        width: 320,
        height: 320,
        type: i,
        cornerRadius: [0, 0, 0, 0],
        cornerType: 0,
        depth: 0,
        extrudeBevelSize: 0,
        extrudeBevelSegments: 1,
      };
    if (i === "UIGeometry")
      return {
        type: i,
        frame: "",
        cornerRadius: [0, 0, 0, 0],
        cornerType: 0,
        width: 1,
        height: 1,
      };
    if (i === "PathGeometry")
      return {
        type: i,
        width: 1,
        height: 1,
        depth: 1,
        path: Ym.defaultData(),
        extrusion: ZT,
      };
    if (i === "VectorGeometry")
      return {
        width: 1,
        height: 1,
        type: i,
        subdivisions: 12,
        shape: qm.defaultData(),
        depth: 0,
        extrudeBevelSize: 0,
        extrudeBevelSegments: 1,
      };
    if (i === "BooleanGeometry")
      return {
        type: i,
        operation: 2,
        width: 0,
        height: 0,
        depth: 0,
        phongAngle: 35,
      };
    if (i === "TextGeometry")
      return {
        type: i,
        width: 100,
        height: 100,
        depth: 0,
        horizontalAlign: 1,
        verticalAlign: 1,
        fontSize: 16,
        lineHeight: 1.2,
        letterSpacing: 0,
        text: { textValue: "" },
        textTransform: 1,
        font: "Roboto_regular",
        extrudeBevelSize: 0,
        extrudeBevelSegments: 1,
      };
    if (i === "SphereGeometry")
      return {
        type: "SphereGeometry",
        width: 100,
        height: 100,
        depth: 100,
        widthSegments: 64,
        heightSegments: 64,
        phiStart: 0,
        phiLength: 2 * Math.PI,
        thetaStart: 0,
        thetaLength: 180,
      };
    throw new Error("not implemented");
  }
  e.defaultData = t;
})(Pc || (Pc = {}));
var D2 = ["width", "height", "depth"],
  e1;
((e) =>
  (e.defaultData = {
    enabled: !1,
    useBackgroundColor: !1,
    color: us.white,
    near: 0.1,
    far: 2e3,
  }))(e1 || (e1 = {}));
var Qm;
((e) => {
  let t = { opacity: 1, blendFunction: 13, enabled: !1 };
  e.defaultData = {
    enabled: !1,
    pixelation: { ...t, blendFunction: 16, granularity: 15 },
    bloom: {
      ...t,
      blendFunction: 16,
      intensity: 1,
      blurScale: 1,
      luminanceThreshold: 0.25,
      luminanceSmoothing: 0.025,
      kernelSize: 3,
    },
    chromaticAberration: { ...t, offset: [2, 2] },
    vignette: { ...t, darkness: 1, offset: 0 },
    hueSaturation: { ...t, hue: 3, saturation: 0 },
    brightnessContrast: { ...t, brightness: 0.25, contrast: 0 },
    depthOfField: { ...t, focalLength: 2, focusDistance: 2, bokehScale: 2 },
    noise: { ...t, blendFunction: 16 },
  };
})(Qm || (Qm = {}));
var t1;
((e) => (e.defaultData = { softShadowQuality: "low" }))(t1 || (t1 = {}));
var i1;
((e) =>
  (e.defaultData = {
    enabled: !0,
    color: {
      r: 0.8274509803921568,
      g: 0.8274509803921568,
      b: 0.8274509803921568,
    },
    intensity: 0.75,
  }))(i1 || (i1 = {}));
var r1;
((e) =>
  (e.defaultData = {
    occlusion: !1,
    aoFullRes: !1,
    radius: 256,
    bias: 0.5,
    aoColor: {
      r: 0.19607843137254902,
      g: 0.19607843137254902,
      b: 0.19607843137254902,
    },
  }))(r1 || (r1 = {}));
var Kc;
((e) => (e.defaultData = { usePhysics: !1, gravity: -10 }))(Kc || (Kc = {}));
var s1;
((e) => (e.defaultData = { playCamera: mu, gameControlObject: null }))(
  s1 || (s1 = {})
);
var a1;
((e) =>
  (e.defaultData = {
    backgroundColor: Ti.fromHexAndA(xG, 1),
    postprocessing: Qm.defaultData,
    fog: e1.defaultData,
    globalPhysics: Kc.defaultData,
    ambient: i1.defaultData,
    ao: r1.defaultData,
    shadow: t1.defaultData,
    publish: s1.defaultData,
  }))(a1 || (a1 = {}));
var n1;
((e) =>
  (e.defaultData = {
    colliderType: "box",
    size: [100, 100, 100],
    colliderHelperVisible: !0,
    forceType: "collider",
    forceRange: "global",
    forceIntensity: 0.5,
    forceDambing: 0.95,
  }))(n1 || (n1 = {}));
var O2;
((e) => {
  function t(r) {
    return r === "Component" || r === "Instance";
  }
  e.isComponentRelated = t;
  function i(r) {
    return r === "Empty" || r === "Instance";
  }
  e.isEmptyOrComponent = i;
})(O2 || (O2 = {}));
var Jc;
((e) => {
  e.identity = { ...Wy.identity, hiddenMatrix: Xc.identity };
  function t(s) {
    return {
      position: s.position,
      rotation: s.rotation,
      scale: s.scale,
      hiddenMatrix: s.hiddenMatrix,
    };
  }
  e.fromObject = t;
  function i(s, a) {
    return {
      position: a?.position || s.position,
      rotation: a?.rotation || s.rotation,
      scale: a?.scale || s.scale,
      hiddenMatrix: a?.hiddenMatrix || s.hiddenMatrix,
    };
  }
  e.merge = i;
  function r(s, a) {
    return pT({
      position: ih.isEqual(s.position, a.position) ? void 0 : a.position,
      rotation: ih.isEqual(s.rotation, a.rotation) ? void 0 : a.rotation,
      scale: ih.isEqual(s.scale, a.scale) ? null : a.scale,
      hiddenMatrix: Xc.isEqual(s.hiddenMatrix, a.hiddenMatrix)
        ? void 0
        : a.hiddenMatrix,
    });
  }
  e.diff = r;
})(Jc || (Jc = {}));
var ns;
((e) =>
  (e.defaultData = {
    states: new At(),
    events: new At(),
    visible: !0,
    raycastLock: !1,
    physics: Zc.defaultData,
    pathSnapping: {
      pathId: null,
      slide: 0,
      offset: 0,
      orientation: "tangential",
    },
    ...Jc.identity,
    cloner: null,
  }))(ns || (ns = {}));
var o1;
((e) => (e.defaultData = { type: "Empty", ...ns.defaultData }))(
  o1 || (o1 = {})
);
var I2;
((e) =>
  (e.defaultData = {
    type: "ParticleCollider",
    ...n1.defaultData,
    ...ns.defaultData,
  }))(I2 || (I2 = {}));
var R2;
((e) => (e.defaultData = { type: "Component", ...ns.defaultData }))(
  R2 || (R2 = {})
);
var L2;
((e) =>
  (e.defaultData = { type: "Particle", ...ns.defaultData, ...Gm.defaultData }))(
  L2 || (L2 = {})
);
var Dc;
((e) =>
  (e.defaultData = { type: "Mesh", ...ns.defaultData, ...Ky.defaultData }))(
  Dc || (Dc = {})
);
var Gd;
((e) =>
  (e.defaultData = {
    ...ns.defaultData,
    ...Jc.identity,
    position: [0, 0, Qc.DefaultTargetOffset],
    ...Qc.defaultData,
  }))(Gd || (Gd = {}));
var l1;
((e) => {
  function t(i) {
    return { ...ns.defaultData, ...Xy.defaultData(i) };
  }
  (e.defaultData = t),
    (e.defaultDirectionalLightData = {
      ...e.defaultData("DirectionalLight"),
      position: [200, 300, 300],
      name: "Directional Light",
      intensity: 0.7,
    });
})(l1 || (l1 = {}));
var Zm;
((e) => {
  function t(r, s, a = 0) {
    for (; a < s.length; ) {
      let n = r ? r[s[a]] : void 0;
      if (s.length === a + 1) return n;
      if (n) (r = n.descendants), (a += 1);
      else return;
    }
  }
  e.resolveWithDes = t;
  function i(r, s, a = 0) {
    let n = t(r, s, a);
    if (n) {
      let o = Object.keys(n);
      if (o.length === 1 && o[0] === "descendants") return;
    }
    return n;
  }
  e.resolve = i;
})(Zm || (Zm = {}));
var rl;
((e) => {
  (e.rootOverrideProps = ["physics", "events"]),
    (e.compositeNonOptionalOverrideProps = ["geometry"]),
    (e.compositeEntireOverrideOverrideProps = ["material"]);
  function t(r, s) {
    return {
      ...ns.defaultData,
      ...s,
      component: r,
      overrides: new _r(),
      physics: void 0,
      events: void 0,
      type: "Instance",
    };
  }
  e.ofComponent = t;
  function i(r) {
    let s = Jc.fromObject(r.data);
    return t(r.id, s);
  }
  e.fromComponentData = i;
})(rl || (rl = {}));
var $c;
((e) => {
  e.defaultData = {
    type: "Page",
    ...ns.defaultData,
    physics: { ...Zc.defaultData, fusedBody: !1 },
    ...a1.defaultData,
    camera: Gd.defaultData,
  };
  function t(i) {
    return i.uiScene !== void 0;
  }
  e.isUIPage = t;
})($c || ($c = {}));
var h1;
((e) => (
  (e.defaultCamera = {
    position: [0, 0, 1e3],
    scale: [1, 1, 1],
    rotation: [0, 0, 0],
    hiddenMatrix: Xc.identity,
    name: "Play Camera",
    visible: !0,
    raycastLock: !1,
    physics: Zc.defaultData,
    states: new At(),
    events: new At(),
    cloner: null,
    pathSnapping: {
      pathId: null,
      orientation: "tangential",
      slide: 0,
      offset: 0,
    },
    ...Qc.defaultData,
  }),
  (e.KeysByResetCategory = {
    States: ["states"],
    Events: ["events"],
    Material: ["material", "materials"],
    Geometry: ["geometry"],
    Position: ["position"],
    Rotation: ["rotation"],
    Scale: ["scale"],
    Transform: ["position", "scale", "rotation", "hiddenMatrix"],
    Name: ["name"],
    Visibility: ["visible", "raycastLock", "flatShading", "wireframe", "side"],
    Shadows: ["castShadow", "receiveShadow"],
    Cloner: ["cloner"],
    Physics: ["physics"],
  }),
  (e.defaultMeshObject = {
    name: "Rectangle",
    ...ns.defaultData,
    ...Dc.defaultData,
    geometry: Pc.defaultData("RectangleGeometry"),
    material: gs.defaultTwoLayerData("phong", "layer1", "layer2"),
  }),
  (e.defaultBooleanObject = {
    name: "Boolean",
    ...ns.defaultData,
    ...Dc.defaultData,
    geometry: Pc.defaultData("BooleanGeometry"),
    material: gs.defaultTwoLayerData("phong", "layer1", "layer2"),
  }),
  (e.defaultTextObject = {
    name: "Text",
    ...ns.defaultData,
    ...Dc.defaultData,
    geometry: Pc.defaultData("TextGeometry"),
    material: gs.defaultTwoLayerData("phong", "layer1", "layer2"),
  })
))(h1 || (h1 = {}));
var Wl;
((e) => {
  function t(a, n) {
    let o = { name: n };
    return (
      a.type === "Mesh"
        ? ((o.geometry = {}),
          "material" in a && (o.material = { layers: new _r() }),
          "materials" in a &&
            (o.materials = a.materials.map((l) => ({ layers: new _r() }))))
        : uh.is(a.type) && ((o.perspective = {}), (o.orthographic = {})),
      o
    );
  }
  e.newEmpty = t;
  function i(a, n) {
    if (n === void 0) return a;
    let o = { ...a };
    return (
      "material" in o &&
        "material" in n &&
        n.material &&
        (o.material = Hd(o.material, (l) => {
          if (typeof l != "string")
            for (let [h, u] of Object.entries(n.material.layers)) {
              let c = l.layers.data(h);
              c && jr.patch(c, u);
            }
        }).data),
      o.materials &&
        n.materials &&
        (o.materials = Hd(o.materials, (l) => {
          for (let h = 0; h < o.materials.length; h++) {
            let u = n.materials[h];
            if (typeof u != "string")
              for (let [c, d] of Object.entries(u.layers)) {
                let p = l[h]?.layers?.data(c);
                p && jr.patch(p, d);
              }
          }
        }).data),
      o
    );
  }
  function r(a, n) {
    let o,
      l = [],
      h = { orthographic: 0, perspective: 0, geometry: 0 };
    function u(c, d) {
      for (let [p, f] of Object.entries(d.layers)) {
        let { texture: m, ...g } = f;
        if (m !== void 0 && Object.keys(m).length > 0) {
          let y = { path: [...c, "layers", p, "texture"], props: m, type: 0 };
          l.push(y);
        }
        if (Object.keys(g).length > 0) {
          let y = { path: [...c, "layers", p], props: g, type: 0 };
          l.push(y);
        }
      }
    }
    for (let [c, d] of Object.entries(n))
      if (c !== "name")
        if (c === "cloner") l.push(...qy.toOps(d, ["cloner"]));
        else if (c === "pathSnapping")
          l.push({
            path: [c],
            props: { slide: d.slide, offset: d.offset },
            type: 0,
          });
        else if (c === "material") u(["material"], d);
        else if (c === "materials")
          for (let [p, f] of Object.entries(d)) u(["materials", p], f);
        else if (h[c] === 0) {
          if (c === "geometry" && d.extrusion !== void 0) {
            let p = { path: [c, "extrusion"], props: d.extrusion, type: 0 };
            l.push(p), (d = { ...d }), delete d.extrusion;
          }
          if (Object.keys(d).length > 0) {
            let p = { path: [c], props: d, type: 0 };
            l.push(p);
          }
        } else
          o === void 0 && ((o = { path: [], props: {}, type: 0 }), l.push(o)),
            (o.props[c] = d);
    return l;
  }
  e.toOps = r;
  function s(a, n) {
    if (n === void 0) return a;
    let o = { ...a };
    if (
      (Object.assign(o, Jc.merge(o, n)),
      Object.assign(o, {
        pathSnapping: Object.assign({}, o.pathSnapping, {
          slide: n.pathSnapping?.slide ?? o.pathSnapping?.slide ?? 0,
          offset: n.pathSnapping?.offset ?? o.pathSnapping?.offset ?? 0,
        }),
      }),
      uh.is(a.type))
    ) {
      (o.orthographic = { ...o.orthographic }),
        (o.perspective = { ...o.perspective });
      let l = n;
      l.orthographic?.zoom !== void 0 &&
        (o.orthographic.zoom = l.orthographic.zoom),
        l.perspective?.zoom !== void 0 &&
          (o.perspective.zoom = l.perspective.zoom),
        l.isUpVectorFlipped !== void 0 &&
          (o.isUpVectorFlipped = l.isUpVectorFlipped),
        l.targetOffset !== void 0 && (o.targetOffset = l.targetOffset);
    } else if (a.type === "Mesh")
      "geometry" in n &&
        Object.assign(o, { geometry: $y.merge(o.geometry, n.geometry) }),
        (n.material || n.materials) && (o = i(o, n)),
        o.cloner &&
          "cloner" in n &&
          Object.assign(o, { cloner: il.merge(o.cloner, n.cloner) });
    else if (a.type === "Empty")
      o.cloner &&
        "cloner" in n &&
        Object.assign(o, { cloner: il.merge(o.cloner, n.cloner) });
    else if (Yy.is(a.type)) {
      let l = n;
      l.intensity !== void 0 && (o.intensity = l.intensity),
        l.color !== void 0 &&
          (typeof l.color == "string"
            ? (o.color = l.color)
            : (o.color = us.clone(l.color)));
    }
    return o;
  }
  e.patch = s;
})(Wl || (Wl = {}));
var Km;
((e) =>
  (e.defaultData = {
    enablePan: !0,
    enableZoom: !0,
    enableRotate: !0,
    enableDamping: !0,
    rotationLimitsMode: 0,
    rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
    rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
    rotationSoftLimit: 2,
    panLimitsMode: 0,
    panVerticalOffset: { min: 250, max: 250 },
    panHorizontalOffset: { min: 250, max: 250 },
    panSoftLimit: 2,
    zoomLimitsEnabled: !1,
    zoomLimits: { min: 0.1, max: 2 },
    autoRotate: !1,
    autoRotateSpeed: 2,
    autoRotateClockwise: !0,
    hoverRotatePanMode: 0,
    hoverRotatePanStrength: 20,
    hoverRotateDamping: 0.125,
    isTouchZoom: !0,
    orbitTouches: 2,
    panTouches: 3,
    resetHoverEffectOnPointerLeave: !0,
  }))(Km || (Km = {}));
var sl;
((e) =>
  (e.defaultData = {
    orbitControls: Km.defaultData,
    playPage: Ad,
    withBackground: !0,
    preventScroll: !1,
    preventTouchScroll: !1,
    hideCursor: !1,
    mouseEventTarget: "canvas",
    joystickSizeAndXYOffset: Array(12)
      .fill(0)
      .map((t, i) => {
        let r = 0,
          s = 0;
        return (
          i < 5 ? (s = -30) : i < 10 && (s = 30),
          i === 0 || i === 10 || i === 5
            ? (r = 30)
            : (i === 4 || i === 11 || i === 9) && (r = -30),
          [120, [r, s], "show"]
        );
      }),
    settings: {
      image: { format: "jpg", ratio: 1 },
      video: {
        format: "mp4",
        imageFormat: "jpg",
        fps: 30,
        mbps: 80,
        ratio: Math.max(
          1,
          typeof window < "u" ? Math.floor(window.devicePixelRatio) : 1
        ),
        stopMode: "manual",
        duration: 5e3,
      },
      web: { logo: !0, compress: !0, preset: 1, preload: !0, hint: !1 },
    },
    stopRaycast: !0,
    hdTransmission: !1,
  }))(sl || (sl = {}));
var c1;
((e) =>
  (e.defaultData = { id: "basic", label: "Basic", style: "None", prompt: "" }))(
  c1 || (c1 = {})
);
var u1;
((e) =>
  (e.defaultData = {
    weather: 0,
    shadows: 0,
    lightOrigin: 0,
    temperature: 0,
    sun: 0,
    camera: 0,
    environment: 0,
    particles: 0,
    nature: 0,
    floor: 0,
  }))(u1 || (u1 = {}));
var ql;
((e) => (
  (e.defaultData = () => ({
    mode: "line-art-both",
    prompt: "",
    negativePrompt: "",
    style: { ...c1.defaultData },
    isRandomSeed: !0,
    seed: e.generateSeed(),
    guessMode: !1,
    advanced: !1,
    steps: 20,
    guidanceScale: 7.5,
    controlNetScale: 1,
    modifiers: u1.defaultData,
  })),
  (e.generateSeed = () => Math.round(Math.random() * 1e5))
))(ql || (ql = {}));
var Wd;
((e) => {
  function t(r) {
    return (
      r.find(
        (s) => s.data.type === "Page" && s.data.globalPhysics.usePhysics
      ) !== void 0
    );
  }
  e.physicsEnabled = t;
  function i(r, s, a) {
    r.scene.objects.traverseFrom(s, (n, o) => {
      if (o.type === "Instance") {
        let l = tg.getComponentData(r, o.component)?.data;
        l && a(n, o, l.events);
      } else a(n, o, o.events);
    });
  }
  e.traverseModuleInstances = i;
})(Wd || (Wd = {}));
var Yl;
((e) => {
  e.TRASH_CAN_ID = "830a2708-8ed9-49cf-a68e-085299892222";
  function t(s = { withLight: !0, withSquare: !0 }) {
    let a = [],
      n = h1.defaultMeshObject;
    s.withLight === !0 &&
      a.push({
        fi: -1,
        data: l1.defaultDirectionalLightData,
        id: "830a2708-8ed9-49cf-a68e-085299899103",
        children: [],
      }),
      s.withSquare === !0 &&
        a.push({
          fi: 1,
          id: "7ba78968-2a55-48f2-b14c-5191da3e075e",
          data: n,
          children: [],
        });
    let o = new as();
    return (
      o.push({
        fi: 1,
        id: Ad,
        data: { ...$c.defaultData, name: "Scene 1" },
        children: a,
      }),
      o
    );
  }
  (e.defaultData = {
    objects: t(),
    publish: sl.defaultData,
    styles: ql.defaultData(),
  }),
    (e.emptyDataWithoutPage = function () {
      return {
        objects: new as(),
        publish: sl.defaultData,
        styles: ql.defaultData(),
      };
    }),
    (e.emptyDataWithPage = function (s) {
      return {
        objects: t(s),
        publish: sl.defaultData,
        styles: ql.defaultData(),
      };
    }),
    (e.emptyData = function () {
      return {
        objects: new as(),
        publish: { ...sl.defaultData },
        styles: ql.defaultData(),
      };
    });
  function i(s) {
    return { ...e.defaultData, objects: In(s, as.prototype) };
  }
  e.withObjs = i;
  function r(s, a) {
    return i([{ id: s, data: a, children: [], fi: 0 }]);
  }
  e.withObj = r;
})(Yl || (Yl = {}));
var Md;
((e) =>
  (e.defaultData = {
    preset: "fullscreen",
    allowResponsive: !1,
    size: [512, 512],
    coords: [0, 0],
    sceneScale: 1,
    color: { r: 0, g: 0, b: 0, a: 0.5 },
  }))(Md || (Md = {}));
var Jm;
((e) =>
  (e.emptyImage = {
    data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",
    name: "empty",
  }))(Jm || (Jm = {}));
var $s;
((e) => {
  function t(n) {
    return n.textValue !== void 0;
  }
  e.isTextValue = t;
  function i(n) {
    return typeof n == "number";
  }
  e.isNumber = i;
  function r(n) {
    return typeof n == "boolean";
  }
  e.isBoolean = r;
  function s(n) {
    return t(n) ? "string" : r(n) ? "boolean" : "number";
  }
  e.typeOfVariable = s;
  function a(n) {
    return e.isTextValue(n)
      ? Array.isArray(n.textValue)
        ? n.textValue
            .map((o) => o.toString().padStart(n.padding ?? 2, "0"))
            .join(n.deliminator ?? ":") +
          (n.suffix !== void 0 ? " " + n.suffix : "")
        : n.textValue.toString()
      : e.isBoolean(n)
      ? n
        ? "True"
        : "False"
      : e.isNumber(n)
      ? parseFloat(n.toFixed(3)).toString()
      : n.toString();
  }
  e.getDisplayedValue = a;
})($s || ($s = {}));
var d1;
((e) =>
  (e.all = [
    "images",
    "videos",
    "colors",
    "audios",
    "particles",
    "fonts",
    "materials",
    "variables",
  ]))(d1 || (d1 = {}));
var B2;
((e) => (e.all = [...d1.all, "components"]))(B2 || (B2 = {}));
var z2;
((e) => {
  function t() {
    return {
      images: new Ft(),
      videos: new Ft(),
      colors: new Ft(),
      audios: new Ft(),
      particles: new Ft(),
      fonts: new Ft(),
      materials: new Ft(),
      components: new Ft(),
      variables: new Ft(),
    };
  }
  e.defaultData = t;
})(z2 || (z2 = {}));
var dh;
((e) => {
  function t() {
    return {
      images: new Ft(),
      videos: new Ft(),
      colors: new Ft(),
      audios: new Ft(),
      particles: new Ft(),
      fonts: new Ft(),
      materials: new Ft(),
      components: new Ft(),
      variables: new Ft(),
    };
  }
  e.defaultData = t;
})(dh || (dh = {}));
var wa;
((e) => {
  function t() {
    let n = {};
    return (
      (n["89b10010-844c-11ec-a8a3-0242ac120002"] = {
        r: 0.5,
        g: 0.5,
        b: 0.5,
        a: 1,
        name: "Default Color",
      }),
      In(n, Ft.prototype)
    );
  }
  e.defaultColors = t;
  function i(n) {
    let o = {};
    return (
      n?.withAITexture &&
        (o["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = {
          ...Jm.emptyImage,
          name: "AI generated image",
        }),
      In(o, Ft.prototype)
    );
  }
  e.defaultImages = i;
  function r() {
    return {
      catelogs: new Ft(),
      materials: new Ft(),
      images: new Ft(),
      videos: new Ft(),
      colors: new Ft(),
      audios: new Ft(),
      particles: new Ft(),
      fonts: new Ft(),
      variables: new At(),
      lib: dh.defaultData(),
    };
  }
  e.emptyData = r;
  function s(n) {
    switch (n) {
      case "number":
        return { value: 0, name: "Number" };
      case "boolean":
        return { value: !1, name: "Boolean" };
      case "string":
        return { value: { textValue: "String value" }, name: "String" };
      case "time":
        let o = [0, 0, 0];
        return {
          name: "Time",
          value: { textValue: o, deliminator: ":", padding: 2, suffix: "AM" },
          dynamicVariableType: "time",
          format: "HH:mm:ss",
          format12h24h: "12ampm",
          timeZone: null,
          hasEnd: !1,
          endValue: {
            textValue: o,
            deliminator: ":",
            padding: 2,
            suffix: "AM",
          },
          autoStart: !0,
          repeat: !1,
        };
      case "counter":
        return {
          name: "Counter",
          value: 0,
          dynamicVariableType: "counter",
          updateInterval: 1e3,
          increment: 1,
          autoStart: !0,
          hasEnd: !0,
          endValue: 60,
          repeat: !0,
          randomStart: !1,
          range: [0, 100],
          decimals: 0,
        };
      case "random":
        return {
          name: "Random",
          value: 0,
          dynamicVariableType: "random",
          updateInterval: 1e3,
          increment: 1,
          autoStart: !0,
          isStatic: !1,
          hasEnd: !0,
          endValue: 60,
          repeat: !0,
          min: 0,
          max: 100,
          decimals: 0,
        };
      default:
        console.error("Unknown variable type", n);
    }
  }
  e.defaultVariables = s;
  function a(n, o) {
    if (o.format === "HH:mm:ss") {
      let l = Math.floor(n / 3600),
        h = Math.floor((n - l * 3600) / 60),
        u = Math.round(n - l * 3600 - h * 60);
      return { textValue: [l, h, u] };
    } else if (o.format === "mm:ss") {
      let l = Math.floor(n / 60),
        h = Math.round(n - l * 60);
      return { textValue: [l, h] };
    } else
      return (
        o.format === "number"
          ? (n = Math.round(n))
          : (n = Math.round(n * 1e3) / 1e3),
        n
      );
  }
  e.getFormattedTimerTime = a;
})(wa || (wa = {}));
var $m;
((e) => (e.list = ["idle", "move", "jump", "run"]))($m || ($m = {}));
var eg;
((e) => (
  (e.defaultColliderData = {
    type: "capsule",
    height: 200,
    radius: 50,
    position: [0, 0, 0],
    rotation: [0, 0, 0],
  }),
  (e.defaultDataThirdPerson = {
    moveMode: "walk",
    forwardDirection: "+z",
    speedTranslate: 1e3,
    speedRotate: 100,
    runMultiplier: 2,
    rotationMode: "normal",
    rotBy: "keys",
    rotByTouch: "drag",
    delayPos: [0.3, 0.3],
    delayRot: [0.3, 0.3],
    keyAssignments: [
      ["moveNegZ", "W"],
      ["moveNegX", "A"],
      ["movePosZ", "S"],
      ["movePosX", "D"],
      ["rotPosX", "\u25B2"],
      ["rotPosY", "\u25C0"],
      ["rotNegX", "\u25BC"],
      ["rotNegY", "\u25B6"],
      ["jump", "Space"],
      ["run", "\u21E7"],
      ["none", "Ctrl"],
    ],
    touchControl: !0,
    joystickPosLoc: 5,
    joystickRotLoc: 11,
    jumpTouchButtonLoc: 9,
    collider: e.defaultColliderData,
    colliderHelperVisible: !0,
    collisionEnabled: !0,
    jumpPower: 100,
    resetYPosition: 3e3,
    alignToGround: !1,
    autoOrientMove: !0,
    orientWith: "camera",
    orientMode: "radial",
    delayPosCamera: 0.3,
    delayRotCamera: 0.3,
    camera: "",
    cameraXAxis: "Limit",
    cameraYAxis: "Free",
    cameraRotXLimits: [0, Math.PI / 2],
    cameraRotYLimits: [-Math.PI / 2, Math.PI / 2],
    gameActions: {
      idle: new At(),
      move: new At(),
      jump: new At(),
      run: new At(),
    },
    navmesh: {
      enabled: !1,
      ch: 6,
      cs: 6,
      walkableClimb: 5,
      walkableHeight: 1,
      walkableRadius: 0,
      zones: "all",
      objects: [],
      helperVisible: !0,
      destinationHelperRadius: 0,
      destinationHelperColor: Ti.fromHexAndA(3728051, 1),
    },
  })
))(eg || (eg = {}));
function F2(e) {
  e.layers.forEach((t) => {
    if (t.type === "depth" && t.colorA !== void 0) {
      let i = t.colorA,
        r = t.colorB,
        s = [
          [i.r, i.g, i.b, i.a],
          [r.r, r.g, r.b, r.a],
        ],
        a = [0, 1];
      for (let o = 2; o < 10; o++) s.push(s[1]), a.push(1);
      let n = {
        ...bo(
          hr(t),
          "type",
          "visible",
          "isVector",
          "isWorldSpace",
          "origin",
          "alpha",
          "mode"
        ),
        near: Math.max(0, t.near),
        far: Math.max(0, t.far),
        colors: s,
        steps: a,
        num: 2,
        direction: [1, 0, 0],
        smooth: !1,
        gradientType: 1,
      };
      Object.assign(t, n);
    } else if (
      t.type === "depth" &&
      t.gradientType === 1 &&
      (t.near < 0 || t.far < 0)
    ) {
      let i = { ...hr(t), near: Math.max(t.near, 0), far: Math.max(t.far, 0) };
      Object.assign(t, i);
    }
  });
}
function Qo(e, t) {
  Object.values(e.shared.materials).forEach((i) => t(i));
}
function Zo(e, t) {
  e.scene.objects.traverse((i, r) => {
    "materials" in r
      ? r.materials.forEach((s, a) => {
          s === void 0 &&
            ((r.materials[a] = gs.defaultData()), (s = r.materials[a])),
            typeof s != "string" && t(s);
        })
      : "material" in r
      ? typeof r.material != "string" &&
        (r.material === void 0 && (r.material = gs.defaultData()),
        t(r.material))
      : r.type === "Mesh" &&
        (r.material === void 0 && (r.material = gs.defaultData()),
        t(r.material)),
      "overrides" in r &&
        Object.values(r.overrides).forEach((s) => {
          s.material &&
            typeof s.material != "string" &&
            Object.getPrototypeOf(s.material) !== _r.prototype &&
            t(s.material);
        });
  });
}
function _G(e) {
  Object.assign(e.scene.publish, {
    orbitControls: { ...Km.defaultData, ...hr(e.scene.publish.orbitControls) },
  });
}
function SG(e) {
  Object.assign(e.scene.publish.settings, {
    video: {
      ...sl.defaultData.settings.video,
      ...hr(e.scene.publish.settings.video),
    },
  });
}
function AG(e) {
  function t(i) {
    if (i.layers) {
      for (let r of Object.values(i.layers))
        if (r) {
          for (let [s, a] of Object.entries(r))
            if (
              ((XT.includes(s) || typeof a == "boolean") && delete r[s],
              s === "texture")
            )
              for (let [n, o] of Object.entries(a))
                (wG.includes(n) || typeof o == "boolean") && delete a[n];
        }
    }
  }
  e.scene.objects.traverse((i, r) => {
    r.states.forEach((s) => {
      let a = s;
      a.material
        ? t(a.material)
        : a.materials &&
          a.materials.forEach((n) => {
            t(n);
          });
    });
  });
}
function MG(e) {
  e.scene.publish.withBackground = !0;
}
function EG(e) {
  e.scene.publish.settings.web = {
    compress: !0,
    preload: !0,
    preset: 1,
    logo: !0,
    hint: !1,
  };
}
function CG(e) {
  e.scene.objects.traverse((t, i) => {
    let r = i.cloner;
    r &&
      ((r.radial.scale = r.radial.scale.map((s) => s + 1)),
      (r.linear.scale = r.linear.scale.map((s) => s + 1)));
  });
}
function TG(e) {
  e.scene.objects.traverse((t, i) => {
    let r = i.geometry;
    r &&
      (r.type === "DodecahedronGeometry" || r.type === "IcosahedronGeometry") &&
      (r.detail = Math.round(r.detail));
  });
}
function PG(e) {
  e.scene.objects.traverse((t, i) => {
    let r = e.scene.objects.unproxy().parent(t);
    if (r) {
      let s = hr(e.scene.objects.data(r));
      s &&
        s.type === "Mesh" &&
        s.geometry.type === "BooleanGeometry" &&
        i.type === "Mesh" &&
        (i.visible = hr(i).booleanExclude !== !0);
    }
  });
}
function DG(e) {
  e.scene.objects.traverse((t, i) => {
    if (i.type === "Mesh") {
      let r = i;
      i.geometry.type === "NonParametricGeometry"
        ? r.material !== void 0 && delete r.material
        : r.materials !== void 0 && delete r.materials;
    }
  });
}
function OG(e) {
  function t(r) {
    Object.setPrototypeOf(r, _r.prototype),
      r.texture && Object.setPrototypeOf(r.texture, _r.prototype);
  }
  function i(r) {
    Object.setPrototypeOf(r, _r.prototype);
    for (let s in r) t(r[s]);
  }
  e.scene.objects.traverse((r, s) => {
    s.states.forEach((a) => {
      let n = a;
      if (n.material) {
        let o = hr(n.material).layers;
        i(o), (n.material.layers = o);
      }
      if (n.materials)
        for (let o = 0; o < n.materials.length; o++) {
          let l = n.materials[o],
            h = hr(l).layers;
          i(h), (l.layers = h);
        }
    });
  });
}
function k2(e) {
  e.layers === void 0 && Object.assign(e, gs.defaultTwoLayerData("lambert"));
}
function Jv(e) {
  !e.layers ||
    e.layers.forEach((t) => {
      if (t.type === "depth" && t.colors.length === 10) {
        let i = [...t.colors];
        i.push(t.colors[9]);
        let r = [...t.steps];
        r.push(t.steps[9]);
        let s = { ...hr(t), colors: i, steps: r };
        Object.assign(t, s);
      }
    });
}
function IG(e) {
  e.scene.objects.traverse((t, i) => {
    i.type === "Mesh" &&
      (i.geometry.type === "BooleanGeometry" ||
        i.geometry.type === "SubdivGeometry") &&
      (i.geometry.phongAngle = 35);
  });
}
function N2(e) {
  e.scene.objects.traverse((t, i) => {
    "materials" in i
      ? i.materials.forEach((r) => {
          typeof r != "string" && Jv(r);
        })
      : "material" in i && typeof i.material != "string" && Jv(i.material);
  }),
    Object.values(e.shared.materials).forEach((t) => Jv(t));
}
function RG(e) {
  (e.scene.environment.ambientLight.softShadows = !1),
    (e.scene.environment.ambientLight.softShadowQuality = "low"),
    e.scene.objects.traverse((t, i) => {
      (i.type === "DirectionalLight" || i.type === "SpotLight") &&
        ((i.shadowResolution = 1024), (i.shadowRadius = 1), (i.depth = 1e5));
    }),
    (e.shared.penumbraSize = new Array(5).fill(0.5));
}
function LG(e) {
  e.shared.audios = In({}, Ft.prototype);
}
function BG(e) {
  e.shared.videos = In({}, Ft.prototype);
}
function zG(e) {
  let t = e.shared.materials;
  Object.entries(t).forEach(([i, r]) => {
    if (!r.layers) {
      let s = {
        name: "Untitled Material",
        layers: [
          {
            fi: 0,
            data: {
              type: "light",
              category: "phong",
              alpha: 0.6,
              visible: !0,
              mode: 0,
              specular: { r: 0.2, g: 0.2, b: 0.2 },
              shininess: 5,
            },
            id: "layer1",
          },
          {
            fi: 1,
            data: {
              type: "color",
              alpha: 1,
              visible: !0,
              mode: 0,
              color: {
                r: 0.2823529411764706,
                g: 0.2823529411764706,
                b: 0.30196078431372547,
              },
            },
            id: "layer2",
          },
        ],
      };
      Object.assign(t, { [i]: s });
    }
  });
}
function FG(e) {
  Object.entries(hr(e.shared.images))
    .filter((t) => t[1].asset === !1)
    .map((t) => t[0])
    .forEach((t) => {
      delete e.shared.images[t];
    }),
    Object.entries(hr(e.shared.audios))
      .filter((t) => t[1].asset === !1)
      .map((t) => t[0])
      .forEach((t) => {
        delete e.shared.audios[t];
      });
}
function kG(e) {
  e.scene.publish.settings.web.preload = !1;
}
function U2(e) {
  e.layers &&
    e.layers.forEach((t) => {
      t.type === "depth" &&
        t.num !== void 0 &&
        ((t.colors = t.colors.slice(0, t.num)),
        (t.steps = t.steps.slice(0, t.num)),
        delete t.num);
    });
}
function V2(e) {
  e.layers &&
    e.layers.forEach((t) => {
      bG(t) && t.isMask === void 0 && (t.isMask = !1),
        (t.type === "texture" || t.type === "video") &&
          t.blending === void 0 &&
          (t.blending = 0),
        (t.type === "noise" ||
          (t.type === "displace" && t.displacementType === "noise")) &&
          (t.voronoiStyle === void 0 && (t.voronoiStyle = 0),
          t.highCut === void 0 && (t.highCut = 1),
          t.lowCut === void 0 && (t.lowCut = 0),
          t.smoothness === void 0 && (t.smoothness = 0.3),
          t.seed === void 0 && (t.seed = 0),
          t.quality === void 0 && (t.quality = 1));
    });
}
function NG(e) {
  e.shared.fonts = In({}, Ft.prototype);
}
function UG(e) {
  return e
    .replace(".typeface", "")
    .replace(/optimer/gi, "open sans")
    .replace("space_mono", "space mono")
    .replace(/alma_mono/gi, "varela round")
    .replace(/droid_sans_mono/gi, "noto sans mono")
    .replace(
      /droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi,
      "roboto"
    )
    .replace(/droid_serif/gi, "roboto slab")
    .replace("_sans", " sans")
    .replace("crimson_text", "crimson text")
    .replace("medium_medium", "medium")
    .replace("fatface_fatface", "fatface")
    .replace("100hairline", "thin")
    .replace("200thin", "extralight")
    .replace("300light", "light")
    .replace("500medium", "medium")
    .replace("600semi", "semibold")
    .replace("800heavy", "extrabold")
    .replace("900black", "black")
    .replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi, "bodoni_$1_$2")
    .replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda")
    .replace(/(thin|hairline)(_regular)?/gi, "100")
    .replace(/(extra|ultra)light(_regular)?/gi, "200")
    .replace(/light(_regular)?/gi, "300")
    .replace(/_book|_normal|_roman/gi, "_regular")
    .replace(/medium(_regular)?/gi, "500")
    .replace(/(semi|demi)bold(_regular)?/gi, "600")
    .replace(/(extra|ultra)bold(_regular)?/gi, "800")
    .replace(/bold(_regular)?/gi, "700")
    .replace(/(black|heavy|fatface)(_regular)?/gi, "900")
    .replace(/([1-9]00)_italic/gi, "$1italic")
    .replace(/regularitalic/gi, "italic")
    .replace(/regularitalic/gi, "italic")
    .split(" ")
    .map((t) => t.charAt(0).toUpperCase() + t.slice(1))
    .join(" ");
}
function VG(e) {
  let t = [];
  e.scene.objects.traverse((i, r) => {
    let s = r;
    if (s.type === "TextFrame") {
      let a = gs.defaultTwoLayerData("phong"),
        n = typeof s.color == "string" ? e.shared.colors[s.color] : s.color;
      (a.layers[1].data.color = { r: n.r, g: n.g, b: n.b }),
        (a.layers[1].data.alpha = s.alpha);
      let o = UG(s.font);
      e.shared.fonts[o] === void 0 && (e.shared.fonts[o] = { name: o });
      let l = {
          name: s.name,
          ...ns.defaultData,
          ...Dc.defaultData,
          flatShading: !1,
          wireframe: !1,
          geometry: {
            ...Pc.defaultData("TextGeometry"),
            width: s.width,
            height: s.height,
            font: o,
            depth: 0,
            horizontalAlign: s.horizontalAlign,
            verticalAlign: s.verticalAlign,
            fontSize: s.fontSize * 1.40625,
            lineHeight: s.lineHeight / 1.40625,
            letterSpacing: s.letterSpacing - 1,
            text: s.text,
            textTransform: s.textTransform,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1,
          },
          material: a,
          states: hr(s.states),
          events: hr(s.events),
          visible: s.visible,
          raycastLock: s.raycastLock,
          position: s.position,
          rotation: s.rotation,
          scale: s.scale,
          hiddenMatrix: s.hiddenMatrix,
        },
        h = hr(e.scene.objects).parent(i);
      e.scene.objects.insertAfter(h ?? null, i, [
        { id: i + "new", data: l, children: [] },
      ]),
        t.push(i);
    }
  }),
    t.forEach((i) => {
      e.scene.objects.delete(i);
    });
}
function jG(e) {
  let t = {
    0: "MouseDown",
    1: "MouseUp",
    2: "MouseHover",
    5: "KeyDown",
    6: "KeyUp",
    7: "Start",
    9: "LookAt",
    10: "Follow",
    11: "Scroll",
    12: "Audio",
    13: "GameControl",
  };
  e.scene.objects.traverse((i, r) => {
    r.events.forEach((s) => {
      if (t[Number(s.type)])
        if (
          (Object.assign(s, { type: t[Number(s.type)] }),
          s.type === "Audio" &&
            "audioEvent" in s &&
            (Object.assign(s, { playAudio: s.audioEvent }),
            delete s.audioEvent),
          s.type === "GameControl")
        )
          Object.assign(s, {
            gameActions: { idle: new At(), move: new At(), jump: new At() },
          });
        else {
          let a = new At();
          Object.assign(s, { actions: a }),
            (s.type === "MouseDown" ||
              s.type === "MouseUp" ||
              s.type === "KeyDown" ||
              s.type === "KeyUp") &&
              "url" in s &&
              a.push({
                fi: 0,
                id: dt.generateUUID(),
                data: { type: "Link", url: s.url, delay: 0 },
              }),
            "targets" in s &&
              (s.targets.forEach((n, o, l) => {
                let h = {
                    state: void 0,
                    repeat: 0,
                    delay: 0,
                    delayDirection: void 0,
                    direction: "normal",
                    duration: 0,
                    easing: 4,
                  },
                  u = { easing: n.easing, duration: n.duration };
                n.easing === 6
                  ? Object.assign(
                      u,
                      bo(n, "mass", "stiffness", "damping", "velocity")
                    )
                  : n.easing === 5 &&
                    Object.assign(u, {
                      control1: { ...n.control1 },
                      control2: { ...n.control2 },
                    });
                let c = {
                    repeat: n.repeat ? -1 : 0,
                    delay: n.delay,
                    delayDirection: n.delayDirection,
                    direction:
                      n.cycle && n.rewind
                        ? "pingpong-rewind"
                        : n.cycle
                        ? "pingpong"
                        : "normal",
                  },
                  d = { state: n.state, ...c, ...u },
                  p = {
                    allowSlerp: !0,
                    type: "Transition",
                    object: n.object,
                    repeat: 0,
                    delay: 0,
                    delayDirection: void 0,
                    direction: "normal",
                    tweens: new At(
                      { fi: 0, id: dt.generateUUID(), data: h },
                      { fi: 1, id: dt.generateUUID(), data: d }
                    ),
                  };
                a.push({ fi: l, id: o, data: p });
              }),
              delete s.targets);
        }
    });
  });
}
function HG(e) {
  e.scene.objects.traverse((t, i) => {
    function r(s, a) {
      let n = new At(),
        o = [];
      if (
        (i.events.forEach((l, h, u) => {
          if (l.type === "Audio" && l.trigger === a) {
            let c;
            o.push(h),
              l.interaction === "play"
                ? (c = {
                    ...bo(l, "interaction", "audio", "delay", "volume", "loop"),
                    triggerAfter: "after" in l ? l.after : void 0,
                    toggle: "after" in l ? l.toggle : void 0,
                    type: "Audio",
                  })
                : (l.interaction === "pause" || l.interaction === "stop") &&
                  (c = {
                    ...bo(l, "interaction", "delay", "object", "playAudio"),
                    type: "Audio",
                  }),
              c && n.push({ fi: u, id: h, data: c });
          }
        }),
        o.forEach((l) => i.events.delete(l)),
        n.length)
      ) {
        let l = i.events.find((h) => h.type === s)?.data;
        l
          ? "actions" in l && l.actions.insertBefore(null, n)
          : i.events.insertBefore(null, [
              { id: dt.generateUUID(), data: { type: s, actions: n } },
            ]);
      }
    }
    r("Start", "start"),
      r("MouseDown", "mouseDown"),
      r("MouseUp", "mouseUp"),
      r("KeyDown", "keyDown"),
      r("KeyUp", "keyUp");
  });
}
function j2(e) {
  let t = e.layers.find((i) => i.type === "light")?.data;
  if (t?.category === "basic") {
    let i = jr.defaultData("light", "phong"),
      r = t;
    Object.assign(r, i), (r.visible = !1);
  }
}
function H2(e) {
  Qo(e, j2), Zo(e, j2);
}
function GG(e) {
  e.scene.objects.traverse((t, i) => {
    i.type === "Mesh" &&
      i.geometry.type === "SubdivGeometry" &&
      (i.geometry.scaleBaked || (i.geometry.scaleBaked = [1, 1, 1]));
  });
}
function WG(e) {
  e.scene.objects.traverse((t, i) => {
    (i.type === "Empty" || i.type === "Mesh") &&
      i.cloner &&
      !i.cloner.randomnessObject &&
      !i.cloner.toObject &&
      !i.cloner.randomness &&
      (i.cloner = {
        ...i.cloner,
        toObject: {
          object: "",
          spreadType: "random",
          scale: [0, 0, 0],
          rotation: [0, 0, 0],
          position: [0, 0, 0],
          axis: "x",
          seed: 0,
          count: 99,
          align: "normal",
        },
        randomness: !1,
        randomnessObject: {
          strength: 100,
          scale: [0, 0, 0],
          rotation: [0, 0, 0],
          position: [0, 0, 0],
          movement: 1,
          seed: 0,
          freqScale: 10,
          noiseType: "perlin",
        },
      });
  });
}
function qG(e) {
  e.scene.objects.traverse((t, i) => {
    i.type === "Mesh" &&
      i.geometry.type === "NonParametricGeometry" &&
      !("material" in i) &&
      !("materials" in i) &&
      (i.material = gs.defaultTwoLayerData("phong"));
  });
}
function YG(e) {
  e.scene.publish.orbitControls.autoZoom === void 0 &&
    (e.scene.publish.orbitControls.autoZoom = !1),
    e.scene.objects.traverse((t, i) => {
      (i.type === "OrthographicCamera" || i.type === "PerspectiveCamera") &&
        (i.orthographic.autoZoom === void 0 && (i.orthographic.autoZoom = !1),
        i.orthographic.autoZoomFrustumSize === void 0 &&
          (i.orthographic.autoZoomFrustumSize = 790));
    });
}
function XG(e) {
  e.scene.objects.traverse((t, i) => {
    i.pathSnapping === void 0 &&
      (i.pathSnapping = {
        pathId: null,
        slide: 0,
        offset: 0,
        orientation: "tangential",
      }),
      i.pathSnapping.offset === void 0 && (i.pathSnapping.offset = 0);
  });
}
function QG(e) {
  e.scene.publish.mouseEventTarget === void 0 &&
    (e.scene.publish.mouseEventTarget = "canvas"),
    e.scene.publish.settings.web.hint === void 0 &&
      (e.scene.publish.settings.web.hint = !1);
}
function ZG(e) {
  let { video: t } = e.scene.publish.settings;
  t.format === "gif" && t.fps > 48 && (t.fps = 15);
}
function KG(e) {
  e.scene.objects.traverse((t, i) => {
    i.events.forEach((r) => {
      r.type === "GameControl" &&
        (r.resetYPosition = Math.abs(r.resetYPosition - i.position[1]));
    });
  });
}
function JG(e) {
  let t = e.scene.environment.usePhysics;
  e.scene.objects.traverse((i, r) => {
    t && r.physics === null ? (r.collision = !1) : (r.collision = "visibility");
  });
}
function $G(e) {
  e.scene.objects.traverse((t, i) => {
    i.events.forEach((r) => {
      r.type === "GameControl" &&
        (r.navmesh = eg.defaultDataThirdPerson.navmesh);
    });
  });
}
function e9(e) {
  e.scene.styles || (e.scene.styles = ql.defaultData());
}
function G2(e) {
  e.layers.forEach((t) => {
    t.type === "light" &&
      t.category !== "toon" &&
      t.occlusion === void 0 &&
      (t.occlusion = !0);
  });
}
function t9(e) {
  e.scene.environment.ambientLight.occlusion === void 0 &&
    (e.scene.environment.ambientLight.occlusion = !1),
    e.scene.environment.ambientLight.aoFullRes === void 0 &&
      (e.scene.environment.ambientLight.aoFullRes = !1),
    e.scene.environment.ambientLight.radius === void 0 &&
      (e.scene.environment.ambientLight.radius = 256),
    e.scene.environment.ambientLight.bias === void 0 &&
      (e.scene.environment.ambientLight.bias = 0.5),
    e.scene.environment.ambientLight.aoColor === void 0 &&
      (e.scene.environment.ambientLight.aoColor = {
        r: 0.19607843137254902,
        g: 0.19607843137254902,
        b: 0.19607843137254902,
      }),
    Zo(e, G2),
    Qo(e, G2);
}
function i9(e) {
  e.scene.objects.traverse((t, i) => {
    i.events.forEach((r) => {
      r.type === "GameControl" &&
        Object.assign(r.gameActions, { run: new At() });
    });
  });
}
function r9(e) {
  e.scene.objects.traverse((t, i) => {
    i.events.forEach((r) => {
      r.type === "GameControl" &&
        (r.keyAssignments = [
          ...r.keyAssignments,
          ["run", "\u21E7"],
          ["none", "Ctrl"],
        ]);
    });
  });
}
function W2(e) {
  e.layers &&
    e.layers.forEach((t) => {
      t.type === "light" &&
        t.bumpMapIntensity === void 0 &&
        (t.bumpMapIntensity = 5);
    });
}
function s9(e, t) {
  if (
    (t < 1 && (Zo(e, F2), Qo(e, F2), (e.schema = 1)),
    t < 2 && (_G(e), (e.schema = 2)),
    t < 3 && (AG(e), (e.schema = 3)),
    t < 4 && (MG(e), (e.schema = 4)),
    t < 5 && (EG(e), (e.schema = 5)),
    t < 6 && (CG(e), (e.schema = 6)),
    t < 7 && (TG(e), (e.schema = 7)),
    t < 8 && (e.schema = 8),
    t < 9 && (N2(e), (e.schema = 9)),
    t < 10 && (IG(e), (e.schema = 10)),
    t < 11 && (RG(e), (e.schema = 11)),
    t < 12 && (N2(e), (e.schema = 12)),
    t < 13 && (LG(e), (e.schema = 13)),
    t < 14 && (zG(e), (e.schema = 14)),
    t < 15 && (FG(e), (e.schema = 15)),
    t < 16 && (kG(e), (e.schema = 16)),
    t < 17 && (Zo(e, U2), Qo(e, U2), (e.schema = 17)),
    t < 18 && (Zo(e, k2), Qo(e, k2), (e.schema = 18)),
    t < 19 && (SG(e), (e.schema = 19)),
    t < 20 && (NG(e), VG(e), (e.schema = 20)),
    t < 21 && (jG(e), HG(e), (e.schema = 21)),
    t < 22 && (H2(e), (e.schema = 22)),
    t < 23 && (GG(e), (e.schema = 23)),
    t < 24 && (WG(e), (e.schema = 24)),
    (t < 25 || e.shared.videos === void 0) &&
      (BG(e), t < 25 && (e.schema = 25)),
    t < 26 && (PG(e), (e.schema = 26)),
    t < 27 && (DG(e), (e.schema = 27)),
    t < 28 && (H2(e), (e.schema = 28)),
    t < 29 && (OG(e), (e.schema = 29)),
    t < 30 && (qG(e), (e.schema = 30)),
    t < 31 && (YG(e), (e.schema = 31)),
    t < 33 && (XG(e), (e.schema = 33)),
    t < 34 && (QG(e), (e.schema = 34)),
    t < 35 && (ZG(e), (e.schema = 35)),
    t < 36 && (KG(e), (e.schema = 36)),
    t < 37 && (JG(e), (e.schema = 37)),
    t < 38 && (Zo(e, V2), Qo(e, V2), (e.schema = 38)),
    t < 39 && ($G(e), (e.schema = 39)),
    t < 40 && (e9(e), (e.schema = 40)),
    t < 41 && (t9(e), (e.schema = 41)),
    t < 42 && (i9(e), (e.schema = 42)),
    t < 43 && (r9(e), (e.schema = 43)),
    t < 99)
  ) {
    Zo(e, W2),
      Qo(e, W2),
      e.scene.publish.playCamera === null && (e.scene.publish.playCamera = mu);
    let i = hr(e.scene.objects),
      r = e.scene.objects;
    (e.scene.publish.playPage = Ad),
      r.insertBefore(null, null, [
        {
          id: Ad,
          data: {
            ...$c.defaultData,
            backgroundColor: e.scene.backgroundColor,
            fog: e.scene.fog,
            postprocessing: e.scene.postprocessing,
            ao: bo(
              e.scene.environment.ambientLight,
              "occlusion",
              "aoFullRes",
              "radius",
              "bias",
              "aoColor"
            ),
            publish: {
              playCamera: e.scene.publish.playCamera,
              gameControlObject: e.scene.publish.gameControlObject,
            },
            shadow: bo(e.scene.environment.ambientLight, "softShadowQuality"),
            globalPhysics: {
              ...Kc.defaultData,
              ...bo(e.scene.environment, "usePhysics", "gravity"),
            },
            camera: hr(e.scene.ownerCamera) ?? $c.defaultData.camera,
            name: "Scene",
          },
          children: [],
        },
      ]);
    for (let n of i) n.id !== Yl.TRASH_CAN_ID && r.move(Ad, n.fi, n.id);
    let s = 0,
      a = 0;
    e.shared.penumbraSize &&
      e.scene.objects.traverse((n, o) => {
        o.type === "DirectionalLight"
          ? ((o.penumbraSize = e.shared.penumbraSize[Math.min(s, 2)]), (s += 1))
          : o.type === "SpotLight" &&
            ((o.penumbraSize = e.shared.penumbraSize[3 + Math.min(a, 1)]),
            (a += 1)),
          (o.physics === void 0 || o.physics === null) &&
            o.type !== "Instance" &&
            ((o.physics = {}), Object.assign(o.physics, Zc.defaultData)),
          o.physics !== void 0 &&
            o.physics !== null &&
            ((o.physics.enabled = o.collision ?? "visibility"),
            delete o.collision);
      }),
      (e.schema = 99);
  }
}
function q2(e) {
  e.layers &&
    e.layers.forEach((t) => {
      t.type === "light" && t.alphaOverride === void 0 && (t.alphaOverride = 1);
    });
}
function a9(e) {
  e.scene.objects.traverse((t, i) => {
    let r = i.geometry;
    r &&
      r.type === "PathGeometry" &&
      ((r.extrusion.capType = "flat"),
      (r.extrusion.bevel = 50),
      (r.extrusion.bevelSides = 6),
      r.extrusion.shape.type === "Custom" &&
        (r.extrusion.shape.shapeQuality = "low"));
  });
}
function n9(e) {
  Array.isArray(hr(e.events)) &&
    e.events?.forEach((t) => {
      "disabled" in t || (t.disabled = !1),
        (t.type === "MouseDown" ||
          t.type === "MouseUp" ||
          t.type === "MousePress") &&
          (t.mode = t.mode || "Object");
    });
}
var mc = 180 / Math.PI;
function Y2(e) {
  e.rotation = e.rotation.slice(0, 3).map((t) => t * mc);
}
function JT(e) {
  Y2(e),
    e.type === "Page" && Y2(e.camera),
    e.states?.forEach((i) => {
      i.rotation === void 0 ||
        i.rotation === null ||
        (i.rotation = i.rotation.slice(0, 3).map((r) => r * mc));
    });
  let t = e.geometry;
  t &&
    t.type === "SphereGeometry" &&
    (t.thetaLength = (t.thetaLength ?? 180) * mc),
    t && t.type === "TorusGeometry" && (t.arc = t.arc * mc),
    t &&
      t.type === "PathGeometry" &&
      ((t.extrusion.angle *= mc), (t.extrusion.twist *= mc)),
    e.type === "Mesh" &&
      e.geometry.type === "TextGeometry" &&
      (e.geometry.text = { textValue: e.geometry.text }),
    Array.isArray(hr(e.events)) &&
      e.events?.forEach((i) => {
        (i.type === "MouseDown" ||
          i.type === "MouseUp" ||
          i.type === "MousePress" ||
          i.type === "KeyDown" ||
          i.type === "KeyUp" ||
          i.type === "KeyPress" ||
          i.type === "Collision" ||
          i.type === "Trigger") &&
          (i.runMode = i.toggle ? "Toggle" : "Repeat");
      });
}
function o9(e) {
  e.shared.variables = In({}, Ft.prototype);
}
function l9(e) {
  let t = hr(e.shared.variables);
  e.shared.variables = In(
    Object.entries(t ?? {}).map(([i, r], s) => ({ fi: s, id: i, data: r })),
    At.prototype
  );
}
var lo = 111;
function $T(e, t) {
  t(e.data);
  for (let i of e.children) $T(i, t);
}
function h9(e) {
  let t = e.schema ?? 104;
  t !== lo && t < 105 && ($T(e.asset, JT), (e.schema = 105));
}
function c9(e) {
  (e.shared.particles = In({}, Ft.prototype)),
    e.shared.lib && (e.shared.lib.particles = dh.defaultData().particles);
}
function u9(e) {
  e.scene.objects.traverse((t, i) => {
    i.type === "Particle" &&
      typeof i.renderMaterial.size == "number" &&
      Object.assign(i.renderMaterial, {
        size: [i.renderMaterial.size, i.renderMaterial.size],
      });
  });
}
function e3(e) {
  let t = e.schema ?? 0;
  if (t !== lo) {
    console.warn("updating from ", t, "to ", lo),
      s9(e, t),
      t < 100 &&
        (e.scene.publish.joystickSizeAndXYOffset === void 0 &&
          (e.scene.publish.joystickSizeAndXYOffset =
            sl.defaultData.joystickSizeAndXYOffset),
        (e.schema = 100)),
      t < 101 && (Zo(e, q2), Qo(e, q2), (e.schema = 101)),
      t < 102 && (a9(e), (e.schema = 102)),
      t < 104 &&
        ((e.shared.catelogs = new Ft()),
        (e.shared.lib = dh.defaultData()),
        (e.schema = 104)),
      t < 105 &&
        (o9(e),
        e.scene.objects.traverse((i, r) => {
          JT(r);
        }),
        (e.schema = 105));
    for (let i of Object.values(e.shared.lib.components)) h9(i);
    t < 106 && (l9(e), (e.schema = 106)),
      t < 107 &&
        ((e.shared.lib.variables = dh.defaultData().variables),
        (e.schema = 107)),
      t < 109 && (c9(e), (e.schema = 109)),
      t < 110 && (u9(e), (e.schema = 110)),
      t < 111 &&
        (e.scene.objects.traverse((i, r) => {
          n9(r);
        }),
        (e.schema = 111));
  }
}
var tg;
((e) => {
  (e.defaultData = {
    schema: lo,
    scene: Yl.defaultData,
    frames: new Ft().add(
      "72fc2993-2da3-4b6b-96ac-2879db3a28bd",
      Md.defaultData
    ),
    shared: { ...wa.emptyData(), colors: wa.defaultColors() },
  }),
    (e.emptyDataForImports = function (s) {
      let a = Yl.emptyDataWithPage(s);
      return {
        schema: lo,
        scene: a,
        frames: new Ft().add(
          "72fc2993-2da3-4b6b-96ac-2879db3a28bd",
          Md.defaultData
        ),
        shared: {
          ...wa.emptyData(),
          colors: wa.defaultColors(),
          images: wa.defaultImages(s),
        },
      };
    }),
    (e.emptyData = function () {
      return {
        schema: lo,
        scene: Yl.emptyDataWithPage(),
        frames: new Ft().add(
          "72fc2993-2da3-4b6b-96ac-2879db3a28bd",
          Md.defaultData
        ),
        shared: wa.emptyData(),
      };
    }),
    (e.clipboard2dData = function () {
      return {
        schema: lo,
        scene: Yl.emptyData(),
        frames: new Ft(),
        shared: wa.emptyData(),
      };
    }),
    (e.collabHelper = {
      ...Iy,
      updateSchema(s) {
        return (s.schema ?? 0) < lo ? Hd(s, e3) : (s.schema ?? 0) - lo;
      },
    });
  function t(s) {
    let a = e.collabHelper.updateSchema(s);
    return typeof a == "number" ? (a === 0 ? s : null) : a.data;
  }
  e.updateSchemaDirectly = t;
  function i(s) {
    return { ...s, shared: { ...s.shared, lib: dh.defaultData() } };
  }
  e.withoutLib = i;
  function r(s, a) {
    let n = s.scene.objects.get(a);
    if (n && n.data.type === "Component") return n;
    {
      let o = s.shared.lib.components[a];
      if (o) return o.asset;
    }
  }
  e.getComponentData = r;
})(tg || (tg = {}));
var X2;
((e) => {
  function t(i) {
    return !0;
  }
  e.is = t;
})(X2 || (X2 = {}));
var ig;
((e) => {
  e.defaultData = { position: [0, 0], scale: [1, 1], rotation: 0 };
  function t(r, s) {
    return {
      position: s?.position ?? r.position,
      rotation: s?.rotation ?? r.rotation,
      scale: s?.scale ?? r.scale,
    };
  }
  e.merge = t;
  function i(r, s) {
    return pT({
      position: tl.isEqual(r.position, s.position) ? void 0 : s.position,
      rotation: r.rotation === s.rotation ? void 0 : s.rotation,
      scale: tl.isEqual(r.scale, s.scale) ? void 0 : s.scale,
    });
  }
  e.diff = i;
})(ig || (ig = {}));
var p1;
((e) => (e.defaultData = { horizontalConstraint: 0, verticalConstraint: 0 }))(
  p1 || (p1 = {})
);
var rg;
((e) =>
  (e.defaultData = {
    opacity: 1,
    fill: { color: Ti.white, enabled: !0 },
    stroke: {
      color: Ti.from0to1([0, 0, 0, 1]),
      thickness: 1,
      enabled: !1,
      mode: "inside",
    },
    layerBlur: { radius: 2, enabled: !1 },
    backgroundBlur: { radius: 2, enabled: !1 },
    dropShadow: {
      offset: [10, 10],
      blurRadius: 10,
      color: Ti.from0to1([0, 0, 0, 1]),
      enabled: !1,
      spread: 0,
    },
    innerShadow: {
      offset: [10, 10],
      blurRadius: 10,
      color: Ti.from0to1([0, 0, 0, 1]),
      enabled: !1,
      spread: 0,
    },
  }))(rg || (rg = {}));
var Xl;
((e) => {
  function t(n, o) {
    return { name: o };
  }
  e.newEmpty = t;
  function i(n, o) {
    if (o === void 0) return n;
    let l = { ...n },
      h = ["width", "height", "cornerRadius"];
    for (let u of h)
      u in l && u in o && o[u] !== void 0 && Object.assign(l, { [u]: o[u] });
    return l;
  }
  function r(n, o) {
    if (o === void 0) return n;
    let l = { ...n };
    return (
      "fill" in l &&
        "fill" in o &&
        o.fill !== void 0 &&
        Object.assign(l, { fill: { ...l.fill, ...o.fill } }),
      "stroke" in l &&
        "stroke" in o &&
        o.stroke !== void 0 &&
        Object.assign(l, { stroke: { ...l.stroke, ...o.stroke } }),
      "layerBlur" in l &&
        "layerBlur" in o &&
        o.layerBlur !== void 0 &&
        Object.assign(l, { layerBlur: { ...l.layerBlur, ...o.layerBlur } }),
      "backgroundBlur" in l &&
        "backgroundBlur" in o &&
        o.backgroundBlur !== void 0 &&
        Object.assign(l, {
          backgroundBlur: { ...l.backgroundBlur, ...o.backgroundBlur },
        }),
      "dropShadow" in l &&
        "dropShadow" in o &&
        o.dropShadow !== void 0 &&
        Object.assign(l, { dropShadow: { ...l.dropShadow, ...o.dropShadow } }),
      "innerShadow" in l &&
        "innerShadow" in o &&
        o.innerShadow !== void 0 &&
        Object.assign(l, {
          innerShadow: { ...l.innerShadow, ...o.innerShadow },
        }),
      l
    );
  }
  function s(n, o) {
    if (o === void 0) return n;
    let l = { ...n };
    return Object.assign(l, ig.merge(l, o)), (l = i(l, o)), (l = r(l, o)), l;
  }
  e.patch = s;
  function a(n, o) {
    let l,
      h = [];
    for (let [u, c] of Object.entries(o))
      u !== "name" &&
        (l === void 0 && ((l = { path: [], props: {}, type: 0 }), h.push(l)),
        (l.props[u] = c));
    return h;
  }
  e.toOps = a;
})(Xl || (Xl = {}));
var qd;
((e) =>
  (e.defaultData = {
    ...ig.defaultData,
    ...p1.defaultData,
    states: new At(),
    events: new At(),
    visible: !0,
    raycastLock: !1,
  }))(qd || (qd = {}));
var eu;
((e) => (e.defaultData = { ...qd.defaultData, ...rg.defaultData }))(
  eu || (eu = {})
);
var sg;
((e) => (e.defaultData = { cornerRadius: [0, 0, 0, 0] }))(sg || (sg = {}));
var f1;
((e) =>
  (e.defaultData = {
    ...eu.defaultData,
    type: "ellipse2d",
    width: 100,
    height: 100,
    name: "Ellipse",
  }))(f1 || (f1 = {}));
var Yd;
((e) =>
  (e.defaultData = {
    ...eu.defaultData,
    ...sg.defaultData,
    type: "rectangle2d",
    width: 100,
    height: 100,
    name: "Rectangle",
  }))(Yd || (Yd = {}));
var m1;
((e) =>
  (e.defaultData = {
    ...eu.defaultData,
    type: "text2d",
    width: 100,
    height: 100,
    fontSize: 12,
    lineHeight: 1.2,
    letterSpacing: 0,
    text: { textValue: "Hello world" },
    horizontalAlign: 1,
    verticalAlign: 1,
    textTransform: 1,
    font: "Roboto_regular",
    name: "Text",
  }))(m1 || (m1 = {}));
var g1;
((e) =>
  (e.defaultData = {
    ...eu.defaultData,
    type: "path2d",
    path: "",
    name: "Path",
  }))(g1 || (g1 = {}));
var Q2;
((e) => {
  function t(i) {
    return (
      i.type === "ellipse2d" ||
      i.type === "rectangle2d" ||
      i.type === "text2d" ||
      i.type === "vector2d" ||
      i.type === "path2d"
    );
  }
  e.is = t;
})(Q2 || (Q2 = {}));
var ag;
((e) =>
  (e.defaultData = { ...qd.defaultData, name: "Group", type: "group2d" }))(
  ag || (ag = {})
);
var v1;
((e) =>
  (e.defaultData = {
    ...qd.defaultData,
    ...sg.defaultData,
    ...rg.defaultData,
    name: "Frame",
    type: "frame2d",
    clipped: !0,
    width: 200,
    height: 200,
    fill: { color: Ti.fromHexAndA(ea, 1), enabled: !0 },
    stroke: {
      color: Ti.fromHexAndA(0, 1),
      thickness: 1,
      enabled: !1,
      mode: "inside",
    },
    backgroundBlur: { radius: 2, enabled: !1 },
    layerBlur: { radius: 2, enabled: !1 },
  }))(v1 || (v1 = {}));
var rh;
((e) => {
  function t(a) {
    switch (a) {
      case "rectangle2d":
        return { ...Yd.defaultData };
      case "ellipse2d":
        return { ...f1.defaultData };
      case "text2d":
        return { ...m1.defaultData };
      case "vector2d":
        return { ...Yd.defaultData };
      case "path2d":
        return { ...g1.defaultData };
      case "frame2d":
        return { ...v1.defaultData };
      case "group2d":
        return { ...ag.defaultData };
    }
  }
  e.defaultData = t;
  function i(a) {
    return "width" in a && "height" in a
      ? [
          typeof a.width == "number" ? a.width * 0.5 : 0,
          typeof a.height == "number" ? a.height * 0.5 : 0,
        ]
      : [0, 0];
  }
  e.getPivot = i;
  function r(a) {
    return (
      a.type === "rectangle2d" ||
      a.type === "ellipse2d" ||
      a.type === "text2d" ||
      a.type === "frame2d"
    );
  }
  e.isResizeable = r;
  function s(a) {
    return a.type === "rectangle2d" || a.type === "frame2d";
  }
  e.hasCorners = s;
})(rh || (rh = {}));
var y1;
((e) => (
  (e.defaultData = { name: "UI", type: "scene2d", objects: new as() }),
  (e.emptyData = function () {
    return { type: "scene2d", objects: new as() };
  })
))(y1 || (y1 = {}));
function Ql(e, t = !1) {
  let i = e[0].index !== null,
    r = new Set(Object.keys(e[0].attributes)),
    s = new Set(Object.keys(e[0].morphAttributes)),
    a = {},
    n = {},
    o = e[0].morphTargetsRelative,
    l = new yt(),
    h = 0;
  for (let u = 0; u < e.length; ++u) {
    let c = e[u],
      d = 0;
    if (i !== (c.index !== null))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
            u +
            ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
        ),
        null
      );
    for (let p in c.attributes) {
      if (!r.has(p))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
              u +
              '. All geometries must have compatible attributes; make sure "' +
              p +
              '" attribute exists among all geometries, or in none of them.'
          ),
          null
        );
      a[p] === void 0 && (a[p] = []), a[p].push(c.attributes[p]), d++;
    }
    if (d !== r.size)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
            u +
            ". Make sure all geometries have the same number of attributes."
        ),
        null
      );
    if (o !== c.morphTargetsRelative)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
            u +
            ". .morphTargetsRelative must be consistent throughout all geometries."
        ),
        null
      );
    for (let p in c.morphAttributes) {
      if (!s.has(p))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
              u +
              ".  .morphAttributes must be consistent throughout all geometries."
          ),
          null
        );
      n[p] === void 0 && (n[p] = []), n[p].push(c.morphAttributes[p]);
    }
    if (t) {
      let p;
      if (i) p = c.index.count;
      else if (c.attributes.position !== void 0)
        p = c.attributes.position.count;
      else
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
              u +
              ". The geometry must have either an index or a position attribute"
          ),
          null
        );
      l.addGroup(h, p, u), (h += p);
    }
  }
  if (i) {
    let u = 0,
      c = [];
    for (let d = 0; d < e.length; ++d) {
      let p = e[d].index;
      for (let f = 0; f < p.count; ++f) c.push(p.getX(f) + u);
      u += e[d].attributes.position.count;
    }
    l.setIndex(c);
  }
  for (let u in a) {
    let c = Z2(a[u]);
    if (!c)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
            u +
            " attribute."
        ),
        null
      );
    l.setAttribute(u, c);
  }
  for (let u in n) {
    let c = n[u][0].length;
    if (c === 0) break;
    (l.morphAttributes = l.morphAttributes || {}), (l.morphAttributes[u] = []);
    for (let d = 0; d < c; ++d) {
      let p = [];
      for (let m = 0; m < n[u].length; ++m) p.push(n[u][m][d]);
      let f = Z2(p);
      if (!f)
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
              u +
              " morphAttribute."
          ),
          null
        );
      l.morphAttributes[u].push(f);
    }
  }
  return l;
}
function Z2(e) {
  let t,
    i,
    r,
    s = 0;
  for (let o = 0; o < e.length; ++o) {
    let l = e[o];
    if (l.isInterleavedBufferAttribute)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."
        ),
        null
      );
    if ((t === void 0 && (t = l.array.constructor), t !== l.array.constructor))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
        ),
        null
      );
    if ((i === void 0 && (i = l.itemSize), i !== l.itemSize))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
        ),
        null
      );
    if ((r === void 0 && (r = l.normalized), r !== l.normalized))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
        ),
        null
      );
    s += l.array.length;
  }
  let a = new t(s),
    n = 0;
  for (let o = 0; o < e.length; ++o)
    a.set(e[o].array, n), (n += e[o].array.length);
  return new It(a, i, r);
}
var d9 = Math.pow(2, -24),
  gf = class {
    constructor() {}
  };
function An(e, t, i) {
  return (
    (i.min.x = t[e]),
    (i.min.y = t[e + 1]),
    (i.min.z = t[e + 2]),
    (i.max.x = t[e + 3]),
    (i.max.y = t[e + 4]),
    (i.max.z = t[e + 5]),
    i
  );
}
function K2(e) {
  let t = -1,
    i = -1 / 0;
  for (let r = 0; r < 3; r++) {
    let s = e[r + 3] - e[r];
    s > i && ((i = s), (t = r));
  }
  return t;
}
function J2(e, t) {
  t.set(e);
}
function $2(e, t, i) {
  let r, s;
  for (let a = 0; a < 3; a++) {
    let n = a + 3;
    (r = e[a]),
      (s = t[a]),
      (i[a] = r < s ? r : s),
      (r = e[n]),
      (s = t[n]),
      (i[n] = r > s ? r : s);
  }
}
function vf(e, t, i) {
  for (let r = 0; r < 3; r++) {
    let s = t[e + 2 * r],
      a = t[e + 2 * r + 1],
      n = s - a,
      o = s + a;
    n < i[r] && (i[r] = n), o > i[r + 3] && (i[r + 3] = o);
  }
}
function Wu(e) {
  let t = e[3] - e[0],
    i = e[4] - e[1],
    r = e[5] - e[2];
  return 2 * (t * i + i * r + r * t);
}
function p9(e, t) {
  if (!e.index) {
    let i = e.attributes.position.count,
      r = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
      s;
    i > 65535
      ? (s = new Uint32Array(new r(4 * i)))
      : (s = new Uint16Array(new r(2 * i))),
      e.setIndex(new It(s, 1));
    for (let a = 0; a < i; a++) s[a] = a;
  }
}
function f9(e) {
  if (!e.groups || !e.groups.length)
    return [{ offset: 0, count: e.index.count / 3 }];
  let t = [],
    i = new Set();
  for (let s of e.groups) i.add(s.start), i.add(s.start + s.count);
  let r = Array.from(i.values()).sort((s, a) => s - a);
  for (let s = 0; s < r.length - 1; s++) {
    let a = r[s],
      n = r[s + 1];
    t.push({ offset: a / 3, count: (n - a) / 3 });
  }
  return t;
}
function $v(e, t, i, r, s = null) {
  let a = 1 / 0,
    n = 1 / 0,
    o = 1 / 0,
    l = -1 / 0,
    h = -1 / 0,
    u = -1 / 0,
    c = 1 / 0,
    d = 1 / 0,
    p = 1 / 0,
    f = -1 / 0,
    m = -1 / 0,
    g = -1 / 0,
    y = s !== null;
  for (let x = t * 6, b = (t + i) * 6; x < b; x += 6) {
    let _ = e[x + 0],
      S = e[x + 1],
      M = _ - S,
      C = _ + S;
    M < a && (a = M),
      C > l && (l = C),
      y && _ < c && (c = _),
      y && _ > f && (f = _);
    let A = e[x + 2],
      T = e[x + 3],
      P = A - T,
      R = A + T;
    P < n && (n = P),
      R > h && (h = R),
      y && A < d && (d = A),
      y && A > m && (m = A);
    let z = e[x + 4],
      N = e[x + 5],
      L = z - N,
      G = z + N;
    L < o && (o = L),
      G > u && (u = G),
      y && z < p && (p = z),
      y && z > g && (g = z);
  }
  (r[0] = a),
    (r[1] = n),
    (r[2] = o),
    (r[3] = l),
    (r[4] = h),
    (r[5] = u),
    y &&
      ((s[0] = c), (s[1] = d), (s[2] = p), (s[3] = f), (s[4] = m), (s[5] = g));
}
function m9(e, t, i, r) {
  let s = 1 / 0,
    a = 1 / 0,
    n = 1 / 0,
    o = -1 / 0,
    l = -1 / 0,
    h = -1 / 0;
  for (let u = t * 6, c = (t + i) * 6; u < c; u += 6) {
    let d = e[u + 0];
    d < s && (s = d), d > o && (o = d);
    let p = e[u + 2];
    p < a && (a = p), p > l && (l = p);
    let f = e[u + 4];
    f < n && (n = f), f > h && (h = f);
  }
  (r[0] = s), (r[1] = a), (r[2] = n), (r[3] = o), (r[4] = l), (r[5] = h);
}
function g9(e, t, i, r, s) {
  let a = i,
    n = i + r - 1,
    o = s.pos,
    l = s.axis * 2;
  for (;;) {
    for (; a <= n && t[a * 6 + l] < o; ) a++;
    for (; a <= n && t[n * 6 + l] >= o; ) n--;
    if (a < n) {
      for (let h = 0; h < 3; h++) {
        let u = e[a * 3 + h];
        (e[a * 3 + h] = e[n * 3 + h]), (e[n * 3 + h] = u);
        let c = t[a * 6 + h * 2 + 0];
        (t[a * 6 + h * 2 + 0] = t[n * 6 + h * 2 + 0]),
          (t[n * 6 + h * 2 + 0] = c);
        let d = t[a * 6 + h * 2 + 1];
        (t[a * 6 + h * 2 + 1] = t[n * 6 + h * 2 + 1]),
          (t[n * 6 + h * 2 + 1] = d);
      }
      a++, n--;
    } else return a;
  }
}
var ro = 32,
  v9 = (e, t) => e.candidate - t.candidate,
  ko = new Array(ro)
    .fill()
    .map(() => ({
      count: 0,
      bounds: new Float32Array(6),
      rightCacheBounds: new Float32Array(6),
      leftCacheBounds: new Float32Array(6),
      candidate: 0,
    })),
  yf = new Float32Array(6);
function y9(e, t, i, r, s, a) {
  let n = -1,
    o = 0;
  if (a === 0) (n = K2(t)), n !== -1 && (o = (t[n] + t[n + 3]) / 2);
  else if (a === 1) (n = K2(e)), n !== -1 && (o = x9(i, r, s, n));
  else if (a === 2) {
    let l = Wu(e),
      h = 1.25 * s,
      u = r * 6,
      c = (r + s) * 6;
    for (let d = 0; d < 3; d++) {
      let p = t[d],
        f = (t[d + 3] - p) / ro;
      if (s < ro / 4) {
        let m = [...ko];
        m.length = s;
        let g = 0;
        for (let x = u; x < c; x += 6, g++) {
          let b = m[g];
          (b.candidate = i[x + 2 * d]), (b.count = 0);
          let { bounds: _, leftCacheBounds: S, rightCacheBounds: M } = b;
          for (let C = 0; C < 3; C++)
            (M[C] = 1 / 0),
              (M[C + 3] = -1 / 0),
              (S[C] = 1 / 0),
              (S[C + 3] = -1 / 0),
              (_[C] = 1 / 0),
              (_[C + 3] = -1 / 0);
          vf(x, i, _);
        }
        m.sort(v9);
        let y = s;
        for (let x = 0; x < y; x++) {
          let b = m[x];
          for (; x + 1 < y && m[x + 1].candidate === b.candidate; )
            m.splice(x + 1, 1), y--;
        }
        for (let x = u; x < c; x += 6) {
          let b = i[x + 2 * d];
          for (let _ = 0; _ < y; _++) {
            let S = m[_];
            b >= S.candidate
              ? vf(x, i, S.rightCacheBounds)
              : (vf(x, i, S.leftCacheBounds), S.count++);
          }
        }
        for (let x = 0; x < y; x++) {
          let b = m[x],
            _ = b.count,
            S = s - b.count,
            M = b.leftCacheBounds,
            C = b.rightCacheBounds,
            A = 0;
          _ !== 0 && (A = Wu(M) / l);
          let T = 0;
          S !== 0 && (T = Wu(C) / l);
          let P = 1 + 1.25 * (A * _ + T * S);
          P < h && ((n = d), (h = P), (o = b.candidate));
        }
      } else {
        for (let y = 0; y < ro; y++) {
          let x = ko[y];
          (x.count = 0), (x.candidate = p + f + y * f);
          let b = x.bounds;
          for (let _ = 0; _ < 3; _++) (b[_] = 1 / 0), (b[_ + 3] = -1 / 0);
        }
        for (let y = u; y < c; y += 6) {
          let x = ~~((i[y + 2 * d] - p) / f);
          x >= ro && (x = ro - 1);
          let b = ko[x];
          b.count++, vf(y, i, b.bounds);
        }
        let m = ko[ro - 1];
        J2(m.bounds, m.rightCacheBounds);
        for (let y = ro - 2; y >= 0; y--) {
          let x = ko[y],
            b = ko[y + 1];
          $2(x.bounds, b.rightCacheBounds, x.rightCacheBounds);
        }
        let g = 0;
        for (let y = 0; y < ro - 1; y++) {
          let x = ko[y],
            b = x.count,
            _ = x.bounds,
            S = ko[y + 1].rightCacheBounds;
          b !== 0 && (g === 0 ? J2(_, yf) : $2(_, yf, yf)), (g += b);
          let M = 0,
            C = 0;
          g !== 0 && (M = Wu(yf) / l);
          let A = s - g;
          A !== 0 && (C = Wu(S) / l);
          let T = 1 + 1.25 * (M * g + C * A);
          T < h && ((n = d), (h = T), (o = x.candidate));
        }
      }
    }
  } else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);
  return { axis: n, pos: o };
}
function x9(e, t, i, r) {
  let s = 0;
  for (let a = t, n = t + i; a < n; a++) s += e[a * 6 + r * 2];
  return s / i;
}
function b9(e, t) {
  let i = e.attributes.position,
    r = e.index.array,
    s = r.length / 3,
    a = new Float32Array(s * 6),
    n = i.normalized,
    o = i.array,
    l = i.offset || 0,
    h = 3;
  i.isInterleavedBufferAttribute && (h = i.data.stride);
  let u = ["getX", "getY", "getZ"];
  for (let c = 0; c < s; c++) {
    let d = c * 3,
      p = c * 6,
      f,
      m,
      g;
    n
      ? ((f = r[d + 0]), (m = r[d + 1]), (g = r[d + 2]))
      : ((f = r[d + 0] * h + l),
        (m = r[d + 1] * h + l),
        (g = r[d + 2] * h + l));
    for (let y = 0; y < 3; y++) {
      let x, b, _;
      n
        ? ((x = i[u[y]](f)), (b = i[u[y]](m)), (_ = i[u[y]](g)))
        : ((x = o[f + y]), (b = o[m + y]), (_ = o[g + y]));
      let S = x;
      b < S && (S = b), _ < S && (S = _);
      let M = x;
      b > M && (M = b), _ > M && (M = _);
      let C = (M - S) / 2,
        A = y * 2;
      (a[p + A + 0] = S + C),
        (a[p + A + 1] = C + (Math.abs(S) + C) * d9),
        S < t[y] && (t[y] = S),
        M > t[y + 3] && (t[y + 3] = M);
    }
  }
  return a;
}
function w9(e, t) {
  function i(y) {
    d && d(y / p);
  }
  function r(y, x, b, _ = null, S = 0) {
    if (
      (!f &&
        S >= l &&
        ((f = !0),
        h &&
          (console.warn(
            `MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`
          ),
          console.warn(e))),
      b <= u || S >= l)
    )
      return i(x + b), (y.offset = x), (y.count = b), y;
    let M = y9(y.boundingData, _, n, x, b, c);
    if (M.axis === -1) return i(x + b), (y.offset = x), (y.count = b), y;
    let C = g9(o, n, x, b, M);
    if (C === x || C === x + b) i(x + b), (y.offset = x), (y.count = b);
    else {
      y.splitAxis = M.axis;
      let A = new gf(),
        T = x,
        P = C - x;
      (y.left = A),
        (A.boundingData = new Float32Array(6)),
        $v(n, T, P, A.boundingData, a),
        r(A, T, P, a, S + 1);
      let R = new gf(),
        z = C,
        N = b - P;
      (y.right = R),
        (R.boundingData = new Float32Array(6)),
        $v(n, z, N, R.boundingData, a),
        r(R, z, N, a, S + 1);
    }
    return y;
  }
  p9(e, t);
  let s = new Float32Array(6),
    a = new Float32Array(6),
    n = b9(e, s),
    o = e.index.array,
    l = t.maxDepth,
    h = t.verbose,
    u = t.maxLeafTris,
    c = t.strategy,
    d = t.onProgress,
    p = e.index.count / 3,
    f = !1,
    m = [],
    g = f9(e);
  if (g.length === 1) {
    let y = g[0],
      x = new gf();
    (x.boundingData = s),
      m9(n, y.offset, y.count, a),
      r(x, y.offset, y.count, a),
      m.push(x);
  } else
    for (let y of g) {
      let x = new gf();
      (x.boundingData = new Float32Array(6)),
        $v(n, y.offset, y.count, x.boundingData, a),
        r(x, y.offset, y.count, a),
        m.push(x);
    }
  return m;
}
function _9(e, t) {
  let i = w9(e, t),
    r,
    s,
    a,
    n = [],
    o = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let u = 0; u < i.length; u++) {
    let c = i[u],
      d = l(c),
      p = new o(32 * d);
    (r = new Float32Array(p)),
      (s = new Uint32Array(p)),
      (a = new Uint16Array(p)),
      h(0, c),
      n.push(p);
  }
  return n;
  function l(u) {
    return u.count ? 1 : 1 + l(u.left) + l(u.right);
  }
  function h(u, c) {
    let d = u / 4,
      p = u / 2,
      f = !!c.count,
      m = c.boundingData;
    for (let g = 0; g < 6; g++) r[d + g] = m[g];
    if (f) {
      let g = c.offset,
        y = c.count;
      return (s[d + 6] = g), (a[p + 14] = y), (a[p + 15] = 65535), u + 32;
    } else {
      let g = c.left,
        y = c.right,
        x = c.splitAxis,
        b;
      if (((b = h(u + 32, g)), b / 4 > Math.pow(2, 32)))
        throw new Error(
          "MeshBVH: Cannot store child pointer greater than 32 bits."
        );
      return (s[d + 6] = b / 4), (b = h(b, y)), (s[d + 7] = x), b;
    }
  }
}
var Rn = class {
  constructor() {
    (this.min = 1 / 0), (this.max = -1 / 0);
  }
  setFromPointsField(e, t) {
    let i = 1 / 0,
      r = -1 / 0;
    for (let s = 0, a = e.length; s < a; s++) {
      let n = e[s][t];
      (i = n < i ? n : i), (r = n > r ? n : r);
    }
    (this.min = i), (this.max = r);
  }
  setFromPoints(e, t) {
    let i = 1 / 0,
      r = -1 / 0;
    for (let s = 0, a = t.length; s < a; s++) {
      let n = t[s],
        o = e.dot(n);
      (i = o < i ? o : i), (r = o > r ? o : r);
    }
    (this.min = i), (this.max = r);
  }
  isSeparated(e) {
    return this.min > e.max || e.min > this.max;
  }
};
Rn.prototype.setFromBox = (function () {
  let e = new I();
  return function (t, i) {
    let r = i.min,
      s = i.max,
      a = 1 / 0,
      n = -1 / 0;
    for (let o = 0; o <= 1; o++)
      for (let l = 0; l <= 1; l++)
        for (let h = 0; h <= 1; h++) {
          (e.x = r.x * o + s.x * (1 - o)),
            (e.y = r.y * l + s.y * (1 - l)),
            (e.z = r.z * h + s.z * (1 - h));
          let u = t.dot(e);
          (a = Math.min(u, a)), (n = Math.max(u, n));
        }
    (this.min = a), (this.max = n);
  };
})();
var qee = (function () {
    let e = new Rn();
    return function (t, i) {
      let r = t.points,
        s = t.satAxes,
        a = t.satBounds,
        n = i.points,
        o = i.satAxes,
        l = i.satBounds;
      for (let h = 0; h < 3; h++) {
        let u = a[h],
          c = s[h];
        if ((e.setFromPoints(c, n), u.isSeparated(e))) return !1;
      }
      for (let h = 0; h < 3; h++) {
        let u = l[h],
          c = o[h];
        if ((e.setFromPoints(c, r), u.isSeparated(e))) return !1;
      }
    };
  })(),
  S9 = (function () {
    let e = new I(),
      t = new I(),
      i = new I();
    return function (r, s, a) {
      let n = r.start,
        o = e,
        l = s.start,
        h = t;
      i.subVectors(n, l),
        e.subVectors(r.end, r.start),
        t.subVectors(s.end, s.start);
      let u = i.dot(h),
        c = h.dot(o),
        d = h.dot(h),
        p = i.dot(o),
        f = o.dot(o) * d - c * c,
        m,
        g;
      f !== 0 ? (m = (u * c - p * d) / f) : (m = 0),
        (g = (u + m * c) / d),
        (a.x = m),
        (a.y = g);
    };
  })(),
  ab = (function () {
    let e = new re(),
      t = new I(),
      i = new I();
    return function (r, s, a, n) {
      S9(r, s, e);
      let o = e.x,
        l = e.y;
      if (o >= 0 && o <= 1 && l >= 0 && l <= 1) {
        r.at(o, a), s.at(l, n);
        return;
      } else if (o >= 0 && o <= 1) {
        l < 0 ? s.at(0, n) : s.at(1, n), r.closestPointToPoint(n, !0, a);
        return;
      } else if (l >= 0 && l <= 1) {
        o < 0 ? r.at(0, a) : r.at(1, a), s.closestPointToPoint(a, !0, n);
        return;
      } else {
        let h;
        o < 0 ? (h = r.start) : (h = r.end);
        let u;
        l < 0 ? (u = s.start) : (u = s.end);
        let c = t,
          d = i;
        if (
          (r.closestPointToPoint(u, !0, t),
          s.closestPointToPoint(h, !0, i),
          c.distanceToSquared(u) <= d.distanceToSquared(h))
        ) {
          a.copy(c), n.copy(u);
          return;
        } else {
          a.copy(h), n.copy(d);
          return;
        }
      }
    };
  })(),
  A9 = (function () {
    let e = new I(),
      t = new I(),
      i = new Ks(),
      r = new Ma();
    return function (s, a) {
      let { radius: n, center: o } = s,
        { a: l, b: h, c: u } = a;
      if (
        ((r.start = l),
        (r.end = h),
        r.closestPointToPoint(o, !0, e).distanceTo(o) <= n ||
          ((r.start = l),
          (r.end = u),
          r.closestPointToPoint(o, !0, e).distanceTo(o) <= n) ||
          ((r.start = h),
          (r.end = u),
          r.closestPointToPoint(o, !0, e).distanceTo(o) <= n))
      )
        return !0;
      let c = a.getPlane(i);
      if (Math.abs(c.distanceToPoint(o)) <= n) {
        let d = c.projectPoint(o, t);
        if (a.containsPoint(d)) return !0;
      }
      return !1;
    };
  })(),
  M9 = 1e-15;
function Xh(e) {
  return Math.abs(e) < M9;
}
var Ao = class extends rs {
  constructor(...e) {
    super(...e),
      (this.isExtendedTriangle = !0),
      (this.satAxes = new Array(4).fill().map(() => new I())),
      (this.satBounds = new Array(4).fill().map(() => new Rn())),
      (this.points = [this.a, this.b, this.c]),
      (this.sphere = new Ws()),
      (this.plane = new Ks()),
      (this.needsUpdate = !0);
  }
  intersectsSphere(e) {
    return A9(e, this);
  }
  update() {
    let e = this.a,
      t = this.b,
      i = this.c,
      r = this.points,
      s = this.satAxes,
      a = this.satBounds,
      n = s[0],
      o = a[0];
    this.getNormal(n), o.setFromPoints(n, r);
    let l = s[1],
      h = a[1];
    l.subVectors(e, t), h.setFromPoints(l, r);
    let u = s[2],
      c = a[2];
    u.subVectors(t, i), c.setFromPoints(u, r);
    let d = s[3],
      p = a[3];
    d.subVectors(i, e),
      p.setFromPoints(d, r),
      this.sphere.setFromPoints(this.points),
      this.plane.setFromNormalAndCoplanarPoint(n, e),
      (this.needsUpdate = !1);
  }
};
Ao.prototype.closestPointToSegment = (function () {
  let e = new I(),
    t = new I(),
    i = new Ma();
  return function (r, s = null, a = null) {
    let { start: n, end: o } = r,
      l = this.points,
      h,
      u = 1 / 0;
    for (let c = 0; c < 3; c++) {
      let d = (c + 1) % 3;
      i.start.copy(l[c]),
        i.end.copy(l[d]),
        ab(i, r, e, t),
        (h = e.distanceToSquared(t)),
        h < u && ((u = h), s && s.copy(e), a && a.copy(t));
    }
    return (
      this.closestPointToPoint(n, e),
      (h = n.distanceToSquared(e)),
      h < u && ((u = h), s && s.copy(e), a && a.copy(n)),
      this.closestPointToPoint(o, e),
      (h = o.distanceToSquared(e)),
      h < u && ((u = h), s && s.copy(e), a && a.copy(o)),
      Math.sqrt(u)
    );
  };
})();
Ao.prototype.intersectsTriangle = (function () {
  let e = new Ao(),
    t = new Array(3),
    i = new Array(3),
    r = new Rn(),
    s = new Rn(),
    a = new I(),
    n = new I(),
    o = new I(),
    l = new I(),
    h = new Ma(),
    u = new Ma(),
    c = new Ma();
  return function (d, p = null, f = !1) {
    this.needsUpdate && this.update(),
      d.isExtendedTriangle
        ? d.needsUpdate && d.update()
        : (e.copy(d), e.update(), (d = e));
    let m = this.plane,
      g = d.plane;
    if (Math.abs(m.normal.dot(g.normal)) > 1 - 1e-10) {
      let y = this.satBounds,
        x = this.satAxes;
      (i[0] = d.a), (i[1] = d.b), (i[2] = d.c);
      for (let S = 0; S < 4; S++) {
        let M = y[S],
          C = x[S];
        if ((r.setFromPoints(C, i), M.isSeparated(r))) return !1;
      }
      let b = d.satBounds,
        _ = d.satAxes;
      (t[0] = this.a), (t[1] = this.b), (t[2] = this.c);
      for (let S = 0; S < 4; S++) {
        let M = b[S],
          C = _[S];
        if ((r.setFromPoints(C, t), M.isSeparated(r))) return !1;
      }
      for (let S = 0; S < 4; S++) {
        let M = x[S];
        for (let C = 0; C < 4; C++) {
          let A = _[C];
          if (
            (a.crossVectors(M, A),
            r.setFromPoints(a, t),
            s.setFromPoints(a, i),
            r.isSeparated(s))
          )
            return !1;
        }
      }
      return (
        p &&
          (f ||
            console.warn(
              "ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."
            ),
          p.start.set(0, 0, 0),
          p.end.set(0, 0, 0)),
        !0
      );
    } else {
      let y = this.points,
        x = !1,
        b = 0;
      for (let N = 0; N < 3; N++) {
        let L = y[N],
          G = y[(N + 1) % 3];
        h.start.copy(L), h.end.copy(G), h.delta(n);
        let Y = x ? u.start : u.end,
          Z = Xh(g.distanceToPoint(L));
        if (Xh(g.normal.dot(n)) && Z) {
          u.copy(h), (b = 2);
          break;
        }
        if ((g.intersectLine(h, Y) || Z) && !Xh(Y.distanceTo(G))) {
          if ((b++, x)) break;
          x = !0;
        }
      }
      if (b === 1 && d.containsPoint(u.end))
        return p && (p.start.copy(u.end), p.end.copy(u.end)), !0;
      if (b !== 2) return !1;
      let _ = d.points,
        S = !1,
        M = 0;
      for (let N = 0; N < 3; N++) {
        let L = _[N],
          G = _[(N + 1) % 3];
        h.start.copy(L), h.end.copy(G), h.delta(o);
        let Y = S ? c.start : c.end,
          Z = Xh(m.distanceToPoint(L));
        if (Xh(m.normal.dot(o)) && Z) {
          c.copy(h), (M = 2);
          break;
        }
        if ((m.intersectLine(h, Y) || Z) && !Xh(Y.distanceTo(G))) {
          if ((M++, S)) break;
          S = !0;
        }
      }
      if (M === 1 && this.containsPoint(c.end))
        return p && (p.start.copy(c.end), p.end.copy(c.end)), !0;
      if (M !== 2) return !1;
      if ((u.delta(n), c.delta(o), n.dot(o) < 0)) {
        let N = c.start;
        (c.start = c.end), (c.end = N);
      }
      let C = u.start.dot(n),
        A = u.end.dot(n),
        T = c.start.dot(n),
        P = c.end.dot(n),
        R = A < T,
        z = C < P;
      return C !== P && T !== A && R === z
        ? !1
        : (p &&
            (l.subVectors(u.start, c.start),
            l.dot(n) > 0 ? p.start.copy(u.start) : p.start.copy(c.start),
            l.subVectors(u.end, c.end),
            l.dot(n) < 0 ? p.end.copy(u.end) : p.end.copy(c.end)),
          !0);
    }
  };
})();
Ao.prototype.distanceToPoint = (function () {
  let e = new I();
  return function (t) {
    return this.closestPointToPoint(t, e), t.distanceTo(e);
  };
})();
Ao.prototype.distanceToTriangle = (function () {
  let e = new I(),
    t = new I(),
    i = ["a", "b", "c"],
    r = new Ma(),
    s = new Ma();
  return function (a, n = null, o = null) {
    let l = n || o ? r : null;
    if (this.intersectsTriangle(a, l))
      return (n || o) && (n && l.getCenter(n), o && l.getCenter(o)), 0;
    let h = 1 / 0;
    for (let u = 0; u < 3; u++) {
      let c,
        d = i[u],
        p = a[d];
      this.closestPointToPoint(p, e),
        (c = p.distanceToSquared(e)),
        c < h && ((h = c), n && n.copy(e), o && o.copy(p));
      let f = this[d];
      a.closestPointToPoint(f, e),
        (c = f.distanceToSquared(e)),
        c < h && ((h = c), n && n.copy(f), o && o.copy(e));
    }
    for (let u = 0; u < 3; u++) {
      let c = i[u],
        d = i[(u + 1) % 3];
      r.set(this[c], this[d]);
      for (let p = 0; p < 3; p++) {
        let f = i[p],
          m = i[(p + 1) % 3];
        s.set(a[f], a[m]), ab(r, s, e, t);
        let g = e.distanceToSquared(t);
        g < h && ((h = g), n && n.copy(e), o && o.copy(t));
      }
    }
    return Math.sqrt(h);
  };
})();
var Ln = class {
  constructor(e, t, i) {
    (this.isOrientedBox = !0),
      (this.min = new I()),
      (this.max = new I()),
      (this.matrix = new je()),
      (this.invMatrix = new je()),
      (this.points = new Array(8).fill().map(() => new I())),
      (this.satAxes = new Array(3).fill().map(() => new I())),
      (this.satBounds = new Array(3).fill().map(() => new Rn())),
      (this.alignedSatBounds = new Array(3).fill().map(() => new Rn())),
      (this.needsUpdate = !1),
      e && this.min.copy(e),
      t && this.max.copy(t),
      i && this.matrix.copy(i);
  }
  set(e, t, i) {
    this.min.copy(e),
      this.max.copy(t),
      this.matrix.copy(i),
      (this.needsUpdate = !0);
  }
  copy(e) {
    this.min.copy(e.min),
      this.max.copy(e.max),
      this.matrix.copy(e.matrix),
      (this.needsUpdate = !0);
  }
};
Ln.prototype.update = (function () {
  return function () {
    let e = this.matrix,
      t = this.min,
      i = this.max,
      r = this.points;
    for (let l = 0; l <= 1; l++)
      for (let h = 0; h <= 1; h++)
        for (let u = 0; u <= 1; u++) {
          let c = (1 * l) | (2 * h) | (4 * u),
            d = r[c];
          (d.x = l ? i.x : t.x),
            (d.y = h ? i.y : t.y),
            (d.z = u ? i.z : t.z),
            d.applyMatrix4(e);
        }
    let s = this.satBounds,
      a = this.satAxes,
      n = r[0];
    for (let l = 0; l < 3; l++) {
      let h = a[l],
        u = s[l],
        c = 1 << l,
        d = r[c];
      h.subVectors(n, d), u.setFromPoints(h, r);
    }
    let o = this.alignedSatBounds;
    o[0].setFromPointsField(r, "x"),
      o[1].setFromPointsField(r, "y"),
      o[2].setFromPointsField(r, "z"),
      this.invMatrix.copy(this.matrix).invert(),
      (this.needsUpdate = !1);
  };
})();
Ln.prototype.intersectsBox = (function () {
  let e = new Rn();
  return function (t) {
    this.needsUpdate && this.update();
    let i = t.min,
      r = t.max,
      s = this.satBounds,
      a = this.satAxes,
      n = this.alignedSatBounds;
    if (
      ((e.min = i.x),
      (e.max = r.x),
      n[0].isSeparated(e) ||
        ((e.min = i.y), (e.max = r.y), n[1].isSeparated(e)) ||
        ((e.min = i.z), (e.max = r.z), n[2].isSeparated(e)))
    )
      return !1;
    for (let o = 0; o < 3; o++) {
      let l = a[o],
        h = s[o];
      if ((e.setFromBox(l, t), h.isSeparated(e))) return !1;
    }
    return !0;
  };
})();
Ln.prototype.intersectsTriangle = (function () {
  let e = new Ao(),
    t = new Array(3),
    i = new Rn(),
    r = new Rn(),
    s = new I();
  return function (a) {
    this.needsUpdate && this.update(),
      a.isExtendedTriangle
        ? a.needsUpdate && a.update()
        : (e.copy(a), e.update(), (a = e));
    let n = this.satBounds,
      o = this.satAxes;
    (t[0] = a.a), (t[1] = a.b), (t[2] = a.c);
    for (let c = 0; c < 3; c++) {
      let d = n[c],
        p = o[c];
      if ((i.setFromPoints(p, t), d.isSeparated(i))) return !1;
    }
    let l = a.satBounds,
      h = a.satAxes,
      u = this.points;
    for (let c = 0; c < 3; c++) {
      let d = l[c],
        p = h[c];
      if ((i.setFromPoints(p, u), d.isSeparated(i))) return !1;
    }
    for (let c = 0; c < 3; c++) {
      let d = o[c];
      for (let p = 0; p < 4; p++) {
        let f = h[p];
        if (
          (s.crossVectors(d, f),
          i.setFromPoints(s, t),
          r.setFromPoints(s, u),
          i.isSeparated(r))
        )
          return !1;
      }
    }
    return !0;
  };
})();
Ln.prototype.closestPointToPoint = (function () {
  return function (e, t) {
    return (
      this.needsUpdate && this.update(),
      t
        .copy(e)
        .applyMatrix4(this.invMatrix)
        .clamp(this.min, this.max)
        .applyMatrix4(this.matrix),
      t
    );
  };
})();
Ln.prototype.distanceToPoint = (function () {
  let e = new I();
  return function (t) {
    return this.closestPointToPoint(t, e), t.distanceTo(e);
  };
})();
Ln.prototype.distanceToBox = (function () {
  let e = ["x", "y", "z"],
    t = new Array(12).fill().map(() => new Ma()),
    i = new Array(12).fill().map(() => new Ma()),
    r = new I(),
    s = new I();
  return function (a, n = 0, o = null, l = null) {
    if ((this.needsUpdate && this.update(), this.intersectsBox(a)))
      return (
        (o || l) &&
          (a.getCenter(s),
          this.closestPointToPoint(s, r),
          a.closestPointToPoint(r, s),
          o && o.copy(r),
          l && l.copy(s)),
        0
      );
    let h = n * n,
      u = a.min,
      c = a.max,
      d = this.points,
      p = 1 / 0;
    for (let m = 0; m < 8; m++) {
      let g = d[m];
      s.copy(g).clamp(u, c);
      let y = g.distanceToSquared(s);
      if (y < p && ((p = y), o && o.copy(g), l && l.copy(s), y < h))
        return Math.sqrt(y);
    }
    let f = 0;
    for (let m = 0; m < 3; m++)
      for (let g = 0; g <= 1; g++)
        for (let y = 0; y <= 1; y++) {
          let x = (m + 1) % 3,
            b = (m + 2) % 3,
            _ = (g << x) | (y << b),
            S = (1 << m) | (g << x) | (y << b),
            M = d[_],
            C = d[S];
          t[f].set(M, C);
          let A = e[m],
            T = e[x],
            P = e[b],
            R = i[f],
            z = R.start,
            N = R.end;
          (z[A] = u[A]),
            (z[T] = g ? u[T] : c[T]),
            (z[P] = y ? u[P] : c[T]),
            (N[A] = c[A]),
            (N[T] = g ? u[T] : c[T]),
            (N[P] = y ? u[P] : c[T]),
            f++;
        }
    for (let m = 0; m <= 1; m++)
      for (let g = 0; g <= 1; g++)
        for (let y = 0; y <= 1; y++) {
          (s.x = m ? c.x : u.x),
            (s.y = g ? c.y : u.y),
            (s.z = y ? c.z : u.z),
            this.closestPointToPoint(s, r);
          let x = s.distanceToSquared(r);
          if (x < p && ((p = x), o && o.copy(r), l && l.copy(s), x < h))
            return Math.sqrt(x);
        }
    for (let m = 0; m < 12; m++) {
      let g = t[m];
      for (let y = 0; y < 12; y++) {
        let x = i[y];
        ab(g, x, r, s);
        let b = r.distanceToSquared(s);
        if (b < p && ((p = b), o && o.copy(r), l && l.copy(s), b < h))
          return Math.sqrt(b);
      }
    }
    return Math.sqrt(p);
  };
})();
var Qh = new I(),
  Zh = new I(),
  Kh = new I(),
  xf = new re(),
  bf = new re(),
  wf = new re(),
  eA = new I(),
  tA = new I(),
  iA = new I(),
  _f = new I();
function E9(e, t, i, r, s, a) {
  let n;
  return (
    a === Yr
      ? (n = e.intersectTriangle(r, i, t, !0, s))
      : (n = e.intersectTriangle(t, i, r, a !== js, s)),
    n === null ? null : { distance: e.origin.distanceTo(s), point: s.clone() }
  );
}
function C9(e, t, i, r, s, a, n, o, l) {
  Qh.fromBufferAttribute(t, a),
    Zh.fromBufferAttribute(t, n),
    Kh.fromBufferAttribute(t, o);
  let h = E9(e, Qh, Zh, Kh, _f, l);
  if (h) {
    r &&
      (xf.fromBufferAttribute(r, a),
      bf.fromBufferAttribute(r, n),
      wf.fromBufferAttribute(r, o),
      (h.uv = rs.getInterpolation(_f, Qh, Zh, Kh, xf, bf, wf, new re()))),
      s &&
        (xf.fromBufferAttribute(s, a),
        bf.fromBufferAttribute(s, n),
        wf.fromBufferAttribute(s, o),
        (h.uv1 = rs.getInterpolation(_f, Qh, Zh, Kh, xf, bf, wf, new re()))),
      i &&
        (eA.fromBufferAttribute(i, a),
        tA.fromBufferAttribute(i, n),
        iA.fromBufferAttribute(i, o),
        (h.normal = rs.getInterpolation(_f, Qh, Zh, Kh, eA, tA, iA, new I())),
        h.normal.dot(e.direction) > 0 && h.normal.multiplyScalar(-1));
    let u = { a, b: n, c: o, normal: new I(), materialIndex: 0 };
    rs.getNormal(Qh, Zh, Kh, u.normal), (h.face = u), (h.faceIndex = a);
  }
  return h;
}
function t3(e, t, i, r, s) {
  let a = r * 3,
    n = e.index.getX(a),
    o = e.index.getX(a + 1),
    l = e.index.getX(a + 2),
    { position: h, normal: u, uv: c, uv1: d } = e.attributes,
    p = C9(i, h, u, c, d, n, o, l, t);
  return p ? ((p.faceIndex = r), s && s.push(p), p) : null;
}
function T9(e, t, i, r, s, a) {
  for (let n = r, o = r + s; n < o; n++) t3(e, t, i, n, a);
}
function P9(e, t, i, r, s) {
  let a = 1 / 0,
    n = null;
  for (let o = r, l = r + s; o < l; o++) {
    let h = t3(e, t, i, o);
    h && h.distance < a && ((n = h), (a = h.distance));
  }
  return n;
}
function wn(e, t, i, r) {
  let s = e.a,
    a = e.b,
    n = e.c,
    o = t,
    l = t + 1,
    h = t + 2;
  i && ((o = i.getX(t)), (l = i.getX(t + 1)), (h = i.getX(t + 2))),
    (s.x = r.getX(o)),
    (s.y = r.getY(o)),
    (s.z = r.getZ(o)),
    (a.x = r.getX(l)),
    (a.y = r.getY(l)),
    (a.z = r.getZ(l)),
    (n.x = r.getX(h)),
    (n.y = r.getY(h)),
    (n.z = r.getZ(h));
}
function rA(e, t, i, r, s, a, n) {
  let o = i.index,
    l = i.attributes.position;
  for (let h = e, u = t + e; h < u; h++)
    if ((wn(n, h * 3, o, l), (n.needsUpdate = !0), r(n, h, s, a))) return !0;
  return !1;
}
var i3 = class {
  constructor(e) {
    (this._getNewPrimitive = e), (this._primitives = []);
  }
  getPrimitive() {
    let e = this._primitives;
    return e.length === 0 ? this._getNewPrimitive() : e.pop();
  }
  releasePrimitive(e) {
    this._primitives.push(e);
  }
};
function Ko(e, t) {
  return t[e + 15] === 65535;
}
function Oc(e, t) {
  return t[e + 6];
}
function Xd(e, t) {
  return t[e + 14];
}
function Qd(e) {
  return e + 8;
}
function Zd(e, t) {
  return t[e + 6];
}
function D9(e, t) {
  return t[e + 7];
}
var Sc = new ur(),
  ng = new I(),
  O9 = ["x", "y", "z"];
function x1(e, t, i, r, s) {
  let a = e * 2,
    n = gu,
    o = ul,
    l = dl;
  if (Ko(a, o)) {
    let h = Oc(e, l),
      u = Xd(a, o);
    T9(t, i, r, h, u, s);
  } else {
    let h = Qd(e);
    og(h, n, r, ng) && x1(h, t, i, r, s);
    let u = Zd(e, l);
    og(u, n, r, ng) && x1(u, t, i, r, s);
  }
}
function b1(e, t, i, r) {
  let s = e * 2,
    a = gu,
    n = ul,
    o = dl;
  if (Ko(s, n)) {
    let l = Oc(e, o),
      h = Xd(s, n);
    return P9(t, i, r, l, h);
  } else {
    let l = D9(e, o),
      h = O9[l],
      u = r.direction[h] >= 0,
      c,
      d;
    u ? ((c = Qd(e)), (d = Zd(e, o))) : ((c = Zd(e, o)), (d = Qd(e)));
    let p = og(c, a, r, ng) ? b1(c, t, i, r) : null;
    if (p) {
      let m = p.point[h];
      if (u ? m <= a[d + l] : m >= a[d + l + 3]) return p;
    }
    let f = og(d, a, r, ng) ? b1(d, t, i, r) : null;
    return p && f ? (p.distance <= f.distance ? p : f) : p || f || null;
  }
}
var I9 = (function () {
    let e,
      t,
      i = [],
      r = new i3(() => new ur());
    return function (...a) {
      (e = r.getPrimitive()), (t = r.getPrimitive()), i.push(e, t);
      let n = s(...a);
      r.releasePrimitive(e), r.releasePrimitive(t), i.pop(), i.pop();
      let o = i.length;
      return o > 0 && ((t = i[o - 1]), (e = i[o - 2])), n;
    };
    function s(a, n, o, l, h = null, u = 0, c = 0) {
      function d(x) {
        let b = x * 2,
          _ = ul,
          S = dl;
        for (; !Ko(b, _); ) (x = Qd(x)), (b = x * 2);
        return Oc(x, S);
      }
      function p(x) {
        let b = x * 2,
          _ = ul,
          S = dl;
        for (; !Ko(b, _); ) (x = Zd(x, S)), (b = x * 2);
        return Oc(x, S) + Xd(b, _);
      }
      let f = a * 2,
        m = gu,
        g = ul,
        y = dl;
      if (Ko(f, g)) {
        let x = Oc(a, y),
          b = Xd(f, g);
        return An(a, m, e), l(x, b, !1, c, u + a, e);
      } else {
        let x = Qd(a),
          b = Zd(a, y),
          _ = x,
          S = b,
          M,
          C,
          A,
          T;
        if (
          h &&
          ((A = e),
          (T = t),
          An(_, m, A),
          An(S, m, T),
          (M = h(A)),
          (C = h(T)),
          C < M)
        ) {
          (_ = b), (S = x);
          let Y = M;
          (M = C), (C = Y), (A = T);
        }
        A || ((A = e), An(_, m, A));
        let P = Ko(_ * 2, g),
          R = o(A, P, M, c + 1, u + _),
          z;
        if (R === 2) {
          let Y = d(_),
            Z = p(_) - Y;
          z = l(Y, Z, !0, c + 1, u + _, A);
        } else z = R && s(_, n, o, l, h, u, c + 1);
        if (z) return !0;
        (T = t), An(S, m, T);
        let N = Ko(S * 2, g),
          L = o(T, N, C, c + 1, u + S),
          G;
        if (L === 2) {
          let Y = d(S),
            Z = p(S) - Y;
          G = l(Y, Z, !0, c + 1, u + S, T);
        } else G = L && s(S, n, o, l, h, u, c + 1);
        return !!G;
      }
    }
  })(),
  R9 = (function () {
    let e = new Ao(),
      t = new Ao(),
      i = new je(),
      r = new Ln(),
      s = new Ln();
    return function a(n, o, l, h, u = null) {
      let c = n * 2,
        d = gu,
        p = ul,
        f = dl;
      if (
        (u === null &&
          (l.boundingBox || l.computeBoundingBox(),
          r.set(l.boundingBox.min, l.boundingBox.max, h),
          (u = r)),
        Ko(c, p))
      ) {
        let m = o,
          g = m.index,
          y = m.attributes.position,
          x = l.index,
          b = l.attributes.position,
          _ = Oc(n, f),
          S = Xd(c, p);
        if ((i.copy(h).invert(), l.boundsTree))
          return (
            An(n, d, s),
            s.matrix.copy(i),
            (s.needsUpdate = !0),
            l.boundsTree.shapecast({
              intersectsBounds: (M) => s.intersectsBox(M),
              intersectsTriangle: (M) => {
                M.a.applyMatrix4(h),
                  M.b.applyMatrix4(h),
                  M.c.applyMatrix4(h),
                  (M.needsUpdate = !0);
                for (let C = _ * 3, A = (S + _) * 3; C < A; C += 3)
                  if (
                    (wn(t, C, g, y),
                    (t.needsUpdate = !0),
                    M.intersectsTriangle(t))
                  )
                    return !0;
                return !1;
              },
            })
          );
        for (let M = _ * 3, C = S + _ * 3; M < C; M += 3) {
          wn(e, M, g, y),
            e.a.applyMatrix4(i),
            e.b.applyMatrix4(i),
            e.c.applyMatrix4(i),
            (e.needsUpdate = !0);
          for (let A = 0, T = x.count; A < T; A += 3)
            if ((wn(t, A, x, b), (t.needsUpdate = !0), e.intersectsTriangle(t)))
              return !0;
        }
      } else {
        let m = n + 8,
          g = f[n + 6];
        return (
          An(m, d, Sc),
          !!(
            (u.intersectsBox(Sc) && a(m, o, l, h, u)) ||
            (An(g, d, Sc), u.intersectsBox(Sc) && a(g, o, l, h, u))
          )
        );
      }
    };
  })();
function og(e, t, i, r) {
  return An(e, t, Sc), i.intersectBox(Sc, r);
}
var w1 = [],
  cm,
  gu,
  ul,
  dl;
function dd(e) {
  cm && w1.push(cm),
    (cm = e),
    (gu = new Float32Array(e)),
    (ul = new Uint16Array(e)),
    (dl = new Uint32Array(e));
}
function Sf() {
  (cm = null), (gu = null), (ul = null), (dl = null), w1.length && dd(w1.pop());
}
var e0 = Symbol("skip tree generation"),
  t0 = new ur(),
  i0 = new ur(),
  Jh = new je(),
  Dl = new Ln(),
  qu = new Ln(),
  Yu = new I(),
  Af = new I(),
  L9 = new I(),
  B9 = new I(),
  z9 = new I(),
  sA = new ur(),
  on = new i3(() => new Ao()),
  Ed = class {
    static serialize(e, t = {}) {
      if (t.isBufferGeometry)
        return (
          console.warn(
            "MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."
          ),
          Ed.serialize(arguments[0], {
            cloneBuffers: arguments[2] === void 0 ? !0 : arguments[2],
          })
        );
      t = { cloneBuffers: !0, ...t };
      let i = e.geometry,
        r = e._roots,
        s = i.getIndex(),
        a;
      return (
        t.cloneBuffers
          ? (a = { roots: r.map((n) => n.slice()), index: s.array.slice() })
          : (a = { roots: r, index: s.array }),
        a
      );
    }
    static deserialize(e, t, i = {}) {
      if (typeof i == "boolean")
        return (
          console.warn(
            "MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."
          ),
          Ed.deserialize(arguments[0], arguments[1], {
            setIndex: arguments[2] === void 0 ? !0 : arguments[2],
          })
        );
      i = { setIndex: !0, ...i };
      let { index: r, roots: s } = e,
        a = new Ed(t, { ...i, [e0]: !0 });
      if (((a._roots = s), i.setIndex)) {
        let n = t.getIndex();
        if (n === null) {
          let o = new It(e.index, 1, !1);
          t.setIndex(o);
        } else n.array !== r && (n.array.set(r), (n.needsUpdate = !0));
      }
      return a;
    }
    constructor(e, t = {}) {
      if (e.isBufferGeometry) {
        if (e.index && e.index.isInterleavedBufferAttribute)
          throw new Error(
            "MeshBVH: InterleavedBufferAttribute is not supported for the index attribute."
          );
      } else throw new Error("MeshBVH: Only BufferGeometries are supported.");
      if (
        ((t = Object.assign(
          {
            strategy: 0,
            maxDepth: 40,
            maxLeafTris: 10,
            verbose: !0,
            useSharedArrayBuffer: !1,
            setBoundingBox: !0,
            onProgress: null,
            [e0]: !1,
          },
          t
        )),
        t.useSharedArrayBuffer && typeof SharedArrayBuffer > "u")
      )
        throw new Error("MeshBVH: SharedArrayBuffer is not available.");
      (this._roots = null),
        t[e0] ||
          ((this._roots = _9(e, t)),
          !e.boundingBox &&
            t.setBoundingBox &&
            (e.boundingBox = this.getBoundingBox(new ur()))),
        (this.geometry = e);
    }
    refit(e = null) {
      e && Array.isArray(e) && (e = new Set(e));
      let t = this.geometry,
        i = t.index.array,
        r = t.attributes.position,
        s,
        a,
        n,
        o,
        l = 0,
        h = this._roots;
      for (let c = 0, d = h.length; c < d; c++)
        (s = h[c]),
          (a = new Uint32Array(s)),
          (n = new Uint16Array(s)),
          (o = new Float32Array(s)),
          u(0, l),
          (l += s.byteLength);
      function u(c, d, p = !1) {
        let f = c * 2;
        if (n[f + 15] === 65535) {
          let m = a[c + 6],
            g = n[f + 14],
            y = 1 / 0,
            x = 1 / 0,
            b = 1 / 0,
            _ = -1 / 0,
            S = -1 / 0,
            M = -1 / 0;
          for (let C = 3 * m, A = 3 * (m + g); C < A; C++) {
            let T = i[C],
              P = r.getX(T),
              R = r.getY(T),
              z = r.getZ(T);
            P < y && (y = P),
              P > _ && (_ = P),
              R < x && (x = R),
              R > S && (S = R),
              z < b && (b = z),
              z > M && (M = z);
          }
          return o[c + 0] !== y ||
            o[c + 1] !== x ||
            o[c + 2] !== b ||
            o[c + 3] !== _ ||
            o[c + 4] !== S ||
            o[c + 5] !== M
            ? ((o[c + 0] = y),
              (o[c + 1] = x),
              (o[c + 2] = b),
              (o[c + 3] = _),
              (o[c + 4] = S),
              (o[c + 5] = M),
              !0)
            : !1;
        } else {
          let m = c + 8,
            g = a[c + 6],
            y = m + d,
            x = g + d,
            b = p,
            _ = !1,
            S = !1;
          e
            ? b || ((_ = e.has(y)), (S = e.has(x)), (b = !_ && !S))
            : ((_ = !0), (S = !0));
          let M = b || _,
            C = b || S,
            A = !1;
          M && (A = u(m, d, b));
          let T = !1;
          C && (T = u(g, d, b));
          let P = A || T;
          if (P)
            for (let R = 0; R < 3; R++) {
              let z = m + R,
                N = g + R,
                L = o[z],
                G = o[z + 3],
                Y = o[N],
                Z = o[N + 3];
              (o[c + R] = L < Y ? L : Y), (o[c + R + 3] = G > Z ? G : Z);
            }
          return P;
        }
      }
    }
    traverse(e, t = 0) {
      let i = this._roots[t],
        r = new Uint32Array(i),
        s = new Uint16Array(i);
      a(0);
      function a(n, o = 0) {
        let l = n * 2,
          h = s[l + 15] === 65535;
        if (h) {
          let u = r[n + 6],
            c = s[l + 14];
          e(o, h, new Float32Array(i, n * 4, 6), u, c);
        } else {
          let u = n + 8,
            c = r[n + 6],
            d = r[n + 7];
          e(o, h, new Float32Array(i, n * 4, 6), d) ||
            (a(u, o + 1), a(c, o + 1));
        }
      }
    }
    raycast(e, t = Xa) {
      let i = this._roots,
        r = this.geometry,
        s = [],
        a = t.isMaterial,
        n = Array.isArray(t),
        o = r.groups,
        l = a ? t.side : t;
      for (let h = 0, u = i.length; h < u; h++) {
        let c = n ? t[o[h].materialIndex].side : l,
          d = s.length;
        if ((dd(i[h]), x1(0, r, c, e, s), Sf(), n)) {
          let p = o[h].materialIndex;
          for (let f = d, m = s.length; f < m; f++) s[f].face.materialIndex = p;
        }
      }
      return s;
    }
    raycastFirst(e, t = Xa) {
      let i = this._roots,
        r = this.geometry,
        s = t.isMaterial,
        a = Array.isArray(t),
        n = null,
        o = r.groups,
        l = s ? t.side : t;
      for (let h = 0, u = i.length; h < u; h++) {
        let c = a ? t[o[h].materialIndex].side : l;
        dd(i[h]);
        let d = b1(0, r, c, e);
        Sf(),
          d != null &&
            (n == null || d.distance < n.distance) &&
            ((n = d), a && (d.face.materialIndex = o[h].materialIndex));
      }
      return n;
    }
    intersectsGeometry(e, t) {
      let i = this.geometry,
        r = !1;
      for (let s of this._roots)
        if ((dd(s), (r = R9(0, i, e, t)), Sf(), r)) break;
      return r;
    }
    shapecast(e, t, i) {
      let r = this.geometry;
      if (e instanceof Function) {
        if (t) {
          let c = t;
          t = (d, p, f, m) => {
            let g = p * 3;
            return c(d, g, g + 1, g + 2, f, m);
          };
        }
        (e = {
          boundsTraverseOrder: i,
          intersectsBounds: e,
          intersectsTriangle: t,
          intersectsRange: null,
        }),
          console.warn(
            "MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature."
          );
      }
      let s = on.getPrimitive(),
        {
          boundsTraverseOrder: a,
          intersectsBounds: n,
          intersectsRange: o,
          intersectsTriangle: l,
        } = e;
      if (o && l) {
        let c = o;
        o = (d, p, f, m, g) =>
          c(d, p, f, m, g) ? !0 : rA(d, p, r, l, f, m, s);
      } else
        o ||
          (l
            ? (o = (c, d, p, f) => rA(c, d, r, l, p, f, s))
            : (o = (c, d, p) => p));
      let h = !1,
        u = 0;
      for (let c of this._roots) {
        if ((dd(c), (h = I9(0, r, n, o, a, u)), Sf(), h)) break;
        u += c.byteLength;
      }
      return on.releasePrimitive(s), h;
    }
    bvhcast(e, t, i) {
      let { intersectsRanges: r, intersectsTriangles: s } = i,
        a = this.geometry.index,
        n = this.geometry.attributes.position,
        o = e.geometry.index,
        l = e.geometry.attributes.position;
      Jh.copy(t).invert();
      let h = on.getPrimitive(),
        u = on.getPrimitive();
      if (s) {
        let d = function (p, f, m, g, y, x, b, _) {
          for (let S = m, M = m + g; S < M; S++) {
            wn(u, S * 3, o, l),
              u.a.applyMatrix4(t),
              u.b.applyMatrix4(t),
              u.c.applyMatrix4(t),
              (u.needsUpdate = !0);
            for (let C = p, A = p + f; C < A; C++)
              if (
                (wn(h, C * 3, a, n),
                (h.needsUpdate = !0),
                s(h, u, C, S, y, x, b, _))
              )
                return !0;
          }
          return !1;
        };
        if (r) {
          let p = r;
          r = function (f, m, g, y, x, b, _, S) {
            return p(f, m, g, y, x, b, _, S) ? !0 : d(f, m, g, y, x, b, _, S);
          };
        } else r = d;
      }
      e.getBoundingBox(i0), i0.applyMatrix4(t);
      let c = this.shapecast({
        intersectsBounds: (d) => i0.intersectsBox(d),
        intersectsRange: (d, p, f, m, g, y) => (
          t0.copy(y),
          t0.applyMatrix4(Jh),
          e.shapecast({
            intersectsBounds: (x) => t0.intersectsBox(x),
            intersectsRange: (x, b, _, S, M) => r(d, p, x, b, m, g, S, M),
          })
        ),
      });
      return on.releasePrimitive(h), on.releasePrimitive(u), c;
    }
    intersectsBox(e, t) {
      return (
        Dl.set(e.min, e.max, t),
        (Dl.needsUpdate = !0),
        this.shapecast({
          intersectsBounds: (i) => Dl.intersectsBox(i),
          intersectsTriangle: (i) => Dl.intersectsTriangle(i),
        })
      );
    }
    intersectsSphere(e) {
      return this.shapecast({
        intersectsBounds: (t) => e.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(e),
      });
    }
    closestPointToGeometry(e, t, i = {}, r = {}, s = 0, a = 1 / 0) {
      e.boundingBox || e.computeBoundingBox(),
        Dl.set(e.boundingBox.min, e.boundingBox.max, t),
        (Dl.needsUpdate = !0);
      let n = this.geometry,
        o = n.attributes.position,
        l = n.index,
        h = e.attributes.position,
        u = e.index,
        c = on.getPrimitive(),
        d = on.getPrimitive(),
        p = Af,
        f = L9,
        m = null,
        g = null;
      r && ((m = B9), (g = z9));
      let y = 1 / 0,
        x = null,
        b = null;
      return (
        Jh.copy(t).invert(),
        qu.matrix.copy(Jh),
        this.shapecast({
          boundsTraverseOrder: (_) => Dl.distanceToBox(_),
          intersectsBounds: (_, S, M) =>
            M < y && M < a
              ? (S &&
                  (qu.min.copy(_.min),
                  qu.max.copy(_.max),
                  (qu.needsUpdate = !0)),
                !0)
              : !1,
          intersectsRange: (_, S) => {
            if (e.boundsTree)
              return e.boundsTree.shapecast({
                boundsTraverseOrder: (M) => qu.distanceToBox(M),
                intersectsBounds: (M, C, A) => A < y && A < a,
                intersectsRange: (M, C) => {
                  for (let A = M * 3, T = (M + C) * 3; A < T; A += 3) {
                    wn(d, A, u, h),
                      d.a.applyMatrix4(t),
                      d.b.applyMatrix4(t),
                      d.c.applyMatrix4(t),
                      (d.needsUpdate = !0);
                    for (let P = _ * 3, R = (_ + S) * 3; P < R; P += 3) {
                      wn(c, P, l, o), (c.needsUpdate = !0);
                      let z = c.distanceToTriangle(d, p, m);
                      if (
                        (z < y &&
                          (f.copy(p),
                          g && g.copy(m),
                          (y = z),
                          (x = P / 3),
                          (b = A / 3)),
                        z < s)
                      )
                        return !0;
                    }
                  }
                },
              });
            {
              let M = u ? u.count : h.count;
              for (let C = 0, A = M; C < A; C += 3) {
                wn(d, C, u, h),
                  d.a.applyMatrix4(t),
                  d.b.applyMatrix4(t),
                  d.c.applyMatrix4(t),
                  (d.needsUpdate = !0);
                for (let T = _ * 3, P = (_ + S) * 3; T < P; T += 3) {
                  wn(c, T, l, o), (c.needsUpdate = !0);
                  let R = c.distanceToTriangle(d, p, m);
                  if (
                    (R < y &&
                      (f.copy(p),
                      g && g.copy(m),
                      (y = R),
                      (x = T / 3),
                      (b = C / 3)),
                    R < s)
                  )
                    return !0;
                }
              }
            }
          },
        }),
        on.releasePrimitive(c),
        on.releasePrimitive(d),
        y === 1 / 0
          ? null
          : (i.point ? i.point.copy(f) : (i.point = f.clone()),
            (i.distance = y),
            (i.faceIndex = x),
            r &&
              (r.point ? r.point.copy(g) : (r.point = g.clone()),
              r.point.applyMatrix4(Jh),
              f.applyMatrix4(Jh),
              (r.distance = f.sub(r.point).length()),
              (r.faceIndex = b)),
            i)
      );
    }
    closestPointToPoint(e, t = {}, i = 0, r = 1 / 0) {
      let s = i * i,
        a = r * r,
        n = 1 / 0,
        o = null;
      if (
        (this.shapecast({
          boundsTraverseOrder: (h) => (
            Yu.copy(e).clamp(h.min, h.max), Yu.distanceToSquared(e)
          ),
          intersectsBounds: (h, u, c) => c < n && c < a,
          intersectsTriangle: (h, u) => {
            h.closestPointToPoint(e, Yu);
            let c = e.distanceToSquared(Yu);
            return c < n && (Af.copy(Yu), (n = c), (o = u)), c < s;
          },
        }),
        n === 1 / 0)
      )
        return null;
      let l = Math.sqrt(n);
      return (
        t.point ? t.point.copy(Af) : (t.point = Af.clone()),
        (t.distance = l),
        (t.faceIndex = o),
        t
      );
    }
    getBoundingBox(e) {
      return (
        e.makeEmpty(),
        this._roots.forEach((t) => {
          An(0, new Float32Array(t), sA), e.union(sA);
        }),
        e
      );
    }
  },
  Xu = Sr(RO()),
  F9 = 0.5 * (Math.sqrt(3) - 1),
  Qu = (3 - Math.sqrt(3)) / 6,
  k9 = 1 / 3,
  ln = 1 / 6,
  Yee = (Math.sqrt(5) - 1) / 4,
  Xee = (5 - Math.sqrt(5)) / 20,
  Cd = (e) => Math.floor(e) | 0,
  aA = new Float64Array([
    1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0,
    -1,
  ]),
  r0 = new Float64Array([
    1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0,
    -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1,
  ]);
function s0(e = Math.random) {
  let t = r3(e),
    i = new Float64Array(t).map((s) => aA[(s % 12) * 2]),
    r = new Float64Array(t).map((s) => aA[(s % 12) * 2 + 1]);
  return function (s, a) {
    let n = 0,
      o = 0,
      l = 0,
      h = (s + a) * F9,
      u = Cd(s + h),
      c = Cd(a + h),
      d = (u + c) * Qu,
      p = u - d,
      f = c - d,
      m = s - p,
      g = a - f,
      y,
      x;
    m > g ? ((y = 1), (x = 0)) : ((y = 0), (x = 1));
    let b = m - y + Qu,
      _ = g - x + Qu,
      S = m - 1 + 2 * Qu,
      M = g - 1 + 2 * Qu,
      C = u & 255,
      A = c & 255,
      T = 0.5 - m * m - g * g;
    if (T >= 0) {
      let z = C + t[A],
        N = i[z],
        L = r[z];
      (T *= T), (n = T * T * (N * m + L * g));
    }
    let P = 0.5 - b * b - _ * _;
    if (P >= 0) {
      let z = C + y + t[A + x],
        N = i[z],
        L = r[z];
      (P *= P), (o = P * P * (N * b + L * _));
    }
    let R = 0.5 - S * S - M * M;
    if (R >= 0) {
      let z = C + 1 + t[A + 1],
        N = i[z],
        L = r[z];
      (R *= R), (l = R * R * (N * S + L * M));
    }
    return 70 * (n + o + l);
  };
}
function N9(e = Math.random) {
  let t = r3(e),
    i = new Float64Array(t).map((a) => r0[(a % 12) * 3]),
    r = new Float64Array(t).map((a) => r0[(a % 12) * 3 + 1]),
    s = new Float64Array(t).map((a) => r0[(a % 12) * 3 + 2]);
  return function (a, n, o) {
    let l,
      h,
      u,
      c,
      d = (a + n + o) * k9,
      p = Cd(a + d),
      f = Cd(n + d),
      m = Cd(o + d),
      g = (p + f + m) * ln,
      y = p - g,
      x = f - g,
      b = m - g,
      _ = a - y,
      S = n - x,
      M = o - b,
      C,
      A,
      T,
      P,
      R,
      z;
    _ >= S
      ? S >= M
        ? ((C = 1), (A = 0), (T = 0), (P = 1), (R = 1), (z = 0))
        : _ >= M
        ? ((C = 1), (A = 0), (T = 0), (P = 1), (R = 0), (z = 1))
        : ((C = 0), (A = 0), (T = 1), (P = 1), (R = 0), (z = 1))
      : S < M
      ? ((C = 0), (A = 0), (T = 1), (P = 0), (R = 1), (z = 1))
      : _ < M
      ? ((C = 0), (A = 1), (T = 0), (P = 0), (R = 1), (z = 1))
      : ((C = 0), (A = 1), (T = 0), (P = 1), (R = 1), (z = 0));
    let N = _ - C + ln,
      L = S - A + ln,
      G = M - T + ln,
      Y = _ - P + 2 * ln,
      Z = S - R + 2 * ln,
      q = M - z + 2 * ln,
      oe = _ - 1 + 3 * ln,
      ce = S - 1 + 3 * ln,
      ie = M - 1 + 3 * ln,
      te = p & 255,
      ue = f & 255,
      ae = m & 255,
      de = 0.6 - _ * _ - S * S - M * M;
    if (de < 0) l = 0;
    else {
      let Ae = te + t[ue + t[ae]];
      (de *= de), (l = de * de * (i[Ae] * _ + r[Ae] * S + s[Ae] * M));
    }
    let ne = 0.6 - N * N - L * L - G * G;
    if (ne < 0) h = 0;
    else {
      let Ae = te + C + t[ue + A + t[ae + T]];
      (ne *= ne), (h = ne * ne * (i[Ae] * N + r[Ae] * L + s[Ae] * G));
    }
    let Ee = 0.6 - Y * Y - Z * Z - q * q;
    if (Ee < 0) u = 0;
    else {
      let Ae = te + P + t[ue + R + t[ae + z]];
      (Ee *= Ee), (u = Ee * Ee * (i[Ae] * Y + r[Ae] * Z + s[Ae] * q));
    }
    let me = 0.6 - oe * oe - ce * ce - ie * ie;
    if (me < 0) c = 0;
    else {
      let Ae = te + 1 + t[ue + 1 + t[ae + 1]];
      (me *= me), (c = me * me * (i[Ae] * oe + r[Ae] * ce + s[Ae] * ie));
    }
    return 32 * (l + h + u + c);
  };
}
function r3(e) {
  let t = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++) t[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    let r = i + ~~(e() * (256 - i)),
      s = t[i];
    (t[i] = t[r]), (t[r] = s);
  }
  for (let i = 256; i < 512; i++) t[i] = t[i - 256];
  return t;
}
var za = new rs(),
  U9 = class {
    constructor(e) {
      this.weightAttribute = null;
      let t = e.geometry;
      if (!t.isBufferGeometry || t.attributes.position.itemSize !== 3)
        throw new Error(
          "THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."
        );
      t.index && (t = t.toNonIndexed()),
        (this.geometry = t),
        (this.randomFunction = Math.random),
        (this.positionAttribute = this.geometry.getAttribute("position")),
        (this.distribution = null);
    }
    build() {
      let e = this.positionAttribute,
        t = new Float32Array(e.count / 3);
      for (let r = 0; r < e.count; r += 3) {
        let s = 1;
        za.a.fromBufferAttribute(e, r),
          za.b.fromBufferAttribute(e, r + 1),
          za.c.fromBufferAttribute(e, r + 2),
          (s *= za.getArea()),
          (t[r / 3] = s);
      }
      this.distribution = new Float32Array(e.count / 3);
      let i = 0;
      for (let r = 0; r < t.length; r++)
        (i += t[r]), (this.distribution[r] = i);
      return this;
    }
    setRandomGenerator(e) {
      return (this.randomFunction = e), this;
    }
    sample(e, t) {
      if (this.distribution) {
        let i = this.distribution[this.distribution.length - 1],
          r = this.binarySearch(this.randomFunction() * i);
        return this.sampleFace(r, e, t);
      }
    }
    binarySearch(e) {
      if (!this.distribution) return 0;
      let t = this.distribution,
        i = 0,
        r = t.length - 1,
        s = -1;
      for (; i <= r; ) {
        let a = Math.ceil((i + r) / 2);
        if (a === 0 || (t[a - 1] <= e && t[a] > e)) {
          s = a;
          break;
        } else e < t[a] ? (r = a - 1) : (i = a + 1);
      }
      return s;
    }
    sampleFace(e, t, i) {
      let r = this.randomFunction(),
        s = this.randomFunction();
      return (
        r + s > 1 && ((r = 1 - r), (s = 1 - s)),
        za.a.fromBufferAttribute(this.positionAttribute, e * 3),
        za.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1),
        za.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2),
        t
          .set(0, 0, 0)
          .addScaledVector(za.a, r)
          .addScaledVector(za.b, s)
          .addScaledVector(za.c, 1 - (r + s)),
        za.getNormal(i),
        this
      );
    }
  },
  V9 = Sr(FE()),
  j9 = new je(),
  H9 = new je(),
  G9 = new je(),
  Kd;
((e) => {
  function t(i) {
    return i && i.__isSPEObject;
  }
  e.is = t;
})(Kd || (Kd = {}));
var nb = (e) =>
    class extends e {
      constructor() {
        super(...arguments),
          (this.previousModelViewMatrix = new je()),
          (this.copyPreviousMatrix = !0),
          (this.hiddenMatrix = new je()),
          (this.matrixWorldRigid = new je()),
          (this.shearScale = new je()),
          (this.shearScaleInv = new je());
      }
      get __isSPEObject() {
        return !0;
      }
      isDescendantOf(t) {
        t instanceof _i && (t = t.uuid);
        let i = this;
        for (; i.parent; ) {
          if (i.parent.uuid === t) return !0;
          i = i.parent;
        }
        return !1;
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || t) &&
            (this.parent === null
              ? this.matrixWorld.multiplyMatrices(
                  this.hiddenMatrix,
                  this.matrix
                )
              : (this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.hiddenMatrix
                ),
                this.matrixWorld.multiplyMatrices(
                  this.matrixWorld,
                  this.matrix
                )),
            (this.matrixWorldNeedsUpdate = !1),
            (t = !0));
        for (let i of this.children) i.updateMatrixWorld(t);
      }
      updateWorldMatrix(t, i) {
        let r = this.parent;
        if (
          (t && r !== null && r.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          this.parent === null
            ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix)
            : (this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.hiddenMatrix
              ),
              this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)),
          i)
        )
          for (let s of this.children) s.updateWorldMatrix(!1, !0);
      }
      traverseChildren(t, i = 0) {
        for (let r of this.children) Kd.is(r) && r.traverseObject(t, i + 1);
      }
      traverseObject(t, i = 0) {
        if (t(this, i) !== !0)
          for (let r of this.children) Kd.is(r) && r.traverseObject(t, i + 1);
      }
      updateMatrixWorldSVD() {
        let t = this.matrixWorld.elements,
          i = [
            [t[0], t[4], t[8]],
            [t[1], t[5], t[9]],
            [t[2], t[6], t[10]],
          ],
          { u: r, v: s, q: a } = (0, V9.SVD)(i),
          n = j9.set(
            r[0][0],
            r[0][1],
            r[0][2],
            0,
            r[1][0],
            r[1][1],
            r[1][2],
            0,
            r[2][0],
            r[2][1],
            r[2][2],
            0,
            0,
            0,
            0,
            1
          ),
          o = H9.set(
            s[0][0],
            s[0][1],
            s[0][2],
            0,
            s[1][0],
            s[1][1],
            s[1][2],
            0,
            s[2][0],
            s[2][1],
            s[2][2],
            0,
            0,
            0,
            0,
            1
          ),
          l = G9.copy(o).transpose();
        this.shearScale.makeScale(a[0], a[1], a[2]).multiply(l).premultiply(o),
          this.shearScaleInv.copy(this.shearScale).invert(),
          this.matrixWorldRigid
            .multiplyMatrices(n, l)
            .copyPosition(this.matrixWorld),
          a.every((h) => Math.abs(a[0] - h) < 0.01)
            ? (this.hasNonUniformScale = !1)
            : (this.hasNonUniformScale = !0);
      }
      attach(t, i) {
        this.updateWorldMatrix(!0, !1);
        let r = new je().copy(this.matrixWorld).invert();
        return (
          t.parent !== null &&
            (t.parent.updateWorldMatrix(!0, !1),
            r.multiply(t.parent.matrixWorld)),
          "hiddenMatrix" in t && t.hiddenMatrix instanceof je
            ? t.hiddenMatrix.premultiply(r)
            : t.applyMatrix4(r),
          t.updateWorldMatrix(!1, !1),
          this.add(t),
          i !== void 0 && (this.children.pop(), this.children.splice(i, 0, t)),
          this
        );
      }
      copy(t, i = !1) {
        return (
          super.copy(t, i),
          (this.hasNonUniformScale = t.hasNonUniformScale),
          this
        );
      }
      onAfterRender(t, i, r, s, a, n) {
        this.copyPreviousMatrix &&
          this.previousModelViewMatrix.copy(this.modelViewMatrix);
      }
    },
  W9 = class extends nb(_i) {},
  q9 = (e) => e.type === "Mesh",
  fs = class extends W9 {
    constructor(e) {
      super(),
        (this.object = e),
        (this.matrixAutoUpdate = !1),
        (this.hasNonUniformScale = e.hasNonUniformScale);
    }
    raycast(e, t) {}
    expand() {
      let e = 0,
        t = this.object.entityChildren(e);
      for (; t; ) {
        let i = this.children[e];
        i?.object !== t &&
          (i && this.remove(i),
          (i = new fs(t)),
          this.add(i),
          this.children.splice(e, 0, this.children.pop()),
          (i.matrixWorldNeedsUpdate = !0),
          (i.matrixAutoUpdate = !1),
          (i.matrix = t.matrix),
          (i.hiddenMatrix = t.hiddenMatrix)),
          i.expand(),
          (e += 1),
          (t = this.object.entityChildren(e));
      }
      for (; this.children.length > e; ) this.remove(this.children[e]);
    }
    get visible() {
      return this.playModeVisible !== void 0
        ? this.playModeVisible
        : this.object.visible ||
            (this.object.dataPatched.visible &&
              this.object.dataPatched.cloner?.hideBase === !0);
    }
    set visible(e) {}
    get castShadow() {
      return this.object.castShadow;
    }
    set castShadow(e) {}
    get receiveShadow() {
      return this.object.receiveShadow;
    }
    set receiveShadow(e) {}
    get isMesh() {
      return q9(this.object);
    }
    get isLight() {
      return this.object.isLight;
    }
    get layers() {
      return this.object.layers;
    }
    set layers(e) {}
    get isCamera() {
      return !1;
    }
    get geometry() {
      if (this.object.geometry) return this.object.geometry;
    }
    get material() {
      if (this.object.material) return this.object.material;
    }
  },
  Nl = new I(),
  Ul = new I(),
  Ic = new je(),
  s3 = [
    new I(-1, 1, 1),
    new I(-1, -1, 1),
    new I(1, -1, 1),
    new I(1, 1, 1),
    new I(-1, 1, -1),
    new I(-1, -1, -1),
    new I(1, -1, -1),
    new I(1, 1, -1),
  ],
  Y9 = [
    [0, 3],
    [1, 2],
    [5, 6],
    [4, 7],
    [0, 1],
    [3, 2],
    [7, 6],
    [4, 5],
    [0, 4],
    [1, 5],
    [2, 6],
    [3, 7],
  ],
  X9 = [
    [0, 2],
    [7, 5],
    [4, 1],
    [3, 6],
    [4, 3],
    [1, 6],
  ],
  nA = (e, t, i) => {
    e.updateEntityBoxSize(Nl, Ul),
      Ic.copy(t).multiply(e.matrixWorld),
      Ul.x === 0 && Ul.y === 0 && Ul.z === 0
        ? i.push(new I(Nl.x, Nl.y, Nl.z).applyMatrix4(Ic))
        : s3.forEach((r) => {
            i.push(r.clone().multiply(Ul).add(Nl).applyMatrix4(Ic));
          });
  },
  oA = class extends ur {
    constructor() {
      super(...arguments),
        (this.matrix = new je()),
        (this.vertices = []),
        (this.faces = []),
        (this.edges = []),
        (this.centerEdges = []);
    }
    copy(e) {
      return (
        super.copy(e),
        this.matrix.copy(e.matrix),
        (this.vertices = e.vertices.map((t) => t.clone())),
        (this.faces = e.faces.map((t) => t.clone())),
        (this.edges = e.edges.map((t) => t.clone())),
        (this.centerEdges = e.centerEdges.map((t) => t.clone())),
        this
      );
    }
    setFromObjectSize(e, t = !1) {
      e.updateWorldMatrix(!1, t),
        this.makeEmpty(),
        this.matrix.copy(e.matrixWorld);
      let i = new je().copy(e.matrixWorld).invert();
      return this.expandByObjectSize(e, i, t);
    }
    expandByObjectSize(e, t, i = !1) {
      let r = [];
      return (
        i === !0
          ? e.traverseEntity((s) => {
              if (s.visible || (s.cloner && s.data.visible)) {
                if (!("geometry" in s)) {
                  r.push(new I());
                  return;
                }
                nA(s, t, r);
              }
            })
          : nA(e, t, r),
        this.setFromPoints(r)
      );
    }
    getCenter(e) {
      return (e = super.getCenter(e)), e.applyMatrix4(this.matrix), e;
    }
    getPositionToCenter(e) {
      return (
        (e = super.getCenter(e)),
        e.applyMatrix4(Ic.copy(this.matrix).setPosition(0, 0, 0)),
        e
      );
    }
    computeVertices() {
      this.getSize(Ul).multiplyScalar(0.5),
        this.getCenter(Nl),
        Ic.copy(this.matrix).setPosition(Nl),
        (this.vertices = s3.map((e) =>
          e.clone().multiply(Ul).applyMatrix4(Ic)
        ));
    }
    computeEdges() {
      this.vertices.length > 0 && this.computeVertices(),
        (this.edges = Y9.map(
          ([e, t]) => new Ma(this.vertices[e], this.vertices[t])
        )),
        (this.centerEdges = this.edges.map((e) => e.getCenter(new I())));
    }
    computeFaces() {
      this.vertices.length > 0 && this.computeVertices(),
        (this.faces = X9.map(([e, t]) =>
          this.vertices[e].clone().add(this.vertices[t]).multiplyScalar(0.5)
        ));
    }
  },
  al = {
    Cloner: () => {},
    changeEntityProptotype: () => {},
    createEntity: () => {},
  },
  Q9 = class extends dC {
    constructor() {
      super();
    }
    getPoints(e = 12) {
      let t = [],
        i,
        r = this.getCurveLengths(),
        s = r[r.length - 1] / r.length;
      for (let a = 0, n = this.curves; a < n.length; a++) {
        let o = n[a],
          l = a === 0 ? r[a] : r[a] - r[a - 1],
          h = Math.ceil((e * l) / s),
          u = o.getPoints(h);
        for (let c = 0; c < u.length; c++) {
          let d = u[c];
          (i && i.equals(d)) || (t.push(d), (i = d));
        }
      }
      return (
        this.autoClose &&
          t.length > 1 &&
          !t[t.length - 1].equals(t[0]) &&
          t.push(t[0]),
        t
      );
    }
  },
  _1 = 0.001;
function S1(e, t, i) {
  return t.clone().sub(e).cross(t.clone().sub(i)).length() <= _1;
}
function a0(e, t) {
  let i = new I(...e.position),
    r = new I(...e.controlNext.position),
    s = new I(...t.controlPrevious.position),
    a = new I(...t.position);
  return S1(i, r, a) && S1(i, s, a);
}
function a3(e) {
  let t = e.points.map((u) => new I(...u.data.position)),
    i = [e.points[0]],
    r = new I(...i[0].data.position);
  for (let u = 0; u < e.points.length - 1; u++)
    S1(r, t[u], t[u + 1]) || (i.push(e.points[u]), (r = t[u]));
  i.push(e.points[e.points.length - 1]);
  let s = e.isClosed,
    a = i.length - (s ? 0 : 1),
    n = i.length,
    o = [];
  for (let u = 0; u < n; u++) {
    let c = i[u].data,
      d = new I(...c.position),
      p = new I(...c.controlPrevious.position),
      f = new I(...c.controlNext.position),
      m = {
        position: d,
        baseRoundness: c.roundness,
        controlPrevious: p,
        controlNext: f,
      };
    if (c.roundness === 0 || (!e.isClosed && (u === 0 || u === n - 1))) {
      o[u] = { ...m, removedLength: 0 };
      continue;
    }
    let g = s && u == 0 ? n - 1 : u - 1,
      y = s && u == n - 1 ? 0 : u + 1,
      x = i[g].data,
      b = i[y].data,
      _ = new I(...x.position),
      S = new I(...b.position),
      M = _.clone().sub(d).normalize(),
      C = S.clone().sub(d).normalize();
    Object.assign(m, { prevDir: M, nextDir: C });
    let A = a0(x, c),
      T = a0(c, b);
    if (!A || !T) o[u] = { ...m, removedLength: 0 };
    else {
      let P = M.clone().add(C).normalize(),
        R = P.clone().cross(M).length() / M.dot(P);
      o[u] = { ...m, tan: R, removedLength: c.roundness / R };
    }
  }
  for (let u = 0; u < a; u++) {
    let c = u,
      d = s && u === n - 1 ? 0 : u + 1,
      p = o[c],
      f = o[d];
    if (p.removedLength !== 0 || f.removedLength !== 0) {
      let m = p.position.distanceTo(f.position);
      (p.removedLength = Math.min(p.removedLength, m / 2)),
        (f.removedLength = Math.min(f.removedLength, m / 2));
    }
  }
  let l = [];
  for (let u = 0; u < a; u++) {
    let c = u,
      d = s && u === n - 1 ? 0 : u + 1,
      p = o[c],
      f = o[d],
      m = null;
    if (!a0(i[c].data, i[d].data))
      p.position.distanceTo(f.position) > _1 &&
        (m = new am(p.position, p.controlNext, f.controlPrevious, f.position));
    else {
      let g = p.position.clone(),
        y = f.position.clone();
      (p.removedLength !== 0 || f.removedLength !== 0) &&
        (p.nextDir && g.add(p.nextDir.clone().setLength(p.removedLength)),
        f.prevDir && y.add(f.prevDir.clone().setLength(f.removedLength))),
        g.distanceTo(y) > _1 &&
          (m = new am(g, g.clone().lerp(y, 0.3), y.clone().lerp(g, 0.3), y));
    }
    l[2 * u + 1] = m;
  }
  for (let u = 0; u < n; u++) {
    let c = o[u];
    if (c.removedLength === 0) {
      l[2 * u] = null;
      continue;
    }
    let d = c.position,
      p = c.prevDir.clone().multiplyScalar(c.removedLength).add(d),
      f = c.nextDir.clone().multiplyScalar(c.removedLength).add(d),
      m = c.tan * c.removedLength,
      g = c.prevDir.clone().add(c.nextDir).normalize(),
      y = p.clone().lerp(f, 0.5),
      x = p.distanceTo(f) / 2,
      b = g
        .clone()
        .multiplyScalar(Math.sqrt(Math.pow(m, 2) - Math.pow(x, 2)))
        .add(y),
      _ = g.clone().multiplyScalar(-m).add(b),
      S = d.distanceTo(_) / d.distanceTo(y),
      M = c.prevDir
        .clone()
        .multiplyScalar(S * d.distanceTo(p))
        .add(d),
      C = M.clone().lerp(_, 2),
      A = p.clone().lerp(M, 4 / 3),
      T = f.clone().lerp(C, 4 / 3);
    l[2 * u] = new am(p, A, T, f);
  }
  let h = new Q9();
  return (
    l.forEach((u) => {
      u && h.add(u);
    }),
    h
  );
}
var si;
((e) => {
  function t(i) {
    return i && i.__isEntity;
  }
  e.is = t;
})(si || (si = {}));
var ho = (e) => si.is(e),
  Z9 = { type: "completeState", isfromEntity: !0 },
  K9 = ["x", "y", "z"],
  n0 = new I(),
  J9 = new I().set(0, 1, 0),
  ob = (e) =>
    class extends nb(e) {
      constructor() {
        super(...arguments),
          (this.raycastLock = !1),
          (this.scaleLock = !1),
          (this.disposed = !1),
          (this.stateSelection = null),
          (this.destroyedInAction = !1),
          (this.instances = []),
          (this.prevState = null),
          (this.currentState = null),
          (this.reversibleToState = null),
          (this.currentTransitionEvent = null),
          (this.previousAction = null),
          (this._singleBBox = new oA()),
          (this._recursiveBBox = new oA()),
          (this.singleBBoxNeedsUpdate = !0),
          (this.recursiveBBoxNeedsUpdate = !0),
          (this._needApplyPathSnapping = !0),
          (this.attachedPaths = new Set());
      }
      get __isEntity() {
        return !0;
      }
      entityChildren(t) {
        let i = this.children[t];
        if (si.is(i)) return i;
      }
      entityChildrenCount() {
        let t = this.children.length;
        for (; t--; ) if (si.is(this.children[t])) return t + 1;
        return 0;
      }
      get isConcreteEntity() {
        return typeof this.identity == "string";
      }
      get isVirtualEntity() {
        return typeof this.identity != "string";
      }
      get isInstanceRoot() {
        return this.isConcreteEntity && this.data.type === "Instance";
      }
      nearestInstanceSelfOrParent() {
        let t = this;
        for (; t.data.type !== "Instance"; ) {
          let i = t.parent;
          if (si.is(i)) t = i;
          else return;
        }
        return t;
      }
      forInstancesRec(t) {
        this.instances.forEach((i) => {
          i.disposed || t(i), i.forInstancesRec(t);
        });
      }
      super_Entity(t, i) {
        typeof t == "string" && (this.uuid = t),
          (this.identity = t),
          (this.data = i),
          (this.matrixAutoUpdate = !1),
          (this.dataPatched = this.data);
      }
      changeSelectedState(t, i, r = !1) {
        if (!(this.data.states.length === 0 && !r)) {
          for (let s of this.data.states)
            Wl.toOps(this.data, s.data).forEach((a) => {
              let n = Nm.replaceProps(a, this.data);
              (this.dataPatched = this.data),
                this.updateByPatchedOp(n, this.data, i);
            });
          if (t !== null) {
            let s = this.data.states.data(t);
            s &&
              ((this.dataPatched = Wl.patch(this.data, s)),
              Wl.toOps(this.data, s).forEach((a) => {
                this.updateByPatchedOp(a, this.dataPatched, i);
              }));
          }
          r && this.updateTransformState(this.dataPatched, i),
            (this.stateSelection = t),
            this.updatePathSnapping(this.dataPatched.pathSnapping);
        }
      }
      get singleBBox() {
        return (
          this.singleBBoxNeedsUpdate &&
            ((this.singleBBoxNeedsUpdate = !1),
            this._singleBBox.setFromObjectSize(this, !1),
            this._singleBBox.computeVertices(),
            this._singleBBox.computeEdges(),
            this._singleBBox.computeFaces()),
          this._singleBBox
        );
      }
      get recursiveBBox() {
        return (
          this.recursiveBBoxNeedsUpdate &&
            ((this.recursiveBBoxNeedsUpdate = !1),
            this._recursiveBBox.setFromObjectSize(this, !0),
            this._recursiveBBox.computeVertices(),
            this._recursiveBBox.computeEdges(),
            this._recursiveBBox.computeFaces()),
          this._recursiveBBox
        );
      }
      updateEntityBoxSize(t, i) {
        t.setScalar(0), i.setScalar(0);
      }
      resetBBoxNeedsUpdateSelf() {
        (this.singleBBoxNeedsUpdate = !0), (this.recursiveBBoxNeedsUpdate = !0);
      }
      resetBBoxNeedsUpdate() {
        this.resetBBoxNeedsUpdateSelf(),
          this.traverseAncestors((t) => {
            ho(t) && t.resetBBoxNeedsUpdateSelf();
          }),
          this.traverseEntity((t) => {
            t.resetBBoxNeedsUpdateSelf();
          });
      }
      find(t) {
        let i;
        return (
          this.traverseEntity((r) => {
            r.uuid === t && (i = r);
          }),
          i
        );
      }
      traverseSortNextHelper() {
        let t = this.parent;
        if (t) {
          let i = t.children,
            r = i.indexOf(this) + 1;
          if (si.is(i[r])) return i[r];
          if (si.is(t)) return t.traverseSortNextHelper();
        }
      }
      sortNext() {
        let t = this.children;
        return this.children.length > 0 && si.is(this.children[0])
          ? t[0]
          : this.traverseSortNextHelper();
      }
      goUp(t) {
        let i = this;
        for (; t > 0 && i !== null; ) (i = i.parent), (t -= 1);
        return i;
      }
      hasAnccestorOrSelf(t) {
        return this === t || this.hasAnccestor(t);
      }
      hasAnccestor(t) {
        let i = this.parent;
        for (; i; ) {
          if (t === i) return !0;
          i = i.parent;
        }
        return !1;
      }
      countToAccestor(t) {
        let i = 0,
          r = this;
        for (; r !== t; ) {
          if (r === null) return -1;
          (r = r.parent), (i += 1);
        }
        return i;
      }
      forEachEntity(t) {
        for (let i of this.children) ho(i) && t(i);
      }
      traverseEntityAncestors(t) {
        this.traverseAncestors((i) => {
          si.is(i) && t(i);
        });
      }
      traverseConcreteEntity(t, i = 0) {
        if (t(this, i) !== !0)
          for (let r of this.children)
            ho(r) && r.isConcreteEntity && r.traverseEntity(t, i + 1);
      }
      traverseEntity(t, i = 0) {
        if (t(this, i) !== !0)
          for (let r of this.children) ho(r) && r.traverseEntity(t, i + 1);
      }
      traverseVisibleEntity(t) {
        t(this);
        for (let i of this.children)
          ho(i) && i.visible && i.traverseVisibleEntity(t);
      }
      updateMatrix() {
        super.updateMatrix(),
          this.cloner && this.cloner.onObjUpdateMatrix(),
          this.dispatchEvent({ type: "updateMatrix" });
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t),
          this.dispatchEvent({ type: "updateMatrixWorld" });
      }
      copy(t, i = !1) {
        return (
          super.copy(t, i),
          (this.dataPatched = t.dataPatched),
          (this.raycastLock = t.raycastLock),
          (this.scaleLock = t.scaleLock),
          this.hiddenMatrix.copy(t.hiddenMatrix),
          this
        );
      }
      hasEntityChild() {
        return this.children.some((t) => ho(t));
      }
      isAncestorOf(t) {
        if (this.uuid === t) return !1;
        let i = !1;
        return (
          this.traverseEntity((r) => {
            r.uuid === t && (i = !0);
          }),
          i
        );
      }
      toObjectTransformState(t = []) {
        this.updateWorldMatrix(!0, !1);
        let i = {
          position: this.position.toArray(),
          rotation: [
            this.rotation.x * dt.RAD2DEG,
            this.rotation.y * dt.RAD2DEG,
            this.rotation.z * dt.RAD2DEG,
          ],
          scale: this.scale.toArray(),
          hiddenMatrix: this.hiddenMatrix.toArray(),
        };
        return Oy(i, t);
      }
      getTransformValues(t, i, r) {
        return i[t].map(
          (s, a) => r?.shared.getVariable(s, [this.uuid, t, K9[a]]) ?? s
        );
      }
      updateTransformState(t, i) {
        let r = !1;
        return (
          t.position &&
            (this.position.fromArray(this.getTransformValues("position", t, i)),
            (r = !0)),
          t.rotation &&
            (n0
              .fromArray(this.getTransformValues("rotation", t, i))
              .multiplyScalar(dt.DEG2RAD),
            this.rotation.setFromVector3(n0),
            (r = !0)),
          t.scale &&
            (this.scale.fromArray(this.getTransformValues("scale", t, i)),
            (r = !0)),
          t.hiddenMatrix !== void 0 &&
            ((r = !0),
            this.hiddenMatrix.fromArray(t.hiddenMatrix ?? Xc.identity)),
          r &&
            (this.updateMatrix(),
            this.resetBBoxNeedsUpdate(),
            this.invalidateClonerTransform(this),
            this.traverseEntityAncestors((s) => {
              s.invalidateClonerTransform(this);
            })),
          t.position &&
            t.rotation &&
            t.scale &&
            t.hiddenMatrix !== void 0 &&
            this.updateWorldMatrix(!1, !0),
          r
        );
      }
      onVariableUpdate(t = !1) {
        if (t) {
          this.resetBBoxNeedsUpdate();
          return;
        }
        this.updateMatrix(),
          this.resetBBoxNeedsUpdate(),
          this.invalidateClonerTransform(this),
          this.traverseEntityAncestors((i) => {
            i.invalidateClonerTransform(this);
          });
      }
      dispose() {
        (this.disposed = !0),
          this.cloner &&
            (this.cloner.removeFromParent(), (this.cloner = void 0));
      }
      disposeChildrenRecursively() {
        for (let t of this.children) si.is(t) && t.disposeRecursively();
      }
      disposeRecursively() {
        this.dispose(),
          this.children.forEach((t) => {
            si.is(t) && t.disposeRecursively();
          });
      }
      toState(t = []) {
        let i = {
          name: this.name,
          visible: this.visible,
          raycastLock: this.raycastLock,
          ...this.toObjectTransformState(t),
        };
        return Oy(i, t);
      }
      updateByObjUpdateOp(t, i) {
        t !== void 0 &&
          this.updateByOp(
            { type: 0, props: t, path: [] },
            { ...this.data, ...t },
            i,
            !1
          );
      }
      updateByOp(t, i, r, s) {
        let a = this.data;
        this.data = i;
        let n = t,
          o = Ii(t.path, ["states", "*"]);
        if (o !== null) {
          if (t.type === 0) {
            let [l] = o;
            if (this?.stateSelection === l) {
              let h = { ...t.props };
              if (
                (delete h.name,
                Object.values(t.props).some((u) => u === void 0))
              ) {
                let u = this.data;
                if (u !== void 0) {
                  let c = ss.zoom(u, t.path.slice(2));
                  if (c)
                    for (let d in t.props)
                      t.props[d] === void 0 && d in c && (h[d] = c[d]);
                }
              }
              n = { ...t, props: h, path: t.path.slice(2) };
            }
          }
        } else if (t.type === 0) {
          let l = this.stateSelection
            ? this.data.states.data(this.stateSelection)
            : void 0;
          if (l !== void 0) {
            if (t.props.name !== void 0 && l.name) {
              let { name: u, ...c } = l;
              l = c;
            }
            if (t.props.material !== void 0 && "material" in l) {
              let { material: u, ...c } = l;
              l = c;
            }
            let h = ss.removeOverridden(t.path, t.props, l);
            n = { ...t, props: h };
          }
        }
        if (
          (this.updateByPatchedOpBase(
            n,
            Wl.patch(
              this.data,
              this.stateSelection
                ? this.data.states.data(this.stateSelection)
                : void 0
            ),
            r
          ),
          Ii(t.path, ["overrides"]))
        ) {
          let l = [],
            h = [...t.path];
          for (
            l.push(h[1]), h.splice(0, 2);
            h.length > 0 && h[0] === "descendants";

          )
            l.push(h[1]), h.splice(0, 2);
          if (l[l.length - 1] === void 0) {
            if (t.type === 0)
              for (let u of Object.keys(t.props)) {
                l[l.length - 1] = u;
                let c = r.scene.findInstance([this.uuid, ...l]);
                c &&
                  ((c.overrideData = t.props[u]),
                  c.updateState(hl.apply(c.component.data, c.overrideData), r));
              }
          } else {
            let u = r.scene.findInstance([this.uuid, ...l]);
            if (u) {
              let c = ss.zoom(u.component.data, h);
              if (((t = { ...t, path: h }), t.type === 0)) {
                let d = t.props;
                if (c)
                  for (let [p, f] of Object.entries(t.props))
                    f === void 0 &&
                      (d === t.props && (d = { ...t.props }), (d[p] = c[p]));
                t = { ...t, props: d };
              }
              (u.overrideData = Zm.resolve(i.overrides, l)),
                u.updateByOp(t, qr.applySimple(u.data, t), r, !1);
            }
          }
        } else if (this.instances.length > 0) {
          let l;
          if (t.path.length === 0 && t.type === 0) {
            let h;
            for (let u of rl.rootOverrideProps)
              u in t.props && (h === void 0 && (h = {}), (h[u] = t.props[u]));
            h && (l = { ...t, props: h });
          } else
            for (let h of rl.rootOverrideProps)
              if (Ii(t.path, [h])) {
                l = t;
                break;
              }
          l !== void 0 &&
            this.instances.forEach((h) => {
              if (h.isInstanceRoot) {
                let u = hl.filterOp(h.overrideData, l);
                u && h.updateByOp(u, qr.applySimple(h.data, u), r, !0);
              }
            }),
            this.instances.forEach((h) => {
              if (!h.isInstanceRoot) {
                let u = hl.filterOp(h.overrideData, t);
                if (u) {
                  let c;
                  a === h.data && t === u
                    ? (c = i)
                    : (c = qr.applySimple(h.data, u)),
                    h.updateByOp(u, c, r, !0);
                }
              }
            });
        }
      }
      updateByPatchedOpBase(t, i, r) {
        if (((this.dataPatched = i), t.path.length === 0 && t.type === 0))
          t.props.type !== void 0 &&
            !uh.is(t.props.type) &&
            al.changeEntityProptotype(this, i, r);
        else if (
          t.path.length === 1 &&
          t.path[0] === "geometry" &&
          t.type === 0 &&
          "type" in t.props
        ) {
          al.changeEntityProptotype(this, i, r);
          for (let s of this.children) si.is(s) && s.updateVisible(r.scene);
        }
        this.updateByPatchedOp(t, i, r);
      }
      updateByPatchedOp(t, i, r) {
        if (
          (t.path.length === 0 && t.type === 0 && this.updateState(t.props, r),
          Ii(t.path, ["pathSnapping"]) !== null &&
            this.updatePathSnapping(i.pathSnapping),
          Ii(t.path, ["cloner"]) !== null)
        ) {
          let s = qr.drop(t, 1);
          s.path.length === 0 && s.type === 0 && s.props.disabled === !0
            ? this.setFromClonerState(null, r)
            : this.cloner
            ? this.cloner.updateState(i.cloner, r.scene)
            : (this.setFromClonerState(i.cloner, r),
              this.expandCloner(r.scene)),
            this.updateVisible(r.scene);
        }
      }
      updatePathSnapping(t = this.dataPatched.pathSnapping) {
        (this._updatedPathSnapping = t), (this._needApplyPathSnapping = !0);
      }
      get updatedPathSnapping() {
        return this._updatedPathSnapping;
      }
      applyPathSnapping(t) {
        let i =
            this._updatedPathSnapping?.pathId ??
            this.dataPatched.pathSnapping.pathId,
          r =
            this._updatedPathSnapping?.slide ??
            this.dataPatched.pathSnapping.slide ??
            0,
          s =
            this._updatedPathSnapping?.offset ??
            this.dataPatched.pathSnapping.offset ??
            0,
          a =
            this._updatedPathSnapping?.orientation ??
            this.dataPatched.pathSnapping.orientation;
        if (i === null) return;
        let n = t.find(i);
        if (!n || this._needApplyPathSnapping === !1) return;
        this._needApplyPathSnapping = !1;
        let o = n.data;
        if (o.geometry.path.points.length <= 1) return;
        let l = a3(o.geometry.path),
          h = (r + s) % 1;
        r + s === 1 && h === 0 && (h = 1);
        let u = l.getPointAt(h);
        if (u === null) return;
        let c = this.parent ? this.parent?.matrixWorld : new je();
        n.updateMatrixWorld();
        let d = new je().multiplyMatrices(c.clone().invert(), n.matrixWorld);
        u.applyMatrix4(d);
        let p = { position: u.toArray(), rotation: o.rotation };
        if (a === "tangential") {
          let f = new je().extractRotation(n.matrixWorld),
            m = l.getTangentAt(h).applyMatrix4(f).add(u),
            g = new je().lookAt(u, m, J9),
            y = n0
              .setFromEuler(new Ir().setFromRotationMatrix(g))
              .multiplyScalar(dt.RAD2DEG);
          p = { ...p, rotation: y.toArray() };
        }
        this.updateTransformState(p),
          this.traverseEntity((f) => {
            f._cameraType && f.dispatchEvent(Z9);
          });
      }
      updateVisible(t) {
        if (
          ((this.visible =
            this.dataPatched.visible &&
            (!this.dataPatched.cloner ||
              (this.dataPatched.cloner.disabled ?? !1) ||
              this.dataPatched.cloner?.hideBase !== !0)),
          !t)
        )
          return;
        let i = !1;
        this.traverseEntity((r) => {
          if (r.data.type === "Splat") return (i = !0), !0;
        }),
          i && t.reloadSplats();
      }
      updateState_Entity(t, i) {
        t.name !== void 0 && (this.name = t.name),
          t.raycastLock !== void 0 && (this.raycastLock = t.raycastLock),
          t.visible !== void 0 &&
            (this.updateVisible(i?.scene), this.resetBBoxNeedsUpdate()),
          i &&
            "cloner" in t &&
            t.cloner !== void 0 &&
            (this.setFromClonerState(t.cloner, i), this.updateVisible(i.scene)),
          this.updateTransformState(t, i);
      }
      get attachedSurfaceCloners() {
        return this.children.filter(
          (t) => t instanceof al.Cloner && t.parameters.type === "toObject"
        );
      }
      setFromClonerState(t, i) {
        this.disposed ||
          (t === null || t.disabled
            ? (this.cloner && this.cloner.removeFromParent(),
              (this.cloner = void 0))
            : this.cloner === void 0
            ? ((this.cloner = new al.Cloner(this, t)),
              i.scene.addPendingExpandCloner(this))
            : this.cloner.updateState(t, i.scene));
      }
      expandCloner(t) {
        !this.disposed && this.cloner && this.cloner.expandClones(t);
      }
      invalidateClonerTransform(t) {
        this.cloner && this.cloner.invalidateTransform(t);
      }
      requestRender() {
        this.dispatchEvent({ type: "requestRender" });
      }
    },
  n3 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          radialSegments: 64,
          heightSegments: 1,
          openEnded: !1,
          thetaStart: 0,
          thetaLength: 360,
          cornerRadius: 8,
          cornerSegments: 8,
          hollow: 0,
        },
        e.parameters
      );
      i.thetaLength = dt.clamp(i.thetaLength, 0, 360);
      let r = i.width / 2,
        s = i.radiusTop ?? r,
        a = i.radiusBottom ?? r;
      return (
        s === a
          ? ((s = r), (a = r))
          : s > a
          ? ((s = r), (a = (a * r) / s))
          : ((s = (s * r) / a), (a = r)),
        {
          parameters: Object.assign(i, {
            width: Math.abs(i.width),
            height: Math.abs(i.height ?? i.width),
            depth: Math.abs(i.depth ?? i.width),
            radiusTop: s,
            radiusBottom: a,
          }),
        }
      );
    }
    static build(e) {
      let {
          width: t,
          depth: i,
          height: r,
          radialSegments: s,
          heightSegments: a,
          openEnded: n,
          thetaStart: o,
          thetaLength: l,
          radiusTop: h,
          radiusBottom: u,
          cornerRadius: c,
          cornerSegments: d,
          hollow: p,
        } = e.parameters,
        f;
      return (
        l === 0
          ? ((f = new yt()), f.setAttribute("position", new ot([], 3)))
          : c || p
          ? (f = new o3(h, u, r, s, a, n, o, (l * Math.PI) / 180, c, c, d, p))
          : (f = new Mx(h, u, r, s, a, n, o, (l * Math.PI) / 180)),
        f.scale(1, 1, i / t),
        Object.assign(f, { userData: { ...e, type: "CylinderGeometry" } })
      );
    }
  };
function No(e, t, i) {
  (i.x = e.x * t.x), (i.y = e.y), (i.z = e.x * t.y);
}
function lA(e) {
  return new re(e.y, -e.x);
}
var o3 = class extends yt {
    constructor(e, t, i, r, s, a, n, o, l, h, u, c, d = !1) {
      super(),
        (this.type = "RoundedCylinderBufferGeometry"),
        (e = e !== void 0 ? e : 1),
        (t = t !== void 0 ? t : 1),
        (i = i || 1),
        (r = Math.floor(r) || 8),
        (s = Math.floor(s) || 1),
        (a = a !== void 0 ? a : !1),
        (n = n !== void 0 ? n : 0),
        (o = o !== void 0 ? o : Math.PI * 2),
        a && ((l = 0), (h = 0));
      let p = [],
        f = [],
        m = [],
        g = [],
        y = 0,
        x = i / 2,
        b = new I(),
        _ = new I();
      d && e == 0 && (e = l), d && t == 0 && (t = h);
      let S = new re(e, x),
        M = new re(t, -x),
        C = null,
        A = null,
        T = null,
        P = null,
        R = S.clone().sub(M),
        z = 0,
        N = 0,
        L = 0;
      c > 0 && ((z = Math.min(e, t) * (1 - c)), (N = e - z), (L = t - z));
      let G = S.clone();
      G.x -= z;
      let Y = Math.PI - R.angle(),
        Z = R.angle(),
        q = Math.tan(Z / 2),
        oe = Math.tan(Y / 2),
        ce = q + oe,
        ie = c ? ce : oe,
        te = c ? ce : q;
      if (
        ((l = Math.min(l, (e - N) / ie, R.length() / ce)),
        (h = Math.min(h, (t - L) / te, R.length() / ce)),
        l > 0)
      ) {
        let me = l / q;
        (C = S.clone().sub(new re(me, l))),
          c && ((T = C.clone()), (T.x -= z - ce * l)),
          S.sub(R.clone().setLength(me));
      }
      if (h > 0) {
        let me = h / oe;
        (A = M.clone().sub(new re(me, -h))),
          M.add(R.clone().setLength(me)),
          c &&
            ((P = A.clone()),
            (P.x -= z - ce * h),
            G.sub(R.clone().setLength(me)));
      }
      R = S.clone().sub(M);
      let ue = R.length() < 0.5,
        ae = [];
      for (let me = 0; me <= r; me++) {
        let Ae = [],
          ye = me / r,
          Ue = ye * o + n,
          Le = new re(Math.sin(Ue), Math.cos(Ue));
        P && A
          ? (de(Ae, ye, Le, Y, h, P, -1, !0), de(Ae, ye, Le, Z, h, A, -1, !1))
          : A
          ? (ne(Ae, Le, A.x, 0, -1), de(Ae, ye, Le, Z, h, A, -1, !1))
          : a || ne(Ae, Le, t, L, -1);
        let Te = lA(R).normalize();
        if ((No(Te, Le, b), !ue))
          for (let tt = 0; tt <= s; tt++) {
            let Je = tt / s,
              rt = R.clone().multiplyScalar(Je).add(M);
            No(rt, Le, _),
              f.push(_.x, _.y, _.z),
              m.push(b.x, b.y, b.z),
              g.push(ye, 0.5 + _.y / i),
              Ae.push(y++);
          }
        if (
          (T && C
            ? (de(Ae, ye, Le, Y, l, C, 1, !1), de(Ae, ye, Le, Z, l, T, 1, !0))
            : C
            ? (de(Ae, ye, Le, Y, l, C, 1, !1), ne(Ae, Le, C.x, 0, 1))
            : a || ne(Ae, Le, e, N, 1),
          c && !ue)
        ) {
          let tt = lA(R).multiplyScalar(-1).normalize();
          No(tt, Le, b);
          for (let Je = 0; Je <= s; Je++) {
            let rt = Je / s,
              st = R.clone().multiplyScalar(-rt).add(G);
            No(st, Le, _),
              f.push(_.x, _.y, _.z),
              m.push(b.x, b.y, b.z),
              g.push(ye, 0.5 + _.y / i),
              Ae.push(y++);
          }
        }
        c && !a && Ae.push(Ae[0]), ae.push(Ae);
      }
      for (let me = 0; me < ae.length - 1; me++)
        for (let Ae = 0; Ae < ae[0].length - 1; Ae++) {
          if (a && c && Ae == s) continue;
          let ye = ae[me][Ae],
            Ue = ae[me + 1][Ae],
            Le = ae[me + 1][Ae + 1],
            Te = ae[me][Ae + 1],
            tt = f[Le * 3 + 0],
            Je = f[Le * 3 + 2];
          p.push(ye, Ue, Te), (tt != 0 || Je != 0) && p.push(Ue, Le, Te);
        }
      o < Math.PI * 2 && (Ee(-1, ae[0], n), Ee(1, ae[ae.length - 1], n + o)),
        this.setIndex(p),
        this.setAttribute("position", new ot(f, 3)),
        this.setAttribute("normal", new ot(m, 3)),
        this.setAttribute("uv", new ot(g, 2));
      function de(me, Ae, ye, Ue, Le, Te, tt, Je) {
        for (let rt = 0; rt < u + 1; rt++) {
          let st = rt / u,
            Ze = tt < 0 ? st : 1 - st;
          Je && (Ze -= 1), (Ze *= Ue);
          let Qe = new re(Math.sin(Ze), Math.cos(Ze) * tt),
            pt = Qe.clone().multiplyScalar(Le).add(Te);
          No(pt, ye, _),
            f.push(_.x, _.y, _.z),
            No(Qe, ye, b),
            m.push(b.x, b.y, b.z),
            g.push(Ae, 0.5 + _.y / i),
            me.push(y++);
        }
      }
      function ne(me, Ae, ye, Ue, Le) {
        let Te = new I(),
          tt = new re(),
          Je = [ye, Ue];
        Le < 0 && Je.reverse();
        for (let rt of Je)
          tt.set(rt, x * Le),
            No(tt, Ae, Te),
            f.push(Te.x, Te.y, Te.z),
            m.push(0, Le, 0),
            g.push(0.5, 0.5),
            me.push(y++);
      }
      function Ee(me, Ae, ye) {
        let Ue = new re(Math.sin(ye), Math.cos(ye)),
          Le = new re(-Math.cos(ye), Math.sin(ye)),
          Te = new I(),
          tt =
            me < 0
              ? (st, Ze, Qe) => p.push(st, Ze, Qe)
              : (st, Ze, Qe) => p.push(st, Qe, Ze),
          Je = new re((e + t + N + L) / 4, 0);
        No(Je, Ue, Te),
          f.push(Te.x, Te.y, Te.z),
          m.push(Le.x, 0, Le.y),
          g.push(0.5, 0.5);
        let rt = y++;
        for (let st of Ae) {
          let Ze = f.slice(st * 3, st * 3 + 3);
          f.push(...Ze), m.push(Le.x, 0, Le.y);
          let Qe = g.slice(st * 2, st * 2 + 2);
          g.push(...Qe), y++;
        }
        for (let st = rt + 1; st < y - 1; st++) tt(rt, st, st + 1);
        tt(rt, y - 1, rt + 1);
      }
    }
  },
  $9 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          radialSegments: 32,
          heightSegments: 8,
          openEnded: !1,
          thetaStart: 0,
          thetaLength: 360,
          cornerRadiusTop: 8,
          cornerRadiusBottom: 8,
          cornerSegments: 8,
        },
        e.parameters
      );
      return (
        (i.thetaLength = dt.clamp(i.thetaLength, 0, 360)),
        {
          parameters: Object.assign(i, {
            width: Math.abs(i.width),
            height: Math.abs(i.height ?? i.width),
            depth: Math.abs(i.depth ?? i.width),
          }),
        }
      );
    }
    static build(e) {
      let {
          width: t,
          depth: i,
          height: r,
          radialSegments: s,
          heightSegments: a,
          openEnded: n,
          thetaStart: o,
          thetaLength: l,
          cornerRadiusTop: h,
          cornerRadiusBottom: u,
          cornerSegments: c,
        } = e.parameters,
        d;
      return (
        l === 0
          ? ((d = new yt()), d.setAttribute("position", new ot([], 3)))
          : h > 0 || u > 0 || l < 360
          ? (d = new o3(
              0,
              t / 2,
              r,
              s,
              a,
              n,
              o,
              (l * Math.PI) / 180,
              h,
              u,
              c,
              0,
              !0
            ))
          : (d = new Ex(t / 2, r, s, a, n)),
        d.scale(1, 1, i / t),
        Object.assign(d, { userData: { ...e, type: "ConeGeometry" } })
      );
    }
  },
  eW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          widthSegments: 1,
          heightSegments: 1,
          depthSegments: 1,
          cornerRadius: 8,
          cornerSegments: 8,
        },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          widthSegments: s,
          heightSegments: a,
          depthSegments: n,
          cornerRadius: o,
          cornerSegments: l,
        } = e.parameters,
        h;
      return (
        o == 0
          ? (h = new Za(t, i, r, s, a, n))
          : (h = new tW(t, i, r, s, a, n, o, l)),
        Object.assign(h, { userData: { ...e, type: "CubeGeometry" } })
      );
    }
  },
  o0 = Math.PI / 2,
  tW = class extends yt {
    constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1, n = 0, o = 4) {
      super(), (this.type = "BoxGeometry");
      let l = this;
      (r = Math.floor(r)),
        (s = Math.floor(s)),
        (a = Math.floor(a)),
        (o = Math.floor(o)),
        (n = Math.min(n, e / 2, t / 2, i / 2));
      let h = [],
        u = [],
        c = [],
        d = [],
        p = 0,
        f = 0;
      m("z", "y", "x", -1, -1, i, t, e, a, s, 0),
        m("z", "y", "x", 1, -1, i, t, -e, a, s, 1),
        m("x", "z", "y", 1, 1, e, i, t, r, a, 2),
        m("x", "z", "y", 1, -1, e, i, -t, r, a, 3),
        m("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        m("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        n > 0 &&
          (g("z", "y", "x", -1, -1, 1, i, t, e, a, 0),
          g("z", "y", "x", 1, -1, -1, i, t, e, a, 1),
          g("z", "y", "x", -1, 1, -1, i, t, e, a, 1),
          g("z", "y", "x", 1, 1, 1, i, t, e, a, 0),
          g("x", "y", "z", -1, -1, -1, e, t, i, r, 0),
          g("x", "y", "z", 1, -1, 1, e, t, i, r, 1),
          g("x", "y", "z", -1, 1, 1, e, t, i, r, 0),
          g("x", "y", "z", 1, 1, -1, e, t, i, r, 1),
          g("y", "x", "z", -1, -1, 1, t, e, i, s, 0),
          g("y", "x", "z", 1, -1, -1, t, e, i, s, 1),
          g("y", "x", "z", 1, 1, 1, t, e, i, s, 1),
          g("y", "x", "z", -1, 1, -1, t, e, i, s, 0),
          y(1, 1, 1),
          y(-1, 1, 1),
          y(1, -1, 1),
          y(-1, -1, 1),
          y(1, 1, -1),
          y(-1, 1, -1),
          y(1, -1, -1),
          y(-1, -1, -1)),
        this.setIndex(h),
        this.setAttribute("position", new ot(u, 3)),
        this.setAttribute("normal", new ot(c, 3)),
        this.setAttribute("uv", new ot(d, 2));
      function m(x, b, _, S, M, C, A, T, P, R, z) {
        let N = (C - 2 * n) / P,
          L = (A - 2 * n) / R,
          G = C / 2 - n,
          Y = A / 2 - n,
          Z = T / 2,
          q = P + 1,
          oe = R + 1,
          ce = 0,
          ie = 0,
          te = new I();
        for (let ue = 0; ue < oe; ue++) {
          let ae = ue * L - Y;
          for (let de = 0; de < q; de++) {
            let ne = de * N - G;
            (te[x] = ne * S),
              (te[b] = ae * M),
              (te[_] = Z),
              u.push(te.x, te.y, te.z),
              (te[x] = 0),
              (te[b] = 0),
              (te[_] = T > 0 ? 1 : -1),
              c.push(te.x, te.y, te.z),
              d.push(de / P),
              d.push(1 - ue / R),
              (ce += 1);
          }
        }
        for (let ue = 0; ue < R; ue++)
          for (let ae = 0; ae < P; ae++) {
            let de = p + ae + q * ue,
              ne = p + ae + q * (ue + 1),
              Ee = p + (ae + 1) + q * (ue + 1),
              me = p + (ae + 1) + q * ue;
            h.push(de, ne, me), h.push(ne, Ee, me), (ie += 6);
          }
        l.addGroup(f, ie, z), (f += ie), (p += ce);
      }
      function g(x, b, _, S, M, C, A, T, P, R, z) {
        let N = (A - 2 * n) / R,
          L = A / 2 - n,
          G = T / 2 - n,
          Y = P / 2,
          Z = R + 1,
          q = 0,
          oe = 0,
          ce = new I(),
          ie = new I();
        for (let te = 0; te < o + 1; te++) {
          let ue = (te / o) * o0,
            ae = Math.sin(ue) * n,
            de = (1 - Math.cos(ue)) * n,
            ne = Math.sin(ue),
            Ee = Math.cos(ue);
          (ce[b] = (G + ae) * M),
            (ce[_] = (Y - de) * C),
            (ie[x] = 0),
            (ie[b] = ne * Math.sign(ce[b])),
            (ie[_] = Ee * Math.sign(ce[_]));
          for (let me = 0; me < Z; me++) {
            let Ae = me * N - L;
            (ce[x] = Ae * S),
              u.push(ce.x, ce.y, ce.z),
              c.push(ie.x, ie.y, ie.z),
              d.push(me / R),
              d.push(0),
              (q += 1);
          }
        }
        for (let te = 0; te < o; te++)
          for (let ue = 0; ue < R; ue++) {
            let ae = p + ue + Z * te,
              de = p + ue + Z * (te + 1),
              ne = p + (ue + 1) + Z * (te + 1),
              Ee = p + (ue + 1) + Z * te;
            h.push(ae, de, Ee), h.push(de, ne, Ee), (oe += 6);
          }
        l.addGroup(f, oe, z), (f += oe), (p += q);
      }
      function y(x, b, _) {
        let S = new I(),
          M = new I(e / 2, t / 2, i / 2);
        M.subScalar(n);
        let C = [],
          A =
            x * b * _ > 0
              ? (P, R, z) => h.push(P, R, z)
              : (P, R, z) => h.push(P, z, R);
        for (let P = 0; P <= o; P++) {
          let R = [],
            z = o0 * (1 - P / o),
            N = Math.cos(z),
            L = Math.sin(z),
            G = 0;
          for (let Y = 0; Y <= P; Y++) {
            let Z = Math.cos(G),
              q = Math.sin(G);
            (S.x = N * Z), (S.y = L), (S.z = N * q);
            let oe = M.clone().addScaledVector(S, n);
            u.push(x * oe.x, b * oe.y, _ * oe.z),
              c.push(x * S.x, b * S.y, _ * S.z),
              d.push(0, 0),
              R.push(p++),
              (G += o0 / P);
          }
          C.push(R);
        }
        let T = C.length - 1;
        for (let P = 0; P < T; P++) {
          let R = C[P],
            z = C[P + 1],
            N = R.length - 1;
          A(R[0], z[1], z[0]);
          for (let L = 1; L <= N; L++)
            A(R[L - 1], R[L], z[L]), A(R[L], z[L + 1], z[L]);
        }
      }
    }
  },
  lb = class extends yt {
    constructor(e = [], t = [], i = "", r = 1, s = 0.2, a = 4) {
      super(), (this.type = "PolyhedronGeometryRound");
      let n = [],
        o = [],
        l = [];
      h(),
        u(),
        this.setAttribute("position", new ot(n, 3)),
        this.setAttribute("normal", new ot(l, 3)),
        this.setAttribute("uv", new ot(o, 2));
      return;
      function h() {
        (s = Math.min(1 - 1e-5, s)), s == 0 && (a = 0);
        let c = {
            IcosahedronGeometry: 5,
            DodecahedronGeometry: 3,
            HexahedronGeometry: 3,
            OctahedronGeometry: 4,
            TetrahedronGeometry: 3,
          }[i],
          d = new I(),
          p = d.clone(),
          f = new rs(),
          m = s * r,
          g = r - m,
          y = a + 1,
          x = new I(),
          b = (Z, q) => x.subVectors(Z, q).normalize(),
          _ = (Z, q) =>
            Array(Z)
              .fill(void 0)
              .map(q),
          S = _(e.length / 3, (Z, q) =>
            new I().fromArray(e, q * 3).setLength(r)
          ),
          M = [],
          C = 1e6;
        for (let Z = 0; Z < S.length; Z++) {
          let q = S[Z],
            oe = [],
            ce,
            ie,
            te,
            ue = 1e10,
            ae = -1;
          for (; (ae = t.indexOf(Z, ae + 1)) != -1; ) {
            let me = ae - (ae % 3);
            (ce = t[me + ((ae + 1) % 3)]),
              (ie = t[me + ((ae + 2) % 3)]),
              (te = q.distanceToSquared(S[ce])),
              (ue = Math.min(ue, te)),
              oe.push([ce, ie, te]);
          }
          ue += 1e-6;
          let de = [],
            ne = 0,
            Ee = oe.length;
          for (let me = 0; me < Ee; me++) {
            [ce, ie, te] = oe[ne];
            let Ae = M[ce]?.includes(Z) == !0;
            te <= ue && de.push(ce + +Ae * C),
              (ne = oe.findIndex((ye) => ye[0] == ie));
          }
          M.push(de);
        }
        let A = [];
        {
          let Z = 0,
            q = 0,
            oe,
            ce,
            ie = c == 3;
          for (let te = 0; te <= a; te++) {
            (oe = (te * (te + 1)) / 2), (ce = ((te + 1) * (te + 2)) / 2);
            for (let ue = 0; ue < a - te; ue++)
              ([Z, q] = [oe + ue + te + 2, ce + ue + te + 3]),
                A.push(oe, ce, ...(ie ? [q, oe] : [Z, ce]), q, Z),
                ([oe, ce] = [Z, q]);
            A.push(oe, ce, oe + a + 2);
          }
        }
        let T = d.clone(),
          P = d.clone(),
          R = d.clone(),
          z = d.clone(),
          N = d.clone(),
          L = [],
          G = _(S.length, () => _(c, () => d.clone()));
        for (let Z = 0; Z < S.length; Z++) {
          d.copy(S[Z]).normalize(), T.copy(d).multiplyScalar(g);
          let q = M[Z];
          for (let de = 0; de < q.length; de++) {
            let ne = q[de],
              Ee = q[(de + 1) % c];
            f.setFromPointsAndIndices(S, Z, ne % C, Ee % C),
              f.b.sub(f.a).setLength(1e10).add(f.a),
              f.c.sub(f.a).setLength(1e10).add(f.a),
              f.closestPointToPoint(T, G[Z][de]);
          }
          let oe = [],
            ce = [],
            ie = [],
            te = new I();
          a == 0 &&
            [...G[Z]].reduce((de, ne) => de.add(ne), te).multiplyScalar(1 / c);
          for (let de = 0; de < c; de++) {
            let ne = [],
              Ee = (de - 1 + c) % c,
              me = G[Z][Ee],
              Ae = G[Z][de];
            d.copy(me).sub(T), p.copy(Ae).sub(T);
            let ye = T.angleTo(d),
              Ue = d.angleTo(p),
              Le = Math.cos(ye) * m;
            a == 0 ? P.copy(te) : P.copy(T).setLength(g + Le), ce.push(Le);
            let Te = [P, me, Ae];
            for (let tt = 0; tt < 2; tt++) {
              let Je = Te[tt],
                rt = Te[tt + 1];
              z.subVectors(Je, T),
                N.subVectors(rt, T),
                R.crossVectors(z, N).normalize();
              for (let st = 0; st < y; st++) {
                let Ze = ([ye, Ue][tt] * st) / y;
                d.copy(z).applyAxisAngle(R, Ze).add(T),
                  oe.push(d.clone()),
                  tt &&
                    (b(d, T), ne.push([st == 0 ? Je : d.clone(), x.clone()]));
              }
              tt && (b(rt, T), ne.push([rt, x.clone()]));
            }
            ie.push(ne);
          }
          L.push(ie);
          let ue = 2 * y,
            ae = 2;
          for (let de = 0; de < c; de++) {
            let ne = ue * de,
              Ee = ue * ((de + 1) % c),
              me = [oe[ne]];
            for (let ye = 1; ye < y; ye++) {
              (z = oe[ne + ye]), (N = oe[Ee + ye]), me.push(z);
              for (let Ue = 1, Le = ye - ae + 1; Ue <= Le; Ue++)
                d.lerpVectors(z, N, Ue / (Le + 1)),
                  d.sub(T).setLength(ce[de]).add(T),
                  me.push(d.clone());
              me.push(N);
            }
            for (let ye = 0; ye < y; ye++) me.push(oe[ye + y + ne]);
            me.push(oe[Ee + y]);
            let Ae = A.map((ye) => me[ye]);
            n.push(...Ae.map((ye) => [ye.x, ye.y, ye.z]).flat()),
              l.push(...Ae.map((ye) => (b(ye, T), [x.x, x.y, x.z])).flat());
          }
        }
        let Y = [];
        for (let Z = 0; Z < M.length; Z++)
          for (let q = 0; q < c; q++) {
            let oe = M[Z][q];
            if (oe < C) {
              let ce = M[oe].findIndex((ue) => ue % C == Z),
                ie = L[Z][q],
                te = L[oe][ce];
              for (let ue = 0; ue < y; ue++) {
                let ae = ie[ue],
                  de = te[y - ue],
                  ne = ie[ue + 1],
                  Ee = te[y - (ue + 1)];
                [ae, de, ne, ne, de, Ee].forEach((me) => {
                  n.push(me[0].x, me[0].y, me[0].z),
                    l.push(me[1].x, me[1].y, me[1].z);
                });
              }
              Y.push(ie[0][0], te[y][0], ie[y][0], te[0][0]);
            }
          }
        for (; Y.length; ) {
          let Z, q, oe, ce;
          [Z, q] = Y.splice(0, 2);
          let ie = [Z];
          for (; Z != q; )
            ie.push(q),
              (oe = Y.indexOf(q)),
              (ce = oe % 2),
              (q = Y.splice(oe - ce, 2)[1 - ce]);
          x.subVectors(ie[0], ie[1])
            .cross(d.subVectors(ie[0], ie[2]))
            .normalize();
          let te = x.dot(ie[0]) < 0;
          te && x.negate();
          for (let ue = 1; ue <= ie.length - 2; ue++)
            [ie[ue + +te], ie[ue + 1 - +te], ie[0]].forEach((ae) => {
              n.push(ae.x, ae.y, ae.z), l.push(x.x, x.y, x.z);
            });
        }
      }
      function u() {
        let c = new I();
        for (let M = 0; M < n.length; M += 3) {
          (c.x = n[M + 0]), (c.y = n[M + 1]), (c.z = n[M + 2]);
          let C = _(c) / 2 / Math.PI + 0.5,
            A = S(c) / Math.PI + 0.5;
          o.push(C, 1 - A);
        }
        let d = new I(),
          p = new I(),
          f = new I(),
          m = new I(),
          g = new re(),
          y = new re(),
          x = new re(),
          b = (M, C, A, T) => {
            T < 0 && M.x === 1 && (o[C] = M.x - 1),
              A.x === 0 && A.z === 0 && (o[C] = T / 2 / Math.PI + 0.5);
          };
        for (let M = 0, C = 0; M < n.length; M += 9, C += 6) {
          d.set(n[M + 0], n[M + 1], n[M + 2]),
            p.set(n[M + 3], n[M + 4], n[M + 5]),
            f.set(n[M + 6], n[M + 7], n[M + 8]),
            g.set(o[C + 0], o[C + 1]),
            y.set(o[C + 2], o[C + 3]),
            x.set(o[C + 4], o[C + 5]),
            m.copy(d).add(p).add(f).divideScalar(3);
          let A = _(m);
          b(g, C + 0, d, A), b(y, C + 2, p, A), b(x, C + 4, f, A);
        }
        for (let M = 0; M < o.length; M += 6) {
          let C = o[M + 0],
            A = o[M + 2],
            T = o[M + 4],
            P = Math.max(C, A, T),
            R = Math.min(C, A, T);
          P > 0.9 &&
            R < 0.1 &&
            (C < 0.2 && (o[M + 0] += 1),
            A < 0.2 && (o[M + 2] += 1),
            T < 0.2 && (o[M + 4] += 1));
        }
        function _(M) {
          return Math.atan2(M.z, -M.x);
        }
        function S(M) {
          return Math.atan2(-M.y, Math.sqrt(M.x * M.x + M.z * M.z));
        }
      }
    }
    static fromJSON(e) {
      return new lb(e.vertices, e.indices, e.radius, e.corner, e.cornerSides);
    }
  },
  iW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          detail: s,
          corner: a,
          cornerSides: n,
        } = e.parameters,
        o = s === 0 && a !== 0 ? new l3(t * 0.5, a, n) : new fC(t * 0.5, s);
      return (
        o.scale(1, i / t, r / t),
        Object.assign(o, { userData: { ...e, type: "DodecahedronGeometry" } })
      );
    }
  },
  l3 = class extends lb {
    constructor(e = 1, t = 0.2, i = 4) {
      let r = (1 + Math.sqrt(5)) / 2,
        s = 1 / r,
        a = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -s,
          -r,
          0,
          -s,
          r,
          0,
          s,
          -r,
          0,
          s,
          r,
          -s,
          -r,
          0,
          -s,
          r,
          0,
          s,
          -r,
          0,
          s,
          r,
          0,
          -r,
          0,
          -s,
          r,
          0,
          -s,
          -r,
          0,
          s,
          r,
          0,
          s,
        ],
        n = [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ],
        o = "DodecahedronGeometry";
      super(a, n, o, e, t, i), (this.type = o);
    }
    static fromJSON(e) {
      return new l3(e.radius, e.corner, e.cornerSides);
    }
  },
  Zu = 1e-12,
  hb = class {
    constructor(e) {
      (this.position = new re()),
        (this.startPosition = new re()),
        (this.uuid = dt.generateUUID()),
        (this.position = e.clone());
    }
    start() {
      this.reset();
    }
    reset() {
      this.startPosition.copy(this.position);
    }
    applyOffset(e) {
      this.position.copy(this.startPosition).add(e);
    }
    copy(e) {
      return (
        this.position.copy(e.position),
        this.startPosition.copy(e.startPosition),
        this
      );
    }
    clone() {
      return new hb(this.position).copy(this);
    }
    toJSON() {
      return [this.position.x, this.position.y];
    }
  },
  A1 = class extends hb {
    constructor(e) {
      super(e.position), (this.parent = e);
    }
    copy(e) {
      return super.copy(e), this;
    }
    clone() {
      return new A1(this.parent).copy(this);
    }
  },
  Rc = class extends hb {
    constructor(e, t) {
      super(t),
        (this.controls = []),
        (this.roundness = 0),
        (this.areControlsDirectionsMirrored = !0),
        (this.uuid = e),
        this.controls.push(new A1(this), new A1(this));
    }
    static create(e, t) {
      let i = new Rc(e, new re(...t.position));
      return (
        i.controls[0].position.set(...t.controlPrevious.position),
        i.controls[1].position.set(...t.controlNext.position),
        (i.roundness = t.roundness),
        (i.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored),
        i
      );
    }
    getOppositeControl(e) {
      let t = this.controls.indexOf(e);
      return t === 0 ? this.controls[1] : t === 1 ? this.controls[0] : null;
    }
    applyOffsetToControls(e, t = 1) {
      for (let i = 0, r = this.controls.length; i < r; i++) {
        let s = this.controls[i];
        this.position.distanceTo(s.position) <= t
          ? s.position.copy(this.position)
          : s.applyOffset(e);
      }
    }
    controlsMoved() {
      return !(
        this.position.equals(this.controls[0].position) &&
        this.position.equals(this.controls[1].position)
      );
    }
    copy(e) {
      return (
        super.copy(e),
        this.controls[0].copy(e.controls[0]),
        this.controls[1].copy(e.controls[1]),
        (this.roundness = e.roundness),
        (this.uuid = e.uuid),
        this
      );
    }
    clone() {
      return new Rc(this.uuid, this.position).copy(this);
    }
    toJSON() {
      return super
        .toJSON()
        .concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [
          this.roundness,
        ]);
    }
    computeTangents() {
      let e = this.curveBefore?.getTangentAt(1),
        t = this.curveAfter?.getTangentAt(0);
      return [e, t];
    }
    computeNormals(e = new re(), t = new re()) {
      let [i, r] = this.computeTangents();
      return i && r && (hA(i, e), hA(r, t)), [e, t];
    }
    computeTangent(e = new re()) {
      let [t, i] = this.computeTangents();
      return t && i && e.copy(t).add(i).normalize(), e;
    }
    computeNormal(e = new re()) {
      let [t, i] = this.computeNormals();
      return e.copy(t).add(i).normalize(), e;
    }
  };
function hA(e, t = new re()) {
  let i = e.length();
  return t.set(-e.y / i, e.x / i);
}
var cb = (e) => e,
  vu = new re(),
  Fg = new re(),
  rW = new re(),
  sW = new re(),
  aW = new re(),
  nW = new re(),
  h3 = new I(),
  c3 = new I();
function oW(e) {
  let t = new re();
  t.addVectors(e.v0, vu.subVectors(e.v1, e.v0).multiplyScalar(2 / 3));
  let i = new re();
  return (
    i.addVectors(e.v2, Fg.subVectors(e.v1, e.v2).multiplyScalar(2 / 3)),
    new Ha(e.v0, t, i, e.v2)
  );
}
function pd(e, t, i = Number.EPSILON) {
  return Math.abs(e - t) < i;
}
function lW(e, t, i = Number.EPSILON) {
  return e.distanceTo(t) < i;
}
function hW(e, t, i = Number.EPSILON) {
  return e.distanceTo(t) < i;
}
function u3(e, t, i) {
  let r = Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)),
    s = Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2)),
    a = Math.sqrt(Math.pow(i.x - e.x, 2) + Math.pow(i.y - e.y, 2));
  return Math.acos((s * s + r * r - a * a) / (2 * s * r));
}
function cW(e, t, i) {
  return uA(e, t) && uA(t, i) && M1(e.position, t.position, i.position);
}
function M1(e, t, i) {
  return vu.copy(t).sub(e).cross(Fg.copy(i).sub(e)) === 0;
}
function uW(e, t, i, r, s) {
  let a = Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)),
    n = (e.y + t.y) / 2,
    o = (e.x + t.x) / 2,
    l = (Math.sqrt(Math.pow(i, 2) - Math.pow(a / 2, 2)) * (e.y - t.y)) / a,
    h = (Math.sqrt(Math.pow(i, 2) - Math.pow(a / 2, 2)) * (t.x - e.x)) / a;
  return r.set(o + l, n + h), s.set(o - l, n - h), [r, s];
}
function dW(e, t, i) {
  let r = e.distanceTo(i),
    s = t.distanceTo(i);
  return r < s ? t : e;
}
function pW(e, t, i, r, s, a) {
  let n = t.x - e.x,
    o = t.y - e.y,
    l = i.x - e.x,
    h = i.y - e.y,
    u = Math.sqrt((n + l) * (n + l) + (o + h) * (o + h)),
    c;
  return (
    u3(t, e, i) > Math.PI && (u *= -1),
    pd(h, o)
      ? (c = ((o + h) * (r / u - 0.5) * 8) / 3 / (n - l))
      : (c = ((n + l) * (r / u - 0.5) * 8) / 3 / (h - o)),
    s.set(t.x - c * o, t.y + c * n),
    a.set(i.x + c * h, i.y - c * l),
    [s, a]
  );
}
function cA(e, t) {
  return (
    e.position.equals(e.controls[1].position) &&
    t.position.equals(t.controls[0].position)
  );
}
function uA(e, t) {
  return (
    M1(e.position, e.controls[1].position, t.position) &&
    M1(e.position, t.controls[0].position, t.position)
  );
}
function fW(e, t, i, r, s = 0.5) {
  let a = vu.subVectors(t, e).multiplyScalar(s).add(e),
    n = Fg.subVectors(i, t).multiplyScalar(s).add(t),
    o = rW.subVectors(r, i).multiplyScalar(s).add(i),
    l = a,
    h = sW.subVectors(n, a).multiplyScalar(s).add(a),
    u = aW.subVectors(o, n).multiplyScalar(s).add(n),
    c = o,
    d = nW.subVectors(u, h).multiplyScalar(s).add(h);
  return [e.x, e.y, l.x, l.y, h.x, h.y, d.x, d.y, u.x, u.y, c.x, c.y, r.x, r.y];
}
function mW(e, t, i = 12, r = !0) {
  let s = c3.set(0, 0, 0),
    a,
    n = 0,
    o = [];
  for (let l = 0; l < t.length; l++) {
    let h = cb(t[l]),
      u = vu,
      c = sh(h, i);
    o.push(c);
    for (let d = 0; d <= c; d++)
      if (h instanceof Ha || h instanceof pl || h instanceof Ya) {
        if (
          (h.getPoint(d / c, u), s.set(u.x, u.y, 0), a !== void 0 && hW(a, s))
        )
          continue;
        a === void 0 && (a = h3), a.copy(s), e.setXYZ(n, s.x, s.y, s.z), n++;
      }
  }
  return (
    r &&
      n > 1 &&
      !(
        e.getX(n - 1) === e.getX(0) &&
        e.getY(n - 1) === e.getY(0) &&
        e.getZ(n - 1) === e.getZ(0)
      ) &&
      (e.setXYZ(n, e.getX(0), e.getY(0), e.getZ(0)), n++),
    e
  );
}
function gW(e, t, i, r = 12, s = !0) {
  let a = c3.set(0, 0, 0),
    n = 0,
    o = [];
  for (let l = 0; l < t.length; l++) {
    if (i[l] === !1) continue;
    let h,
      u = cb(t[l]),
      c = vu,
      d = sh(u, r);
    o.push(d);
    for (let p = 0; p <= d; p++)
      if (u instanceof Ha || u instanceof pl || u instanceof Ya) {
        if ((u.getPoint(p / d, c), a.set(c.x, c.y, 0), h?.equals(a))) continue;
        h === void 0
          ? (h = h3)
          : (e.setXYZ(n, h.x, h.y, h.z), n++, e.setXYZ(n, a.x, a.y, a.z), n++),
          h.copy(a);
      }
  }
  return (
    s &&
      n > 1 &&
      !(
        e.getX(n - 1) === e.getX(0) &&
        e.getY(n - 1) === e.getY(0) &&
        e.getZ(n - 1) === e.getZ(0)
      ) &&
      (e.setXYZ(n, e.getX(0), e.getY(0), e.getZ(0)), n++),
    o
  );
}
function dA(e, t = 12, i = !1) {
  let r = [];
  for (let s = 0, a = e.length; s < a; s++) {
    let n = e[s],
      o = 0;
    if (i && n.roundedCurveCorner !== void 0) {
      let l = sh(n.roundedCurveCorner, t) * 0.5;
      s > 0 && (r[s - 1] += l), (o += l);
    }
    n.curveAfter !== void 0 && (o += sh(n.curveAfter, t)), r.push(o);
  }
  return (
    e.length > 0 &&
      i &&
      e[0].roundedCurveCorner !== void 0 &&
      (r[e.length - 1] += sh(e[0].roundedCurveCorner, t) * 0.5),
    r
  );
}
function sh(e, t = 12) {
  return e && e instanceof wg
    ? t * 2
    : e && (e instanceof Ya || e instanceof uC)
    ? 1
    : e && e instanceof Ax
    ? t * e.points.length
    : t;
}
function vW(e, t, i = 12, r = !0) {
  let s,
    a = 0;
  for (let n = 0; n < t.length; n++) {
    let o = cb(t[n]),
      l = sh(o, i),
      h = vu;
    for (let u = 0; u <= l; u++)
      if (o instanceof Ha || o instanceof pl || o instanceof Ya) {
        if ((o.getPoint(u / l, h), s !== void 0 && lW(s, h, Zu))) continue;
        s === void 0 && (s = Fg), s.copy(h), e.push(h.x, h.y), a++;
      }
  }
  return (
    pd(e[0], e[e.length - 2], Zu) &&
      pd(e[1], e[e.length - 1], Zu) &&
      (e.pop(), e.pop()),
    r &&
      a > 1 &&
      !(pd(e[a - 1], e[1], Zu) && pd(e[a - 2], e[0], Zu)) &&
      (e.push(e[0], e[1]), a++),
    e
  );
}
var l0 = new re(),
  yW = new re(),
  xW = new re(),
  bW = new re(),
  wW = new re(),
  _W = new re(),
  er = class extends Am {
    constructor(e = 100, t = 100) {
      super(),
        (this.points = []),
        (this.shapeHoles = []),
        (this.plane = new Ks(new I(0, 0, -1))),
        (this.subdivision = 0),
        (this.controlSnapDistance = 4),
        (this.pointIDs = 0),
        (this.isMesh2D = !1),
        (this.isText = !1),
        (this._roundness = 0),
        (this.isClosed = !1),
        (this.useCubicForRoundedCorners = !0),
        (this.uuid = dt.generateUUID()),
        (this.needsUpdate = !1),
        (this.roundedCurves = []),
        (this._width = e),
        (this._height = t);
    }
    static createFromState(e, t, i) {
      let r = new er();
      return (
        (r.isClosed = e.isClosed),
        (r.points = e.points.map((s) => Rc.create(s.id, s.data))),
        typeof e.roundness == "number" && (r.roundness = e.roundness),
        (r.shapeHoles = e.shapeHoles.map((s) => er.createFromState(s))),
        t !== void 0 && i !== void 0 && r.applySize(t, i),
        r.update(),
        r
      );
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get roundness() {
      return this._roundness;
    }
    set roundness(e) {
      if (this._roundness !== e) {
        this._roundness = e;
        for (let t = 0, i = this.points.length; t < i; t++)
          this.points[t].roundness = e;
        this.needsUpdate = !0;
      }
    }
    getPointsIndexesByIds(e) {
      return e.map((t) => this.getPointIndexById(t)).filter((t) => t >= 0);
    }
    getPointIndexById(e) {
      let t = this.points.length,
        i = this.points.findIndex((r) => r.uuid === e);
      if (i < 0) {
        let r = t;
        for (let s = 0, a = this.shapeHoles.length; s < a; s++) {
          let n = this.shapeHoles[s],
            o = n.points.length,
            l = n.getPointIndexById(e);
          if (l < 0) r += o;
          else return l + r;
        }
      }
      return i;
    }
    getLineIndexById(e) {
      return this.getPointIndexById(e);
    }
    getBezierPoint(e) {
      if (e <= this.points.length - 1) return this.points[e];
      if (this.shapeHoles.length > 0) {
        let t = this.points.length;
        for (let i = 0, r = this.shapeHoles.length; i < r; i++) {
          let s = this.shapeHoles[i],
            a = e - t;
          if (a <= s.points.length - 1) return s.points[a];
          t += s.points.length;
        }
      }
      throw new Error("This shape does not have a point for this index: " + e);
    }
    getBezierPointIndex(e) {
      let t = this.points.indexOf(e);
      if (t >= 0) return t;
      if (((t = this.points.length), this.shapeHoles.length > 0))
        for (let i = 0, r = this.shapeHoles.length; i < r; i++) {
          let s = this.shapeHoles[i],
            a = s.points.indexOf(e);
          if (a >= 0) return t + a;
          t += s.points.length;
        }
      return -1;
    }
    getAllPoints() {
      let e = [].concat(...this.shapeHoles.map((t) => t.points));
      return [...this.points, ...e];
    }
    applySize(e, t) {
      e === 0 && (e = 0.001),
        t === 0 && (t = 0.001),
        (this._width = e),
        (this._height = t);
    }
    applyScale(e, t) {
      let i = l0.set(e, t);
      for (let r = 0, s = this.points.length; r < s; r++) {
        let a = this.points[r];
        a.position.multiply(i),
          a.controls[0].position.multiply(i),
          a.controls[1].position.multiply(i);
      }
      for (let r = 0, s = this.shapeHoles.length; r < s; r++)
        this.shapeHoles[r].applyScale(e, t);
      this._update();
    }
    createPoint(e, t = 0, i = dt.generateUUID()) {
      let r;
      e instanceof re ? (r = e) : (r = new re(e, t));
      let s = new Rc(i, r);
      return (s.roundness = this.roundness), s;
    }
    addPoint(e) {
      this.points.push(e), (this.needsUpdate = !0);
    }
    addPointAt(e, t) {
      this.points.splice(t, 0, e), (this.needsUpdate = !0);
    }
    getPointByUuid(e) {
      for (let t = 0, i = this.points.length; t < i; t++) {
        let r = this.points[t];
        if (r.uuid === e) return r;
      }
      for (let t = 0, i = this.shapeHoles.length; t < i; t++) {
        let r = this.shapeHoles[t].getPointByUuid(e);
        if (r) return r;
      }
    }
    getFirstPoint() {
      return this.points[0];
    }
    getLastPoint() {
      return this.points[this.points.length - 1];
    }
    removePoint(e) {
      let t = this.points.indexOf(e);
      t >= 0 && this.points.splice(t, 1), (this.needsUpdate = !0);
    }
    removePointById(e) {
      let t = this.points.find((i) => i.uuid === e);
      t && this.removePoint(t);
    }
    update() {
      for (let e = 0, t = this.shapeHoles.length; e < t; e++)
        this.shapeHoles[e].update();
      this._update();
    }
    extractShapePointsToBuffer(e, t = 12, i = !1) {
      (this.subdivision = t),
        this.curveDivisions === void 0 && this.computeCurveDivisions(t);
      let r = i ? this.roundedCurveDivisions : this.curveDivisions;
      return (
        mW(e, i ? this.roundedCurves : this.curves, t, this.autoClose),
        r.reduce((s, a) => s + a, 0) + 1
      );
    }
    computeCurveDivisions(e = 12) {
      return (
        (this.curveDivisions = dA(this.points, e, !1)),
        (this.roundedCurveDivisions = dA(this.points, e, !0)),
        this.curveDivisions
      );
    }
    extractFilteredShapePointsToBuffer(e, t, i = 12) {
      return (
        gW(e, this.curves, t, i, this.autoClose).reduce((r, s) => r + s, 0) * 2
      );
    }
    extractShapePointsToFlatArray(e, t = 12) {
      return (
        (this.subdivision = t),
        this.curveDivisions === void 0 && this.computeCurveDivisions(t),
        vW(e, this.roundedCurves, t, this.autoClose)
      );
    }
    getCurveIndexFromVertexId(e, t = !1) {
      let i = 0;
      this.curveDivisions === void 0 &&
        this.computeCurveDivisions(this.subdivision);
      let r = t ? this.roundedCurveDivisions : this.curveDivisions,
        s = 0;
      t &&
        this.points[0].roundedCurveCorner !== void 0 &&
        (s = sh(this.points[0].roundedCurveCorner, this.subdivision) * 0.5);
      let a = e - s;
      a < 0 && (a += r.reduce((n, o) => n + o, 0));
      for (let n = 0, o = r.length; n < o; n++) {
        let l = r[n];
        if (a < i + l) return [n, (a - i + 1) / l];
        i += l;
      }
      return [0, 1];
    }
    getCurveT(e, t, i) {
      let r = this.points[e],
        s = this.points[e >= this.points.length - 1 ? 0 : e + 1],
        a = this.curveDivisions,
        n = a[e];
      if (cA(r, s)) {
        let l = r.position.distanceTo(s.position);
        return r.position.distanceTo(l0.set(i.x, i.y)) / l;
      }
      let o = 0;
      for (let l = 0; l < e; l++) o += a[l];
      return (t - o) / n;
    }
    dispose() {}
    _applyCurveForPoint(e, t) {
      cA(t, e)
        ? this.lineTo(e.position.x, e.position.y)
        : this.bezierCurveTo(
            t.controls[1].position.x,
            t.controls[1].position.y,
            e.controls[0].position.x,
            e.controls[0].position.y,
            e.position.x,
            e.position.y
          );
      let i = this.curves[this.curves.length - 1];
      (e.curveBefore = i), (t.curveAfter = i);
      let r = i.clone();
      (e.roundedCurveBefore = r),
        (t.roundedCurveAfter = r),
        (e.roundedCurveCorner = void 0),
        this.roundedCurves.push(r);
    }
    _update() {
      if (((this.curves = []), (this.roundedCurves = []), !this.points.length))
        return;
      for (let t = 0, i = this.points.length; t < i; t++) {
        let r = this.points[t];
        if (t === 0) this.moveTo(r.position.x, r.position.y);
        else {
          let s = this.points[t - 1];
          this._applyCurveForPoint(r, s);
        }
      }
      let e = this.getLastPoint();
      if ((e?.curveAfter && (e.curveAfter = void 0), this.isClosed)) {
        let t = this.points[0],
          i = this.points[this.points.length - 1];
        this._applyCurveForPoint(t, i);
      }
      if (this.points.length > 2) {
        let t = 0;
        for (let i = 0, r = this.points.length; i < r; i++) {
          let s = this.points[i],
            a = this.points[i - 1] ?? this.points[this.points.length - 1],
            n = this.points[i + 1] ?? this.points[0],
            o = s.roundness,
            l = a && n && cW(a, s, n);
          if (!s.controlsMoved() && o > 0 && !l) {
            let h = s.curveBefore,
              u = s.curveAfter;
            if (h === void 0 || u === void 0) continue;
            let c = s.roundedCurveBefore,
              d = s.roundedCurveAfter,
              p = h.getLength(),
              f = u.getLength(),
              m = Math.min(o, p * 0.499),
              g = Math.min(o, f * 0.499),
              y = Math.min(m, g),
              x = 1 - y / p,
              b = y / f,
              _ = h.getPointAt(x, l0),
              S = u.getPointAt(b, yW);
            this._subSplitCurve(h, c, x, _, void 0),
              this._subSplitCurve(u, d, b, void 0, S);
            let M;
            if (this.useCubicForRoundedCorners) {
              let C = u3(_, s.position, S) / 2,
                A = Math.tan(C) * _.distanceTo(s.position),
                [T, P] = uW(_, S, A, xW, bW),
                R = dW(T, P, s.position),
                [z, N] = pW(R, _, S, A, wW, _W);
              M = new Ha(_.clone(), z.clone(), N.clone(), S.clone());
            } else M = new pl(_.clone(), s.position.clone(), S.clone());
            (s.roundedCurveCorner = M),
              this.roundedCurves.splice(i + t, 0, M),
              t++;
          }
        }
      }
    }
    _subSplitCurve(e, t, i, r, s) {
      if (e instanceof Ya)
        r !== void 0 && t.v2.copy(r), s !== void 0 && t.v1.copy(s);
      else {
        let a = e,
          n = t,
          o = a.getUtoTmapping(i, 0),
          l = fW(a.v0, a.v1, a.v2, a.v3, o);
        return (
          r !== void 0 &&
            (n.v0.set(l[0], l[1]),
            n.v1.set(l[2], l[3]),
            n.v2.set(l[4], l[5]),
            n.v3.set(l[6], l[7])),
          s !== void 0 &&
            (n.v0.set(l[6], l[7]),
            n.v1.set(l[8], l[9]),
            n.v2.set(l[10], l[11]),
            n.v3.set(l[12], l[13])),
          n
        );
      }
      return t;
    }
    clone() {
      let e = new er(this._width, this._height);
      return (
        (e.points = this.points.map((t) => t.clone())),
        (e.isClosed = this.isClosed),
        (e.roundness = this.roundness),
        (e.isMesh2D = this.isMesh2D),
        (e.shapeHoles = this.shapeHoles.map((t) => t.clone())),
        e
      );
    }
    toJSON() {
      return {
        points: this.points.reduce((e, t) => e.concat(t.toJSON()), []),
        shapeHoles: this.shapeHoles.map((e) => e.toJSON()),
        isClosed: this.isClosed,
        roundness: this.roundness,
      };
    }
    fromJSON(e) {
      (this.points = []), (this.pointIDs = 0);
      let t = e.points.length / 7;
      for (let i = 0; i < t; i++) {
        let r = i * 7,
          s = e.points[r + 0],
          a = e.points[r + 1],
          n = e.points[r + 2],
          o = e.points[r + 3],
          l = e.points[r + 4],
          h = e.points[r + 5],
          u = e.points[r + 6],
          c = new Rc(dt.generateUUID(), new re(s, a));
        c.controls[0].position.set(n, o),
          c.controls[1].position.set(l, h),
          (c.roundness = u),
          this.points.push(c);
      }
      return (
        (this.shapeHoles = e.shapeHoles?.length
          ? e.shapeHoles.map((i) => {
              let r = new er();
              return r.fromJSON(i), r;
            })
          : []),
        (this.isClosed = e.isClosed),
        (this._roundness = e.roundness),
        this._update(),
        this
      );
    }
    fromShape(e, t = !1) {
      this.isText = t;
      let i = (s, a) => {
          a instanceof Ha &&
            a.v3.equals(s.position) &&
            s.controls[0].position.copy(a.v2);
        },
        r = (s) => {
          let a = [],
            n,
            o;
          for (n = 0, o = s.length; n < o; n++)
            s[n] instanceof pl && (s[n] = oW(s[n]));
          for (n = 0, o = s.length; n < o; n++) {
            let u = s[n],
              c = n > 0 ? s[n - 1] : null,
              d;
            u instanceof Ha
              ? ((d = this.createPoint(u.v0)),
                d.controls[1].position.copy(u.v1))
              : u instanceof Ya && (d = this.createPoint(u.v1)),
              d !== void 0 && (c !== null && i(d, c), a.push(d));
          }
          let l = s[s.length - 1],
            h = !1;
          return (
            l instanceof Ha
              ? l.v3.equals(a[0].position) &&
                (a[0].controls[0].position.copy(l.v2), (h = !0))
              : l instanceof Ya && l.v2.equals(a[0].position) && (h = !0),
            (this.isClosed = h),
            a
          );
        };
      return (
        (this.points = r(e.curves)),
        e instanceof Am &&
          (this.shapeHoles = e.holes.map((s) => {
            let a = new er();
            return a.fromShape(s), a;
          })),
        this.update(),
        this
      );
    }
    updatePoint(e, t) {
      let i = this.getPointByUuid(e);
      i &&
        (t.position !== void 0 && i.position.fromArray(t.position),
        t.roundness !== void 0 && (i.roundness = t.roundness),
        t.areControlsDirectionsMirrored !== void 0 &&
          (i.areControlsDirectionsMirrored = t.areControlsDirectionsMirrored),
        (this.needsUpdate = !0));
    }
    updatePreviousControl(e, t) {
      let i = this.getPointByUuid(e)?.controls[0];
      i &&
        (t.position && i.position.fromArray(t.position),
        (this.needsUpdate = !0));
    }
    updateNextControl(e, t) {
      let i = this.getPointByUuid(e)?.controls[1];
      i &&
        (t.position && i.position.fromArray(t.position),
        (this.needsUpdate = !0));
    }
  },
  E1 = Math.PI * 2;
function h0({ x: e, y: t }, i, r, s, a) {
  return { x: e * i + s, y: t * r + a };
}
function SW(e, t) {
  let i =
      t === 1.5707963267948966
        ? 0.551915024494
        : t === -1.5707963267948966
        ? -0.551915024494
        : 1.3333333333333333 * Math.tan(t / 4),
    r = Math.cos(e),
    s = Math.sin(e),
    a = Math.cos(e + t),
    n = Math.sin(e + t);
  return [
    { x: r - s * i, y: s + r * i },
    { x: a + n * i, y: n - a * i },
    { x: a, y: n },
  ];
}
function pA(e, t, i, r) {
  let s = e * r - t * i < 0 ? -1 : 1,
    a = Math.min(1, Math.max(-1, e * i + t * r));
  return s * Math.acos(a);
}
function AW(e, t, i, r, s, a, n, o, l, h) {
  let u = Math.pow(s, 2),
    c = Math.pow(a, 2),
    d = Math.pow(n, 2),
    p = Math.pow(o, 2),
    f = u * c - u * p - c * d;
  f < 0 && (f = 0),
    (f /= u * p + c * d),
    (f = Math.sqrt(f) * (l === h ? -1 : 1));
  let m = ((f * s) / a) * o,
    g = ((f * -a) / s) * n,
    y = m + (e + i) / 2,
    x = g + (t + r) / 2,
    b = (n - m) / s,
    _ = (o - g) / a,
    S = (-n - m) / s,
    M = (-o - g) / a,
    C = pA(1, 0, b, _),
    A = pA(b, _, S, M);
  return (
    !h && A > 0 && (A -= E1),
    h && A < 0 && (A += E1),
    { centerx: y, centery: x, ang1: C, ang2: A }
  );
}
function MW({
  px: e,
  py: t,
  cx: i,
  cy: r,
  rx: s,
  ry: a,
  largeArcFlag: n,
  sweepFlag: o,
}) {
  let l = [];
  if (s === 0 || a === 0) return [];
  let h = (e - i) / 2,
    u = (t - r) / 2;
  if (h === 0 && u === 0) return [];
  (s = Math.abs(s)), (a = Math.abs(a));
  let c = Math.pow(h, 2) / Math.pow(s, 2) + Math.pow(u, 2) / Math.pow(a, 2);
  c > 1 && ((s *= Math.sqrt(c)), (a *= Math.sqrt(c)));
  let d = AW(e, t, i, r, s, a, h, u, n, o),
    { ang1: p, ang2: f } = d,
    { centerx: m, centery: g } = d,
    y = Math.abs(f) / (E1 / 4);
  Math.abs(1 - y) < 1e-7 && (y = 1);
  let x = Math.max(Math.ceil(y), 1);
  f /= x;
  for (let b = 0; b < x; b++) l.push(SW(p, f)), (p += f);
  return l.map((b) => {
    let { x: _, y: S } = h0(b[0], s, a, m, g),
      { x: M, y: C } = h0(b[1], s, a, m, g),
      { x: A, y: T } = h0(b[2], s, a, m, g);
    return { x1: _, y1: S, x2: M, y2: C, x: A, y: T };
  });
}
var Ci;
(function (e) {
  (e[(e.ODD = 0)] = "ODD"),
    (e[(e.NONZERO = 1)] = "NONZERO"),
    (e[(e.POSITIVE = 2)] = "POSITIVE"),
    (e[(e.NEGATIVE = 3)] = "NEGATIVE"),
    (e[(e.ABS_GEQ_TWO = 4)] = "ABS_GEQ_TWO");
})(Ci || (Ci = {}));
var yr;
(function (e) {
  (e[(e.POLYGONS = 0)] = "POLYGONS"),
    (e[(e.CONNECTED_POLYGONS = 1)] = "CONNECTED_POLYGONS"),
    (e[(e.BOUNDARY_CONTOURS = 2)] = "BOUNDARY_CONTOURS");
})(yr || (yr = {}));
function Dt(e, t) {
  if (!e) throw t || "Assertion Failed!";
}
var St = (function () {
    function e() {}
    return (
      (e.vertEq = function (t, i) {
        return t.s === i.s && t.t === i.t;
      }),
      (e.vertLeq = function (t, i) {
        return t.s < i.s || (t.s === i.s && t.t <= i.t);
      }),
      (e.transLeq = function (t, i) {
        return t.t < i.t || (t.t === i.t && t.s <= i.s);
      }),
      (e.edgeGoesLeft = function (t) {
        return e.vertLeq(t.Dst, t.Org);
      }),
      (e.edgeGoesRight = function (t) {
        return e.vertLeq(t.Org, t.Dst);
      }),
      (e.vertL1dist = function (t, i) {
        return Math.abs(t.s - i.s) + Math.abs(t.t - i.t);
      }),
      (e.edgeEval = function (t, i, r) {
        Dt(e.vertLeq(t, i) && e.vertLeq(i, r));
        var s = i.s - t.s,
          a = r.s - i.s;
        return s + a > 0
          ? s < a
            ? i.t - t.t + (t.t - r.t) * (s / (s + a))
            : i.t - r.t + (r.t - t.t) * (a / (s + a))
          : 0;
      }),
      (e.edgeSign = function (t, i, r) {
        Dt(e.vertLeq(t, i) && e.vertLeq(i, r));
        var s = i.s - t.s,
          a = r.s - i.s;
        return s + a > 0 ? (i.t - r.t) * s + (i.t - t.t) * a : 0;
      }),
      (e.transEval = function (t, i, r) {
        Dt(e.transLeq(t, i) && e.transLeq(i, r));
        var s = i.t - t.t,
          a = r.t - i.t;
        return s + a > 0
          ? s < a
            ? i.s - t.s + (t.s - r.s) * (s / (s + a))
            : i.s - r.s + (r.s - t.s) * (a / (s + a))
          : 0;
      }),
      (e.transSign = function (t, i, r) {
        Dt(e.transLeq(t, i) && e.transLeq(i, r));
        var s = i.t - t.t,
          a = r.t - i.t;
        return s + a > 0 ? (i.s - r.s) * s + (i.s - t.s) * a : 0;
      }),
      (e.vertCCW = function (t, i, r) {
        return t.s * (i.t - r.t) + i.s * (r.t - t.t) + r.s * (t.t - i.t) >= 0;
      }),
      (e.interpolate = function (t, i, r, s) {
        return (
          (t = t < 0 ? 0 : t),
          (r = r < 0 ? 0 : r),
          t <= r
            ? r === 0
              ? (i + s) / 2
              : i + (s - i) * (t / (t + r))
            : s + (i - s) * (r / (t + r))
        );
      }),
      (e.intersect = function (t, i, r, s, a) {
        var n, o, l;
        e.vertLeq(t, i) || ((l = t), (t = i), (i = l)),
          e.vertLeq(r, s) || ((l = r), (r = s), (s = l)),
          e.vertLeq(t, r) ||
            ((l = t), (t = r), (r = l), (l = i), (i = s), (s = l)),
          e.vertLeq(r, i)
            ? e.vertLeq(i, s)
              ? ((n = e.edgeEval(t, r, i)),
                (o = e.edgeEval(r, i, s)),
                n + o < 0 && ((n = -n), (o = -o)),
                (a.s = e.interpolate(n, r.s, o, i.s)))
              : ((n = e.edgeSign(t, r, i)),
                (o = -e.edgeSign(t, s, i)),
                n + o < 0 && ((n = -n), (o = -o)),
                (a.s = e.interpolate(n, r.s, o, s.s)))
            : (a.s = (r.s + i.s) / 2),
          e.transLeq(t, i) || ((l = t), (t = i), (i = l)),
          e.transLeq(r, s) || ((l = r), (r = s), (s = l)),
          e.transLeq(t, r) ||
            ((l = t), (t = r), (r = l), (l = i), (i = s), (s = l)),
          e.transLeq(r, i)
            ? e.transLeq(i, s)
              ? ((n = e.transEval(t, r, i)),
                (o = e.transEval(r, i, s)),
                n + o < 0 && ((n = -n), (o = -o)),
                (a.t = e.interpolate(n, r.t, o, i.t)))
              : ((n = e.transSign(t, r, i)),
                (o = -e.transSign(t, s, i)),
                n + o < 0 && ((n = -n), (o = -o)),
                (a.t = e.interpolate(n, r.t, o, s.t)))
            : (a.t = (r.t + i.t) / 2);
      }),
      e
    );
  })(),
  Ku = (function () {
    function e() {
      (this.next = null),
        (this.prev = null),
        (this.anEdge = null),
        (this.trail = null),
        (this.n = 0),
        (this.marked = !1),
        (this.inside = !1);
    }
    return e;
  })(),
  Mf = (function () {
    function e(t) {
      (this.side = t),
        (this.next = null),
        (this.Org = null),
        (this.Sym = null),
        (this.Onext = null),
        (this.Lnext = null),
        (this.Lface = null),
        (this.activeRegion = null),
        (this.winding = 0);
    }
    return (
      Object.defineProperty(e.prototype, "Rface", {
        get: function () {
          return this.Sym.Lface;
        },
        set: function (t) {
          this.Sym.Lface = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Dst", {
        get: function () {
          return this.Sym.Org;
        },
        set: function (t) {
          this.Sym.Org = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Oprev", {
        get: function () {
          return this.Sym.Lnext;
        },
        set: function (t) {
          this.Sym.Lnext = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Lprev", {
        get: function () {
          return this.Onext.Sym;
        },
        set: function (t) {
          this.Onext.Sym = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Dprev", {
        get: function () {
          return this.Lnext.Sym;
        },
        set: function (t) {
          this.Lnext.Sym = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Rprev", {
        get: function () {
          return this.Sym.Onext;
        },
        set: function (t) {
          this.Sym.Onext = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Dnext", {
        get: function () {
          return this.Sym.Onext.Sym;
        },
        set: function (t) {
          this.Sym.Onext.Sym = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(e.prototype, "Rnext", {
        get: function () {
          return this.Sym.Lnext.Sym;
        },
        set: function (t) {
          this.Sym.Lnext.Sym = t;
        },
        enumerable: !0,
        configurable: !0,
      }),
      e
    );
  })(),
  gc = (function () {
    function e() {
      (this.next = null),
        (this.prev = null),
        (this.anEdge = null),
        (this.coords = [0, 0, 0]),
        (this.s = 0),
        (this.t = 0),
        (this.pqHandle = 0),
        (this.n = 0),
        (this.idx = 0);
    }
    return e;
  })(),
  fA = (function () {
    function e() {
      var t = new gc(),
        i = new Ku(),
        r = new Mf(0),
        s = new Mf(1);
      (t.next = t.prev = t),
        (t.anEdge = null),
        (i.next = i.prev = i),
        (r.next = r),
        (r.Sym = s),
        (s.next = s),
        (s.Sym = r),
        (this.vHead = t),
        (this.fHead = i),
        (this.eHead = r),
        (this.eHeadSym = s);
    }
    return (
      (e.prototype.makeEdge_ = function (t) {
        var i = new Mf(0),
          r = new Mf(1);
        t.Sym.side < t.side && (t = t.Sym);
        var s = t.Sym.next;
        return (
          (r.next = s),
          (s.Sym.next = i),
          (i.next = t),
          (t.Sym.next = r),
          (i.Sym = r),
          (i.Onext = i),
          (i.Lnext = r),
          (i.Org = null),
          (i.Lface = null),
          (i.winding = 0),
          (i.activeRegion = null),
          (r.Sym = i),
          (r.Onext = r),
          (r.Lnext = i),
          (r.Org = null),
          (r.Lface = null),
          (r.winding = 0),
          (r.activeRegion = null),
          i
        );
      }),
      (e.prototype.splice_ = function (t, i) {
        var r = t.Onext,
          s = i.Onext;
        (r.Sym.Lnext = i), (s.Sym.Lnext = t), (t.Onext = s), (i.Onext = r);
      }),
      (e.prototype.makeVertex_ = function (t, i, r) {
        var s = t;
        Dt(s, "Vertex can't be null!");
        var a = r.prev;
        (s.prev = a), (a.next = s), (s.next = r), (r.prev = s), (s.anEdge = i);
        var n = i;
        do (n.Org = s), (n = n.Onext);
        while (n !== i);
      }),
      (e.prototype.makeFace_ = function (t, i, r) {
        var s = t;
        Dt(s, "Face can't be null");
        var a = r.prev;
        (s.prev = a),
          (a.next = s),
          (s.next = r),
          (r.prev = s),
          (s.anEdge = i),
          (s.trail = null),
          (s.marked = !1),
          (s.inside = r.inside);
        var n = i;
        do (n.Lface = s), (n = n.Lnext);
        while (n !== i);
      }),
      (e.prototype.killEdge_ = function (t) {
        t.Sym.side < t.side && (t = t.Sym);
        var i = t.next,
          r = t.Sym.next;
        (i.Sym.next = r), (r.Sym.next = i);
      }),
      (e.prototype.killVertex_ = function (t, i) {
        var r = t.anEdge,
          s = r;
        do (s.Org = i), (s = s.Onext);
        while (s !== r);
        var a = t.prev,
          n = t.next;
        (n.prev = a), (a.next = n);
      }),
      (e.prototype.killFace_ = function (t, i) {
        var r = t.anEdge,
          s = r;
        do (s.Lface = i), (s = s.Lnext);
        while (s !== r);
        var a = t.prev,
          n = t.next;
        (n.prev = a), (a.next = n);
      }),
      (e.prototype.makeEdge = function () {
        var t = new gc(),
          i = new gc(),
          r = new Ku(),
          s = this.makeEdge_(this.eHead);
        return (
          this.makeVertex_(t, s, this.vHead),
          this.makeVertex_(i, s.Sym, this.vHead),
          this.makeFace_(r, s, this.fHead),
          s
        );
      }),
      (e.prototype.splice = function (t, i) {
        var r = !1,
          s = !1;
        if (t !== i) {
          if (
            (i.Org !== t.Org && ((s = !0), this.killVertex_(i.Org, t.Org)),
            i.Lface !== t.Lface && ((r = !0), this.killFace_(i.Lface, t.Lface)),
            this.splice_(i, t),
            !s)
          ) {
            var a = new gc();
            this.makeVertex_(a, i, t.Org), (t.Org.anEdge = t);
          }
          if (!r) {
            var n = new Ku();
            this.makeFace_(n, i, t.Lface), (t.Lface.anEdge = t);
          }
        }
      }),
      (e.prototype.delete = function (t) {
        var i = t.Sym,
          r = !1;
        if (
          (t.Lface !== t.Rface && ((r = !0), this.killFace_(t.Lface, t.Rface)),
          t.Onext === t)
        )
          this.killVertex_(t.Org, null);
        else if (
          ((t.Rface.anEdge = t.Oprev),
          (t.Org.anEdge = t.Onext),
          this.splice_(t, t.Oprev),
          !r)
        ) {
          var s = new Ku();
          this.makeFace_(s, t, t.Lface);
        }
        i.Onext === i
          ? (this.killVertex_(i.Org, null), this.killFace_(i.Lface, null))
          : ((t.Lface.anEdge = i.Oprev),
            (i.Org.anEdge = i.Onext),
            this.splice_(i, i.Oprev)),
          this.killEdge_(t);
      }),
      (e.prototype.addEdgeVertex = function (t) {
        var i = this.makeEdge_(t),
          r = i.Sym;
        this.splice_(i, t.Lnext), (i.Org = t.Dst);
        var s = new gc();
        return this.makeVertex_(s, r, i.Org), (i.Lface = r.Lface = t.Lface), i;
      }),
      (e.prototype.splitEdge = function (t) {
        var i = this.addEdgeVertex(t),
          r = i.Sym;
        return (
          this.splice_(t.Sym, t.Sym.Oprev),
          this.splice_(t.Sym, r),
          (t.Dst = r.Org),
          (r.Dst.anEdge = r.Sym),
          (r.Rface = t.Rface),
          (r.winding = t.winding),
          (r.Sym.winding = t.Sym.winding),
          (r.idx = t.idx),
          (r.Sym.idx = t.Sym.idx),
          r
        );
      }),
      (e.prototype.connect = function (t, i) {
        var r = !1,
          s = this.makeEdge_(t),
          a = s.Sym;
        if (
          (i.Lface !== t.Lface && ((r = !0), this.killFace_(i.Lface, t.Lface)),
          this.splice_(s, t.Lnext),
          this.splice_(a, i),
          (s.Org = t.Dst),
          (a.Org = i.Org),
          (s.Lface = a.Lface = t.Lface),
          (t.Lface.anEdge = a),
          !r)
        ) {
          var n = new Ku();
          this.makeFace_(n, s, t.Lface);
        }
        return s;
      }),
      (e.prototype.zapFace = function (t) {
        var i = t.anEdge,
          r,
          s,
          a,
          n,
          o;
        s = i.Lnext;
        do
          (r = s),
            (s = r.Lnext),
            (r.Lface = null),
            r.Rface === null &&
              (r.Onext === r
                ? this.killVertex_(r.Org, null)
                : ((r.Org.anEdge = r.Onext), this.splice_(r, r.Oprev)),
              (a = r.Sym),
              a.Onext === a
                ? this.killVertex_(a.Org, null)
                : ((a.Org.anEdge = a.Onext), this.splice_(a, a.Oprev)),
              this.killEdge_(r));
        while (r != i);
        (n = t.prev), (o = t.next), (o.prev = n), (n.next = o);
      }),
      (e.prototype.countFaceVerts_ = function (t) {
        var i = t.anEdge,
          r = 0;
        do r++, (i = i.Lnext);
        while (i !== t.anEdge);
        return r;
      }),
      (e.prototype.mergeConvexFaces = function (t) {
        var i, r, s, a, n, o, l;
        for (i = this.fHead.next; i !== this.fHead; i = i.next)
          if (i.inside)
            for (
              r = i.anEdge, n = r.Org;
              (s = r.Lnext),
                (a = r.Sym),
                a &&
                  a.Lface &&
                  a.Lface.inside &&
                  ((o = this.countFaceVerts_(i)),
                  (l = this.countFaceVerts_(a.Lface)),
                  o + l - 2 <= t &&
                    St.vertCCW(r.Lprev.Org, r.Org, a.Lnext.Lnext.Org) &&
                    St.vertCCW(a.Lprev.Org, a.Org, r.Lnext.Lnext.Org) &&
                    ((s = a.Lnext), this.delete(a), (r = null), (a = null))),
                !(r && r.Lnext.Org === n);

            )
              r = s;
        return !0;
      }),
      (e.prototype.check = function () {
        var t = this.fHead,
          i = this.vHead,
          r = this.eHead,
          s,
          a,
          n,
          o,
          l,
          h;
        for (a = t, a = t; (s = a.next) !== t; a = s) {
          Dt(s.prev === a), (l = s.anEdge);
          do
            Dt(l.Sym !== l),
              Dt(l.Sym.Sym === l),
              Dt(l.Lnext.Onext.Sym === l),
              Dt(l.Onext.Sym.Lnext === l),
              Dt(l.Lface === s),
              (l = l.Lnext);
          while (l !== s.anEdge);
        }
        for (
          Dt(s.prev === a && s.anEdge === null), o = i, o = i;
          (n = o.next) !== i;
          o = n
        ) {
          Dt(n.prev === o), (l = n.anEdge);
          do
            Dt(l.Sym !== l),
              Dt(l.Sym.Sym === l),
              Dt(l.Lnext.Onext.Sym === l),
              Dt(l.Onext.Sym.Lnext === l),
              Dt(l.Org === n),
              (l = l.Onext);
          while (l !== n.anEdge);
        }
        for (
          Dt(n.prev === o && n.anEdge === null), h = r, h = r;
          (l = h.next) !== r;
          h = l
        )
          Dt(l.Sym.next === h.Sym),
            Dt(l.Sym !== l),
            Dt(l.Sym.Sym === l),
            Dt(l.Org !== null),
            Dt(l.Dst !== null),
            Dt(l.Lnext.Onext.Sym === l),
            Dt(l.Onext.Sym.Lnext === l);
        Dt(
          l.Sym.next === h.Sym &&
            l.Sym === this.eHeadSym &&
            l.Sym.Sym === l &&
            l.Org === null &&
            l.Dst === null &&
            l.Lface === null &&
            l.Rface === null
        );
      }),
      e
    );
  })(),
  mA = (function () {
    function e() {
      this.handle = null;
    }
    return e;
  })(),
  gA = (function () {
    function e() {
      (this.key = null), (this.node = 0);
    }
    return e;
  })(),
  EW = (function () {
    function e(t, i) {
      (this.leq = i),
        (this.max = 0),
        (this.nodes = []),
        (this.handles = []),
        (this.initialized = !1),
        (this.freeList = 0),
        (this.size = 0),
        (this.max = t),
        (this.nodes = []),
        (this.handles = []);
      for (var r = 0; r < t + 1; r++)
        (this.nodes[r] = new mA()), (this.handles[r] = new gA());
      (this.initialized = !1),
        (this.nodes[1].handle = 1),
        (this.handles[1].key = null);
    }
    return (
      (e.prototype.floatDown_ = function (t) {
        var i = this.nodes,
          r = this.handles,
          s,
          a,
          n;
        for (s = i[t].handle; ; ) {
          if (
            ((n = t << 1),
            n < this.size &&
              this.leq(r[i[n + 1].handle].key, r[i[n].handle].key) &&
              ++n,
            Dt(n <= this.max),
            (a = i[n].handle),
            n > this.size || this.leq(r[s].key, r[a].key))
          ) {
            (i[t].handle = s), (r[s].node = t);
            break;
          }
          (i[t].handle = a), (r[a].node = t), (t = n);
        }
      }),
      (e.prototype.floatUp_ = function (t) {
        var i = this.nodes,
          r = this.handles,
          s,
          a,
          n;
        for (s = i[t].handle; ; ) {
          if (
            ((n = t >> 1),
            (a = i[n].handle),
            n === 0 || this.leq(r[a].key, r[s].key))
          ) {
            (i[t].handle = s), (r[s].node = t);
            break;
          }
          (i[t].handle = a), (r[a].node = t), (t = n);
        }
      }),
      (e.prototype.init = function () {
        for (var t = this.size; t >= 1; --t) this.floatDown_(t);
        this.initialized = !0;
      }),
      (e.prototype.min = function () {
        return this.handles[this.nodes[1].handle].key;
      }),
      (e.prototype.insert = function (t) {
        var i, r;
        if (((i = ++this.size), i * 2 > this.max)) {
          this.max *= 2;
          var s, a;
          for (
            a = this.nodes.length, this.nodes.length = this.max + 1, s = a;
            s < this.nodes.length;
            s++
          )
            this.nodes[s] = new mA();
          for (
            a = this.handles.length, this.handles.length = this.max + 1, s = a;
            s < this.handles.length;
            s++
          )
            this.handles[s] = new gA();
        }
        return (
          this.freeList === 0
            ? (r = i)
            : ((r = this.freeList), (this.freeList = this.handles[r].node)),
          (this.nodes[i].handle = r),
          (this.handles[r].node = i),
          (this.handles[r].key = t),
          this.initialized && this.floatUp_(i),
          r
        );
      }),
      (e.prototype.extractMin = function () {
        var t = this.nodes,
          i = this.handles,
          r = t[1].handle,
          s = i[r].key;
        return (
          this.size > 0 &&
            ((t[1].handle = t[this.size].handle),
            (i[t[1].handle].node = 1),
            (i[r].key = null),
            (i[r].node = this.freeList),
            (this.freeList = r),
            --this.size,
            this.size > 0 && this.floatDown_(1)),
          s
        );
      }),
      (e.prototype.delete = function (t) {
        var i = this.nodes,
          r = this.handles,
          s;
        Dt(t >= 1 && t <= this.max && r[t].key !== null),
          (s = r[t].node),
          (i[s].handle = i[this.size].handle),
          (r[i[s].handle].node = s),
          --this.size,
          s <= this.size &&
            (s <= 1 || this.leq(r[i[s >> 1].handle].key, r[i[s].handle].key)
              ? this.floatDown_(s)
              : this.floatUp_(s)),
          (r[t].key = null),
          (r[t].node = this.freeList),
          (this.freeList = t);
      }),
      e
    );
  })(),
  c0 = (function () {
    function e() {
      (this.eUp = null),
        (this.nodeUp = null),
        (this.windingNumber = 0),
        (this.inside = !1),
        (this.sentinel = !1),
        (this.dirty = !1),
        (this.fixUpperEdge = !1);
    }
    return e;
  })(),
  vA = (function () {
    function e() {
      (this.key = null), (this.next = null), (this.prev = null);
    }
    return e;
  })(),
  CW = (function () {
    function e(t, i) {
      (this.frame = t),
        (this.leq = i),
        (this.head = new vA()),
        (this.head.next = this.head),
        (this.head.prev = this.head);
    }
    return (
      (e.prototype.min = function () {
        return this.head.next;
      }),
      (e.prototype.max = function () {
        return this.head.prev;
      }),
      (e.prototype.insert = function (t) {
        return this.insertBefore(this.head, t);
      }),
      (e.prototype.search = function (t) {
        var i = this.head;
        do i = i.next;
        while (i.key !== null && !this.leq(this.frame, t, i.key));
        return i;
      }),
      (e.prototype.insertBefore = function (t, i) {
        do t = t.prev;
        while (t.key !== null && !this.leq(this.frame, t.key, i));
        var r = new vA();
        return (
          (r.key = i),
          (r.next = t.next),
          (t.next.prev = r),
          (r.prev = t),
          (t.next = r),
          r
        );
      }),
      (e.prototype.delete = function (t) {
        (t.next.prev = t.prev), (t.prev.next = t.next);
      }),
      e
    );
  })(),
  TW = (function () {
    function e() {}
    return (
      (e.regionBelow = function (t) {
        return t.nodeUp.prev.key;
      }),
      (e.regionAbove = function (t) {
        return t.nodeUp.next.key;
      }),
      (e.debugEvent = function (t) {}),
      (e.addWinding = function (t, i) {
        (t.winding += i.winding), (t.Sym.winding += i.Sym.winding);
      }),
      (e.edgeLeq = function (t, i, r) {
        var s = t.event,
          a = i.eUp,
          n = r.eUp;
        if (a.Dst === s)
          return n.Dst === s
            ? St.vertLeq(a.Org, n.Org)
              ? St.edgeSign(n.Dst, a.Org, n.Org) <= 0
              : St.edgeSign(a.Dst, n.Org, a.Org) >= 0
            : St.edgeSign(n.Dst, s, n.Org) <= 0;
        if (n.Dst === s) return St.edgeSign(a.Dst, s, a.Org) >= 0;
        var o = St.edgeEval(a.Dst, s, a.Org),
          l = St.edgeEval(n.Dst, s, n.Org);
        return o >= l;
      }),
      (e.deleteRegion = function (t, i) {
        i.fixUpperEdge && Dt(i.eUp.winding === 0),
          (i.eUp.activeRegion = null),
          t.dict.delete(i.nodeUp);
      }),
      (e.fixUpperEdge = function (t, i, r) {
        Dt(i.fixUpperEdge),
          t.mesh.delete(i.eUp),
          (i.fixUpperEdge = !1),
          (i.eUp = r),
          (r.activeRegion = i);
      }),
      (e.topLeftRegion = function (t, i) {
        var r = i.eUp.Org,
          s;
        do i = e.regionAbove(i);
        while (i.eUp.Org === r);
        if (i.fixUpperEdge) {
          if (
            ((s = t.mesh.connect(e.regionBelow(i).eUp.Sym, i.eUp.Lnext)),
            s === null)
          )
            return null;
          e.fixUpperEdge(t, i, s), (i = e.regionAbove(i));
        }
        return i;
      }),
      (e.topRightRegion = function (t) {
        var i = t.eUp.Dst;
        do t = e.regionAbove(t);
        while (t.eUp.Dst === i);
        return t;
      }),
      (e.addRegionBelow = function (t, i, r) {
        var s = new c0();
        return (
          (s.eUp = r),
          (s.nodeUp = t.dict.insertBefore(i.nodeUp, s)),
          (s.fixUpperEdge = !1),
          (s.sentinel = !1),
          (s.dirty = !1),
          (r.activeRegion = s),
          s
        );
      }),
      (e.isWindingInside = function (t, i) {
        switch (t.windingRule) {
          case Ci.ODD:
            return (i & 1) !== 0;
          case Ci.NONZERO:
            return i !== 0;
          case Ci.POSITIVE:
            return i > 0;
          case Ci.NEGATIVE:
            return i < 0;
          case Ci.ABS_GEQ_TWO:
            return i >= 2 || i <= -2;
        }
        throw new Error("Invalid winding rulle");
      }),
      (e.computeWinding = function (t, i) {
        (i.windingNumber = e.regionAbove(i).windingNumber + i.eUp.winding),
          (i.inside = e.isWindingInside(t, i.windingNumber));
      }),
      (e.finishRegion = function (t, i) {
        var r = i.eUp,
          s = r.Lface;
        (s.inside = i.inside), (s.anEdge = r), e.deleteRegion(t, i);
      }),
      (e.finishLeftRegions = function (t, i, r) {
        for (var s, a = null, n = i, o = i.eUp; n !== r; ) {
          if (
            ((n.fixUpperEdge = !1),
            (a = e.regionBelow(n)),
            (s = a.eUp),
            s.Org != o.Org)
          ) {
            if (!a.fixUpperEdge) {
              e.finishRegion(t, n);
              break;
            }
            (s = t.mesh.connect(o.Lprev, s.Sym)), e.fixUpperEdge(t, a, s);
          }
          o.Onext !== s && (t.mesh.splice(s.Oprev, s), t.mesh.splice(o, s)),
            e.finishRegion(t, n),
            (o = a.eUp),
            (n = a);
        }
        return o;
      }),
      (e.addRightEdges = function (t, i, r, s, a, n) {
        var o,
          l,
          h,
          u,
          c = !0;
        h = r;
        do
          Dt(St.vertLeq(h.Org, h.Dst)),
            e.addRegionBelow(t, i, h.Sym),
            (h = h.Onext);
        while (h !== s);
        for (
          a === null && (a = e.regionBelow(i).eUp.Rprev), l = i, u = a;
          (o = e.regionBelow(l)), (h = o.eUp.Sym), h.Org === u.Org;

        )
          h.Onext !== u &&
            (t.mesh.splice(h.Oprev, h), t.mesh.splice(u.Oprev, h)),
            (o.windingNumber = l.windingNumber - h.winding),
            (o.inside = e.isWindingInside(t, o.windingNumber)),
            (l.dirty = !0),
            !c &&
              e.checkForRightSplice(t, l) &&
              (e.addWinding(h, u), e.deleteRegion(t, l), t.mesh.delete(u)),
            (c = !1),
            (l = o),
            (u = h);
        (l.dirty = !0),
          Dt(l.windingNumber - h.winding === o.windingNumber),
          n && e.walkDirtyRegions(t, l);
      }),
      (e.spliceMergeVertices = function (t, i, r) {
        t.mesh.splice(i, r);
      }),
      (e.vertexWeights = function (t, i, r) {
        var s = St.vertL1dist(i, t),
          a = St.vertL1dist(r, t),
          n = (0.5 * a) / (s + a),
          o = (0.5 * s) / (s + a);
        (t.coords[0] += n * i.coords[0] + o * r.coords[0]),
          (t.coords[1] += n * i.coords[1] + o * r.coords[1]),
          (t.coords[2] += n * i.coords[2] + o * r.coords[2]);
      }),
      (e.getIntersectData = function (t, i, r, s, a, n) {
        (i.coords[0] = i.coords[1] = i.coords[2] = 0),
          (i.idx = -1),
          e.vertexWeights(i, r, s),
          e.vertexWeights(i, a, n);
      }),
      (e.checkForRightSplice = function (t, i) {
        var r = e.regionBelow(i),
          s = i.eUp,
          a = r.eUp;
        if (St.vertLeq(s.Org, a.Org)) {
          if (St.edgeSign(a.Dst, s.Org, a.Org) > 0) return !1;
          St.vertEq(s.Org, a.Org)
            ? s.Org !== a.Org &&
              (t.pq.delete(s.Org.pqHandle),
              e.spliceMergeVertices(t, a.Oprev, s))
            : (t.mesh.splitEdge(a.Sym),
              t.mesh.splice(s, a.Oprev),
              (i.dirty = r.dirty = !0));
        } else {
          if (St.edgeSign(s.Dst, a.Org, s.Org) < 0) return !1;
          (e.regionAbove(i).dirty = i.dirty = !0),
            t.mesh.splitEdge(s.Sym),
            t.mesh.splice(a.Oprev, s);
        }
        return !0;
      }),
      (e.checkForLeftSplice = function (t, i) {
        var r = e.regionBelow(i),
          s = i.eUp,
          a = r.eUp,
          n;
        if ((Dt(!St.vertEq(s.Dst, a.Dst)), St.vertLeq(s.Dst, a.Dst))) {
          if (St.edgeSign(s.Dst, a.Dst, s.Org) < 0) return !1;
          (e.regionAbove(i).dirty = i.dirty = !0),
            (n = t.mesh.splitEdge(s)),
            t.mesh.splice(a.Sym, n),
            (n.Lface.inside = i.inside);
        } else {
          if (St.edgeSign(a.Dst, s.Dst, a.Org) > 0) return !1;
          (i.dirty = r.dirty = !0),
            (n = t.mesh.splitEdge(a)),
            t.mesh.splice(s.Lnext, a.Sym),
            (n.Rface.inside = i.inside);
        }
        return !0;
      }),
      (e.checkForIntersect = function (t, i) {
        var r = e.regionBelow(i),
          s = i.eUp,
          a = r.eUp,
          n = s.Org,
          o = a.Org,
          l = s.Dst,
          h = a.Dst,
          u,
          c,
          d = new gc(),
          p,
          f;
        if (
          (Dt(!St.vertEq(h, l)),
          Dt(St.edgeSign(l, t.event, n) <= 0),
          Dt(St.edgeSign(h, t.event, o) >= 0),
          Dt(n !== t.event && o !== t.event),
          Dt(!i.fixUpperEdge && !r.fixUpperEdge),
          n === o ||
            ((u = Math.min(n.t, l.t)), (c = Math.max(o.t, h.t)), u > c))
        )
          return !1;
        if (St.vertLeq(n, o)) {
          if (St.edgeSign(h, n, o) > 0) return !1;
        } else if (St.edgeSign(l, o, n) < 0) return !1;
        return (
          e.debugEvent(t),
          St.intersect(l, n, h, o, d),
          Dt(Math.min(n.t, l.t) <= d.t),
          Dt(d.t <= Math.max(o.t, h.t)),
          Dt(Math.min(h.s, l.s) <= d.s),
          Dt(d.s <= Math.max(o.s, n.s)),
          St.vertLeq(d, t.event) && ((d.s = t.event.s), (d.t = t.event.t)),
          (p = St.vertLeq(n, o) ? n : o),
          St.vertLeq(p, d) && ((d.s = p.s), (d.t = p.t)),
          St.vertEq(d, n) || St.vertEq(d, o)
            ? (e.checkForRightSplice(t, i), !1)
            : (!St.vertEq(l, t.event) && St.edgeSign(l, t.event, d) >= 0) ||
              (!St.vertEq(h, t.event) && St.edgeSign(h, t.event, d) <= 0)
            ? h === t.event
              ? (t.mesh.splitEdge(s.Sym),
                t.mesh.splice(a.Sym, s),
                (i = e.topLeftRegion(t, i)),
                (s = e.regionBelow(i).eUp),
                e.finishLeftRegions(t, e.regionBelow(i), r),
                e.addRightEdges(t, i, s.Oprev, s, s, !0),
                !0)
              : l === t.event
              ? (t.mesh.splitEdge(a.Sym),
                t.mesh.splice(s.Lnext, a.Oprev),
                (r = i),
                (i = e.topRightRegion(i)),
                (f = e.regionBelow(i).eUp.Rprev),
                (r.eUp = a.Oprev),
                (a = e.finishLeftRegions(t, r, null)),
                e.addRightEdges(t, i, a.Onext, s.Rprev, f, !0),
                !0)
              : (St.edgeSign(l, t.event, d) >= 0 &&
                  ((e.regionAbove(i).dirty = i.dirty = !0),
                  t.mesh.splitEdge(s.Sym),
                  (s.Org.s = t.event.s),
                  (s.Org.t = t.event.t)),
                St.edgeSign(h, t.event, d) <= 0 &&
                  ((i.dirty = r.dirty = !0),
                  t.mesh.splitEdge(a.Sym),
                  (a.Org.s = t.event.s),
                  (a.Org.t = t.event.t)),
                !1)
            : (t.mesh.splitEdge(s.Sym),
              t.mesh.splitEdge(a.Sym),
              t.mesh.splice(a.Oprev, s),
              (s.Org.s = d.s),
              (s.Org.t = d.t),
              (s.Org.pqHandle = t.pq.insert(s.Org)),
              e.getIntersectData(t, s.Org, n, l, o, h),
              (e.regionAbove(i).dirty = i.dirty = r.dirty = !0),
              !1)
        );
      }),
      (e.walkDirtyRegions = function (t, i) {
        for (var r = e.regionBelow(i), s, a; ; ) {
          for (; r.dirty; ) (i = r), (r = e.regionBelow(r));
          if (
            !i.dirty &&
            ((r = i), (i = e.regionAbove(i)), i === null || !i.dirty)
          )
            return;
          if (
            ((i.dirty = !1),
            (s = i.eUp),
            (a = r.eUp),
            s.Dst !== a.Dst &&
              e.checkForLeftSplice(t, i) &&
              (r.fixUpperEdge
                ? (e.deleteRegion(t, r),
                  t.mesh.delete(a),
                  (r = e.regionBelow(i)),
                  (a = r.eUp))
                : i.fixUpperEdge &&
                  (e.deleteRegion(t, i),
                  t.mesh.delete(s),
                  (i = e.regionAbove(r)),
                  (s = i.eUp))),
            s.Org !== a.Org)
          )
            if (
              s.Dst !== a.Dst &&
              !i.fixUpperEdge &&
              !r.fixUpperEdge &&
              (s.Dst === t.event || a.Dst === t.event)
            ) {
              if (e.checkForIntersect(t, i)) return;
            } else e.checkForRightSplice(t, i);
          s.Org === a.Org &&
            s.Dst === a.Dst &&
            (e.addWinding(a, s),
            e.deleteRegion(t, i),
            t.mesh.delete(s),
            (i = e.regionAbove(r)));
        }
      }),
      (e.connectRightVertex = function (t, i, r) {
        var s,
          a = r.Onext,
          n = e.regionBelow(i),
          o = i.eUp,
          l = n.eUp,
          h = !1;
        if (
          (o.Dst !== l.Dst && e.checkForIntersect(t, i),
          St.vertEq(o.Org, t.event) &&
            (t.mesh.splice(a.Oprev, o),
            (i = e.topLeftRegion(t, i)),
            (a = e.regionBelow(i).eUp),
            e.finishLeftRegions(t, e.regionBelow(i), n),
            (h = !0)),
          St.vertEq(l.Org, t.event) &&
            (t.mesh.splice(r, l.Oprev),
            (r = e.finishLeftRegions(t, n, null)),
            (h = !0)),
          h)
        ) {
          e.addRightEdges(t, i, r.Onext, a, a, !0);
          return;
        }
        St.vertLeq(l.Org, o.Org) ? (s = l.Oprev) : (s = o),
          (s = t.mesh.connect(r.Lprev, s)),
          e.addRightEdges(t, i, s, s.Onext, s.Onext, !1),
          (s.Sym.activeRegion.fixUpperEdge = !0),
          e.walkDirtyRegions(t, i);
      }),
      (e.connectLeftDegenerate = function (t, i, r) {
        var s, a, n, o, l;
        if (((s = i.eUp), St.vertEq(s.Org, r))) {
          Dt(!1), e.spliceMergeVertices(t, s, r.anEdge);
          return;
        }
        if (!St.vertEq(s.Dst, r)) {
          t.mesh.splitEdge(s.Sym),
            i.fixUpperEdge && (t.mesh.delete(s.Onext), (i.fixUpperEdge = !1)),
            t.mesh.splice(r.anEdge, s),
            e.sweepEvent(t, r);
          return;
        }
        Dt(!1),
          (i = e.topRightRegion(i)),
          (l = e.regionBelow(i)),
          (n = l.eUp.Sym),
          (a = o = n.Onext),
          l.fixUpperEdge &&
            (Dt(a !== n),
            e.deleteRegion(t, l),
            t.mesh.delete(n),
            (n = a.Oprev)),
          t.mesh.splice(r.anEdge, n),
          St.edgeGoesLeft(a) || (a = null),
          e.addRightEdges(t, i, n.Onext, o, a, !0);
      }),
      (e.connectLeftVertex = function (t, i) {
        var r,
          s,
          a,
          n,
          o,
          l,
          h = new c0();
        if (
          ((h.eUp = i.anEdge.Sym),
          (r = t.dict.search(h).key),
          (s = e.regionBelow(r)),
          !!s)
        ) {
          if (((n = r.eUp), (o = s.eUp), St.edgeSign(n.Dst, i, n.Org) === 0)) {
            e.connectLeftDegenerate(t, r, i);
            return;
          }
          if (
            ((a = St.vertLeq(o.Dst, n.Dst) ? r : s), r.inside || a.fixUpperEdge)
          ) {
            if (a === r) l = t.mesh.connect(i.anEdge.Sym, n.Lnext);
            else {
              var u = t.mesh.connect(o.Dnext, i.anEdge);
              l = u.Sym;
            }
            a.fixUpperEdge
              ? e.fixUpperEdge(t, a, l)
              : e.computeWinding(t, e.addRegionBelow(t, r, l)),
              e.sweepEvent(t, i);
          } else e.addRightEdges(t, r, i.anEdge, i.anEdge, null, !0);
        }
      }),
      (e.sweepEvent = function (t, i) {
        (t.event = i), e.debugEvent(t);
        for (var r = i.anEdge; r.activeRegion === null; )
          if (((r = r.Onext), r === i.anEdge)) {
            e.connectLeftVertex(t, i);
            return;
          }
        var s = e.topLeftRegion(t, r.activeRegion);
        Dt(s !== null);
        var a = e.regionBelow(s),
          n = a.eUp,
          o = e.finishLeftRegions(t, a, null);
        o.Onext === n
          ? e.connectRightVertex(t, s, o)
          : e.addRightEdges(t, s, o.Onext, n, n, !0);
      }),
      (e.addSentinel = function (t, i, r, s) {
        var a = new c0(),
          n = t.mesh.makeEdge();
        (n.Org.s = r),
          (n.Org.t = s),
          (n.Dst.s = i),
          (n.Dst.t = s),
          (t.event = n.Dst),
          (a.eUp = n),
          (a.windingNumber = 0),
          (a.inside = !1),
          (a.fixUpperEdge = !1),
          (a.sentinel = !0),
          (a.dirty = !1),
          (a.nodeUp = t.dict.insert(a));
      }),
      (e.initEdgeDict = function (t) {
        t.dict = new CW(t, e.edgeLeq);
        var i = t.bmax[0] - t.bmin[0],
          r = t.bmax[1] - t.bmin[1],
          s = t.bmin[0] - i,
          a = t.bmax[0] + i,
          n = t.bmin[1] - r,
          o = t.bmax[1] + r;
        e.addSentinel(t, s, a, n), e.addSentinel(t, s, a, o);
      }),
      (e.doneEdgeDict = function (t) {
        for (var i, r = 0; (i = t.dict.min().key) !== null; )
          i.sentinel || (Dt(i.fixUpperEdge), Dt(++r === 1)),
            Dt(i.windingNumber === 0),
            e.deleteRegion(t, i);
      }),
      (e.removeDegenerateEdges = function (t) {
        var i,
          r,
          s,
          a = t.mesh.eHead;
        for (i = a.next; i !== a; i = r)
          (r = i.next),
            (s = i.Lnext),
            St.vertEq(i.Org, i.Dst) &&
              i.Lnext.Lnext !== i &&
              (e.spliceMergeVertices(t, s, i),
              t.mesh.delete(i),
              (i = s),
              (s = i.Lnext)),
            s.Lnext === i &&
              (s !== i &&
                ((s === r || s === r.Sym) && (r = r.next), t.mesh.delete(s)),
              (i === r || i === r.Sym) && (r = r.next),
              t.mesh.delete(i));
      }),
      (e.initPriorityQ = function (t) {
        var i,
          r,
          s,
          a = 0;
        for (s = t.mesh.vHead, r = s.next; r !== s; r = r.next) a++;
        for (
          a += 8,
            i = t.pq = new EW(a, St.vertLeq),
            s = t.mesh.vHead,
            r = s.next;
          r !== s;
          r = r.next
        )
          r.pqHandle = i.insert(r);
        return r !== s ? !1 : (i.init(), !0);
      }),
      (e.donePriorityQ = function (t) {
        t.pq = null;
      }),
      (e.removeDegenerateFaces = function (t, i) {
        var r, s, a;
        for (r = i.fHead.next; r !== i.fHead; r = s)
          (s = r.next),
            (a = r.anEdge),
            Dt(a.Lnext !== a),
            a.Lnext.Lnext === a && (e.addWinding(a.Onext, a), t.mesh.delete(a));
        return !0;
      }),
      (e.computeInterior = function (t, i) {
        i === void 0 && (i = !0);
        var r, s;
        if ((e.removeDegenerateEdges(t), !e.initPriorityQ(t))) return !1;
        for (e.initEdgeDict(t); (r = t.pq.extractMin()) !== null; ) {
          for (; (s = t.pq.min()), !(s === null || !St.vertEq(s, r)); )
            (s = t.pq.extractMin()),
              e.spliceMergeVertices(t, r.anEdge, s.anEdge);
          e.sweepEvent(t, r);
        }
        return (
          (t.event = t.dict.min().key.eUp.Org),
          e.debugEvent(t),
          e.doneEdgeDict(t),
          e.donePriorityQ(t),
          e.removeDegenerateFaces(t, t.mesh) ? (i && t.mesh.check(), !0) : !1
        );
      }),
      e
    );
  })(),
  PW = (function () {
    function e() {
      (this.mesh = new fA()),
        (this.normal = [0, 0, 0]),
        (this.sUnit = [0, 0, 0]),
        (this.tUnit = [0, 0, 0]),
        (this.bmin = [0, 0]),
        (this.bmax = [0, 0]),
        (this.windingRule = Ci.ODD),
        (this.dict = null),
        (this.pq = null),
        (this.event = null),
        (this.vertexIndexCounter = 0),
        (this.vertices = []),
        (this.vertexIndices = []),
        (this.vertexCount = 0),
        (this.elements = []),
        (this.elementCount = 0);
    }
    return (
      (e.prototype.dot_ = function (t, i) {
        return t[0] * i[0] + t[1] * i[1] + t[2] * i[2];
      }),
      (e.prototype.normalize_ = function (t) {
        var i = t[0] * t[0] + t[1] * t[1] + t[2] * t[2];
        if (!i) throw "Zero-size vector!";
        (i = Math.sqrt(i)), (t[0] /= i), (t[1] /= i), (t[2] /= i);
      }),
      (e.prototype.longAxis_ = function (t) {
        var i = 0;
        return (
          Math.abs(t[1]) > Math.abs(t[0]) && (i = 1),
          Math.abs(t[2]) > Math.abs(t[i]) && (i = 2),
          i
        );
      }),
      (e.prototype.computeNormal_ = function (t) {
        var i,
          r,
          s,
          a,
          n,
          o,
          l = [0, 0, 0],
          h = [0, 0, 0],
          u = [0, 0, 0],
          c = [0, 0, 0],
          d = [0, 0, 0],
          p = [null, null, null],
          f = [null, null, null],
          m = this.mesh.vHead;
        i = m.next;
        for (var g = 0; g < 3; ++g)
          (a = i.coords[g]), (h[g] = a), (f[g] = i), (l[g] = a), (p[g] = i);
        for (i = m.next; i !== m; i = i.next)
          for (var y = 0; y < 3; ++y)
            (a = i.coords[y]),
              a < h[y] && ((h[y] = a), (f[y] = i)),
              a > l[y] && ((l[y] = a), (p[y] = i));
        var x = 0;
        if (
          (l[1] - h[1] > l[0] - h[0] && (x = 1),
          l[2] - h[2] > l[x] - h[x] && (x = 2),
          h[x] >= l[x])
        ) {
          (t[0] = 0), (t[1] = 0), (t[2] = 1);
          return;
        }
        for (
          o = 0,
            r = f[x],
            s = p[x],
            u[0] = r.coords[0] - s.coords[0],
            u[1] = r.coords[1] - s.coords[1],
            u[2] = r.coords[2] - s.coords[2],
            i = m.next;
          i !== m;
          i = i.next
        )
          (c[0] = i.coords[0] - s.coords[0]),
            (c[1] = i.coords[1] - s.coords[1]),
            (c[2] = i.coords[2] - s.coords[2]),
            (d[0] = u[1] * c[2] - u[2] * c[1]),
            (d[1] = u[2] * c[0] - u[0] * c[2]),
            (d[2] = u[0] * c[1] - u[1] * c[0]),
            (n = d[0] * d[0] + d[1] * d[1] + d[2] * d[2]),
            n > o && ((o = n), (t[0] = d[0]), (t[1] = d[1]), (t[2] = d[2]));
        o <= 0 && ((t[0] = t[1] = t[2] = 0), (t[this.longAxis_(u)] = 1));
      }),
      (e.prototype.checkOrientation_ = function () {
        for (
          var t = this.mesh.fHead, i, r = this.mesh.vHead, s, a = 0, n = t.next;
          n !== t;
          n = n.next
        )
          if (((s = n.anEdge), !(s.winding <= 0)))
            do (a += (s.Org.s - s.Dst.s) * (s.Org.t + s.Dst.t)), (s = s.Lnext);
            while (s !== n.anEdge);
        if (a < 0) {
          for (i = r.next; i !== r; i = i.next) i.t = -i.t;
          (this.tUnit[0] = -this.tUnit[0]),
            (this.tUnit[1] = -this.tUnit[1]),
            (this.tUnit[2] = -this.tUnit[2]);
        }
      }),
      (e.prototype.projectPolygon_ = function () {
        var t = this.mesh.vHead,
          i = [0, 0, 0],
          r,
          s,
          a = !1;
        (i[0] = this.normal[0]),
          (i[1] = this.normal[1]),
          (i[2] = this.normal[2]),
          !i[0] && !i[1] && !i[2] && (this.computeNormal_(i), (a = !0)),
          (r = this.sUnit),
          (s = this.tUnit);
        var n = this.longAxis_(i);
        (r[n] = 0),
          (r[(n + 1) % 3] = 1),
          (r[(n + 2) % 3] = 0),
          (s[n] = 0),
          (s[(n + 1) % 3] = 0),
          (s[(n + 2) % 3] = i[n] > 0 ? 1 : -1);
        for (var o = t.next; o !== t; o = o.next)
          (o.s = this.dot_(o.coords, r)), (o.t = this.dot_(o.coords, s));
        a && this.checkOrientation_();
        for (var l = !0, h = t.next; h !== t; h = h.next)
          l
            ? ((this.bmin[0] = this.bmax[0] = h.s),
              (this.bmin[1] = this.bmax[1] = h.t),
              (l = !1))
            : (h.s < this.bmin[0] && (this.bmin[0] = h.s),
              h.s > this.bmax[0] && (this.bmax[0] = h.s),
              h.t < this.bmin[1] && (this.bmin[1] = h.t),
              h.t > this.bmax[1] && (this.bmax[1] = h.t));
      }),
      (e.prototype.addWinding_ = function (t, i) {
        (t.winding += i.winding), (t.Sym.winding += i.Sym.winding);
      }),
      (e.prototype.tessellateMonoRegion_ = function (t, i) {
        var r, s;
        if (((r = i.anEdge), !(r.Lnext !== r && r.Lnext.Lnext !== r)))
          throw "Mono region invalid";
        for (; St.vertLeq(r.Dst, r.Org); r = r.Lprev);
        for (; St.vertLeq(r.Org, r.Dst); r = r.Lnext);
        s = r.Lprev;
        for (var a = void 0; r.Lnext !== s; )
          if (St.vertLeq(r.Dst, s.Org)) {
            for (
              ;
              s.Lnext !== r &&
              (St.edgeGoesLeft(s.Lnext) ||
                St.edgeSign(s.Org, s.Dst, s.Lnext.Dst) <= 0);

            )
              (a = t.connect(s.Lnext, s)), (s = a.Sym);
            s = s.Lprev;
          } else {
            for (
              ;
              s.Lnext !== r &&
              (St.edgeGoesRight(r.Lprev) ||
                St.edgeSign(r.Dst, r.Org, r.Lprev.Org) >= 0);

            )
              (a = t.connect(r, r.Lprev)), (r = a.Sym);
            r = r.Lnext;
          }
        if (s.Lnext === r) throw "Mono region invalid";
        for (; s.Lnext.Lnext !== r; ) (a = t.connect(s.Lnext, s)), (s = a.Sym);
        return !0;
      }),
      (e.prototype.tessellateInterior_ = function (t) {
        for (var i, r = t.fHead.next; r !== t.fHead; r = i)
          if (((i = r.next), r.inside && !this.tessellateMonoRegion_(t, r)))
            return !1;
        return !0;
      }),
      (e.prototype.discardExterior_ = function (t) {
        for (var i, r = t.fHead.next; r !== t.fHead; r = i)
          (i = r.next), r.inside || t.zapFace(r);
      }),
      (e.prototype.setWindingNumber_ = function (t, i, r) {
        for (var s, a = t.eHead.next; a !== t.eHead; a = s)
          (s = a.next),
            a.Rface.inside !== a.Lface.inside
              ? (a.winding = a.Lface.inside ? i : -i)
              : r
              ? t.delete(a)
              : (a.winding = 0);
      }),
      (e.prototype.getNeighbourFace_ = function (t) {
        return !t.Rface || !t.Rface.inside ? -1 : t.Rface.n;
      }),
      (e.prototype.outputPolymesh_ = function (t, i, r, s) {
        var a,
          n = 0,
          o = 0,
          l;
        r > 3 && t.mergeConvexFaces(r);
        for (var h = t.vHead.next; h !== t.vHead; h = h.next) h.n = -1;
        for (var u = t.fHead.next; u !== t.fHead; u = u.next)
          if (((u.n = -1), !!u.inside)) {
            (a = u.anEdge), (l = 0);
            do {
              var h = a.Org;
              h.n === -1 && ((h.n = o), o++), l++, (a = a.Lnext);
            } while (a !== u.anEdge);
            if (l > r) throw "Face vertex greater that support polygon";
            (u.n = n), ++n;
          }
        (this.elementCount = n),
          i === yr.CONNECTED_POLYGONS && (n *= 2),
          (this.elements = []),
          (this.elements.length = n * r),
          (this.vertexCount = o),
          (this.vertices = []),
          (this.vertices.length = o * s),
          (this.vertexIndices = []),
          (this.vertexIndices.length = o);
        for (var h = t.vHead.next; h !== t.vHead; h = h.next)
          if (h.n !== -1) {
            var c = h.n * s;
            (this.vertices[c + 0] = h.coords[0]),
              (this.vertices[c + 1] = h.coords[1]),
              s > 2 && (this.vertices[c + 2] = h.coords[2]),
              (this.vertexIndices[h.n] = h.idx);
          }
        for (var d = 0, u = t.fHead.next; u !== t.fHead; u = u.next)
          if (u.inside) {
            (a = u.anEdge), (l = 0);
            do {
              var h = a.Org;
              (this.elements[d++] = h.n), l++, (a = a.Lnext);
            } while (a !== u.anEdge);
            for (var p = l; p < r; ++p) this.elements[d++] = -1;
            if (i === yr.CONNECTED_POLYGONS) {
              a = u.anEdge;
              do
                (this.elements[d++] = this.getNeighbourFace_(a)), (a = a.Lnext);
              while (a !== u.anEdge);
              for (var f = l; f < r; ++f) this.elements[d++] = -1;
            }
          }
      }),
      (e.prototype.outputContours_ = function (t, i) {
        var r,
          s,
          a = 0,
          n = 0;
        (this.vertexCount = 0), (this.elementCount = 0);
        for (var o = t.fHead.next; o !== t.fHead; o = o.next)
          if (o.inside) {
            s = r = o.anEdge;
            do this.vertexCount++, (r = r.Lnext);
            while (r !== s);
            this.elementCount++;
          }
        (this.elements = []),
          (this.elements.length = this.elementCount * 2),
          (this.vertices = []),
          (this.vertices.length = this.vertexCount * i),
          (this.vertexIndices = []),
          (this.vertexIndices.length = this.vertexCount);
        var l = 0,
          h = 0,
          u = 0;
        a = 0;
        for (var o = t.fHead.next; o !== t.fHead; o = o.next)
          if (o.inside) {
            (n = 0), (s = r = o.anEdge);
            do
              (this.vertices[l++] = r.Org.coords[0]),
                (this.vertices[l++] = r.Org.coords[1]),
                i > 2 && (this.vertices[l++] = r.Org.coords[2]),
                (this.vertexIndices[h++] = this.vertexIdCallback
                  ? this.vertexIdCallback(r)
                  : r.Org.idx),
                n++,
                (r = r.Lnext);
            while (r !== s);
            (this.elements[u++] = a), (this.elements[u++] = n), (a += n);
          }
      }),
      (e.prototype.addContour = function (t, i) {
        this.mesh === null && (this.mesh = new fA()),
          t < 2 && (t = 2),
          t > 3 && (t = 3);
        for (var r = null, s = 0; s < i.length; s += t)
          r === null
            ? ((r = this.mesh.makeEdge()), this.mesh.splice(r, r.Sym))
            : (this.mesh.splitEdge(r), (r = r.Lnext)),
            (r.Org.coords[0] = i[s + 0]),
            (r.Org.coords[1] = i[s + 1]),
            t > 2 ? (r.Org.coords[2] = i[s + 2]) : (r.Org.coords[2] = 0),
            (r.Org.idx = this.vertexIndexCounter++),
            this.edgeCreateCallback && this.edgeCreateCallback(r),
            (r.winding = 1),
            (r.Sym.winding = -1);
      }),
      (e.prototype.tesselate = function (t, i, r, s, a, n) {
        if (
          (t === void 0 && (t = Ci.ODD),
          i === void 0 && (i = yr.POLYGONS),
          n === void 0 && (n = !0),
          (this.vertices = []),
          (this.elements = []),
          (this.vertexIndices = []),
          (this.vertexIndexCounter = 0),
          a &&
            ((this.normal[0] = a[0]),
            (this.normal[1] = a[1]),
            (this.normal[2] = a[2])),
          (this.windingRule = t),
          s < 2 && (s = 2),
          s > 3 && (s = 3),
          !this.mesh)
        )
          return !1;
        this.projectPolygon_(), TW.computeInterior(this, n);
        var o = this.mesh;
        return (
          i === yr.BOUNDARY_CONTOURS
            ? this.setWindingNumber_(o, 1, !0)
            : this.tessellateInterior_(o),
          n && o.check(),
          i === yr.BOUNDARY_CONTOURS
            ? this.outputContours_(o, s)
            : this.outputPolymesh_(o, i, r, s),
          !0
        );
      }),
      e
    );
  })();
function nl(e) {
  var t = e.windingRule,
    i = t === void 0 ? Ci.ODD : t,
    r = e.elementType,
    s = r === void 0 ? yr.POLYGONS : r,
    a = e.polySize,
    n = a === void 0 ? 3 : a,
    o = e.vertexSize,
    l = o === void 0 ? 2 : o,
    h = e.normal,
    u = h === void 0 ? [0, 0, 1] : h,
    c = e.contours,
    d = c === void 0 ? [] : c,
    p = e.strict,
    f = p === void 0 ? !0 : p,
    m = e.debug,
    g = m === void 0 ? !1 : m;
  if (!d && f) throw new Error("Contours can't be empty");
  if (d) {
    var y = new PW();
    e.edgeCreateCallback && (y.edgeCreateCallback = e.edgeCreateCallback),
      e.vertexIdCallback && (y.vertexIdCallback = e.vertexIdCallback);
    for (var x = 0; x < d.length; x++) y.addContour(l || 2, d[x]);
    return (
      y.tesselate(i, s, n, l, u, f),
      {
        vertices: y.vertices,
        vertexIndices: y.vertexIndices,
        vertexCount: y.vertexCount,
        elements: y.elements,
        elementCount: y.elementCount,
        mesh: g ? y.mesh : void 0,
      }
    );
  }
}
var Qee = Ci.ODD,
  Zee = Ci.NONZERO,
  Kee = Ci.POSITIVE,
  Jee = Ci.NEGATIVE,
  $ee = Ci.ABS_GEQ_TWO,
  ete = yr.POLYGONS,
  tte = yr.CONNECTED_POLYGONS,
  ite = yr.BOUNDARY_CONTOURS,
  C1 = class {
    constructor(e = 256, t = !1) {
      (this.capacity = e),
        (this.size = 0),
        (this.debug = t),
        this.debug && console.log(`allocating with cap ${e}`);
      let i = e * C1.eSize;
      this.buffer = new ArrayBuffer(i);
      let r = Float32Array.BYTES_PER_ELEMENT,
        s = 0;
      (this.positions = new Float32Array(this.buffer, s * r, 3 * e)),
        (s += 3 * e),
        (this.normals = new Float32Array(this.buffer, s * r, 3 * e)),
        (s += 3 * e),
        (this.uvs = new Float32Array(this.buffer, s * r, 2 * e));
    }
    realloc(e, t = !1) {
      if (e < this.size) throw Error("cannot shrink buffer");
      if (e <= this.capacity && !t) return;
      this.debug && console.log(`resizing from ${this.capacity} \u2192 ${e}`);
      let i = e * C1.eSize,
        r = new ArrayBuffer(i),
        s = Float32Array.BYTES_PER_ELEMENT,
        a = 0,
        n = new Float32Array(r, a * s, 3 * e);
      a += 3 * e;
      let o = new Float32Array(r, a * s, 3 * e);
      a += 3 * e;
      let l = new Float32Array(r, a * s, 2 * e);
      t
        ? (n.set(this.positions.subarray(0, this.size * 3)),
          o.set(this.normals.subarray(0, this.size * 3)),
          l.set(this.uvs.subarray(0, this.size * 2)))
        : (n.set(this.positions), o.set(this.normals), l.set(this.uvs)),
        (this.buffer = r),
        (this.positions = n),
        (this.normals = o),
        (this.uvs = l),
        (this.capacity = e);
    }
    get(e = 1) {
      let t = this.size + e;
      if (t > this.capacity) {
        let r = this.capacity;
        for (; t > r; ) r *= 2;
        this.realloc(r);
      }
      let i = this.size;
      return (this.size = t), i;
    }
    reserve(e) {
      let t = this.size + e;
      t > this.capacity && this.realloc(t);
    }
    shrink() {
      this.debug &&
        console.log(`shrinking ${this.capacity} \u2192 ${this.size}`),
        this.realloc(this.size, !0);
    }
  },
  d3 = C1;
d3.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
var DW = Sr(BO()),
  ub = {
    vertices: [160, 160, -160, 160, -160, -160, 160, -160],
    vertexIndices: [1, 0, 3, 2],
    vertexCount: 4,
    elements: [0, 4],
    elementCount: 1,
    mesh: void 0,
  },
  p3 = {
    vertices: [],
    vertexIndices: [],
    vertexCount: 0,
    elements: [],
    elementCount: 0,
    mesh: void 0,
  },
  f3 = {
    vertices: [-160, 160, 160, -160, 160, 160, -160, -160],
    vertexIndices: [1, 3, 0, 2],
    vertexCount: 4,
    elements: [0, 1, 2, 1, 0, 3],
    elementCount: 2,
    mesh: void 0,
  },
  u0 =
    (e, t) =>
    ([i, r]) => (r < i && (r += t), (e >= i ? e : e + t) <= r),
  db = class extends yt {
    constructor(e, t, i = 0, r = 12, s = 3, a = Ci.ODD, n = !1) {
      super(),
        (this.forPathBevel = n),
        (this.type = "ShapeGeometry"),
        (this.vertexCache = {}),
        (this._shape = e),
        (this._depth = t),
        (this._curveSegments = r),
        (this._bevelSegmentsInput = s);
      let o = this._shape.extractShapePointsToFlatArray([], r),
        l = this._shape.shapeHoles.map((T) => {
          let P = T.extractShapePointsToFlatArray([], r),
            R = [];
          for (let z = P.length - 1; z >= 1; z -= 2) {
            let N = P[z - 1],
              L = P[z - 0];
            R.push(N, L);
          }
          return R;
        }),
        h = [],
        u = [];
      for (let T = 0; T < o.length; T += 2) u.push([o[T], o[T + 1]]);
      h.push(u);
      for (let T = 0; T < l.length; T++) {
        let P = l[T],
          R = [];
        for (let z = 0; z < P.length; z += 2) R.push([P[z], P[z + 1]]);
        h.push(R);
      }
      let c;
      e.isText
        ? (c =
            new DC()
              .setFromPoints(e.points.map((T) => T.position))
              .getSize(new re())
              .length() * 0.1)
        : h[0].length === 0
        ? (c = i)
        : (c = (0, DW.default)(h).distance),
        i <= 0
          ? ((this._bevel = 0), (this._bevelSegments = 0))
          : ((this._bevel = Math.min(i, c, t / 2)),
            (this._bevelSegments = Math.floor(s)));
      let d;
      try {
        d = nl({
          windingRule: a,
          elementType: yr.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [o],
        });
      } catch {
        d = ub;
      }
      let p;
      try {
        p = nl({
          windingRule: Ci.ODD,
          elementType: yr.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [...l],
        });
      } catch {
        p = p3;
      }
      if (!d) throw new Error("error generating geometry");
      let f = d.elementCount;
      if (p) {
        d.elementCount += p.elementCount;
        for (let T = 0; T < p.elements.length; T++) {
          let P = p.elements[T],
            R = T % 2 === 0 ? d.vertexCount : 0;
          d.elements.push(P + R);
        }
        for (let T = 0; T < p.vertexIndices.length; T++) {
          let P = p.vertexIndices[T],
            R = d.vertexCount;
          d.vertexIndices.push(P + R);
        }
        for (let T = 0; T < p.vertices.length; T++) {
          let P = p.vertices[T];
          d.vertices.push(P);
        }
      }
      let m = 1 / 0,
        g = -1 / 0,
        y = 1 / 0,
        x = -1 / 0;
      for (let T = 0, P = d.vertexCount; T < P; T++) {
        let R = T * 2,
          z = d.vertices[R + 0],
          N = d.vertices[R + 1];
        z < m && (m = z), z > g && (g = z), N < y && (y = N), N > x && (x = N);
      }
      (this._minX = m),
        (this._minY = y),
        (this._width = g - m),
        (this._height = x - y),
        (this._buffer = new d3(this._computeBufferEstimatedSize(d)));
      let b = [],
        _ = [];
      for (let T = d.elementCount - 1; T >= 0; T--) {
        let P = T >= f,
          R = T * 2,
          z = d.elements[R + 0],
          N = d.elements[R + 1],
          L = z + N,
          G = { start: z, count: N, normals: [], continuous: [], concave: [] },
          Y = z,
          Z = L - 1,
          q = z + 1,
          oe = this._shape.roundedCurves.length;
        do {
          let ae = Y - z,
            de = d.vertices[Z * 2 + 0],
            ne = d.vertices[Z * 2 + 1],
            Ee = d.vertices[Y * 2 + 0],
            me = d.vertices[Y * 2 + 1],
            Ae = d.vertices[q * 2 + 0],
            ye = d.vertices[q * 2 + 1],
            Ue = Ee - de,
            Le = me - ne,
            Te = Math.sqrt(Ue * Ue + Le * Le);
          (Ue /= Te), (Le /= Te);
          let tt = Ee - Ae,
            Je = me - ye,
            rt = Math.sqrt(tt * tt + Je * Je);
          (tt /= rt),
            (Je /= rt),
            (G.normals[ae * 2 + 0] = -Je),
            (G.normals[ae * 2 + 1] = tt),
            (G.concave[ae] = Ue * Je - Le * tt > 0);
          let st = d.vertexIndices[Y];
          if (Array.isArray(st)) G.continuous[ae] = !1;
          else {
            let [Ze, Qe] = this._shape.getCurveIndexFromVertexId(st - 1, !0);
            if (Qe > 0 && Qe < 1) G.continuous[ae] = !0;
            else {
              let pt = Qe === 1 ? Ze + 1 : Ze - 1;
              pt = (pt + oe) % oe;
              let bt = Qe === 1 ? 0 : 1,
                $ = this._shape.roundedCurves[Ze].getTangent(Qe),
                W = this._shape.roundedCurves[pt].getTangent(bt);
              G.continuous[ae] = $.dot(W) > 0.95;
            }
          }
          P && ((G.normals[ae * 2 + 0] *= -1), (G.normals[ae * 2 + 1] *= -1)),
            ([Z, Y, q] = [Y, q, q + 1]),
            q >= L && (q -= N);
        } while (q !== z + 1);
        let ce = [];
        ce.push({
          bevelI: 0,
          angle: 0,
          size: 0,
          boundary: {
            vertices: d.vertices.slice(z * 2, L * 2),
            vertexCount: N,
            vertexIndices: new Array(N).fill(!0).map((ae, de) => [de, de]),
            elements: [0, N],
            elementCount: 1,
            mesh: null,
          },
          reverseMap: [],
          insetPoints: d.vertices.slice(z * 2, L * 2),
        });
        let ie = 0;
        for (let ae = 1; ae <= this._bevelSegments; ae++) {
          let de = ((ae / this._bevelSegments) * Math.PI) / 2,
            ne = (1 - Math.cos(de)) * this._bevel,
            Ee = [],
            me = [],
            Ae = [],
            ye = [],
            Ue = 0;
          for (let Te = 0; Te < N; Te++) {
            let tt = Te * 2,
              Je = ((Te - 1 + N) % N) * 2,
              rt = d.vertices[G.start * 2 + tt + 0],
              st = d.vertices[G.start * 2 + tt + 1],
              Ze = -G.normals[Je + 0] * ne,
              Qe = -G.normals[Je + 1] * ne,
              pt = -G.normals[tt + 0] * ne,
              bt = -G.normals[tt + 1] * ne;
            if (G.concave[Te] || (!G.concave[Te] && P)) {
              let $ = Math.atan2(Qe, Ze),
                W = Math.atan2(bt, pt);
              W > $ && (W -= Math.PI * 2);
              let _e = W - $;
              if (G.continuous[Te] || P) {
                let Ge = $ + _e / 2,
                  V = Math.cos(Ge) * ne,
                  De = Math.sin(Ge) * ne;
                (Ee[2 * Ue + 0] = rt + V * (P ? -1 : 1)),
                  (Ee[2 * Ue + 1] = st + De * (P ? -1 : 1)),
                  (ye[Ue] = Te),
                  Ue++;
              } else {
                let Ge = Math.max(
                  1,
                  Math.floor(((r / 4) * Math.abs(_e)) / Math.PI)
                );
                for (let V = 0; V <= Ge; V++) {
                  let De = $ + _e * (V / Ge),
                    ct = Math.cos(De) * ne,
                    We = Math.sin(De) * ne;
                  (Ee[2 * Ue + 0] = rt + ct),
                    (Ee[2 * Ue + 1] = st + We),
                    (ye[Ue] = Te),
                    Ue++;
                }
              }
            } else
              (Ee[2 * Ue + 0] = rt + Ze),
                (Ee[2 * Ue + 1] = st + Qe),
                (ye[Ue] = Te),
                (me[Te] = Ue),
                Ue++,
                (Ee[2 * Ue + 0] = rt),
                (Ee[2 * Ue + 1] = st),
                (ye[Ue] = Te),
                Ue++,
                (Ee[2 * Ue + 0] = rt + pt),
                (Ee[2 * Ue + 1] = st + bt),
                (ye[Ue] = Te),
                (Ae[Te] = Ue),
                Ue++;
          }
          let Le = nl({
            windingRule: Ci.POSITIVE,
            elementType: yr.BOUNDARY_CONTOURS,
            vertexSize: 2,
            strict: !0,
            contours: [Ee],
            edgeCreateCallback: (Te) => {
              let tt = Te.Org.idx,
                Je = ye[tt],
                rt = ye[(tt + 1) % ye.length];
              (Te.idx = [Je, rt]), (Te.Sym.idx = [rt, Je]);
            },
            vertexIdCallback: (Te) => {
              let tt = Te.Lprev.idx;
              return [tt ? tt[1] : 0, Te.idx ? Te.idx[0] : 0];
            },
          });
          if (!Le)
            throw (
              (console.log("Error"),
              new Error(`error generating bevel geometry for ${ae}'th loop`))
            );
          if (!Le.vertexCount) {
            let Te = (((ae - 1) / this._bevelSegments) * Math.PI) / 2;
            ie = (1 - Math.sin(Te)) * this._bevel;
            break;
          }
          for (let Te = 0; Te < Le.vertexIndices.length; Te++) {
            let [tt, Je] = Le.vertexIndices[Te];
            if (tt === Je) continue;
            let rt = Je;
            Je < tt && (rt += N);
            for (let st = tt; st < rt; st++) {
              let Ze = st % N,
                Qe = (st + 1) % N;
              if (!G.continuous[Ze] || !G.continuous[Qe]) {
                (Le.vertexIndices[Te] = [tt, Ze]),
                  Le.vertexIndices.splice(Te + 1, 0, [Qe, Je]),
                  Le.vertices.splice(
                    (Te + 1) * 2,
                    0,
                    Le.vertices[Te * 2],
                    Le.vertices[Te * 2 + 1]
                  );
                break;
              }
            }
          }
          ce.push({
            bevelI: ae,
            angle: de,
            size: ne,
            boundary: Le,
            reverseMap: ye,
            insetPoints: Ee,
          });
        }
        let te = (ae, de, ne) => {
            let Ee = 0,
              me = ae.boundary.vertexIndices.length;
            for (; Ee < me && ne(ae.boundary.vertexIndices[de]); )
              (de = (de + 1) % me), Ee++;
            return Ee;
          },
          ue = b.length;
        for (let ae = 1; ae < ce.length; ae++) {
          let de = ce[ae - 1],
            ne = ce[ae],
            Ee = de.boundary.vertexIndices.length,
            me = ne.boundary.vertexIndices.length;
          if (!Ee || !me) break;
          let Ae = G.concave.length,
            ye = 0,
            Ue = u0(ye, N);
          for (
            ;
            !de.boundary.vertexIndices.filter(Ue).length ||
            !ne.boundary.vertexIndices.filter(Ue).length;

          )
            ye++, (Ue = u0(ye, N));
          let Le = de.boundary.vertexIndices.findIndex(Ue),
            Te = ne.boundary.vertexIndices.findIndex(Ue);
          do Le = (Le + 1) % Ee;
          while (Ue(de.boundary.vertexIndices[Le]));
          do Te = (Te + 1) % me;
          while (Ue(ne.boundary.vertexIndices[Te]));
          ye = (ye + 1) % N;
          let tt = ye,
            Je = 0,
            rt = this._buildBevelVert(G, de, (Le - 1 + Ee) % Ee, void 0, Je),
            st = this._buildBevelVert(G, ne, (Te - 1 + me) % me, void 0, Je),
            Ze = rt,
            Qe = st,
            pt,
            bt,
            $ = !1;
          do {
            (Je = (ye || Ae) / Ae), (Ue = u0(ye, N));
            let W = te(de, Le, Ue),
              _e = te(ne, Te, Ue),
              Ge = $;
            if ((($ = !1), W && !_e)) {
              for (let V = 0; V < W; V++)
                (pt = this._buildBevelVert(
                  G,
                  de,
                  (Le + V) % Ee,
                  V / (W - 1),
                  Je
                )),
                  b.push(Ze.topN, pt.topP, Qe.topN),
                  n === !1 && b.push(pt.bottomP, Ze.bottomN, Qe.bottomN),
                  (Ze = pt);
              $ = !0;
            } else if (!W && _e)
              for (let V = 0; V < _e; V++)
                (bt = this._buildBevelVert(
                  G,
                  ne,
                  (Te + V) % me,
                  V / (_e - 1),
                  Je
                )),
                  b.push(Qe.topN, Ze.topP, bt.topP),
                  n === !1 && b.push(Ze.bottomP, Qe.bottomN, bt.bottomP),
                  (Qe = bt);
            else if (W && _e)
              if (
                ((pt = this._buildBevelVert(G, de, Le, 0, Je)),
                (bt = this._buildBevelVert(G, ne, Te, 0, Je)),
                Ge
                  ? (b.push(Ze.topN, bt.topP, Qe.topN),
                    b.push(Ze.topN, pt.topP, bt.topP),
                    n === !1 &&
                      (b.push(bt.bottomP, Ze.bottomN, Qe.bottomN),
                      b.push(bt.bottomP, pt.bottomP, Ze.bottomN)))
                  : (b.push(Qe.topN, Ze.topN, pt.topP),
                    b.push(Qe.topN, pt.topP, bt.topP),
                    n === !1 &&
                      (b.push(pt.bottomP, Ze.bottomN, Qe.bottomN),
                      b.push(pt.bottomP, Qe.bottomN, bt.bottomP))),
                (Ze = pt),
                (Qe = bt),
                W === _e)
              )
                for (let V = 1; V < W; V++)
                  (pt = this._buildBevelVert(
                    G,
                    de,
                    (Le + V) % Ee,
                    V / (W - 1),
                    Je
                  )),
                    (bt = this._buildBevelVert(
                      G,
                      ne,
                      (Te + V) % me,
                      V / (_e - 1),
                      Je
                    )),
                    b.push(Ze.topN, pt.topP, Qe.topN),
                    b.push(Qe.topN, pt.topP, bt.topP),
                    n === !1 &&
                      (b.push(pt.bottomP, Ze.bottomN, Qe.bottomN),
                      b.push(pt.bottomP, Qe.bottomN, bt.bottomP)),
                    (Ze = pt),
                    (Qe = bt);
              else if (W > _e) {
                let V = W / _e,
                  De = 0;
                for (let ct = 1; ct < W; ct++)
                  (pt = this._buildBevelVert(
                    G,
                    de,
                    (Le + ct) % Ee,
                    ct / (W - 1),
                    Je
                  )),
                    b.push(Ze.topN, pt.topP, Qe.topN),
                    n === !1 && b.push(pt.bottomP, Ze.bottomN, Qe.bottomN),
                    (Ze = pt),
                    ct > (De + 1) * V &&
                      (De++,
                      (bt = this._buildBevelVert(
                        G,
                        ne,
                        (Te + De) % me,
                        De / (_e - 1),
                        Je
                      )),
                      b.push(Qe.topN, pt.topP, bt.topP),
                      n === !1 && b.push(pt.bottomP, Qe.bottomN, bt.bottomP),
                      (Qe = bt));
              } else {
                let V = _e / W,
                  De = 0;
                for (let ct = 1; ct < _e; ct++)
                  (bt = this._buildBevelVert(
                    G,
                    ne,
                    (Te + ct) % me,
                    ct / (_e - 1),
                    Je
                  )),
                    b.push(Qe.topN, pt.topP, bt.topP),
                    n === !1 && b.push(pt.bottomP, Qe.bottomN, bt.bottomP),
                    (Qe = bt),
                    ct > (De + 1) * V &&
                      (De++,
                      (pt = this._buildBevelVert(
                        G,
                        de,
                        (Le + De) % Ee,
                        De / (W - 1),
                        Je
                      )),
                      b.push(Ze.topN, pt.topP, Qe.topN),
                      n === !1 && b.push(pt.bottomP, Ze.bottomN, Qe.bottomN),
                      (Ze = pt));
              }
            (Le = (Le + W) % Ee), (Te = (Te + _e) % me), (ye = (ye + 1) % Ae);
          } while (ye !== tt);
        }
        if (
          (n === !1 &&
            this._depth > this._bevel * 2 &&
            this._buildWall(ce, G, b),
          P)
        ) {
          let ae = [];
          for (let de = b.length - 1; de >= ue + 2; de -= 3) {
            let ne = b[de - 2],
              Ee = b[de - 1],
              me = b[de - 0];
            ae.push(me, Ee, ne);
          }
          b.splice(ue, b.length - ue, ...ae);
        }
        if (P) {
          let ae = [];
          for (
            let de = ce[ce.length - 1].boundary.vertices.length - 1;
            de >= 1;
            de -= 2
          ) {
            let ne = ce[ce.length - 1].boundary.vertices[de - 1],
              Ee = ce[ce.length - 1].boundary.vertices[de - 0];
            ae.push(ne, Ee);
          }
          _.push(ae);
        }
        if (!P) {
          let ae = ce[ce.length - 1],
            de;
          try {
            de = nl({
              windingRule: ce.length > 1 ? Ci.POSITIVE : Ci.ODD,
              elementType: yr.POLYGONS,
              vertexSize: 2,
              strict: !0,
              contours: [ae.insetPoints, ..._],
            });
          } catch {
            de = f3;
          }
          if (!de) throw new Error("Error generating geometry for surface");
          l.length === 0 &&
            this._bevel < c &&
            Object.assign(this, { useNgonForTopBottomFaceDuringBake: !0 });
          for (let ne = 0; ne < de.elementCount * 3; ne += 3) {
            let Ee = this._buildSurfaceVert(de, de.elements[ne + 0], ie),
              me = this._buildSurfaceVert(de, de.elements[ne + 1], ie),
              Ae = this._buildSurfaceVert(de, de.elements[ne + 2], ie);
            b.push(Ee.top, me.top, Ae.top),
              n === !1 && b.push(Ae.bottom, me.bottom, Ee.bottom);
          }
        }
        this.vertexCache = {};
      }
      this._buffer.shrink();
      let S = new It(Uint32Array.from(b), 1),
        M = new It(this._buffer.positions, 3),
        C = new It(this._buffer.normals, 3),
        A = new It(this._buffer.uvs, 2);
      (M.needsUpdate = !0),
        (C.needsUpdate = !0),
        (A.needsUpdate = !0),
        (S.needsUpdate = !0),
        this.setAttribute("position", M),
        this.setAttribute("normal", C),
        this.setAttribute("uv", A),
        this.setIndex(S);
    }
    _computeBufferEstimatedSize(e) {
      return e.vertexCount * 2 * (2 + this._bevelSegments);
    }
    _buildWall(e, t, i) {
      let r = e[0];
      for (let s = 0, a = r.boundary.vertexCount; s < a; s++) {
        let n = this._buildBevelVert(t, r, s),
          o = this._buildBevelVert(t, r, (s + 1) % a);
        i.push(o.topP, n.topN, n.bottomN), i.push(o.topP, n.bottomN, o.bottomP);
      }
    }
    _buildSurfaceVert(e, t, i) {
      let r = t.toString();
      if (r in this.vertexCache) return this.vertexCache[r];
      let s = e.vertices[t * 2 + 0],
        a = e.vertices[t * 2 + 1],
        n = (s - this._minX) / this._width,
        o = (a - this._minY) / this._height;
      this.forPathBevel && (o = 1);
      let l = this._buffer.get(this.forPathBevel ? 1 : 2),
        h = l * 3,
        u = l * 2,
        c = { top: l + 0, bottom: l + 1 };
      return (
        (this._buffer.positions[h + 0] = s),
        (this._buffer.positions[h + 1] = a),
        (this._buffer.positions[h + 2] = this.forPathBevel
          ? this._bevel
          : this._depth - i),
        (this._buffer.normals[h + 0] = 0),
        (this._buffer.normals[h + 1] = 0),
        (this._buffer.normals[h + 2] = 1),
        (this._buffer.uvs[u + 0] = n),
        (this._buffer.uvs[u + 1] = o),
        this.forPathBevel === !1 &&
          ((this._buffer.positions[h + 3] = s),
          (this._buffer.positions[h + 4] = a),
          (this._buffer.positions[h + 5] = i),
          (this._buffer.normals[h + 3] = 0),
          (this._buffer.normals[h + 4] = 0),
          (this._buffer.normals[h + 5] = -1),
          (this._buffer.uvs[u + 2] = n),
          (this._buffer.uvs[u + 3] = o)),
        (this.vertexCache[r] = c),
        c
      );
    }
    _buildBevelVert(e, t, i, r = 1, s) {
      let a = `${t.bevelI}:${i}`;
      if (
        a in this.vertexCache &&
        s !== 0 &&
        s !== 1 &&
        (!s || s === this.vertexCache[a].pathBevelUCoord)
      )
        return this.vertexCache[a];
      let [n, o] = t.boundary.vertexIndices[i],
        l,
        h,
        u,
        c;
      n !== o
        ? ((h = n), (l = o), (c = !1), (u = e.continuous[h] && e.continuous[l]))
        : ((l = n),
          (h = (l - 1 + e.count) % e.count),
          (c = e.concave[l] && t.bevelI > 0),
          (u = e.continuous[l] || c));
      let d = Math.cos(t.angle),
        p = Math.sin(t.angle),
        f = i * 2,
        m = l * 2,
        g = h * 2,
        y = t.boundary.vertices[f + 0],
        x = t.boundary.vertices[f + 1],
        b = (1 - p) * this._bevel,
        _ = (y - this._minX) / this._width,
        S = (x - this._minY) / this._height;
      this.forPathBevel && (s !== void 0 && (_ = s), (S = 1));
      let M = e.normals[m + 0],
        C = e.normals[m + 1],
        A = e.normals[g + 0],
        T = e.normals[g + 1];
      if (c) {
        let L = A - M,
          G = T - C;
        (M = M + L * (1 - r)), (C = C + G * (1 - r));
        let Y = Math.sqrt(M * M + C * C);
        (M /= Y), (C /= Y);
      }
      let P = this.forPathBevel
          ? this._buffer.get(u ? 1 : 2)
          : this._buffer.get(u ? 2 : 4),
        R = P * 3,
        z = P * 2,
        N = {
          i,
          fi: l,
          topP: P + 0,
          topN: P + 0,
          bottomP: P + 1,
          bottomN: P + 1,
          pathBevelUCoord: s,
        };
      return (
        (this._buffer.positions[R + 0] = y),
        (this._buffer.positions[R + 1] = x),
        (this._buffer.positions[R + 2] =
          (this.forPathBevel ? this._bevel : this._depth) - b),
        (this._buffer.normals[R + 0] = M * d),
        (this._buffer.normals[R + 1] = C * d),
        (this._buffer.normals[R + 2] = p),
        (this._buffer.uvs[z + 0] = _),
        (this._buffer.uvs[z + 1] = S),
        this.forPathBevel === !1 &&
          ((this._buffer.positions[R + 3] = y),
          (this._buffer.positions[R + 4] = x),
          (this._buffer.positions[R + 5] = b),
          (this._buffer.normals[R + 3] = M * d),
          (this._buffer.normals[R + 4] = C * d),
          (this._buffer.normals[R + 5] = -p),
          (this._buffer.uvs[z + 2] = S),
          (this._buffer.uvs[z + 3] = _)),
        u ||
          (this.forPathBevel
            ? ((P += 1), (R += 3), (z += 2))
            : ((P += 2), (R += 6), (z += 4)),
          (N.topP = P + 0),
          (N.bottomP = P + 1),
          (this._buffer.positions[R + 0] = y),
          (this._buffer.positions[R + 1] = x),
          (this._buffer.positions[R + 2] =
            (this.forPathBevel ? this._bevel : this._depth) - b),
          (this._buffer.normals[R + 0] = A * d),
          (this._buffer.normals[R + 1] = T * d),
          (this._buffer.normals[R + 2] = p),
          (this._buffer.uvs[z + 0] = _),
          (this._buffer.uvs[z + 1] = S),
          this.forPathBevel === !1 &&
            ((this._buffer.positions[R + 3] = y),
            (this._buffer.positions[R + 4] = x),
            (this._buffer.positions[R + 5] = b),
            (this._buffer.normals[R + 3] = A * d),
            (this._buffer.normals[R + 4] = T * d),
            (this._buffer.normals[R + 5] = -p),
            (this._buffer.uvs[z + 2] = S),
            (this._buffer.uvs[z + 3] = _))),
        (this.vertexCache[a] = N),
        N
      );
    }
    clone() {
      let e = new db(
        this._shape,
        this._depth,
        this._bevel,
        this._curveSegments,
        this._bevelSegmentsInput
      );
      return (e.userData = Dg(this.userData)), e;
    }
  },
  m3 = class extends yt {
    constructor(e, t = 12, i = {}) {
      super(),
        (this.type = "ShapeGeometry"),
        (this.windingRule = Ci.ODD),
        (this.elementType = yr.POLYGONS),
        (this.polySize = 3),
        (this.vertexSize = 2),
        (this.strict = !0),
        (this._shape = e),
        (this._curveSegments = t),
        (this._triangulationOptions = Object.assign(
          {
            windingRule: Ci.ODD,
            elementType: yr.POLYGONS,
            polySize: 3,
            vertexSize: 2,
            strict: !0,
          },
          i
        ));
      let r = this._shape.extractShapePointsToFlatArray(
          [],
          this._curveSegments
        ),
        s = this._shape.shapeHoles.map((d) =>
          d.extractShapePointsToFlatArray([], this._curveSegments)
        ),
        a,
        n = !0,
        o = !0,
        l,
        h;
      for (let d = 0, p = r.length / 2; d < p; d++) {
        let f = d * 2,
          m = r[f + 0],
          g = r[f + 1];
        if (
          (l !== void 0 && m !== l && (n = !1),
          h !== void 0 && g !== h && (o = !1),
          (l = m),
          (h = g),
          !n && !o)
        )
          break;
      }
      if (!n && !o)
        try {
          a = nl({
            contours: [r, ...s],
            windingRule: this._triangulationOptions.windingRule,
            elementType: this._triangulationOptions.elementType,
            polySize: this._triangulationOptions.polySize,
            vertexSize: this._triangulationOptions.vertexSize,
            strict: this._triangulationOptions.strict,
          });
        } catch {
          a = ub;
        }
      let u = a?.vertexCount ?? 1,
        c = a?.elementCount ?? 1;
      if (
        ((this._positionAttribute = new It(new Float32Array(u * 3), 3)),
        (this._normalAttribute = new It(new Float32Array(u * 3), 3)),
        (this._uvAttribute = new It(new Float32Array(u * 2), 2)),
        (this._indexAttribute = new It(new Uint32Array(c * 3), 1)),
        a)
      ) {
        let d = 1 / 0,
          p = -1 / 0,
          f = 1 / 0,
          m = -1 / 0;
        for (let x = 0, b = u; x < b; x++) {
          let _ = x * 2,
            S = a.vertices[_ + 0],
            M = a.vertices[_ + 1];
          S < d && (d = S),
            S > p && (p = S),
            M < f && (f = M),
            M > m && (m = M);
        }
        let g = p - d,
          y = m - f;
        for (let x = 0, b = u; x < b; x++) {
          let _ = x * 2,
            S = a.vertices[_ + 0],
            M = a.vertices[_ + 1],
            C = (S - d) / g,
            A = (M - f) / y;
          this._positionAttribute.setXYZ(x, S, M, 0),
            this._normalAttribute.setXYZ(x, 0, 0, 1),
            this._uvAttribute.setXY(x, C, A);
        }
        for (let x = 0, b = c; x < b; x++) {
          let _ = x * 3,
            S = a.elements[_ + 0],
            M = a.elements[_ + 1],
            C = a.elements[_ + 2];
          this._indexAttribute.setX(_ + 0, S),
            this._indexAttribute.setX(_ + 1, M),
            this._indexAttribute.setX(_ + 2, C);
        }
      }
      this.setAttribute("position", this._positionAttribute),
        this.setAttribute("normal", this._normalAttribute),
        this.setAttribute("uv", this._uvAttribute),
        this.setIndex(this._indexAttribute),
        this.setDrawRange(0, (a?.elementCount ?? 1) * 3);
    }
    clone() {
      let e = new m3(this._shape, this._curveSegments);
      return (e.userData = Dg(this.userData)), e;
    }
  },
  g3 = class extends db {
    constructor(e, t, i = 0, r = 12, s = 3, a = Ci.ODD) {
      super(e, t, i, r, s, a), (this.type = "ShapeGeometry");
    }
    _computeBufferEstimatedSize(e) {
      return e.vertexCount * 2 * (2 + this._bevelSegments);
    }
    _buildWall(e, t, i) {
      let r = e[0];
      for (let s = 0, a = r.boundary.vertexCount; s < a; s++) {
        let n = this._buildBevelVert(t, r, s),
          o = this._buildBevelVert(t, r, (s + 1) % a);
        i.push(o.topP, n.topN, n.bottomN), i.push(o.topP, n.bottomN, o.bottomP);
      }
    }
    clone() {
      let e = new g3(
        this._shape,
        this._depth,
        this._bevel,
        this._curveSegments,
        this._bevelSegmentsInput
      );
      return (e.userData = Dg(this.userData)), e;
    }
  },
  wh = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
          {},
          t?.parameters ?? {
            width: 100,
            subdivisions: 40,
            roundness: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 3,
            windingRule: Ci.ODD,
          },
          e.parameters
        ),
        r = Math.abs(i.width),
        s = Math.abs(i.height ?? i.width),
        a = Math.abs(i.depth ?? 0),
        n = e.shape ?? t?.shape,
        o = n?.roundness ?? i.roundness;
      n !== void 0 &&
        (n instanceof er
          ? (n.width !== r || n.height !== s) && n.applySize(r, s)
          : (n = new er(r, s).fromJSON(n)),
        e.parameters?.roundness !== void 0 &&
          e.parameters?.roundness > 0 &&
          n.update());
      let l = n ?? new er(r, s);
      return {
        parameters: Object.assign(i, {
          width: r,
          height: s,
          depth: a,
          roundness: o,
        }),
        shape: l,
      };
    }
    static build(e) {
      let {
        depth: t,
        extrudeBevelSize: i,
        extrudeBevelSegments: r,
        subdivisions: s,
        roundness: a,
        windingRule: n,
      } = e.parameters;
      e.shape.roundness = a;
      let o;
      return (
        t <= 0
          ? (o = new m3(e.shape, s, { windingRule: n }))
          : (o = new g3(e.shape, t, i, s, r, n)),
        Object.assign(o, { userData: { ...e, type: "VectorGeometry" } })
      );
    }
  },
  v3 = Math.PI * 2,
  pb = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          depth: 0,
          spikes: 64,
          angle: 360,
          innerRadius: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
        },
        e.parameters
      );
      return (
        (i.angle = dt.clamp(i.angle, 0, 360)),
        {
          shape: e.shape && e.shape instanceof er ? e.shape : new er(),
          parameters: Object.assign(i, {
            width: Math.abs(i.width),
            height: Math.abs(i.height ?? i.width),
            depth: Math.abs(i.depth ?? 0),
          }),
        }
      );
    }
    static build(e) {
      let {
          width: t,
          height: i,
          spikes: r,
          angle: s,
          innerRadius: a,
          depth: n,
          extrudeBevelSize: o,
          extrudeBevelSegments: l,
        } = e.parameters,
        h = e.shape,
        u = t * 0.5,
        c = i * 0.5,
        d = OW(h, u, c, (s * Math.PI) / 180, r, a);
      (h.isClosed = !0), h.update();
      let p;
      return (
        s === 0
          ? ((p = new yt()), p.setAttribute("position", new ot([], 3)))
          : (p = wh.create({
              shape: h,
              parameters: {
                subdivisions: d,
                depth: n,
                extrudeBevelSize: o,
                extrudeBevelSegments: l,
              },
            })),
        Object.assign(p, { userData: { ...e, type: "EllipseGeometry" } })
      );
    }
  };
function OW(e, t, i, r, s, a) {
  if (r >= v3)
    return s > 30 || s % 4 === 0
      ? (RW(e, t, i, a), Math.round(s / 4))
      : yA(e, r, s, t, i, a);
  r = Math.max(r, 0.001);
  let n = { x: 0, y: i },
    o = r + Math.PI * 0.5,
    l = { x: Math.cos(o) * t, y: Math.sin(o) * i },
    h = MW({
      px: n.x,
      py: n.y,
      cx: l.x,
      cy: l.y,
      rx: t,
      ry: i,
      largeArcFlag: r > Math.PI,
      sweepFlag: !0,
    });
  return s > 30 || s % h.length === 0
    ? IW(e, n.x, n.y, h, s, t, i, a)
    : yA(e, r, s, t, i, a);
}
function IW(e, t, i, r, s, a, n, o) {
  let l = Math.round(s / r.length);
  e.addPoint(Lc(t, i));
  for (let h = 0, u = r.length; h < u; h++) {
    let c = r[h],
      d = e.points[h],
      p = Lc(c.x, c.y);
    d.controls[1].position.set(c.x1, c.y1),
      p.controls[0].position.set(c.x2, c.y2),
      e.addPoint(p);
  }
  return o > 0 ? y3(e, a, n, o) : e.addPoint(Lc(0, 0)), l;
}
function yA(e, t, i, r, s, a) {
  let n = -t / i;
  for (let o = 0; o <= i; o++) {
    let l = n * o,
      h = Math.sin(l) * r,
      u = Math.cos(l) * s;
    e.addPoint(Lc(h, u));
  }
  return (
    t < v3
      ? a > 0
        ? y3(e, r, s, a)
        : e.addPoint(Lc(0, 0))
      : (e.removePoint(e.points[e.points.length - 1]), a > 0 && x3(e, r, s, a)),
    1
  );
}
function RW(e, t, i, r = 0, s = 0, a = 0) {
  let n = 0.5522847498,
    o = t * n,
    l = i * n;
  e.addPoint(Ef(s - t, a, s - t, a - l, s - t, a + l)),
    e.addPoint(Ef(s, a + i, s - o, a + i, s + o, a + i)),
    e.addPoint(Ef(s + t, a, s + t, a + l, s + t, a - l)),
    e.addPoint(Ef(s, a - i, s + o, a - i, s - o, a - i)),
    r > 0 && x3(e, t, i, r);
}
function Lc(e, t) {
  return new Rc(dt.generateUUID(), new re(e, t));
}
function Ef(e, t, i, r, s, a) {
  let n = Lc(e, t);
  return n.controls[0].position.set(i, r), n.controls[1].position.set(s, a), n;
}
function y3(e, t, i, r) {
  b3(e, t, i, r).forEach((s) => e.addPoint(s));
}
function x3(e, t, i, r) {
  let s = b3(e, t, i, r),
    a = new er();
  s.forEach((n) => a.addPoint(n)), (a.isClosed = !0), e.shapeHoles.push(a);
}
function b3(e, t, i, r) {
  let s = (r * t) / 100,
    a = s * (Math.abs(i) / Math.abs(t)),
    n = new re(s / t, a / i),
    o = e.points
      .map((l) => {
        let h = l.clone();
        return (h.uuid = dt.generateUUID()), h;
      })
      .reverse();
  return (
    o.forEach((l) => {
      l.position.multiply(n);
      let h = l.controls[0].position.clone().multiply(n),
        u = l.controls[1].position.clone().multiply(n);
      l.controls[0].position.copy(u), l.controls[1].position.copy(h);
    }),
    o
  );
}
var LW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
          {},
          t?.parameters ?? {
            width: 100,
            revolutions: 2,
            segments: 40,
            pathRadius: 10,
            pathType: 0,
            pathSegments: 30,
            cornerRadius: 30,
            cornerSegments: 4,
          },
          e.parameters
        ),
        r = Math.abs(i.width),
        s = Math.abs(i.height ?? r),
        a = Math.abs(i.depth ?? r),
        n = Math.abs(Math.min(r, a)) / 2;
      return {
        parameters: Object.assign(i, {
          width: r,
          height: s,
          depth: a,
          radius: n,
          segments: Math.round(i.segments),
          pathSegments: Math.round(i.pathSegments),
          cornerSegments: Math.round(i.cornerSegments),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          radius: s,
          revolutions: a,
          segments: n,
          pathRadius: o,
          pathType: l,
          pathSegments: h,
          cornerRadius: u,
          cornerSegments: c,
        } = e.parameters,
        d = new w3(!1, t, i, r, s, a, n, o, l, h, u, c);
      return Object.assign(d, { userData: { ...e, type: "HelixGeometry" } });
    }
  },
  d0 = new Ec([0, 0, 0], 1),
  w3 = class extends yt {
    constructor(
      e = !0,
      t = 1,
      i = 1,
      r = 1,
      s = 1,
      a = 1,
      n = 1,
      o = 1,
      l = 1,
      h = 1,
      u = 1,
      c = 1
    ) {
      if ((super(), a === 0)) return;
      let d = e && a === 1;
      d && (c = 0), u > 100 && (u = 100), u === 0 && (c = 0);
      let p = () => new I(),
        f = new I(),
        m = p(),
        g = p(),
        y = p(),
        x,
        b,
        _,
        S,
        M,
        C,
        A,
        T,
        P = p(),
        R = p(),
        z = p(),
        N = p(),
        L = p(),
        G = p(),
        Y = p(),
        Z = p(),
        q = i - 2 * o + 0.001,
        oe = q / a,
        ce = Math.ceil(n * a),
        ie = ce + 1,
        te = q / ce,
        ue = -q / 2,
        ae = h + 1,
        de = (2 * Math.PI) / h,
        ne = Math.PI / 2 / c,
        Ee = 0.01,
        me = Math.min((1 - u / 100) * o, o - Ee),
        Ae = o - me,
        ye = 0,
        Ue = 2,
        Le = c * Ue + Ue,
        Te = (ae * Le) / Ue,
        tt = Te + ae * ie,
        Je = Math.max(0, ae * (ie + Le)),
        [rt, st, Ze] = [3, 3, 2].map((Fe) => Array(Je * Fe).fill(0)),
        Qe = [],
        pt = s - o;
      function bt(Fe, ut) {
        let at = Math.PI / 2;
        (C = ut * te),
          (T = (2 * Math.PI * (C % oe)) / oe + at),
          (C += ue),
          (A = Math.sin(T) * pt),
          (M = Math.cos(T) * pt),
          e ? Fe.set(M, A, C) : Fe.set(M, C, A);
      }
      bt(f, -1e-10), bt(m, 0), P.copy(f), bt(f, 1);
      let $ = f.distanceTo(m),
        W = d ? 0 : Ae + me,
        _e = $ * ce + 2 * W,
        Ge = me,
        V = _e - W;
      for (let Fe = 0; Fe <= ce; Fe++) {
        bt(g, Fe),
          Z.subVectors(g, P).normalize(),
          P.copy(g),
          G.copy(g)
            .setComponent(+e + 1, 0)
            .normalize(),
          Y.crossVectors(Z, G).normalize();
        let ut = Fe === 0,
          at = Fe === ce,
          wt = ut ? (3 * Math.PI) / 2 : ne,
          xt = ut ? Ge : V,
          ii = ut ? ae : tt,
          ui = ut ? 0 : Je - ae,
          ei = Z.clone()
            .multiplyScalar(ut ? -Ae : Ae)
            .add(g),
          ge = Z.clone()
            .multiplyScalar(ut ? -1 : 1)
            .normalize();
        for (let Ce = 0; Ce < ae; Ce++) {
          let Ye = Ce * de;
          if (
            (R.addVectors(
              f.copy(G).multiplyScalar(o * Math.cos(Ye)),
              m.copy(Y).multiplyScalar(o * Math.sin(Ye))
            ),
            z.copy(R).normalize(),
            ut || at)
          ) {
            d ||
              ((ye = ui + Ce),
              [0, 1, 2].forEach((Ke) => {
                (rt[ye * 3 + Ke] = ei.getComponent(Ke)),
                  (st[ye * 3 + Ke] = ge.getComponent(Ke));
              }),
              (Ze[ye * 2] = +at),
              (Ze[ye * 2 + 1] = Ce / h)),
              m.copy(z).multiplyScalar(me),
              y.addVectors(g, m);
            for (let Ke = 0; Ke < c; Ke++) {
              let gt = Ke * ne + wt;
              N.addVectors(
                f.copy(Z).multiplyScalar(Ae * Math.sin(gt)),
                m.copy(z).multiplyScalar(Ae * Math.cos(gt))
              ),
                L.copy(N).normalize(),
                m.addVectors(y, N),
                N.normalize(),
                (ye = ii + Ke * ae + Ce),
                [0, 1, 2].forEach((yi) => {
                  (rt[ye * 3 + yi] = m.getComponent(yi)),
                    (st[ye * 3 + yi] = L.getComponent(yi));
                });
              let Mt = +ut + Math.sin(gt);
              (Ze[ye * 2] = (xt + Ae * Mt) / _e), (Ze[ye * 2 + 1] = Ce / h);
            }
          }
          m.addVectors(g, R),
            (ye = Te + Fe * ae + Ce),
            [0, 1, 2].forEach((Ke) => {
              (rt[ye * 3 + Ke] = m.getComponent(Ke)),
                (st[ye * 3 + Ke] = z.getComponent(Ke));
            }),
            (Ze[ye * 2] = (W + Fe * $) / _e),
            (Ze[ye * 2 + 1] = Ce / h);
        }
      }
      let De = ie + 2 * c + Ue,
        ct = 1,
        [We, Be] = [+d, De - 1];
      for (let Fe = We; Fe <= Be - 1; Fe++) {
        let ut = d && Fe === Be - 1;
        for (let at = 0; at < ae - 1; at++)
          (x = Fe * ae + at),
            (b = x + 1),
            (_ = (ut ? at : x) + ae),
            (S = (ut ? at + 1 : b) + ae),
            Fe === 0
              ? Qe.push(b, S, _)
              : Fe === De - 2
              ? Qe.push(x, b, _)
              : Qe.push(x, b, _, b, S, _);
      }
      this.setIndex(Qe),
        this.setAttribute("position", new ot(rt, 3)),
        this.setAttribute("normal", new ot(st, 3)),
        this.setAttribute("uv", new ot(Ze, 2));
    }
    getClosedTorusIndicesForBooleanOrSubdiv() {
      let e = this.userData.parameters,
        t = Math.ceil(e.tubularSegments),
        i = e.radialSegments + 1,
        r = Array.from(this.getIndex().array),
        s,
        a,
        n,
        o,
        l = 6 * (t - 1) * e.radialSegments,
        h = t,
        u = h === t;
      for (let c = 0; c < e.radialSegments; c++)
        (s = h * i + c),
          (a = s + 1),
          (n = (u ? c : s) + i),
          (o = (u ? c + 1 : a) + i),
          (r[l++] = s),
          (r[l++] = a),
          (r[l++] = n),
          (r[l++] = a),
          (r[l++] = o),
          (r[l++] = n);
      return (r.length = l), (d0.array = r), (d0.count = r.length), d0;
    }
  },
  BW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          detail: s,
          corner: a,
          cornerSides: n,
        } = e.parameters,
        o = s === 0 && a !== 0 ? new _3(t * 0.5, a, n) : new xC(t * 0.5, s);
      return (
        o.scale(1, i / t, r / t),
        Object.assign(o, { userData: { ...e, type: "IcosahedronGeometry" } })
      );
    }
  },
  _3 = class extends lb {
    constructor(e = 1, t = 0.2, i = 4) {
      let r = (1 + Math.sqrt(5)) / 2,
        s = [
          -1,
          r,
          0,
          1,
          r,
          0,
          -1,
          -r,
          0,
          1,
          -r,
          0,
          0,
          -1,
          r,
          0,
          1,
          r,
          0,
          -1,
          -r,
          0,
          1,
          -r,
          r,
          0,
          -1,
          r,
          0,
          1,
          -r,
          0,
          -1,
          -r,
          0,
          1,
        ],
        a = [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ],
        n = "IcosahedronGeometry";
      super(s, a, n, e, t, i), (this.type = n);
    }
    static fromJSON(e) {
      return new _3(e.radius, e.corner, e.cornerSides);
    }
  },
  zW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      (e.parameters?.points ?? []).forEach((r) => {
        Array.isArray(r) && ((r.x = r[0]), (r.y = r[1]));
      });
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          segments: 64,
          verticalSegments: 64,
          points: [
            { x: 0, y: -50, id: 0 },
            { x: 50, y: -50, id: 1 },
            { x: 50, y: 50, id: 2 },
            { x: 0, y: 50, id: 3 },
          ],
        },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(e) {
      let { points: t, segments: i, verticalSegments: r } = e.parameters,
        s = new Am();
      s.moveTo(t[0].x, t[0].y),
        s.bezierCurveTo(t[1].x, t[1].y, t[2].x, t[2].y, t[3].x, t[3].y);
      let a = new pC(s.extractPoints(r).shape, i);
      return (
        a.rotateZ(Math.PI),
        Object.assign(a, { userData: { ...e, type: "LatheGeometry" } })
      );
    }
  },
  hn = new je(),
  p0 = new _i(),
  Cf = new I(),
  lg = class extends ls {
    constructor() {
      super(),
        (this.uuid = dt.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    applyMatrix4(e) {
      let t = new lr().getNormalMatrix(e);
      for (let i = 0, r = this.vertices.length; i < r; i++)
        this.vertices[i].applyMatrix4(e);
      for (let i = 0, r = this.faces.length; i < r; i++) {
        let s = this.faces[i];
        s.normal.applyMatrix3(t).normalize();
        for (let a = 0, n = s.vertexNormals.length; a < n; a++)
          s.vertexNormals[a].applyMatrix3(t).normalize();
      }
      return (
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    }
    rotateX(e) {
      return hn.makeRotationX(e), this.applyMatrix4(hn), this;
    }
    rotateY(e) {
      return hn.makeRotationY(e), this.applyMatrix4(hn), this;
    }
    rotateZ(e) {
      return hn.makeRotationZ(e), this.applyMatrix4(hn), this;
    }
    translate(e, t, i) {
      return hn.makeTranslation(e, t, i), this.applyMatrix4(hn), this;
    }
    scale(e, t, i) {
      return hn.makeScale(e, t, i), this.applyMatrix4(hn), this;
    }
    lookAt(e) {
      return (
        p0.lookAt(e), p0.updateMatrix(), this.applyMatrix4(p0.matrix), this
      );
    }
    fromBufferGeometry(e) {
      let t = this,
        i = e.index !== null ? e.index : void 0,
        r = e.attributes;
      if (r.position === void 0)
        return (
          console.error(
            "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
          ),
          this
        );
      let s = r.position,
        a = r.normal,
        n = r.color,
        o = r.uv,
        l = r.uv2;
      l !== void 0 && (this.faceVertexUvs[1] = []);
      for (let c = 0; c < s.count; c++)
        t.vertices.push(new I().fromBufferAttribute(s, c)),
          n !== void 0 && t.colors.push(new Et().fromBufferAttribute(n, c));
      function h(c, d, p, f) {
        let m =
            n === void 0
              ? []
              : [t.colors[c].clone(), t.colors[d].clone(), t.colors[p].clone()],
          g =
            a === void 0
              ? []
              : [
                  new I().fromBufferAttribute(a, c),
                  new I().fromBufferAttribute(a, d),
                  new I().fromBufferAttribute(a, p),
                ],
          y = new T1(c, d, p, g, m, f);
        t.faces.push(y),
          o !== void 0 &&
            t.faceVertexUvs[0].push([
              new re().fromBufferAttribute(o, c),
              new re().fromBufferAttribute(o, d),
              new re().fromBufferAttribute(o, p),
            ]),
          l !== void 0 &&
            t.faceVertexUvs[1].push([
              new re().fromBufferAttribute(l, c),
              new re().fromBufferAttribute(l, d),
              new re().fromBufferAttribute(l, p),
            ]);
      }
      let u = e.groups;
      if (u.length > 0)
        for (let c = 0; c < u.length; c++) {
          let d = u[c],
            p = d.start,
            f = d.count;
          for (let m = p, g = p + f; m < g; m += 3)
            i !== void 0
              ? h(i.getX(m), i.getX(m + 1), i.getX(m + 2), d.materialIndex)
              : h(m, m + 1, m + 2, d.materialIndex);
        }
      else if (i !== void 0)
        for (let c = 0; c < i.count; c += 3)
          h(i.getX(c), i.getX(c + 1), i.getX(c + 2));
      else for (let c = 0; c < s.count; c += 3) h(c, c + 1, c + 2);
      return (
        this.computeFaceNormals(),
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null &&
          (this.boundingSphere = e.boundingSphere.clone()),
        this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(Cf).negate(),
        this.translate(Cf.x, Cf.y, Cf.z),
        this
      );
    }
    normalize() {
      this.computeBoundingSphere();
      let e = this.boundingSphere.center,
        t = this.boundingSphere.radius,
        i = t === 0 ? 1 : 1 / t,
        r = new je();
      return (
        r.set(
          i,
          0,
          0,
          -i * e.x,
          0,
          i,
          0,
          -i * e.y,
          0,
          0,
          i,
          -i * e.z,
          0,
          0,
          0,
          1
        ),
        this.applyMatrix4(r),
        this
      );
    }
    computeFaceNormals() {
      let e = new I(),
        t = new I();
      for (let i = 0, r = this.faces.length; i < r; i++) {
        let s = this.faces[i],
          a = this.vertices[s.a],
          n = this.vertices[s.b],
          o = this.vertices[s.c];
        e.subVectors(o, n),
          t.subVectors(a, n),
          e.cross(t),
          e.normalize(),
          s.normal.copy(e);
      }
    }
    computeVertexNormals(e = !0) {
      let t = new Array(this.vertices.length);
      for (let i = 0, r = this.vertices.length; i < r; i++) t[i] = new I();
      if (e) {
        let i = new I(),
          r = new I();
        for (let s = 0, a = this.faces.length; s < a; s++) {
          let n = this.faces[s],
            o = this.vertices[n.a],
            l = this.vertices[n.b],
            h = this.vertices[n.c];
          i.subVectors(h, l),
            r.subVectors(o, l),
            i.cross(r),
            t[n.a].add(i),
            t[n.b].add(i),
            t[n.c].add(i);
        }
      } else {
        this.computeFaceNormals();
        for (let i = 0, r = this.faces.length; i < r; i++) {
          let s = this.faces[i];
          t[s.a].add(s.normal), t[s.b].add(s.normal), t[s.c].add(s.normal);
        }
      }
      for (let i = 0, r = this.vertices.length; i < r; i++) t[i].normalize();
      for (let i = 0, r = this.faces.length; i < r; i++) {
        let s = this.faces[i],
          a = s.vertexNormals;
        a.length === 3
          ? (a[0].copy(t[s.a]), a[1].copy(t[s.b]), a[2].copy(t[s.c]))
          : ((a[0] = t[s.a].clone()),
            (a[1] = t[s.b].clone()),
            (a[2] = t[s.c].clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }
    computeFlatVertexNormals() {
      this.computeFaceNormals();
      for (let e = 0, t = this.faces.length; e < t; e++) {
        let i = this.faces[e],
          r = i.vertexNormals;
        r.length === 3
          ? (r[0].copy(i.normal), r[1].copy(i.normal), r[2].copy(i.normal))
          : ((r[0] = i.normal.clone()),
            (r[1] = i.normal.clone()),
            (r[2] = i.normal.clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }
    computeMorphNormals() {
      for (let t = 0, i = this.faces.length; t < i; t++) {
        let r = this.faces[t];
        r.__originalFaceNormal
          ? r.__originalFaceNormal.copy(r.normal)
          : (r.__originalFaceNormal = r.normal.clone()),
          r.__originalVertexNormals || (r.__originalVertexNormals = []);
        for (let s = 0, a = r.vertexNormals.length; s < a; s++)
          r.__originalVertexNormals[s]
            ? r.__originalVertexNormals[s].copy(r.vertexNormals[s])
            : (r.__originalVertexNormals[s] = r.vertexNormals[s].clone());
      }
      let e = new lg();
      e.faces = this.faces;
      for (let t = 0, i = this.morphTargets.length; t < i; t++) {
        if (!this.morphNormals[t]) {
          (this.morphNormals[t] = {}),
            (this.morphNormals[t].faceNormals = []),
            (this.morphNormals[t].vertexNormals = []);
          let s = this.morphNormals[t].faceNormals,
            a = this.morphNormals[t].vertexNormals;
          for (let n = 0, o = this.faces.length; n < o; n++) {
            let l = new I(),
              h = { a: new I(), b: new I(), c: new I() };
            s.push(l), a.push(h);
          }
        }
        let r = this.morphNormals[t];
        (e.vertices = this.morphTargets[t].vertices),
          e.computeFaceNormals(),
          e.computeVertexNormals();
        for (let s = 0, a = this.faces.length; s < a; s++) {
          let n = this.faces[s],
            o = r.faceNormals[s],
            l = r.vertexNormals[s];
          o.copy(n.normal),
            l.a.copy(n.vertexNormals[0]),
            l.b.copy(n.vertexNormals[1]),
            l.c.copy(n.vertexNormals[2]);
        }
      }
      for (let t = 0, i = this.faces.length; t < i; t++) {
        let r = this.faces[t];
        (r.normal = r.__originalFaceNormal),
          (r.vertexNormals = r.__originalVertexNormals);
      }
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new ur()),
        this.boundingBox.setFromPoints(this.vertices);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Ws()),
        this.boundingSphere.setFromPoints(this.vertices);
    }
    merge(e, t, i = 0) {
      if (!(e && e.isGeometry)) {
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          e
        );
        return;
      }
      let r,
        s = this.vertices.length,
        a = this.vertices,
        n = e.vertices,
        o = this.faces,
        l = e.faces,
        h = this.colors,
        u = e.colors;
      t !== void 0 && (r = new lr().getNormalMatrix(t));
      for (let c = 0, d = n.length; c < d; c++) {
        let p = n[c].clone();
        t !== void 0 && p.applyMatrix4(t), a.push(p);
      }
      for (let c = 0, d = u.length; c < d; c++) h.push(u[c].clone());
      for (let c = 0, d = l.length; c < d; c++) {
        let p = l[c],
          f,
          m,
          g = p.vertexNormals,
          y = p.vertexColors,
          x = new T1(p.a + s, p.b + s, p.c + s);
        x.normal.copy(p.normal),
          r !== void 0 && x.normal.applyMatrix3(r).normalize();
        for (let b = 0, _ = g.length; b < _; b++)
          (f = g[b].clone()),
            r !== void 0 && f.applyMatrix3(r).normalize(),
            x.vertexNormals.push(f);
        x.color.copy(p.color);
        for (let b = 0, _ = y.length; b < _; b++)
          (m = y[b]), x.vertexColors.push(m.clone());
        (x.materialIndex = p.materialIndex + i), o.push(x);
      }
      for (let c = 0, d = e.faceVertexUvs.length; c < d; c++) {
        let p = e.faceVertexUvs[c];
        this.faceVertexUvs[c] === void 0 && (this.faceVertexUvs[c] = []);
        for (let f = 0, m = p.length; f < m; f++) {
          let g = p[f],
            y = [];
          for (let x = 0, b = g.length; x < b; x++) y.push(g[x].clone());
          this.faceVertexUvs[c].push(y);
        }
      }
    }
    mergeMesh(e) {
      if (!(e && e.isMesh)) {
        console.error(
          "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
          e
        );
        return;
      }
      e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix);
    }
    mergeVertices(e = 4) {
      let t = {},
        i = [],
        r = [],
        s = Math.pow(10, e);
      for (let o = 0, l = this.vertices.length; o < l; o++) {
        let h = this.vertices[o],
          u =
            Math.round(h.x * s) +
            "_" +
            Math.round(h.y * s) +
            "_" +
            Math.round(h.z * s);
        t[u] === void 0
          ? ((t[u] = o), i.push(this.vertices[o]), (r[o] = i.length - 1))
          : (r[o] = r[t[u]]);
      }
      let a = [];
      for (let o = 0, l = this.faces.length; o < l; o++) {
        let h = this.faces[o];
        (h.a = r[h.a]), (h.b = r[h.b]), (h.c = r[h.c]);
        let u = [h.a, h.b, h.c];
        for (let c = 0; c < 3; c++)
          if (u[c] === u[(c + 1) % 3]) {
            a.push(o);
            break;
          }
      }
      for (let o = a.length - 1; o >= 0; o--) {
        let l = a[o];
        this.faces.splice(l, 1);
        for (let h = 0, u = this.faceVertexUvs.length; h < u; h++)
          this.faceVertexUvs[h].splice(l, 1);
      }
      let n = this.vertices.length - i.length;
      return (this.vertices = i), n;
    }
    setFromPoints(e) {
      this.vertices = [];
      for (let t = 0, i = e.length; t < i; t++) {
        let r = e[t];
        this.vertices.push(new I(r.x, r.y, r.z || 0));
      }
      return this;
    }
    sortFacesByMaterialIndex() {
      let e = this.faces,
        t = e.length;
      for (let o = 0; o < t; o++) e[o]._id = o;
      function i(o, l) {
        return o.materialIndex - l.materialIndex;
      }
      e.sort(i);
      let r = this.faceVertexUvs[0],
        s = this.faceVertexUvs[1],
        a,
        n;
      r && r.length === t && (a = []), s && s.length === t && (n = []);
      for (let o = 0; o < t; o++) {
        let l = e[o]._id;
        a && a.push(r[l]), n && n.push(s[l]);
      }
      a && (this.faceVertexUvs[0] = a), n && (this.faceVertexUvs[1] = n);
    }
    toJSON() {
      let e = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON",
        },
      };
      if (
        ((e.uuid = this.uuid),
        (e.type = this.type),
        this.name !== "" && (e.name = this.name),
        this.parameters !== void 0)
      ) {
        let p = this.parameters;
        for (let f in p) p[f] !== void 0 && (e[f] = p[f]);
        return e;
      }
      let t = [];
      for (let p = 0; p < this.vertices.length; p++) {
        let f = this.vertices[p];
        t.push(f.x, f.y, f.z);
      }
      let i = [],
        r = [],
        s = {},
        a = [],
        n = {},
        o = [],
        l = {};
      for (let p = 0; p < this.faces.length; p++) {
        let f = this.faces[p],
          m = !0,
          g = !1,
          y = this.faceVertexUvs[0][p] !== void 0,
          x = f.normal.length() > 0,
          b = f.vertexNormals.length > 0,
          _ = f.color.r !== 1 || f.color.g !== 1 || f.color.b !== 1,
          S = f.vertexColors.length > 0,
          M = 0;
        if (
          ((M = h(M, 0, 0)),
          (M = h(M, 1, m)),
          (M = h(M, 2, g)),
          (M = h(M, 3, y)),
          (M = h(M, 4, x)),
          (M = h(M, 5, b)),
          (M = h(M, 6, _)),
          (M = h(M, 7, S)),
          i.push(M),
          i.push(f.a, f.b, f.c),
          i.push(f.materialIndex),
          y)
        ) {
          let C = this.faceVertexUvs[0][p];
          i.push(d(C[0]), d(C[1]), d(C[2]));
        }
        if ((x && i.push(u(f.normal)), b)) {
          let C = f.vertexNormals;
          i.push(u(C[0]), u(C[1]), u(C[2]));
        }
        if ((_ && i.push(c(f.color)), S)) {
          let C = f.vertexColors;
          i.push(c(C[0]), c(C[1]), c(C[2]));
        }
      }
      function h(p, f, m) {
        return m ? p | (1 << f) : p & ~(1 << f);
      }
      function u(p) {
        let f = p.x.toString() + p.y.toString() + p.z.toString();
        return (
          s[f] !== void 0 || ((s[f] = r.length / 3), r.push(p.x, p.y, p.z)),
          s[f]
        );
      }
      function c(p) {
        let f = p.r.toString() + p.g.toString() + p.b.toString();
        return n[f] !== void 0 || ((n[f] = a.length), a.push(p.getHex())), n[f];
      }
      function d(p) {
        let f = p.x.toString() + p.y.toString();
        return (
          l[f] !== void 0 || ((l[f] = o.length / 2), o.push(p.x, p.y)), l[f]
        );
      }
      return (
        (e.data = {}),
        (e.data.vertices = t),
        (e.data.normals = r),
        a.length > 0 && (e.data.colors = a),
        o.length > 0 && (e.data.uvs = [o]),
        (e.data.faces = i),
        e
      );
    }
    clone() {
      return new lg().copy(this);
    }
    copy(e) {
      (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = e.name);
      let t = e.vertices;
      for (let c = 0, d = t.length; c < d; c++)
        this.vertices.push(t[c].clone());
      let i = e.colors;
      for (let c = 0, d = i.length; c < d; c++) this.colors.push(i[c].clone());
      let r = e.faces;
      for (let c = 0, d = r.length; c < d; c++) this.faces.push(r[c].clone());
      for (let c = 0, d = e.faceVertexUvs.length; c < d; c++) {
        let p = e.faceVertexUvs[c];
        this.faceVertexUvs[c] === void 0 && (this.faceVertexUvs[c] = []);
        for (let f = 0, m = p.length; f < m; f++) {
          let g = p[f],
            y = [];
          for (let x = 0, b = g.length; x < b; x++) {
            let _ = g[x];
            y.push(_.clone());
          }
          this.faceVertexUvs[c].push(y);
        }
      }
      let s = e.morphTargets;
      for (let c = 0, d = s.length; c < d; c++) {
        let p = {};
        if (((p.name = s[c].name), s[c].vertices !== void 0)) {
          p.vertices = [];
          for (let f = 0, m = s[c].vertices.length; f < m; f++)
            p.vertices.push(s[c].vertices[f].clone());
        }
        if (s[c].normals !== void 0) {
          p.normals = [];
          for (let f = 0, m = s[c].normals.length; f < m; f++)
            p.normals.push(s[c].normals[f].clone());
        }
        this.morphTargets.push(p);
      }
      let a = e.morphNormals;
      for (let c = 0, d = a.length; c < d; c++) {
        let p = {};
        if (a[c].vertexNormals !== void 0) {
          p.vertexNormals = [];
          for (let f = 0, m = a[c].vertexNormals.length; f < m; f++) {
            let g = a[c].vertexNormals[f],
              y = {};
            (y.a = g.a.clone()),
              (y.b = g.b.clone()),
              (y.c = g.c.clone()),
              p.vertexNormals.push(y);
          }
        }
        if (a[c].faceNormals !== void 0) {
          p.faceNormals = [];
          for (let f = 0, m = a[c].faceNormals.length; f < m; f++)
            p.faceNormals.push(a[c].faceNormals[f].clone());
        }
        this.morphNormals.push(p);
      }
      let n = e.skinWeights;
      for (let c = 0, d = n.length; c < d; c++)
        this.skinWeights.push(n[c].clone());
      let o = e.skinIndices;
      for (let c = 0, d = o.length; c < d; c++)
        this.skinIndices.push(o[c].clone());
      let l = e.lineDistances;
      for (let c = 0, d = l.length; c < d; c++) this.lineDistances.push(l[c]);
      let h = e.boundingBox;
      h !== null && (this.boundingBox = h.clone());
      let u = e.boundingSphere;
      return (
        u !== null && (this.boundingSphere = u.clone()),
        (this.elementsNeedUpdate = e.elementsNeedUpdate),
        (this.verticesNeedUpdate = e.verticesNeedUpdate),
        (this.uvsNeedUpdate = e.uvsNeedUpdate),
        (this.normalsNeedUpdate = e.normalsNeedUpdate),
        (this.colorsNeedUpdate = e.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = e.groupsNeedUpdate),
        this
      );
    }
    toBufferGeometry() {
      let e = new FW().fromGeometry(this),
        t = new yt(),
        i = new Float32Array(e.vertices.length * 3);
      if (
        (t.setAttribute("position", Tf.call(new It(i, 3), e.vertices)),
        e.normals.length > 0)
      ) {
        let r = new Float32Array(e.normals.length * 3);
        t.setAttribute("normal", Tf.call(new It(r, 3), e.normals));
      }
      if (e.colors.length > 0) {
        let r = new Float32Array(e.colors.length * 3);
        t.setAttribute("color", xA.call(new It(r, 3), e.colors));
      }
      if (e.uvs.length > 0) {
        let r = new Float32Array(e.uvs.length * 2);
        t.setAttribute("uv", bA.call(new It(r, 2), e.uvs));
      }
      if (e.uvs2.length > 0) {
        let r = new Float32Array(e.uvs2.length * 2);
        t.setAttribute("uv2", bA.call(new It(r, 2), e.uvs2));
      }
      t.groups = e.groups;
      for (let r in e.morphTargets) {
        let s = [],
          a = e.morphTargets[r];
        for (let n = 0, o = a.length; n < o; n++) {
          let l = a[n],
            h = new ot(l.data.length * 3, 3);
          (h.name = l.name), s.push(Tf.call(h, l.data));
        }
        t.morphAttributes[r] = s;
      }
      if (e.skinIndices.length > 0) {
        let r = new ot(e.skinIndices.length * 4, 4);
        t.setAttribute("skinIndex", wA.call(r, e.skinIndices));
      }
      if (e.skinWeights.length > 0) {
        let r = new ot(e.skinWeights.length * 4, 4);
        t.setAttribute("skinWeight", wA.call(r, e.skinWeights));
      }
      return (
        e.boundingSphere !== null &&
          (t.boundingSphere = e.boundingSphere.clone()),
        e.boundingBox !== null && (t.boundingBox = e.boundingBox.clone()),
        t
      );
    }
    computeTangents() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    }
    computeLineDistances() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
    applyMatrix(e) {
      return (
        console.warn(
          "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(e)
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    static createBufferGeometryFromObject(e) {
      let t = new yt(),
        i = e.geometry;
      if (e.isPoints || e.isLine) {
        let r = new ot(i.vertices.length * 3, 3),
          s = new ot(i.colors.length * 3, 3);
        if (
          (t.setAttribute("position", Tf.call(r, i.vertices)),
          t.setAttribute("color", xA.call(s, i.colors)),
          i.lineDistances && i.lineDistances.length === i.vertices.length)
        ) {
          let a = new ot(i.lineDistances.length, 1);
          t.setAttribute("lineDistance", kW.call(a, i.lineDistances));
        }
        i.boundingSphere !== null &&
          (t.boundingSphere = i.boundingSphere.clone()),
          i.boundingBox !== null && (t.boundingBox = i.boundingBox.clone());
      } else e.isMesh && (t = i.toBufferGeometry());
      return t;
    }
  };
lg.prototype.isGeometry = !0;
var FW = class {
    constructor() {
      (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    computeGroups(e) {
      let t = [],
        i,
        r,
        s,
        a = e.faces;
      for (r = 0; r < a.length; r++) {
        let n = a[r];
        n.materialIndex !== s &&
          ((s = n.materialIndex),
          i !== void 0 && ((i.count = r * 3 - i.start), t.push(i)),
          (i = { start: r * 3, materialIndex: s }));
      }
      i !== void 0 && ((i.count = r * 3 - i.start), t.push(i)),
        (this.groups = t);
    }
    fromGeometry(e) {
      let t = e.faces,
        i = e.vertices,
        r = e.faceVertexUvs,
        s = r[0] && r[0].length > 0,
        a = r[1] && r[1].length > 0,
        n = e.morphTargets,
        o = n.length,
        l;
      if (o > 0) {
        l = [];
        for (let g = 0; g < o; g++) l[g] = { name: n[g].name, data: [] };
        this.morphTargets.position = l;
      }
      let h = e.morphNormals,
        u = h.length,
        c;
      if (u > 0) {
        c = [];
        for (let g = 0; g < u; g++) c[g] = { name: h[g].name, data: [] };
        this.morphTargets.normal = c;
      }
      let d = e.skinIndices,
        p = e.skinWeights,
        f = d.length === i.length,
        m = p.length === i.length;
      i.length > 0 &&
        t.length === 0 &&
        console.error(
          "THREE.DirectGeometry: Faceless geometries are not supported."
        );
      for (let g = 0; g < t.length; g++) {
        let y = t[g];
        this.vertices.push(i[y.a], i[y.b], i[y.c]);
        let x = y.vertexNormals;
        if (x.length === 3) this.normals.push(x[0], x[1], x[2]);
        else {
          let _ = y.normal;
          this.normals.push(_, _, _);
        }
        let b = y.vertexColors;
        if (b.length === 3) this.colors.push(b[0], b[1], b[2]);
        else {
          let _ = y.color;
          this.colors.push(_, _, _);
        }
        if (s === !0) {
          let _ = r[0][g];
          _ !== void 0
            ? this.uvs.push(_[0], _[1], _[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                g
              ),
              this.uvs.push(new re(), new re(), new re()));
        }
        if (a === !0) {
          let _ = r[1][g];
          _ !== void 0
            ? this.uvs2.push(_[0], _[1], _[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                g
              ),
              this.uvs2.push(new re(), new re(), new re()));
        }
        for (let _ = 0; _ < o; _++) {
          let S = n[_].vertices;
          l[_].data.push(S[y.a], S[y.b], S[y.c]);
        }
        for (let _ = 0; _ < u; _++) {
          let S = h[_].vertexNormals[g];
          c[_].data.push(S.a, S.b, S.c);
        }
        f && this.skinIndices.push(d[y.a], d[y.b], d[y.c]),
          m && this.skinWeights.push(p[y.a], p[y.b], p[y.c]);
      }
      return (
        this.computeGroups(e),
        (this.verticesNeedUpdate = e.verticesNeedUpdate),
        (this.normalsNeedUpdate = e.normalsNeedUpdate),
        (this.colorsNeedUpdate = e.colorsNeedUpdate),
        (this.uvsNeedUpdate = e.uvsNeedUpdate),
        (this.groupsNeedUpdate = e.groupsNeedUpdate),
        e.boundingSphere !== null &&
          (this.boundingSphere = e.boundingSphere.clone()),
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        this
      );
    }
  },
  T1 = class {
    constructor(e, t, i, r, s, a = 0) {
      (this.a = e),
        (this.b = t),
        (this.c = i),
        (this.normal = r && r.isVector3 ? r : new I()),
        (this.vertexNormals = Array.isArray(r) ? r : []),
        (this.color = s && s.isColor ? s : new Et()),
        (this.vertexColors = Array.isArray(s) ? s : []),
        (this.materialIndex = a);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.a = e.a),
        (this.b = e.b),
        (this.c = e.c),
        this.normal.copy(e.normal),
        this.color.copy(e.color),
        (this.materialIndex = e.materialIndex);
      for (let t = 0, i = e.vertexNormals.length; t < i; t++)
        this.vertexNormals[t] = e.vertexNormals[t].clone();
      for (let t = 0, i = e.vertexColors.length; t < i; t++)
        this.vertexColors[t] = e.vertexColors[t].clone();
      return this;
    }
  };
function kW(e) {
  return this.array.set(e), this;
}
function xA(e) {
  let t = this.array,
    i = 0;
  for (let r = 0, s = e.length; r < s; r++) {
    let a = e[r];
    a === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyColorsArray(): color is undefined",
        r
      ),
      (a = new Et())),
      (t[i++] = a.r),
      (t[i++] = a.g),
      (t[i++] = a.b);
  }
  return this;
}
function bA(e) {
  let t = this.array,
    i = 0;
  for (let r = 0, s = e.length; r < s; r++) {
    let a = e[r];
    a === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
        r
      ),
      (a = new re())),
      (t[i++] = a.x),
      (t[i++] = a.y);
  }
  return this;
}
function Tf(e) {
  let t = this.array,
    i = 0;
  for (let r = 0, s = e.length; r < s; r++) {
    let a = e[r];
    a === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
        r
      ),
      (a = new I())),
      (t[i++] = a.x),
      (t[i++] = a.y),
      (t[i++] = a.z);
  }
  return this;
}
function wA(e) {
  let t = this.array,
    i = 0;
  for (let r = 0, s = e.length; r < s; r++) {
    let a = e[r];
    a === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
        r
      ),
      (a = new Lt())),
      (t[i++] = a.x),
      (t[i++] = a.y),
      (t[i++] = a.z),
      (t[i++] = a.w);
  }
  return this;
}
var NW = ["a", "b", "c"];
function UW(e, t) {
  switch (t) {
    case "c":
      return e.c;
    case "b":
      return e.b;
    case "a":
    default:
      return e.a;
  }
}
function f0(e, t, i) {
  let r = Math.min(e, t),
    s = Math.max(e, t),
    a = r + "_" + s;
  return i.get(a);
}
function m0(e, t, i, r, s, a) {
  let n = Math.min(e, t),
    o = Math.max(e, t),
    l = n + "_" + o,
    h;
  if (r.has(l)) h = r.get(l);
  else {
    let u = i[n],
      c = i[o];
    (h = { a: u, b: c, newEdge: null, faces: [] }), r.set(l, h);
  }
  h.faces.push(s), a[e].edges.push(h), a[t].edges.push(h);
}
function VW(e, t, i, r) {
  let s, a, n;
  for (s = 0, a = e.length; s < a; s++) i[s] = { edges: [] };
  for (s = 0, a = t.length; s < a; s++)
    (n = t[s]),
      m0(n.a, n.b, e, r, n, i),
      m0(n.b, n.c, e, r, n, i),
      m0(n.c, n.a, e, r, n, i);
}
function Pf(e, t, i, r, s) {
  e.push(new T1(t, i, r, void 0, void 0, s));
}
function $h(e, t) {
  return Math.abs(t - e) / 2 + Math.min(e, t);
}
function Df(e, t, i, r) {
  e.push([t.clone(), i.clone(), r.clone()]);
}
var jW = class {
    constructor(e = 1) {
      this.subdivisions = e;
    }
    modify(e) {
      e instanceof yt ? (e = new lg().fromBufferGeometry(e)) : (e = e.clone()),
        e.mergeVertices();
      let t = this.subdivisions;
      for (; t-- > 0; ) this._smooth(e);
      return e.computeFaceNormals(), e.computeVertexNormals(), e;
    }
    _smooth(e) {
      let t = new I(),
        i,
        r,
        s,
        a,
        n,
        o = e.vertices,
        l = e.faces,
        h = e.faceVertexUvs[0],
        u = h !== void 0 && h.length > 0,
        c = [],
        d = new Map();
      VW(o, l, c, d);
      let p = [],
        f,
        m,
        g,
        y,
        x,
        b,
        _;
      for (let Ee of Array.from(d.keys())) {
        for (
          m = d.get(Ee),
            g = new I(),
            x = 3 / 8,
            b = 1 / 8,
            _ = m.faces.length,
            _ != 2 && ((x = 0.5), (b = 0), _ != 1),
            g.addVectors(m.a, m.b).multiplyScalar(x),
            t.set(0, 0, 0),
            a = 0;
          a < _;
          a++
        ) {
          for (
            y = m.faces[a], n = 0;
            n < 3 && ((f = o[UW(y, NW[n])]), !(f !== m.a && f !== m.b));
            n++
          );
          f && t.add(f);
        }
        t.multiplyScalar(b), g.add(t), (m.newEdge = p.length), p.push(g);
      }
      let S,
        M,
        C,
        A,
        T,
        P,
        R,
        z = [];
      for (r = 0, s = o.length; r < s; r++) {
        for (
          P = o[r],
            T = c[r].edges,
            i = T.length,
            i == 3 ? (S = 3 / 16) : i > 3 && (S = 3 / (8 * i)),
            M = 1 - i * Number(S),
            C = S,
            i <= 2 && (i == 2 ? ((M = 3 / 4), (C = 1 / 8)) : i == 1 || i == 0),
            R = P.clone().multiplyScalar(M),
            t.set(0, 0, 0),
            a = 0;
          a < i;
          a++
        )
          (A = T[a]), (f = A.a !== P ? A.a : A.b), t.add(f);
        t.multiplyScalar(Number(C)), R.add(t), z.push(R);
      }
      let N = z.concat(p),
        L = z.length,
        G,
        Y,
        Z,
        q = [],
        oe = [],
        ce,
        ie,
        te,
        ue,
        ae = new re(),
        de = new re(),
        ne = new re();
      for (r = 0, s = l.length; r < s; r++)
        (y = l[r]),
          (G = Number(f0(y.a, y.b, d).newEdge) + L),
          (Y = Number(f0(y.b, y.c, d).newEdge) + L),
          (Z = Number(f0(y.c, y.a, d).newEdge) + L),
          Pf(q, G, Y, Z, y.materialIndex),
          Pf(q, y.a, G, Z, y.materialIndex),
          Pf(q, y.b, Y, G, y.materialIndex),
          Pf(q, y.c, Z, Y, y.materialIndex),
          u &&
            ((ce = h[r]),
            (ie = ce[0]),
            (te = ce[1]),
            (ue = ce[2]),
            ae.set($h(ie.x, te.x), $h(ie.y, te.y)),
            de.set($h(te.x, ue.x), $h(te.y, ue.y)),
            ne.set($h(ie.x, ue.x), $h(ie.y, ue.y)),
            Df(oe, ae, de, ne),
            Df(oe, ie, ae, ne),
            Df(oe, te, de, ae),
            Df(oe, ue, ne, de));
      (e.vertices = N), (e.faces = q), u && (e.faceVertexUvs[0] = oe);
    }
  },
  Pr = new I(),
  HW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = e.geometry ?? t?.geometry ?? new yt().copy(new Za(100, 100, 100)),
        r;
      t === void 0
        ? (i.computeBoundingBox(),
          i.boundingBox.getSize(Pr),
          (r = { width: Pr.x, height: Pr.y, depth: Pr.z, subdivisions: 0 }))
        : (r = t.parameters);
      let s = { ...r, ...e.parameters };
      return {
        parameters: {
          width: Math.abs(s.width),
          height: Math.abs(s.height),
          depth: Math.abs(s.depth),
          subdivisions: Math.abs(s.subdivisions),
        },
        geometry: i,
      };
    }
    static build(e) {
      let { width: t, height: i, depth: r, subdivisions: s } = e.parameters,
        a = e.geometry ?? new yt().copy(new Za(100, 100, 100)),
        n = a.userData.parameters;
      n === void 0
        ? (a.computeBoundingBox(), a.boundingBox.getSize(Pr))
        : Pr.set(n.width, n.height, n.depth),
        (t !== Pr.x || i !== Pr.y || r !== Pr.z) &&
          a.scale(
            Pr.x === 0 ? 1 : t / Pr.x,
            Pr.y === 0 ? 1 : i / Pr.y,
            Pr.z === 0 ? 1 : r / Pr.z
          );
      let o = a.originalGeometry;
      try {
        s > 0
          ? (o === void 0 || n?.subdivisions !== s) &&
            (o === void 0 && (o = a),
            (a = new jW(s).modify(o).toBufferGeometry()))
          : (o !== void 0 && (a = o),
            (o = void 0),
            a.getAttribute("normal") === void 0 && a.computeVertexNormals());
      } catch {
        o !== void 0 && (a = o),
          (o = void 0),
          a.getAttribute("normal") === void 0 && a.computeVertexNormals();
      }
      return (
        o !== void 0 && Object.assign(a, { originalGeometry: o }),
        delete e.geometry,
        Object.assign(a, { userData: { ...e, type: "NonParametricGeometry" } })
      );
    }
    static loadFromUrl(e, t, i) {
      new TC(i).load(e, (r) => {
        let s = this.normalizeInputs({ geometry: r });
        r.boundingBox.getSize(Pr);
        let a = 100 / Pr.x;
        Object.assign(s.parameters, {
          width: 100,
          height: Pr.y * a,
          depth: Pr.z * a,
        }),
          t(this.build(s));
      });
    }
  },
  S3 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          depth: 0,
          spikes: 5,
          cornerRadius: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 3,
        },
        e.parameters
      );
      return {
        shape: e.shape && e.shape instanceof er ? e.shape : new er(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          spikes: r,
          cornerRadius: s,
          depth: a,
          extrudeBevelSize: n,
          extrudeBevelSegments: o,
        } = e.parameters,
        l = e.shape,
        h = t * 0.5,
        u = i * 0.5,
        c = 0,
        d = 0,
        p = (2 * Math.PI) / r;
      for (let m = 0; m < r; m++) {
        let g = p * m,
          y = c + Math.sin(g) * h,
          x = d + Math.cos(g) * u;
        l.addPoint(l.createPoint(y, x));
      }
      l.isClosed = !0;
      for (let m = 0, g = l.points.length; m < g; m++)
        l.points[m].roundness = s;
      (l.roundness = s), l.update();
      let f = wh.create({
        shape: l,
        parameters: {
          roundness: s,
          depth: a,
          extrudeBevelSize: n,
          extrudeBevelSegments: o,
        },
      });
      return Object.assign(f, { userData: { ...e, type: "PolygonGeometry" } });
    }
  },
  GW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          radialSegments: 4,
          heightSegments: 1,
          cornerRadius: 0,
          cornerSegments: 8,
          openEnded: !1,
        },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          radialSegments: s,
          heightSegments: a,
          openEnded: n,
          cornerRadius: o,
          cornerSegments: l,
        } = e.parameters,
        h = new qW(t * 0.5, i, s, a, n, o, l);
      return (
        h.scale(1, 1, r / t),
        Object.assign(h, { userData: { ...e, type: "PyramidGeometry" } })
      );
    }
  };
function Ju(e, t, i) {
  (i.x = e.x * t.x), (i.y = e.y), (i.z = e.x * t.y);
}
function g0(e, t, i, r, s, a) {
  let n = t.clone().sub(e),
    o = i.clone().sub(e),
    l = n.angleTo(o);
  if ((n.normalize(), o.normalize(), r === s)) {
    let h = n.add(o).normalize();
    a.copy(e).addScaledVector(h, r / Math.sin(l / 2));
  } else {
    let h = n.angleTo(o);
    a.copy(e),
      a.addScaledVector(n, s / Math.sin(h)),
      a.addScaledVector(o, r / Math.sin(h));
  }
}
function WW(e, t, i) {
  let r = e.clone().sub(t),
    s = i.clone().sub(t);
  return r.projectOnVector(s), r.add(t);
}
var qW = class extends yt {
    constructor(e = 0.5, t = 1, i = 4, r = 1, s = !1, a = 0, n = 4) {
      super(),
        (i = Math.floor(Math.max(3, i))),
        (r = Math.floor(r)),
        (n = Math.floor(n));
      let o = [],
        l = [],
        h = [],
        u = [],
        c = 0,
        d = t / 2,
        p = Math.PI / i,
        f = e * Math.cos(Math.PI / i),
        m = (2 * Math.PI) / i,
        g = ((i - 2) * Math.PI) / i,
        y = Math.PI - g,
        x = new I(0, -d, 0),
        b = new I(0, d, 0),
        _ = new re(e, -d),
        S = new re(f, -d),
        M = new re(0, b.y).sub(S),
        C = new re(0, b.y).sub(_),
        A = new re(M.y, -M.x).normalize(),
        T = new re(C.y, -C.x).normalize(),
        P =
          e * Math.cos(Math.PI / i) * Math.tan((Math.PI - M.angle()) / 2) -
          1e-8;
      a = Math.min(a, P);
      let R;
      {
        let q = new I(A.x, A.y, 0),
          oe = new I(Math.cos(m) * q.x, q.y, Math.sin(m) * q.x);
        R = q.angleTo(oe);
      }
      let z = a / Math.tan((Math.PI - M.angle()) / 2),
        N = a / Math.tan((Math.PI - R) / 2),
        L = new I();
      if (!s) {
        l.push(x.x, x.y, x.z), h.push(0, -1, 0), u.push(0, 0);
        let q = c++,
          oe = [],
          ce = _.clone(),
          ie = z / Math.cos(Math.PI / i);
        ce.x -= ie;
        for (let te = 0; te < i; te++) {
          let ue = (te / i) * Math.PI * 2 + p,
            ae = new re(Math.sin(ue), Math.cos(ue));
          Ju(ce, ae, L),
            l.push(L.x, L.y, L.z),
            h.push(0, -1, 0),
            u.push(0, 0),
            oe.push(c++);
        }
        for (let te = 0; te < oe.length; te++)
          o.push(oe[te], q, oe[(te + 1) % oe.length]);
      }
      let G = [];
      {
        let q = new I(),
          oe = new I(),
          ce = new I(),
          ie = new I(),
          te = new I(),
          ue = new I();
        for (let ae = 0; ae < i; ae++) {
          let de = (ae / i) * Math.PI * 2 + p,
            ne = ((ae + 0.5) / i) * Math.PI * 2 + p,
            Ee = ((ae + 1) / i) * Math.PI * 2 + p,
            me = new re(Math.sin(de), Math.cos(de)),
            Ae = new re(Math.sin(ne), Math.cos(ne)),
            ye = new re(Math.sin(Ee), Math.cos(Ee));
          Ju(_, me, oe),
            Ju(_, ye, ce),
            Ju(A, Ae, q),
            g0(b, oe, ce, N, N, ie),
            l.push(ie.x, ie.y, ie.z),
            g0(oe, b, ce, N, z, te),
            l.push(te.x, te.y, te.z),
            g0(ce, oe, b, z, N, ue),
            l.push(ue.x, ue.y, ue.z),
            h.push(q.x, q.y, q.z),
            h.push(q.x, q.y, q.z),
            h.push(q.x, q.y, q.z),
            u.push(0, 0),
            u.push(0, 0),
            u.push(0, 0);
          let Ue = c++,
            Le = c++,
            Te = c++;
          if ((o.push(Ue, Le, Te), a > 0)) {
            {
              let rt = oe.clone().add(ce).multiplyScalar(0.5),
                st = b.clone().sub(rt).normalize(),
                Ze = x
                  .clone()
                  .sub(rt)
                  .normalize()
                  .add(st)
                  .normalize()
                  .multiplyScalar(-1),
                Qe = ue.clone().sub(te);
              Y(rt, Qe, Ze, M.angle());
            }
            let tt, Je;
            {
              let rt = new I();
              Ju(T, ye, rt);
              let st = ue.clone().add(ie).multiplyScalar(0.5);
              st = WW(st, ce, b);
              let Ze = ue.clone().sub(ie);
              [tt, Je] = Y(st, Ze, rt, R, ie.y);
            }
            {
              let rt = tt,
                st = rt.clone().setY(0).normalize(),
                Ze = new I(0, -1, 0),
                Qe = st.clone().cross(Ze);
              Z(rt, st, Ze, Qe);
            }
            G.concat(Je);
            {
              let rt = M.angle(),
                st = Math.PI - rt,
                Ze = b.clone();
              Ze.y -= a / Math.sin(rt - Math.PI / 2);
              let Qe = new I(),
                pt = [];
              for (let $ = 0; $ < n; $++) {
                let W = [],
                  _e = Math.PI / 2 - (st * $) / n,
                  Ge = Math.cos(_e),
                  V = Math.sin(_e),
                  De = ne;
                for (let ct = 0; ct <= $; ct++) {
                  let We = Math.cos(De),
                    Be = Math.sin(De);
                  (q.x = Ge * Be),
                    (q.y = V),
                    (q.z = Ge * We),
                    Qe.copy(Ze).addScaledVector(q, a),
                    l.push(Qe.x, Qe.y, Qe.z),
                    h.push(q.x, q.y, q.z),
                    u.push(0, 0),
                    W.push(c++),
                    (De += (Math.PI * 2) / $ / i);
                }
                pt.push(W);
              }
              Je.reverse(), pt.push(Je);
              let bt = pt.length - 1;
              for (let $ = 0; $ < bt; $++) {
                let W = pt[$],
                  _e = pt[$ + 1],
                  Ge = W.length - 1;
                o.push(_e[1], W[0], _e[0]);
                for (let V = 1; V <= Ge; V++)
                  o.push(W[V], W[V - 1], _e[V]), o.push(_e[V + 1], W[V], _e[V]);
              }
            }
          }
        }
      }
      this.setIndex(o),
        this.setAttribute("position", new ot(l, 3)),
        this.setAttribute("normal", new ot(h, 3)),
        this.setAttribute("uv", new ot(u, 2));
      function Y(q, oe, ce, ie, te) {
        let ue = -ie / 2,
          ae = (Math.PI - ie) / 2,
          de = oe.clone().normalize().cross(ce);
        q.addScaledVector(ce, -a / Math.sin(ae));
        let ne = new I(),
          Ee = new I(),
          me = 1,
          Ae = c,
          ye = [];
        for (let Ue = 0; Ue <= n; Ue++) {
          let Le = ue + (Ue / n) * ie;
          Ee.set(0, 0, 0),
            Ee.addScaledVector(de, Math.sin(Le)),
            Ee.addScaledVector(ce, Math.cos(Le));
          for (let Te = 0; Te <= me; Te++) {
            let tt = Te / me - 0.5;
            if (
              (ne.copy(q),
              ne.addScaledVector(oe, tt),
              ne.addScaledVector(Ee, a),
              te != null)
            ) {
              let Je = Math.max(0, ne.y - te);
              ne.addScaledVector(oe, -Je / oe.y);
            }
            l.push(ne.x, ne.y, ne.z),
              h.push(Ee.x, Ee.y, Ee.z),
              u.push(0, 0),
              Te === 0 && ye.push(c),
              c++;
          }
        }
        for (let Ue = 0; Ue < n; Ue++)
          for (let Le = 0; Le < me; Le++) {
            let Te = Ae + Le + (me + 1) * Ue,
              tt = Te + (me + 1),
              Je = tt + 1,
              rt = Te + 1;
            o.push(Te, tt, rt), o.push(tt, Je, rt);
          }
        return [q.clone().addScaledVector(oe, 0.5), ye];
      }
      function Z(q, oe, ce, ie) {
        let te = Math.PI / 2,
          ue = C.angle() - te,
          ae = [],
          de = new I(),
          ne = new I();
        for (let me = 0; me <= n; me++) {
          let Ae = [],
            ye = me / n;
          for (let Ue = 0; Ue <= me; Ue++) {
            let Le = ((me ? Ue / me : 0) - 0.5) * y,
              Te = Math.cos(Le),
              tt = Math.sin(Le),
              Je = Math.atan(Math.tan(ue) * Te),
              rt = (te + Je) * ye,
              st = Math.cos(rt),
              Ze = Math.sin(rt);
            de.set(0, 0, 0),
              de.addScaledVector(oe, Ze * Te),
              de.addScaledVector(ce, st),
              de.addScaledVector(ie, Ze * tt),
              ne.copy(q).addScaledVector(de, a),
              l.push(ne.x, ne.y, ne.z),
              h.push(de.x, de.y, de.z),
              u.push(0, 0),
              Ae.push(c++);
          }
          ae.push(Ae);
        }
        let Ee = ae.length - 1;
        for (let me = 0; me < Ee; me++) {
          let Ae = ae[me],
            ye = ae[me + 1],
            Ue = Ae.length - 1;
          o.push(Ae[0], ye[1], ye[0]);
          for (let Le = 1; Le <= Ue; Le++)
            o.push(Ae[Le - 1], Ae[Le], ye[Le]),
              o.push(Ae[Le], ye[Le + 1], ye[Le]);
        }
      }
    }
  },
  fb = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
          {},
          t?.parameters ?? {
            width: 100,
            depth: 0,
            cornerRadius: [0, 0, 0, 0],
            cornerType: 1,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1,
          },
          e.parameters
        ),
        r = Object.assign(t?.ui ?? { enabledIndieCorners: !1 }, e.ui);
      return {
        shape: e.shape && e.shape instanceof er ? e.shape : new er(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
        ui: r,
      };
    }
    static build(e) {
      let t = e.shape,
        {
          width: i,
          height: r,
          cornerRadius: s,
          cornerType: a,
          depth: n,
          extrudeBevelSize: o,
          extrudeBevelSegments: l,
        } = e.parameters,
        h = { x: i * 0.5, y: r * 0.5 },
        u = { x: -h.x, y: -h.y },
        c = { x: h.x, y: h.y };
      function d(_, S, M) {
        return S > i && M > r
          ? Math.min((_ * i) / S, (_ * r) / M)
          : S > i
          ? (_ * i) / S
          : M > r
          ? (_ * r) / M
          : _;
      }
      let p = [];
      (p[0] = s[0] === 0 ? 0 : d(s[0], s[0] + s[3], s[0] + s[1])),
        (p[1] = s[1] === 0 ? 0 : d(s[1], s[1] + s[2], s[1] + s[0])),
        (p[2] = s[2] === 0 ? 0 : d(s[2], s[2] + s[1], s[2] + s[3])),
        (p[3] = s[3] === 0 ? 0 : d(s[3], s[3] + s[0], s[3] + s[2]));
      let f = u.x,
        m = c.x,
        g = c.y,
        y = u.y;
      t.addPoint(t.createPoint(f, g)),
        t.addPoint(t.createPoint(m, g)),
        t.addPoint(t.createPoint(m, y)),
        t.addPoint(t.createPoint(f, y)),
        (t.isClosed = !0);
      let x = !0;
      for (let _ = 0, S = t.points.length; _ < S; _++)
        (t.points[_].roundness = p[_]), _ > 0 && p[_] !== p[_ - 1] && (x = !1);
      x && (t.roundness = p[0]),
        (t.useCubicForRoundedCorners = a !== 1),
        t.update();
      let b = wh.create({
        shape: t,
        parameters: { depth: n, extrudeBevelSize: o, extrudeBevelSegments: l },
      });
      return Object.assign(b, {
        userData: { ...e, type: "RectangleGeometry" },
      });
    }
  },
  YW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          widthSegments: 64,
          heightSegments: 64,
          phiStart: 0,
          phiLength: 2 * Math.PI,
          thetaStart: 0,
          thetaLength: 180,
        },
        e.parameters
      );
      return (
        (i.thetaLength = dt.clamp(i.thetaLength, 0, 180)),
        {
          parameters: Object.assign(i, {
            width: Math.abs(i.width),
            height: Math.abs(i.height ?? i.width),
            depth: Math.abs(i.depth ?? i.width),
          }),
        }
      );
    }
    static build(e) {
      let {
          width: t = 100,
          height: i = t,
          depth: r = t,
          widthSegments: s = 64,
          heightSegments: a = 64,
          phiStart: n,
          phiLength: o,
          thetaStart: l,
          thetaLength: h,
        } = e.parameters,
        u;
      return (
        h === 0
          ? ((u = new yt()), u.setAttribute("position", new ot([], 3)))
          : (u = new Cc(0.5 * t, s, a, n, o, l, h * dt.DEG2RAD)),
        u.scale(1, i / t, r / t),
        Object.assign(u, { userData: { ...e, type: "SphereGeometry" } })
      );
    }
  },
  XW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          depth: 0,
          widthSegments: 8,
          heightSegments: 8,
        },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: 0,
        }),
      };
    }
    static build(e) {
      let {
          width: t = 100,
          height: i = t,
          widthSegments: r = 8,
          heightSegments: s = 8,
        } = e.parameters,
        a = new vh(t, i, r, s);
      return (
        a.scale(1, 1, 1),
        Object.assign(a, { userData: { ...e, type: "PlaneGeometry" } })
      );
    }
  },
  QW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          angle: 90,
          cornerRadius: 24,
          cornerSegments: 8,
        },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          angle: s,
          cornerRadius: a,
          cornerSegments: n,
        } = e.parameters,
        o = new ZW(t, i, r, s, a, n);
      return Object.assign(o, { userData: { ...e, type: "BackdropGeometry" } });
    }
  },
  ZW = class extends yt {
    constructor(e = 1, t = 1, i = 1, r = 90, s = 10, a = 24) {
      super(), (this.type = "BackdropGeometry");
      let n = [],
        o = [],
        l = [],
        h = 0.001;
      s == 0 && (a = 1),
        (a = Math.max(1, Math.floor(a))),
        (s = Math.min(s, 100)),
        (r = Math.min(180 - h, r)),
        (r *= Math.PI / 180);
      let u = [],
        c = Math.PI / 2,
        d = (Ee = 0, me = 0, Ae = 0) => new I(Ee, me, Ae),
        p = d(),
        f = d(),
        [m, g, y] = [t / 2, e / 2, i / 2],
        x = -g,
        b = +g,
        [_, S, M] = [d(x, -m, +y), d(x, -m, -y), d(x, +m, -y)],
        C = (Ee, me = !1) => Math.sin(Ee - Math.PI / (1 + +me)),
        A = (Ee, me = !1) => Math.cos(Ee - Math.PI / (1 + +me));
      M.y = Math.sin(r) * t - m;
      let T = Math.cos(r) * t - y,
        P = _.z - h;
      r <= c
        ? ((M.z = Math.min(T, P)),
          M.z == P && (M.y -= (T - P) / Math.tan(c - r)))
        : (S.z = Math.min(S.z - T - y, _.z - h)),
        p.subVectors(_, S),
        f.subVectors(M, S);
      let R = (Math.min(p.length(), f.length()) * s) / 100,
        z = R * Math.tan(r / 2),
        N = R / Math.cos(r / 2),
        L = p.clone().normalize().add(f.normalize()).setLength(N).add(S);
      p.set(0, C(r, !0), A(r, !0)), u.push([M, p.clone()]);
      let G = (Math.PI - r) / a;
      for (let Ee = 0; Ee <= a; Ee++) {
        let me = c + r + Ee * G;
        p.set(0, Math.sin(me) * z, Math.cos(me) * z),
          p.add(L),
          f.set(0, C(me), A(me)),
          u.push([p.clone(), f.clone()]);
      }
      u.push([_, d(0, 1, 0)]);
      let Y = Math.sin(G / 2) * z * 2,
        Z = u.length - 1,
        q = u[0][0].distanceTo(u[1][0]),
        oe = u[Z - 1][0].distanceTo(u[Z][0]),
        ce = q + Y * a + oe;
      u[0].push(1);
      for (let Ee = 0; Ee <= a; Ee++) u[Ee + 1].push(1 - (q + Ee * Y) / ce);
      u[Z].push(0);
      let [ie, te, ue] = u[0],
        ae,
        de,
        ne;
      for (let Ee = 1; Ee < u.length; Ee++)
        ([ae, de, ne] = u[Ee]),
          n.push(
            x,
            ie.y,
            ie.z,
            x,
            ae.y,
            ae.z,
            b,
            ie.y,
            ie.z,
            b,
            ie.y,
            ie.z,
            x,
            ae.y,
            ae.z,
            b,
            ae.y,
            ae.z
          ),
          o.push(
            0,
            te.y,
            te.z,
            0,
            de.y,
            de.z,
            0,
            te.y,
            te.z,
            0,
            te.y,
            te.z,
            0,
            de.y,
            de.z,
            0,
            de.y,
            de.z
          ),
          l.push(0, ue, 0, ne, 1, ue, 1, ue, 0, ne, 1, ne),
          ([ie, te, ue] = [ae, de, ne]);
      this.setAttribute("position", new ot(n, 3)),
        this.setAttribute("normal", new ot(o, 3)),
        this.setAttribute("uv", new ot(l, 2));
    }
  },
  A3 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          depth: 0,
          innerRadiusPercent: 38.19,
          spikes: 5,
          cornerRadius: 0,
          angle: 360,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
        },
        e.parameters
      );
      return {
        shape: e.shape && e.shape instanceof er ? e.shape : new er(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          innerRadiusPercent: r,
          spikes: s,
          cornerRadius: a,
          angle: n,
          depth: o,
          extrudeBevelSize: l,
          extrudeBevelSegments: h,
        } = e.parameters,
        u = e.shape,
        c = t * 0.5,
        d = i * 0.5,
        p = 0,
        f = 0,
        m = (n * Math.PI) / 360 / s,
        g = (Math.PI / 2) * 3 * -1,
        y = (c * r) / 100,
        x = (d * r) / 100;
      if (s === 3 && r === 50) {
        m = (2 * Math.PI) / s;
        for (let _ = 0; _ < s; _++) {
          let S = m * _,
            M = p + Math.sin(S) * c,
            C = f + Math.cos(S) * d;
          u.addPoint(u.createPoint(M, C));
        }
      } else
        for (let _ = 0; _ < s; _++) {
          let S = p + Math.cos(g) * c,
            M = f + Math.sin(g) * d;
          u.addPoint(u.createPoint(S, M)),
            (g += m),
            (S = p + Math.cos(g) * y),
            (M = f + Math.sin(g) * x),
            _ <= s,
            u.addPoint(u.createPoint(S, M)),
            (g += m);
        }
      u.isClosed = !0;
      for (let _ = 0, S = u.points.length; _ < S; _++)
        u.points[_].roundness = a;
      (u.roundness = a), u.update();
      let b = wh.create({
        shape: u,
        parameters: {
          roundness: a,
          depth: o,
          extrudeBevelSize: l,
          extrudeBevelSegments: h,
        },
      });
      return Object.assign(b, { userData: { ...e, type: "StarGeometry" } });
    }
  },
  KW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? { width: 100, depth: 0 },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(e) {
      let { width: t, height: i } = e.parameters,
        r = new vh(t, i);
      return Object.assign(r, {
        userData: { ...e, type: "TextFrameGeometry" },
      });
    }
  },
  JW = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
          {},
          t?.parameters ?? {
            width: 100,
            radialSegments: 32,
            tubularSegments: 64,
            arc: 360,
            cornerRadius: 30,
            cornerSegments: 8,
          },
          e.parameters
        ),
        r = Math.abs(i.width),
        s = Math.abs(i.height ?? i.width),
        a = Math.round(Math.abs(i.depth ?? i.width * 0.25));
      return {
        parameters: Object.assign(i, { width: r, height: s, depth: a }),
      };
    }
    static build(e) {
      let {
          width: t,
          height: i,
          depth: r,
          radialSegments: s,
          tubularSegments: a,
          arc: n,
          cornerRadius: o,
          cornerSegments: l,
        } = e.parameters,
        h = $W(t, i, r, t * 0.5, n, a, 0, 0, s, o, l);
      return (
        h.scale(1, i / t, 1),
        Object.assign(h, { userData: { ...e, type: "TorusGeometry" } })
      );
    }
  };
function $W(e, t, i, r, s, a, n, o, l, h, u) {
  ([t, i] = [i, t]), (n = t / 2);
  let c = dt.clamp(s / 360, 0, 1);
  if (c === 0) {
    let d = new yt();
    return d.setAttribute("position", new ot([], 3)), d;
  }
  return c === 1 && (h = 0), new w3(!0, e, t, i, r, c, a, n, o, l, h, u);
}
var e7 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          tubularSegments: 64,
          radialSegments: 32,
          p: 2,
          q: 3,
        },
        e.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
          tube: i.tube ?? i.width * 0.125,
        }),
      };
    }
    static build(e) {
      let {
          width: t,
          tube: i,
          tubularSegments: r,
          radialSegments: s,
          p: a,
          q: n,
        } = e.parameters,
        o = t * 0.5;
      o !== i && (o -= i);
      let l = new wC(o, i, r, s, a, n);
      return Object.assign(l, {
        userData: { ...e, type: "TorusKnotGeometry" },
      });
    }
  },
  t7 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
        {},
        t?.parameters ?? {
          width: 100,
          depth: 0,
          spikes: 5,
          cornerRadius: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
          isRect: !1,
        },
        e.parameters
      );
      return {
        shape: e.shape && e.shape instanceof er ? e.shape : new er(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(
            i.height ?? i.width * (i.isRect ? 1 : Math.sqrt(3) / 2)
          ),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(e) {
      let {
          width: t = 100,
          height: i,
          cornerRadius: r,
          depth: s,
          extrudeBevelSize: a,
          extrudeBevelSegments: n,
          isRect: o,
        } = e.parameters,
        l = e.shape,
        h = t * 0.5,
        u = i * 0.5;
      o
        ? (l.addPoint(l.createPoint(-h, u)),
          l.addPoint(l.createPoint(h, -u)),
          l.addPoint(l.createPoint(-h, -u)))
        : (l.addPoint(l.createPoint(0, u)),
          l.addPoint(l.createPoint(h, -u)),
          l.addPoint(l.createPoint(-h, -u))),
        (l.isClosed = !0);
      for (let d = 0, p = l.points.length; d < p; d++)
        l.points[d].roundness = r;
      (l.roundness = r), l.update();
      let c = wh.create({
        shape: l,
        parameters: {
          roundness: r,
          depth: s,
          extrudeBevelSize: a,
          extrudeBevelSegments: n,
        },
      });
      return Object.assign(c, { userData: { ...e, type: "TriangleGeometry" } });
    }
  };
function i7(e, t) {
  let i = 2 * Math.PI;
  return ((e % i) + i) % i === ((t % i) + i) % i;
}
var r7 = class {
    add(e, t, i) {
      if (typeof arguments[0] != "string")
        for (let r in arguments[0]) this.add(r, arguments[0][r], arguments[1]);
      else
        (Array.isArray(e) ? e : [e]).forEach(function (r) {
          (this[r] = this[r] || []), t && this[r][i ? "unshift" : "push"](t);
        }, this);
    }
    run(e, t) {
      (this[e] = this[e] || []),
        this[e].forEach(function (i) {
          i.call(t && t.context ? t.context : t, t);
        });
    }
  },
  s7 = class {
    constructor(e) {
      (this.jsep = e), (this.registered = {});
    }
    register(...e) {
      e.forEach((t) => {
        if (typeof t != "object" || !t.name || !t.init)
          throw new Error("Invalid JSEP plugin format");
        this.registered[t.name] ||
          (t.init(this.jsep), (this.registered[t.name] = t));
      });
    }
  },
  Re = class {
    static get version() {
      return "1.3.8";
    }
    static toString() {
      return "JavaScript Expression Parser (JSEP) v" + Re.version;
    }
    static addUnaryOp(e) {
      return (
        (Re.max_unop_len = Math.max(e.length, Re.max_unop_len)),
        (Re.unary_ops[e] = 1),
        Re
      );
    }
    static addBinaryOp(e, t, i) {
      return (
        (Re.max_binop_len = Math.max(e.length, Re.max_binop_len)),
        (Re.binary_ops[e] = t),
        i ? Re.right_associative.add(e) : Re.right_associative.delete(e),
        Re
      );
    }
    static addIdentifierChar(e) {
      return Re.additional_identifier_chars.add(e), Re;
    }
    static addLiteral(e, t) {
      return (Re.literals[e] = t), Re;
    }
    static removeUnaryOp(e) {
      return (
        delete Re.unary_ops[e],
        e.length === Re.max_unop_len &&
          (Re.max_unop_len = Re.getMaxKeyLen(Re.unary_ops)),
        Re
      );
    }
    static removeAllUnaryOps() {
      return (Re.unary_ops = {}), (Re.max_unop_len = 0), Re;
    }
    static removeIdentifierChar(e) {
      return Re.additional_identifier_chars.delete(e), Re;
    }
    static removeBinaryOp(e) {
      return (
        delete Re.binary_ops[e],
        e.length === Re.max_binop_len &&
          (Re.max_binop_len = Re.getMaxKeyLen(Re.binary_ops)),
        Re.right_associative.delete(e),
        Re
      );
    }
    static removeAllBinaryOps() {
      return (Re.binary_ops = {}), (Re.max_binop_len = 0), Re;
    }
    static removeLiteral(e) {
      return delete Re.literals[e], Re;
    }
    static removeAllLiterals() {
      return (Re.literals = {}), Re;
    }
    get char() {
      return this.expr.charAt(this.index);
    }
    get code() {
      return this.expr.charCodeAt(this.index);
    }
    constructor(e) {
      (this.expr = e), (this.index = 0);
    }
    static parse(e) {
      return new Re(e).parse();
    }
    static getMaxKeyLen(e) {
      return Math.max(0, ...Object.keys(e).map((t) => t.length));
    }
    static isDecimalDigit(e) {
      return e >= 48 && e <= 57;
    }
    static binaryPrecedence(e) {
      return Re.binary_ops[e] || 0;
    }
    static isIdentifierStart(e) {
      return (
        (e >= 65 && e <= 90) ||
        (e >= 97 && e <= 122) ||
        (e >= 128 && !Re.binary_ops[String.fromCharCode(e)]) ||
        Re.additional_identifier_chars.has(String.fromCharCode(e))
      );
    }
    static isIdentifierPart(e) {
      return Re.isIdentifierStart(e) || Re.isDecimalDigit(e);
    }
    throwError(e) {
      let t = new Error(e + " at character " + this.index);
      throw ((t.index = this.index), (t.description = e), t);
    }
    runHook(e, t) {
      if (Re.hooks[e]) {
        let i = { context: this, node: t };
        return Re.hooks.run(e, i), i.node;
      }
      return t;
    }
    searchHook(e) {
      if (Re.hooks[e]) {
        let t = { context: this };
        return (
          Re.hooks[e].find(function (i) {
            return i.call(t.context, t), t.node;
          }),
          t.node
        );
      }
    }
    gobbleSpaces() {
      let e = this.code;
      for (
        ;
        e === Re.SPACE_CODE ||
        e === Re.TAB_CODE ||
        e === Re.LF_CODE ||
        e === Re.CR_CODE;

      )
        e = this.expr.charCodeAt(++this.index);
      this.runHook("gobble-spaces");
    }
    parse() {
      this.runHook("before-all");
      let e = this.gobbleExpressions(),
        t = e.length === 1 ? e[0] : { type: Re.COMPOUND, body: e };
      return this.runHook("after-all", t);
    }
    gobbleExpressions(e) {
      let t = [],
        i,
        r;
      for (; this.index < this.expr.length; )
        if (((i = this.code), i === Re.SEMCOL_CODE || i === Re.COMMA_CODE))
          this.index++;
        else if ((r = this.gobbleExpression())) t.push(r);
        else if (this.index < this.expr.length) {
          if (i === e) break;
          this.throwError('Unexpected "' + this.char + '"');
        }
      return t;
    }
    gobbleExpression() {
      let e =
        this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
      return this.gobbleSpaces(), this.runHook("after-expression", e);
    }
    gobbleBinaryOp() {
      this.gobbleSpaces();
      let e = this.expr.substr(this.index, Re.max_binop_len),
        t = e.length;
      for (; t > 0; ) {
        if (
          Re.binary_ops.hasOwnProperty(e) &&
          (!Re.isIdentifierStart(this.code) ||
            (this.index + e.length < this.expr.length &&
              !Re.isIdentifierPart(
                this.expr.charCodeAt(this.index + e.length)
              )))
        )
          return (this.index += t), e;
        e = e.substr(0, --t);
      }
      return !1;
    }
    gobbleBinaryExpression() {
      let e, t, i, r, s, a, n, o, l;
      if (((a = this.gobbleToken()), !a || ((t = this.gobbleBinaryOp()), !t)))
        return a;
      for (
        s = {
          value: t,
          prec: Re.binaryPrecedence(t),
          right_a: Re.right_associative.has(t),
        },
          n = this.gobbleToken(),
          n || this.throwError("Expected expression after " + t),
          r = [a, s, n];
        (t = this.gobbleBinaryOp());

      ) {
        if (((i = Re.binaryPrecedence(t)), i === 0)) {
          this.index -= t.length;
          break;
        }
        (s = { value: t, prec: i, right_a: Re.right_associative.has(t) }),
          (l = t);
        let h = (u) => (s.right_a && u.right_a ? i > u.prec : i <= u.prec);
        for (; r.length > 2 && h(r[r.length - 2]); )
          (n = r.pop()),
            (t = r.pop().value),
            (a = r.pop()),
            (e = { type: Re.BINARY_EXP, operator: t, left: a, right: n }),
            r.push(e);
        (e = this.gobbleToken()),
          e || this.throwError("Expected expression after " + l),
          r.push(s, e);
      }
      for (o = r.length - 1, e = r[o]; o > 1; )
        (e = {
          type: Re.BINARY_EXP,
          operator: r[o - 1].value,
          left: r[o - 2],
          right: e,
        }),
          (o -= 2);
      return e;
    }
    gobbleToken() {
      let e, t, i, r;
      if ((this.gobbleSpaces(), (r = this.searchHook("gobble-token")), r))
        return this.runHook("after-token", r);
      if (((e = this.code), Re.isDecimalDigit(e) || e === Re.PERIOD_CODE))
        return this.gobbleNumericLiteral();
      if (e === Re.SQUOTE_CODE || e === Re.DQUOTE_CODE)
        r = this.gobbleStringLiteral();
      else if (e === Re.OBRACK_CODE) r = this.gobbleArray();
      else {
        for (
          t = this.expr.substr(this.index, Re.max_unop_len), i = t.length;
          i > 0;

        ) {
          if (
            Re.unary_ops.hasOwnProperty(t) &&
            (!Re.isIdentifierStart(this.code) ||
              (this.index + t.length < this.expr.length &&
                !Re.isIdentifierPart(
                  this.expr.charCodeAt(this.index + t.length)
                )))
          ) {
            this.index += i;
            let s = this.gobbleToken();
            return (
              s || this.throwError("missing unaryOp argument"),
              this.runHook("after-token", {
                type: Re.UNARY_EXP,
                operator: t,
                argument: s,
                prefix: !0,
              })
            );
          }
          t = t.substr(0, --i);
        }
        Re.isIdentifierStart(e)
          ? ((r = this.gobbleIdentifier()),
            Re.literals.hasOwnProperty(r.name)
              ? (r = {
                  type: Re.LITERAL,
                  value: Re.literals[r.name],
                  raw: r.name,
                })
              : r.name === Re.this_str && (r = { type: Re.THIS_EXP }))
          : e === Re.OPAREN_CODE && (r = this.gobbleGroup());
      }
      return r
        ? ((r = this.gobbleTokenProperty(r)), this.runHook("after-token", r))
        : this.runHook("after-token", !1);
    }
    gobbleTokenProperty(e) {
      this.gobbleSpaces();
      let t = this.code;
      for (
        ;
        t === Re.PERIOD_CODE ||
        t === Re.OBRACK_CODE ||
        t === Re.OPAREN_CODE ||
        t === Re.QUMARK_CODE;

      ) {
        let i;
        if (t === Re.QUMARK_CODE) {
          if (this.expr.charCodeAt(this.index + 1) !== Re.PERIOD_CODE) break;
          (i = !0), (this.index += 2), this.gobbleSpaces(), (t = this.code);
        }
        this.index++,
          t === Re.OBRACK_CODE
            ? ((e = {
                type: Re.MEMBER_EXP,
                computed: !0,
                object: e,
                property: this.gobbleExpression(),
              }),
              this.gobbleSpaces(),
              (t = this.code),
              t !== Re.CBRACK_CODE && this.throwError("Unclosed ["),
              this.index++)
            : t === Re.OPAREN_CODE
            ? (e = {
                type: Re.CALL_EXP,
                arguments: this.gobbleArguments(Re.CPAREN_CODE),
                callee: e,
              })
            : (t === Re.PERIOD_CODE || i) &&
              (i && this.index--,
              this.gobbleSpaces(),
              (e = {
                type: Re.MEMBER_EXP,
                computed: !1,
                object: e,
                property: this.gobbleIdentifier(),
              })),
          i && (e.optional = !0),
          this.gobbleSpaces(),
          (t = this.code);
      }
      return e;
    }
    gobbleNumericLiteral() {
      let e = "",
        t,
        i;
      for (; Re.isDecimalDigit(this.code); )
        e += this.expr.charAt(this.index++);
      if (this.code === Re.PERIOD_CODE)
        for (
          e += this.expr.charAt(this.index++);
          Re.isDecimalDigit(this.code);

        )
          e += this.expr.charAt(this.index++);
      if (((t = this.char), t === "e" || t === "E")) {
        for (
          e += this.expr.charAt(this.index++),
            t = this.char,
            (t === "+" || t === "-") && (e += this.expr.charAt(this.index++));
          Re.isDecimalDigit(this.code);

        )
          e += this.expr.charAt(this.index++);
        Re.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ||
          this.throwError("Expected exponent (" + e + this.char + ")");
      }
      return (
        (i = this.code),
        Re.isIdentifierStart(i)
          ? this.throwError(
              "Variable names cannot start with a number (" +
                e +
                this.char +
                ")"
            )
          : (i === Re.PERIOD_CODE ||
              (e.length === 1 && e.charCodeAt(0) === Re.PERIOD_CODE)) &&
            this.throwError("Unexpected period"),
        { type: Re.LITERAL, value: parseFloat(e), raw: e }
      );
    }
    gobbleStringLiteral() {
      let e = "",
        t = this.index,
        i = this.expr.charAt(this.index++),
        r = !1;
      for (; this.index < this.expr.length; ) {
        let s = this.expr.charAt(this.index++);
        if (s === i) {
          r = !0;
          break;
        } else if (s === "\\")
          switch (((s = this.expr.charAt(this.index++)), s)) {
            case "n":
              e += `
`;
              break;
            case "r":
              e += "\r";
              break;
            case "t":
              e += "	";
              break;
            case "b":
              e += "\b";
              break;
            case "f":
              e += "\f";
              break;
            case "v":
              e += "\v";
              break;
            default:
              e += s;
          }
        else e += s;
      }
      return (
        r || this.throwError('Unclosed quote after "' + e + '"'),
        { type: Re.LITERAL, value: e, raw: this.expr.substring(t, this.index) }
      );
    }
    gobbleIdentifier() {
      let e = this.code,
        t = this.index;
      for (
        Re.isIdentifierStart(e)
          ? this.index++
          : this.throwError("Unexpected " + this.char);
        this.index < this.expr.length &&
        ((e = this.code), Re.isIdentifierPart(e));

      )
        this.index++;
      return { type: Re.IDENTIFIER, name: this.expr.slice(t, this.index) };
    }
    gobbleArguments(e) {
      let t = [],
        i = !1,
        r = 0;
      for (; this.index < this.expr.length; ) {
        this.gobbleSpaces();
        let s = this.code;
        if (s === e) {
          (i = !0),
            this.index++,
            e === Re.CPAREN_CODE &&
              r &&
              r >= t.length &&
              this.throwError("Unexpected token " + String.fromCharCode(e));
          break;
        } else if (s === Re.COMMA_CODE) {
          if ((this.index++, r++, r !== t.length)) {
            if (e === Re.CPAREN_CODE) this.throwError("Unexpected token ,");
            else if (e === Re.CBRACK_CODE)
              for (let a = t.length; a < r; a++) t.push(null);
          }
        } else if (t.length !== r && r !== 0) this.throwError("Expected comma");
        else {
          let a = this.gobbleExpression();
          (!a || a.type === Re.COMPOUND) && this.throwError("Expected comma"),
            t.push(a);
        }
      }
      return i || this.throwError("Expected " + String.fromCharCode(e)), t;
    }
    gobbleGroup() {
      this.index++;
      let e = this.gobbleExpressions(Re.CPAREN_CODE);
      if (this.code === Re.CPAREN_CODE)
        return (
          this.index++,
          e.length === 1
            ? e[0]
            : e.length
            ? { type: Re.SEQUENCE_EXP, expressions: e }
            : !1
        );
      this.throwError("Unclosed (");
    }
    gobbleArray() {
      return (
        this.index++,
        { type: Re.ARRAY_EXP, elements: this.gobbleArguments(Re.CBRACK_CODE) }
      );
    }
  },
  a7 = new r7();
Object.assign(Re, {
  hooks: a7,
  plugins: new s7(Re),
  COMPOUND: "Compound",
  SEQUENCE_EXP: "SequenceExpression",
  IDENTIFIER: "Identifier",
  MEMBER_EXP: "MemberExpression",
  LITERAL: "Literal",
  THIS_EXP: "ThisExpression",
  CALL_EXP: "CallExpression",
  UNARY_EXP: "UnaryExpression",
  BINARY_EXP: "BinaryExpression",
  ARRAY_EXP: "ArrayExpression",
  TAB_CODE: 9,
  LF_CODE: 10,
  CR_CODE: 13,
  SPACE_CODE: 32,
  PERIOD_CODE: 46,
  COMMA_CODE: 44,
  SQUOTE_CODE: 39,
  DQUOTE_CODE: 34,
  OPAREN_CODE: 40,
  CPAREN_CODE: 41,
  OBRACK_CODE: 91,
  CBRACK_CODE: 93,
  QUMARK_CODE: 63,
  SEMCOL_CODE: 59,
  COLON_CODE: 58,
  unary_ops: { "-": 1, "!": 1, "~": 1, "+": 1 },
  binary_ops: {
    "||": 1,
    "&&": 2,
    "|": 3,
    "^": 4,
    "&": 5,
    "==": 6,
    "!=": 6,
    "===": 6,
    "!==": 6,
    "<": 7,
    ">": 7,
    "<=": 7,
    ">=": 7,
    "<<": 8,
    ">>": 8,
    ">>>": 8,
    "+": 9,
    "-": 9,
    "*": 10,
    "/": 10,
    "%": 10,
  },
  right_associative: new Set(),
  additional_identifier_chars: new Set(["$", "_"]),
  literals: { true: !0, false: !1, null: null },
  this_str: "this",
});
Re.max_unop_len = Re.getMaxKeyLen(Re.unary_ops);
Re.max_binop_len = Re.getMaxKeyLen(Re.binary_ops);
var tu = (e) => new Re(e).parse(),
  n7 = Object.getOwnPropertyNames(Re);
n7.forEach((e) => {
  tu[e] === void 0 && e !== "prototype" && (tu[e] = Re[e]);
});
tu.Jsep = Re;
var o7 = "ConditionalExpression",
  l7 = {
    name: "ternary",
    init(e) {
      e.hooks.add("after-expression", function (t) {
        if (t.node && this.code === e.QUMARK_CODE) {
          this.index++;
          let i = t.node,
            r = this.gobbleExpression();
          if (
            (r || this.throwError("Expected expression"),
            this.gobbleSpaces(),
            this.code === e.COLON_CODE)
          ) {
            this.index++;
            let s = this.gobbleExpression();
            if (
              (s || this.throwError("Expected expression"),
              (t.node = { type: o7, test: i, consequent: r, alternate: s }),
              i.operator && e.binary_ops[i.operator] <= 0.9)
            ) {
              let a = i;
              for (
                ;
                a.right.operator && e.binary_ops[a.right.operator] <= 0.9;

              )
                a = a.right;
              (t.node.test = a.right), (a.right = t.node), (t.node = i);
            }
          } else this.throwError("Expected :");
        }
      });
    },
  };
tu.plugins.register(l7);
var h7 = [
    "+",
    "-",
    "*",
    "/",
    "(",
    ")",
    "==",
    "!=",
    ">",
    "<",
    ">=",
    "<=",
    "and",
    "or",
    "!",
    "%",
    "^",
    ",",
  ],
  c7 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."],
  u7 = [
    "sin",
    "cos",
    "tan",
    "asin",
    "acos",
    "atan",
    "atan2",
    "sqrt",
    "abs",
    "log",
    "exp",
    "floor",
    "ceil",
    "round",
    "min",
    "max",
    "random",
  ];
function d7(e) {
  return typeof e != "string" ? !1 : !isNaN(e) && !isNaN(parseFloat(e));
}
tu.addBinaryOp("^", 11, !0);
function M3(e, t, i = "number") {
  let r = "";
  for (let n = 0; n < e.length; n++) {
    let o = e[n];
    if ("id" in o) {
      let l = e[n - 1];
      if (n > 0 && "id" in l) {
        console.error("Two variables in a row", e);
        return;
      }
      let h = t.getVariable(o.id),
        u = $s.getDisplayedValue(h);
      i === "number" &&
      $s.isTextValue(h) &&
      Array.isArray(h.textValue) &&
      h.textValue.length === 1
        ? (u = parseFloat(u).toString())
        : i === "boolean" && $s.isBoolean(h)
        ? (u = h ? "true" : "false")
        : i === "boolean" &&
          $s.isTextValue(h) &&
          !Array.isArray(h.textValue) &&
          (u = '"' + u + '"'),
        (r += u);
      continue;
    } else if (i === "string") {
      o.name !== '"' && o.name !== "+" && (r += o.name),
        o.name === "+" &&
          r[r.length - 1] === "\\" &&
          (r = r.slice(0, -1) + o.name);
      continue;
    }
    if (o.name === "and") {
      r += "&&";
      continue;
    }
    if (o.name === "or") {
      r += "||";
      continue;
    }
    if (o.name === "True") {
      r += "true";
      continue;
    }
    if (o.name === "False") {
      r += "false";
      continue;
    }
    if (
      i === "boolean" &&
      !d7(o.name) &&
      !c7.includes(o.name) &&
      !h7.includes(o.name) &&
      !u7.includes(o.name.replace(/\($/g, ""))
    ) {
      r += '"' + o.name + '"';
      continue;
    }
    r += o.name;
  }
  if (i === "string") return r;
  if (e.length === 0) {
    if (i === "number") return 0;
    if (i === "boolean") return !1;
  }
  let s;
  try {
    s = tu(r);
  } catch (n) {
    console.error(r, n);
    return;
  }
  let a;
  try {
    a = ci(s);
  } catch (n) {
    console.error(r, s, n);
  }
  return a;
}
function ci(e) {
  switch (e.type) {
    case "BinaryExpression":
      switch (e.operator) {
        case "==":
          return Number(ci(e.left) === ci(e.right));
        case "!=":
          return Number(ci(e.left) !== ci(e.right));
        case ">":
          return Number(ci(e.left) > ci(e.right));
        case ">=":
          return Number(ci(e.left) >= ci(e.right));
        case "<":
          return Number(ci(e.left) < ci(e.right));
        case "<=":
          return Number(ci(e.left) <= ci(e.right));
        case "+":
          return ci(e.left) + ci(e.right);
        case "-":
          return ci(e.left) - ci(e.right);
        case "*":
          return ci(e.left) * ci(e.right);
        case "/":
          return ci(e.left) / ci(e.right);
        case "%":
          return ci(e.left) % ci(e.right);
        case "&&":
          return ci(e.left) && ci(e.right);
        case "||":
          return ci(e.left) || ci(e.right);
        case "^":
          return Math.pow(ci(e.left), ci(e.right));
        default:
          throw new Error("Unknown operator: " + e.operator);
      }
    case "UnaryExpression":
      switch (e.operator) {
        case "-":
          return -ci(e.argument);
        case "!":
          return Number(!ci(e.argument));
        default:
          throw new Error("Unknown operator: " + e.operator);
      }
    case "Identifier":
      throw new Error("Unknown identifier: " + e.name);
    case "Literal":
      return e.value;
    case "CallExpression":
      if (e.callee.type === "Identifier") {
        if (e.callee.name === "random") {
          let t = 0,
            i = 1;
          if (e.arguments.length >= 1)
            try {
              t = ci(e.arguments[0]);
            } catch (r) {
              console.warn(r);
            }
          if (e.arguments.length >= 2)
            try {
              i = ci(e.arguments[1]);
            } catch (r) {
              console.warn(r);
            }
          return (
            (t = Math.min(i, t)),
            (i = Math.max(i, t)),
            t + Math.random() * (i - t)
          );
        }
        return Math[e.callee.name].apply(null, e.arguments.map(ci));
      } else throw new Error("Unknown node");
    default:
      throw new Error("Unknown node type: " + e.type);
  }
}
var p7 = new je(),
  f7 = new je();
function m7(e, t, i) {
  let r = [new I(), new I(), new I()],
    s = [new I(), new I(), new I()];
  return (
    e.extractBasis(r[0], r[1], r[2]),
    t.extractBasis(s[0], s[1], s[2]),
    r.forEach((a, n) => {
      let o = s[n],
        l = dt.lerp(a.length(), o.length(), i);
      a.lerp(o, i).setLength(l);
    }),
    new je().makeBasis(r[0], r[1], r[2])
  );
}
var g7 = class {
    static create(e) {
      return this.build(this.normalizeInputs(e));
    }
    static normalizeInputs(e, t) {
      let i = Object.assign(
          {},
          t?.parameters ?? {
            width: 100,
            height: 100,
            depth: 1,
            subdivisions: 12,
            roundness: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 3,
          },
          e.parameters
        ),
        r = Math.abs(i.width),
        s = Math.abs(i.height ?? i.width),
        a = Math.abs(i.depth ?? 0),
        n = t?.shapeData ?? pb.create({ parameters: QT }).userData.shape;
      return {
        path: e.path ?? Ym.defaultData(),
        parameters: Object.assign(i, {
          width: r,
          height: s,
          depth: a,
          extrusion: { ...ZT, ...i.extrusion },
        }),
        shapeData: n,
      };
    }
    static build(e) {
      if (e.path.points.length >= 2) {
        let t = new v7(e);
        return Object.assign(t, { userData: { ...e, type: "PathGeometry" } });
      } else
        return Object.assign(new yt(), {
          userData: { ...e, type: "PathGeometry" },
        });
    }
  },
  v7 = class extends yt {
    constructor(e) {
      super(),
        (this.type = "PathExtrusionGeometry"),
        (this.inputs = e),
        this.build();
    }
    _isGeometryClosed() {
      return (
        this.inputs.path.isClosed &&
        this.inputs.parameters.extrusion.depth === 1
      );
    }
    _isOpenEnded() {
      let e = this.inputs.parameters.extrusion;
      return (
        !(this.inputs.path.isClosed && e.depth === 1) ||
        !i7(e.twist, 0) ||
        e.startScale !== e.endScale
      );
    }
    build() {
      let e = this._extractPathPoints();
      if (e.length < 2) return;
      let t = this._computeBasisMatrices(e),
        { depth: i, offset: r } = this.inputs.parameters.extrusion;
      (i = Math.max(0, Math.min(i, 1))), (r = Math.max(0, Math.min(r, 1)));
      let s = this.inputs.path.isClosed ? e.length : e.length - 1,
        a = Math.floor(r * s),
        n = this.inputs.path.isClosed
          ? Math.ceil((i + r) * s)
          : Math.ceil(Math.min(1, i + r) * s),
        o = Math.min(Math.max(2, n - a + 1), s + 2),
        l = [],
        h = [];
      for (let Z = 0; Z < o; Z++) {
        let q = this.inputs.path.isClosed
          ? (Z + a) % e.length
          : Math.min(Z + a, e.length - 1);
        l.push(e[q].clone()), h.push(t[q].clone());
      }
      let u = (Z, q, oe) => {
          (l[Z] = l[Z].clone().lerp(l[q], oe)), (h[Z] = m7(h[Z], h[q], oe));
        },
        c = 0,
        d = (r * s) % 1;
      (!this.inputs.path.isClosed || i <= 1) &&
        (d || r === 0) &&
        ((c = d), u(0, 1, c));
      let p = 0,
        f = ((r + i) * s) % 1;
      if (
        (((this.inputs.path.isClosed && i <= 1) ||
          (!this.inputs.path.isClosed && r + i < 1)) &&
          f &&
          ((p = f), u(l.length - 1, l.length - 2, 1 - p)),
        i === 0)
      ) {
        let Z = l.length - 1;
        l[Z].copy(l[0]), h[Z].copy(h[0]);
      }
      this._applyPathModifiers(h, c, p);
      let { bevel: m, bevelSides: g } = this.inputs.parameters.extrusion,
        y = m > 0 ? this.inputs.parameters.extrusion.capType : "flat",
        x = 5;
      this.inputs.parameters.extrusion.shape.type === "Custom" &&
        (x =
          this.inputs.parameters.extrusion.shape.shapeQuality === "low"
            ? 5
            : 12);
      let { regions: b, infos: _, vertices: S } = this._computeShapePoints(x),
        M = 0,
        C;
      y === "round" &&
        ((C = new db(this.inputs.shapeData, 2 * m, m, x, g, void 0, !0)),
        (M = C.getAttribute("position").count));
      let A = 0,
        T = 0;
      _.sort((Z, q) => Z.start - q.start),
        _.forEach((Z) => {
          (Z.verticesStart = A),
            (Z.verticesCount = Z.continuous.reduce(
              (q, oe, ce) => q + (ce === 0 || !oe ? 2 : 1),
              0
            )),
            (T += Z.verticesCount),
            (A = T);
        });
      let P = T * o,
        R,
        z = 0;
      if (this._isOpenEnded() && y === "flat") {
        try {
          R = nl({
            windingRule: Ci.ODD,
            elementType: yr.POLYGONS,
            polySize: 3,
            vertexSize: 2,
            strict: !0,
            contours: b,
          });
        } catch {
          R = f3;
        }
        z = R.vertexCount;
      }
      let N = P + 2 * z + M * 2,
        L = P + 2 * z,
        G = {
          positions: new Float32Array(N * 3),
          normals: new Float32Array(N * 3),
          uvs: new Float32Array(N * 2),
        },
        Y = [];
      if (
        (_.forEach((Z) => {
          this._extrudeRegion(
            Z,
            S,
            h,
            l,
            G,
            Y,
            this._isGeometryClosed() && !this._isOpenEnded()
          );
        }),
        R &&
          (this._closeEnd(R, P, Y, G, h[0], l[0], !1),
          this._closeEnd(R, P + z, Y, G, h[h.length - 1], l[l.length - 1], !0)),
        C)
      ) {
        G.positions.set(C.getAttribute("position").array, L * 3),
          G.normals.set(C.getAttribute("normal").array, L * 3),
          G.uvs.set(C.getAttribute("uv").array, L * 2);
        let Z = Y.length;
        Y.push(...C.getIndex().array.map((ce) => ce + L)),
          (L += M),
          G.positions.set(C.getAttribute("position").array, L * 3),
          G.normals.set(C.getAttribute("normal").array, L * 3),
          G.uvs.set(C.getAttribute("uv").array, L * 2);
        let q = Y.length;
        Y.push(...C.getIndex().array.map((ce) => ce + L)),
          this.setAttribute("position", new It(G.positions, 3)),
          this.setAttribute("normal", new It(G.normals, 3)),
          this.setAttribute("uv", new It(G.uvs, 2)),
          this.setIndex(Y);
        let oe = p7;
        oe.copy(h[h.length - 1]).setPosition(l[l.length - 1]),
          this.applyMatrix4OnRange(oe, L, N),
          oe.copy(h[0]).setPosition(l[0]).multiply(f7.makeScale(1, 1, -1)),
          this.applyMatrix4OnRange(oe, L - M, L),
          this.reverseIndicesOnRange(Z, q);
      } else
        this.setAttribute("position", new It(G.positions, 3)),
          this.setAttribute("normal", new It(G.normals, 3)),
          this.setAttribute("uv", new It(G.uvs, 2)),
          this.setIndex(Y);
    }
    _extractPathPoints() {
      let e = a3(this.inputs.path).getPoints(this.inputs.path.subdivisions);
      if (e.length < 2) return [];
      let t = [e[0]];
      return (
        e.forEach((i) => {
          t[t.length - 1].distanceToSquared(i) > 0.001 && t.push(i);
        }),
        this.inputs.path.isClosed &&
          t[t.length - 1].distanceTo(t[0]) < 0.001 &&
          t.pop(),
        t
      );
    }
    _computeBasisMatrices(e) {
      let t = [],
        i = e.length,
        r = this.inputs.path.isClosed,
        s = new I(),
        a = new I(),
        n = new I(),
        o = new I(),
        l = new I(0, 1, 0);
      for (let f = 0; f < i; f++) {
        let m = e[f],
          g;
        f === 0
          ? (g = r ? e[e.length - 2] : m.clone().multiplyScalar(2).sub(e[1]))
          : (g = e[f - 1]);
        let y;
        f === i - 1
          ? (y = r
              ? e[1]
              : m
                  .clone()
                  .multiplyScalar(2)
                  .sub(e[f - 1]))
          : (y = e[f + 1]);
        let x = m.clone().sub(g).normalize(),
          b = y.clone().sub(m).normalize(),
          _ = x.clone().add(b).normalize();
        n.copy(_),
          f === 0 &&
            (_.equals(l) || _.clone().negate().equals(l)) &&
            l.set(0, 0, 1);
        let S = l.clone().cross(_).normalize(),
          M = _.clone().cross(S).normalize();
        l.copy(M), o.copy(S), f === 0 && (s.copy(M), a.copy(_));
        let C = new je().makeBasis(S, M, _);
        t.push(C);
      }
      let h = r ? a : n,
        u = r ? s : new I(0, 1, 0),
        c = h.clone().cross(o).normalize(),
        d = Math.acos(u.dot(c));
      if (isNaN(d)) return t;
      let p = u.clone().cross(c);
      h.dot(p) > 0 && (d *= -1);
      for (let f = 1; f < t.length; f++) {
        let m = new je().makeRotationZ((d * f) / t.length);
        t[f].multiply(m);
      }
      return t;
    }
    _applyPathModifiers(e, t, i) {
      let r = e.length,
        {
          angle: s,
          twist: a,
          startScale: n,
          endScale: o,
        } = this.inputs.parameters.extrusion,
        l = new je(),
        h = new je();
      return (
        e.forEach((u, c) => {
          let d =
            c === 0
              ? 0
              : c === r - 1
              ? 1
              : (c - t) / (r - (i === 0 ? 0 : 1) - (t + (1 - i)));
          l.makeRotationZ(dt.lerp(s, s + a, d) * dt.DEG2RAD);
          let p = dt.lerp(n, o, d);
          h.makeScale(p, p, p), u.multiply(l).multiply(h);
        }),
        e
      );
    }
    _computeShapePoints(e = 12, t = Ci.ODD) {
      let i = this.inputs.shapeData,
        r = i.extractShapePointsToFlatArray([], e),
        s = i.shapeHoles.map((p) => {
          let f = p.extractShapePointsToFlatArray([], e),
            m = [];
          for (let g = f.length - 1; g >= 1; g -= 2) {
            let y = f[g - 1],
              x = f[g - 0];
            m.push(y, x);
          }
          return m;
        }),
        a;
      try {
        a = nl({
          windingRule: t,
          elementType: yr.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [r],
        });
      } catch {
        a = ub;
      }
      let n;
      try {
        n = nl({
          windingRule: Ci.ODD,
          elementType: yr.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [...s],
        });
      } catch {
        n = p3;
      }
      if (!a) throw new Error("error generating geometry");
      let o = a.elementCount;
      if (n) {
        a.elementCount += n.elementCount;
        for (let p = 0; p < n.elements.length; p++) {
          let f = n.elements[p],
            m = p % 2 === 0 ? a.vertexCount : 0;
          a.elements.push(f + m);
        }
        for (let p = 0; p < n.vertexIndices.length; p++) {
          let f = n.vertexIndices[p],
            m = a.vertexCount;
          a.vertexIndices.push(f + m);
        }
        for (let p = 0; p < n.vertices.length; p++) {
          let f = n.vertices[p];
          a.vertices.push(f);
        }
      }
      let l = 1 / 0,
        h = -1 / 0,
        u = 1 / 0,
        c = -1 / 0;
      for (let p = 0, f = a.vertexCount; p < f; p++) {
        let m = p * 2,
          g = a.vertices[m + 0],
          y = a.vertices[m + 1];
        g < l && (l = g), g > h && (h = g), y < u && (u = y), y > c && (c = y);
      }
      let d = [];
      for (let p = a.elementCount - 1; p >= 0; p--) {
        let f = p >= o,
          m = p * 2,
          g = a.elements[m + 0],
          y = a.elements[m + 1],
          x = g + y,
          b = {
            start: g,
            count: y,
            normals: [],
            isHole: f,
            continuous: [],
            verticesStart: 0,
            verticesCount: 0,
          };
        d.push(b);
        let _ = g,
          S = x - 1,
          M = g + 1,
          C = i.roundedCurves.length;
        do {
          let A = _ - g,
            T = a.vertices[S * 2 + 0],
            P = a.vertices[S * 2 + 1],
            R = a.vertices[_ * 2 + 0],
            z = a.vertices[_ * 2 + 1],
            N = a.vertices[M * 2 + 0],
            L = a.vertices[M * 2 + 1],
            G = R - T,
            Y = z - P,
            Z = Math.sqrt(G * G + Y * Y);
          (G /= Z), (Y /= Z);
          let q = R - N,
            oe = z - L,
            ce = Math.sqrt(q * q + oe * oe);
          (q /= ce),
            (oe /= ce),
            (b.normals[A * 2 + 0] = -oe),
            (b.normals[A * 2 + 1] = q);
          let ie = a.vertexIndices[_];
          if (Array.isArray(ie)) b.continuous[A] = !1;
          else {
            let [te, ue] = i.getCurveIndexFromVertexId(ie - 1, !0);
            if (ue > 0 && ue < 1) b.continuous[A] = !0;
            else {
              let ae = ue === 1 ? te + 1 : te - 1;
              ae = (ae + C) % C;
              let de = ue === 1 ? 0 : 1,
                ne = i.roundedCurves[te].getTangent(ue),
                Ee = i.roundedCurves[ae].getTangent(de);
              b.continuous[A] = ne.dot(Ee) > 0.95;
            }
          }
          f && ((b.normals[A * 2 + 0] *= -1), (b.normals[A * 2 + 1] *= -1)),
            ([S, _, M] = [_, M, M + 1]),
            M >= x && (M -= y);
        } while (M !== g + 1);
      }
      return { regions: [r, ...s], infos: d, vertices: a.vertices };
    }
    _insertVertex(e, t, i, r, s) {
      let a = t * 2,
        n = t * 3;
      (e.positions[n + 0] = i.x),
        (e.positions[n + 1] = i.y),
        (e.positions[n + 2] = i.z),
        (e.normals[n + 0] = r.x),
        (e.normals[n + 1] = r.y),
        (e.normals[n + 2] = r.z),
        (e.uvs[a + 0] = s.x),
        (e.uvs[a + 1] = s.y);
    }
    _extrudeRegion(e, t, i, r, s, a, n) {
      let o = new I(),
        l = new I(),
        h = new I(),
        u = new I(),
        c = new re();
      i.forEach((p, f) => {
        let m = r[f],
          g = e.verticesStart * i.length + e.verticesCount * f;
        for (let y = 0; y < e.count; y++) {
          let x = (e.start + y) * 2;
          if (
            (o.set(t[x + 0], t[x + 1], 0),
            h.copy(o).applyMatrix4(p).add(m),
            e.continuous[y])
          )
            u.set(e.normals[y * 2 + 0], e.normals[y * 2 + 1], 0);
          else {
            let b = y === 0 ? (e.start + e.count - 1) * 2 : x - 2;
            l.set(t[b + 0], t[b + 1], 0),
              u.copy(o).sub(l),
              u.set(-u.y, u.x, 0),
              e.isHole || u.negate();
          }
          if (
            (u.applyMatrix4(p).normalize(),
            c.set(y === 0 ? 1 : y / e.count, f / (i.length - 1)),
            this._insertVertex(s, g, h, u, c),
            g++,
            !e.continuous[y] || y === 0)
          ) {
            if (y === 0)
              u.set(e.normals[y * 2 + 0], e.normals[y * 2 + 1], 0),
                c.set(0, f / (i.length - 1));
            else {
              let b = y === e.count - 1 ? e.start * 2 : x + 2;
              l.set(t[b + 0], t[b + 1], 0),
                u.copy(l).sub(o),
                u.set(-u.y, u.x, 0),
                e.isHole || u.negate();
            }
            u.applyMatrix4(p).normalize(),
              this._insertVertex(s, g, h, u, c),
              g++;
          }
        }
      });
      let d = i.length - 1;
      for (let p = 0; p < d; p++) {
        let f = e.verticesStart * i.length + e.verticesCount * p,
          m = e.verticesStart * i.length + e.verticesCount * (p + 1),
          g = 0;
        for (let y = 0; y < e.count; y++) {
          (!e.continuous[y] || y === 0) && g++;
          let x = y === e.count - 1 ? 0 : g + 1,
            b = f + g,
            _ = f + x,
            S = m + x,
            M = m + g;
          e.isHole ? a.push(b, S, _, b, M, S) : a.push(b, _, S, b, S, M), g++;
        }
      }
    }
    _closeEnd(e, t, i, r, s, a, n) {
      let o = e.vertexCount,
        l = new I(0, 0, n ? -1 : 1).applyMatrix4(s),
        h = new I(),
        u = new re();
      for (let d = 0; d < o; d++) {
        let p = 2 * d;
        h
          .set(e.vertices[p + 0], e.vertices[p + 1], 0)
          .applyMatrix4(s)
          .add(a),
          this._insertVertex(r, t + d, h, l, u);
      }
      let c = e.elements;
      for (let d = 0; d < e.elementCount; d++) {
        let p = 3 * d,
          f = c[p + 0] + t,
          m = c[p + (n ? 1 : 2)] + t,
          g = c[p + (n ? 2 : 1)] + t;
        i.push(f, m, g);
      }
    }
    applyMatrix4OnRange(e, t, i) {
      let r = e.elements,
        s = new lr().getNormalMatrix(e).elements,
        a,
        n,
        o,
        l,
        h = this.attributes.position,
        u = this.attributes.normal;
      if (!h || !u) return;
      let c = h.array,
        d = u.array,
        p = h.itemSize;
      for (let f = t * p, m = i * p; f < m; f += p) {
        if (f === t) debugger;
        (a = c[f + 0]),
          (n = c[f + 1]),
          (o = c[f + 2]),
          (l = 1 / (r[3] * a + r[7] * n + r[11] * o + r[15])),
          (c[f + 0] = (r[0] * a + r[4] * n + r[8] * o + r[12]) * l),
          (c[f + 1] = (r[1] * a + r[5] * n + r[9] * o + r[13]) * l),
          (c[f + 2] = (r[2] * a + r[6] * n + r[10] * o + r[14]) * l),
          (a = d[f + 0]),
          (n = d[f + 1]),
          (o = d[f + 2]),
          (d[f + 0] = s[0] * a + s[3] * n + s[6] * o),
          (d[f + 1] = s[1] * a + s[4] * n + s[7] * o),
          (d[f + 2] = s[2] * a + s[5] * n + s[8] * o);
      }
      (h.needsUpdate = !0), (u.needsUpdate = !0);
    }
    reverseIndicesOnRange(e, t) {
      let i = this.index;
      if (i) {
        for (let r = e; r < t; r += 3) {
          let s = i.getX(r),
            a = i.getX(r + 1),
            n = i.getX(r + 2);
          i.setXYZ(r, n, a, s);
        }
        i.needsUpdate = !0;
      }
    }
  };
function E3() {
  let e = new yt();
  return (
    e.setAttribute("position", new It(new Float32Array([]), 3)),
    e.setIndex(new It(new Uint16Array([]), 1)),
    e
  );
}
var y7 = E3().attributes,
  x7 = 12,
  b7 = 1,
  C3 = class extends yt {
    constructor(e, t) {
      super(),
        (this.charWidths = []),
        (this.charCoords = []),
        (this.wrappedText = []),
        (this.isLowResolution = !1),
        (this.vectorShapes = []),
        Object.assign(this.attributes, y7),
        (this.userData = { parameters: e, type: "TextGeometry" });
      let i = t.getFont(e.font);
      i?.isLoaded
        ? ((this.font = i), this.update(e))
        : this.updateFont(e.font, t).then(() => {
            this.update(e), t?.requestRender();
          });
    }
    async updateFont(e, t) {
      let i = t.getFont(e);
      i && ((this.font = i), await i.loadingPromise);
    }
    update(e) {
      let t = this.font;
      if (
        ((this.userData = { parameters: e, type: "TextGeometry" }),
        !t?.isLoaded)
      ) {
        console.warn("Cannot update text because its font is not loaded");
        return;
      }
      let {
          width: i,
          height: r,
          depth: s,
          extrudeBevelSize: a,
          extrudeBevelSegments: n,
          text: o,
          textTransform: l,
        } = e,
        h = $s.getDisplayedValue(o),
        u = l === 2 ? h.toUpperCase() : l === 3 ? h.toLowerCase() : h,
        c = w7(e, t, u),
        { shapes: d, charWidths: p, charCoords: f } = t.generateShapes(c, e),
        m = (typeof i == "number" ? i : 1) * 0.5,
        g = (typeof r == "number" ? r : 1) * 0.5,
        y = d.map((_) => new er().fromShape(_, !0));
      this.vectorShapes = y;
      let x = y.map((_) =>
          wh.create({
            shape: _,
            parameters: {
              depth: s,
              extrudeBevelSegments: n,
              extrudeBevelSize: a,
              windingRule: s <= 0 ? Ci.NONZERO : Ci.ODD,
              subdivisions: this.isLowResolution && s > 0 ? b7 : x7,
            },
          })
        ),
        b = x.length ? Ql(x) : E3();
      b.translate(-m, g, 0),
        this.dispose(),
        (this.wrappedText = c),
        (this.charCoords = f),
        (this.charWidths = p),
        this.deleteAttribute("extrudeNormal"),
        Object.entries(b.attributes).forEach(([_, S]) => {
          this.setAttribute(_, S);
        }),
        this.setIndex(b.index),
        this.computeBoundingSphere();
    }
    clone() {
      let e = In(new yt(), C3.prototype);
      return e.copy(this), console.log("CloneGeometry", this, e), e;
    }
    copy(e) {
      return (
        Object.entries(e.attributes).forEach(([t, i]) => {
          this.setAttribute(t, i);
        }),
        this.setIndex(e.index),
        (this.userData = {
          parameters: { ...e.userData.parameters },
          type: "TextGeometry",
        }),
        this
      );
    }
    async setText(e) {
      this.font && (await this.font.loadingPromise),
        await this.update({ ...this.userData.parameters, text: e });
    }
    get text() {
      return this.userData.parameters.text ?? "";
    }
  };
function w7(e, t, i) {
  let r = [""],
    s = "";
  for (let a of i)
    (s += a),
      a === " " ||
      a ===
        `
`
        ? ((r[r.length - 1] += s),
          (s = ""),
          a ===
            `
` && r.push(""))
        : t.getTextWidth(r[r.length - 1] + s, e) > e.width &&
          (r[r.length - 1].length && r.push(""),
          t.getTextWidth(r[r.length - 1] + s, e) > e.width &&
            (s.length === 1
              ? ((r[r.length - 1] += s), (s = ""))
              : ((r[r.length - 1] += s.slice(0, -1)),
                (s = s[s.length - 1]),
                r.push(""))));
  return (r[r.length - 1] += s), r;
}
var T3,
  P3 = new Promise((e) => {
    T3 = e;
  }),
  _A = !1,
  Of;
function _7() {
  if (_A) return;
  if (Of) return Of;
  async function e() {
    let t = "https://unpkg.com/@splinetool/modelling-wasm@1.0.31/build",
      i = import("./process.js"),
      [r, s] = await Promise.all([
        i,
        fetch(`${t}/process.wasm`).then((o) => o.arrayBuffer()),
      ]),
      a = r.default,
      n = await a({ wasmBinary: s });
    T3(n), (_A = !0);
  }
  return (Of = e()), Of;
}
var S7 = ["font"];
function Jd(e, t, i, r) {
  let s, a, n;
  e.type === "PathGeometry"
    ? ((a = JSON.parse(JSON.stringify(e))), (n = [[], ["extrusion"]]))
    : ((a = { ...e }), (n = [[]]));
  for (let h of n) {
    let u = a;
    for (let c of h) u = u[c];
    for (s in u) {
      let c = u[s];
      E2(c) &&
        !S7.includes(s) &&
        ((u[s] = t.getVariable(c, [r.uuid, "geometry", ...h, s])),
        E2(u[s]) && (u[s] = 1));
    }
  }
  let o = { parameters: a, type: a.type };
  if (a.type === "PathGeometry") o.path = a.path;
  else if (a.type === "VectorGeometry") {
    let h = er.createFromState(a.shape, a.width, a.height);
    o.shape = h;
  } else if (a.type === "NonParametricGeometry")
    a.data.groups &&
      a.data.groups?.forEach(
        (h) => (h.materialIndex = Math.max(h.materialIndex ?? 0, 0))
      ),
      (o.geometry = new TC().parse(a));
  else if (a.type === "SubdivGeometry") {
    let h = new Cs(a, i);
    return (h.data = e), h;
  } else {
    if (a.type === "TextGeometry") return new C3(a, t);
    if (a.type === "UIGeometry")
      return fb.create({
        parameters: {
          width: a.width,
          height: a.height,
          cornerRadius: a.cornerRadius,
          cornerType: a.cornerType,
        },
      });
  }
  let l;
  try {
    l = CA(o);
  } catch (h) {
    console.error(h);
  }
  if (!l) {
    let h = er.createFromState(qm.defaultData(), 100, 100);
    (o.shape = h), (l = CA(o));
  }
  return l;
}
var A7 = new je();
function P1(e, t, i, r) {
  let s = e.position.array,
    a = e.normal.array,
    n = A7.makeScale(t, i, r).invert().elements,
    o,
    l,
    h;
  for (var u = 0, c = s.length; u < c; u += 3)
    (s[u] *= t),
      (s[u + 1] *= i),
      (s[u + 2] *= r),
      (o = a[u]),
      (l = a[u + 1]),
      (h = a[u + 2]),
      (a[u] = n[0] * o + n[4] * l + n[8] * h),
      (a[u + 1] = n[1] * o + n[5] * l + n[9] * h),
      (a[u + 2] = n[2] * o + n[6] * l + n[10] * h);
  (e.position.needsUpdate = !0), (e.normal.needsUpdate = !0);
}
var If = new ur(),
  ec = new I(),
  Ct;
P3.then((e) => {
  Ct = e;
});
var SA = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]),
  AA = new Uint32Array([0, 1, 2, 3]),
  MA = new Uint8Array([4]),
  Cs = class extends yt {
    constructor(e, t) {
      super(),
        (this.data = e),
        (this.flatShading = t),
        (this.subdivPointer = 0),
        this.rebuild(),
        this.freeSubdivPointer();
    }
    mutateDirectlyScaleBaked(e, t) {
      this.freeSubdivPointer();
      let i = this.data.scaleBaked,
        r = ih.div(t, i);
      this.subdividedGeometry && P1(this.subdividedGeometry.attributes, ...r),
        this.originalGeometry && P1(this.originalGeometry.attributes, ...r),
        (this.data = e);
      let s = this.userData.parameters;
      (this.userData.parameters = {
        width: s.width * r[0],
        height: s.height * r[1],
        depth: s.depth * r[2],
      }),
        this.originalGeometry.boundingSphere.center.multiply(ec.fromArray(r));
      let a = ec.set(s.width, s.height, s.depth).length();
      this.originalGeometry.boundingSphere.radius = a / 2;
    }
    ensureSubdivPointer() {
      return this.subdivPointer === 0 && this.rebuild(), this.subdivPointer;
    }
    rebuild() {
      let e, t, i;
      try {
        ({
          originalGeometry: e,
          subdividedGeometry: t,
          subdivPointer: i,
        } = Cs.build(this.data, void 0, !this.flatShading, void 0));
      } catch {
        (e = new Za(100, 100, 100)), (i = 0);
      }
      (this.subdivPointer = i),
        (this.originalGeometry = e),
        (this.subdividedGeometry = t ?? void 0);
      let r = this.subdividedGeometry ?? this.originalGeometry;
      Object.assign(this, r), this.calcBoundingBox();
    }
    freeSubdivPointer() {
      this.subdivPointer &&
        (Cs.freeSubdivPointer(this.subdivPointer), (this.subdivPointer = 0));
    }
    dispose() {
      super.dispose(), this.freeSubdivPointer();
    }
    calcBoundingBox() {
      let e = this.originalGeometry;
      e.boundingSphere === null &&
        ((e.boundingSphere = new Ws()),
        this.subdividedGeometry &&
          (this.subdividedGeometry.boundingSphere = e.boundingSphere));
      let t = e.attributes.position,
        i = e.boundingSphere.center;
      If.setFromBufferAttribute(t),
        If.getCenter(i),
        (e.boundingSphere.radius = i.distanceTo(If.max)),
        isNaN(e.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ),
        If.getSize(ec);
      let r = { width: ec.x, height: ec.y, depth: ec.z };
      return (this.userData.parameters = r), r;
    }
    static build(e, t, i, r) {
      let s,
        a,
        n,
        o = e?.phongAngle ?? 35;
      i === !1 && (o = -1),
        t && (Ct.free_bvh(t), Ct.free_subdivision_surface(t));
      try {
        s = Cs.allocate(e, r);
      } catch (l) {
        console.error(l, e),
          (s = Cs.allocate(
            { positionWASM: SA, indexWASM: AA, verticesPerFaceWASM: MA },
            r
          ));
      }
      if (
        (Ct.set_destination_refinement_level(s, 0),
        (a = Cs.buildLevel(s, !0, o)),
        e.subdivisions > 0)
      )
        try {
          Ct.set_destination_refinement_level(s, e.subdivisions),
            (n = Cs.buildLevel(s, !1, o));
        } catch {
          try {
            Ct.set_destination_refinement_level(s, e.subdivisions - 1),
              (n = Cs.buildLevel(s, !1, o));
          } catch {
            n = null;
          }
        }
      else n = null;
      return { subdivPointer: s, originalGeometry: a, subdividedGeometry: n };
    }
    static primitiveToQuads(e, t, i) {
      e.widthSegments > 16 && (e.widthSegments = 16),
        e.heightSegments > 16 && (e.heightSegments = 16),
        e.depthSegments > 16 && (e.depthSegments = 16),
        e.radialSegments > 16 && (e.radialSegments = 16),
        e.type === "DodecahedronGeometry" && (e.detail = 0);
      let r =
          e.shape !== void 0 || e.path !== void 0 ? t.geometry : Jd(e, i, !1),
        s;
      e.type === "TorusGeometry" && e.arc === Math.PI * 2
        ? (s = r.getClosedTorusIndicesForBooleanOrSubdiv())
        : (s = r.getIndex());
      let a, n, o, l;
      ({ positions: a, triIndices: l } = kg(r.getAttribute("position"), s));
      let h;
      if (
        e.type === "CylinderGeometry" &&
        e.cornerRadius === 0 &&
        e.hollow === 0 &&
        e.openEnded === !1
      ) {
        let u = e.radialSegments * e.heightSegments * 3 * 2,
          c = u + e.radialSegments * 3;
        h = [u, c];
      }
      return (
        ({ indices: n, verticesPerFace: o } = D3(a, l, r, h)),
        { positions: a, indices: n, verticesPerFace: o }
      );
    }
    static allocate(e, t) {
      let i,
        r,
        s,
        a = [],
        n = [];
      e.positionWASM && e.positionWASM.length > 0
        ? ((i = e.positionWASM), (r = e.indexWASM), (s = e.verticesPerFaceWASM))
        : ((i = SA), (r = AA), (s = MA));
      let o = i.length,
        l = r.length,
        h = s.length,
        u = i.length + a.length + n.length,
        c = r.length + s.length,
        d =
          u * Float32Array.BYTES_PER_ELEMENT +
          c * Uint32Array.BYTES_PER_ELEMENT,
        p = u * Float32Array.BYTES_PER_ELEMENT,
        f = c * Uint32Array.BYTES_PER_ELEMENT,
        m = Ct._malloc(d),
        g = new Float32Array(Ct.HEAPF32.buffer, m, u),
        y = new Uint32Array(Ct.HEAPU32.buffer, m + p, c);
      g.set(i, 0),
        g.set(a, i.length),
        g.set(n, i.length + a.length),
        y.set(r, 0),
        y.set(s, r.length);
      let x;
      e?.scaleBaked?.some((_) => _ !== 1) &&
        (x = new je().makeScale(...e.scaleBaked)),
        t && (x ? x.premultiply(t) : (x = t));
      let b = x
        ? Ct.alloc_subdivision_surface2(
            m,
            o,
            m + p,
            l,
            m + p + r.length * Uint32Array.BYTES_PER_ELEMENT,
            h,
            x.elements
          )
        : Ct.alloc_subdivision_surface(
            m,
            o,
            m + p,
            l,
            m + p + r.length * Uint32Array.BYTES_PER_ELEMENT,
            h
          );
      return Ct._free(m), b;
    }
    static buildLevel(e, t, i, r, s) {
      let a = s
          ? Ct.get_mesh_data2(
              e,
              t ? Ct.Level.CONTROL : Ct.Level.REFINED,
              i,
              s.elements
            )
          : Ct.get_mesh_data(e, t ? Ct.Level.CONTROL : Ct.Level.REFINED, i),
        n = 8,
        o = Ct.HEAPU32.subarray(a >> 2, (a >> 2) + n),
        l = o.subarray(4, 4 + 4),
        h = 0,
        u = Ct.HEAPU32[o[h] >> 2],
        c = Ct.HEAPF32.subarray(u >> 2, (u >> 2) + l[h]);
      h++;
      let d = Ct.HEAPU32[o[h] >> 2],
        p = Ct.HEAPF32.subarray(d >> 2, (d >> 2) + l[h]);
      h++;
      let f = Ct.HEAPU32[o[h] >> 2],
        m = Ct.HEAPU32.subarray(f >> 2, (f >> 2) + l[h]);
      h++;
      let g = Ct.HEAPU32[o[h] >> 2],
        y = Ct.HEAPU32.subarray(g >> 2, (g >> 2) + l[h]);
      if ((h++, r === void 0)) {
        let x = new yt();
        if (
          (x.setIndex(new Ec(y, 1)),
          x.setAttribute("position", new ot(c, 3)),
          x.setAttribute("normal", new ot(p, 3)),
          t)
        ) {
          x.setAttribute("faceMap", new Ec(m, 1));
          let b = new Float32Array((p.length / 3) * 4).fill(0);
          x.setAttribute("color", new It(b, 4));
        }
        return Ct.free_mesh_data(a), (x.userData.type = "SubdivGeometry"), x;
      }
      r.getAttribute("position").copyArray(c),
        r.getAttribute("normal").copyArray(p),
        (r.attributes.position.needsUpdate = !0),
        (r.attributes.normal.needsUpdate = !0),
        Ct.free_mesh_data(a);
    }
    static freeSubdivPointer(e) {
      Ct.free_bvh(e), Ct.free_subdivision_surface(e);
    }
    static buildControlCageWireframe(e, t, i) {
      let r = Ct.get_wireframe_data_for_base_level(e),
        s = 4,
        a = Ct.HEAPU32.subarray(r >> 2, (r >> 2) + s),
        n = a.subarray(2, 2 + 2),
        o = 0,
        l = Ct.HEAPU32[a[o] >> 2],
        h = Ct.HEAPF32.subarray(l >> 2, (l >> 2) + n[o]);
      o++;
      let u = Ct.HEAPU32[a[o] >> 2],
        c = Ct.HEAPU32.subarray(u >> 2, (u >> 2) + n[o]);
      if (t === void 0) {
        let d = new yt();
        d.setAttribute("position", new ot(h, 3));
        let p = new Float32Array(h.length);
        for (let f = 0, m = h.length; f < m; )
          (p[f++] = i.r), (p[f++] = i.g), (p[f++] = i.b);
        return (
          d.setAttribute("color", new It(p, 3)),
          d.setIndex(new Ec(c, 1)),
          Ct.free_wireframe_data_for_base_level(r),
          d
        );
      }
      t.getAttribute("position").copyArray(h),
        (t.attributes.position.needsUpdate = !0),
        Ct.free_wireframe_data_for_base_level(r);
    }
    static updateCollabMesh(e, t, i) {
      let r = t === 0;
      r || Ct.set_destination_refinement_level(e, t);
      let s = i
          ? Ct.get_topological_data2(
              e,
              r ? Ct.Level.CONTROL : Ct.Level.REFINED,
              i.elements
            )
          : Ct.get_topological_data(e, r ? Ct.Level.CONTROL : Ct.Level.REFINED),
        a = 6,
        n = Ct.HEAPU32.subarray(s >> 2, (s >> 2) + a),
        o = n.subarray(3, 3 + 3),
        l = 0,
        h = Ct.HEAPU32[n[l] >> 2],
        u = new Float32Array(Ct.HEAPF32.subarray(h >> 2, (h >> 2) + o[l]));
      l++;
      let c = Ct.HEAPU32[n[l] >> 2],
        d = new Uint32Array(Ct.HEAPU32.subarray(c >> 2, (c >> 2) + o[l]));
      l++;
      let p = Ct.HEAPU32[n[l] >> 2],
        f = new Uint8Array(Ct.HEAPU32.subarray(p >> 2, (p >> 2) + o[l]));
      return (
        Ct.free_topological_data(s),
        { positions: u, indices: d, verticesPerFace: f }
      );
    }
  },
  EA = ["getX", "getY", "getZ"];
function kg(e, t) {
  let i = {},
    r = t ? t.count : e.count,
    s = 0,
    a = [],
    n = [],
    o = 1e4;
  for (let h = 0; h < r; h++) {
    let u = t ? t.getX(h) : h,
      c = "";
    for (let d = 0; d < 3; d++) c += `${~~(e[EA[d]](u) * o)},`;
    if (c in i) a.push(i[c]);
    else {
      for (let d = 0; d < 3; d++) n.push(e[EA[d]](u));
      (i[c] = s), a.push(s), s++;
    }
  }
  let l = [];
  for (let h = 0; h < a.length; h += 3)
    a[h] === a[h + 1] ||
      a[h] === a[h + 2] ||
      a[h + 1] === a[h + 2] ||
      l.push(a[h], a[h + 1], a[h + 2]);
  return { positions: n, triIndices: l };
}
var Rf = new I(),
  v0 = new I(),
  y0 = new I(),
  x0 = new I();
function D3(e, t, i, r) {
  let s = [],
    a = [];
  if (
    i.userData.shape !== void 0 &&
    i.userData.parameters.depth === 0 &&
    i.userData.shape.shapeHoles.length === 0
  ) {
    let l = i.userData.shape.extractShapePointsToFlatArray([]),
      h = i.userData.parameters.spikes;
    if (
      i.userData.type === "EllipseGeometry" &&
      h <= 24 &&
      h % 4 === 0 &&
      i.userData.parameters.angle >= 360
    ) {
      let d = l.length / 2 / h;
      l = l.filter((p, f) => Math.floor(f / 2) % d === 0);
    }
    let u = 0;
    for (let d = 0; d < l.length; d += 2)
      u +=
        (l[d] - l[(d === 0 ? l.length : d) - 2]) *
        (l[d + 1] + l[(d === 0 ? l.length : d) - 1]);
    e.length = 0;
    let c = 0;
    if (u < 0)
      for (let d = 0; d < l.length; d += 2)
        e.push(l[d], l[d + 1], 0), s.push(c++);
    else
      for (let d = l.length - 2; d >= 0; d -= 2)
        e.push(l[d], l[d + 1], 0), s.push(c++);
    return a.push(c), { indices: s, verticesPerFace: a };
  }
  let n = new Float32Array([i.userData.parameters.depth])[0],
    o = 0;
  for (; o < t.length; ) {
    if (i.useNgonForTopBottomFaceDuringBake) {
      let l = 0;
      if (
        ((e[t[o] * 3 + 2] === n || e[t[o] * 3 + 2] === 0) && l++,
        (e[t[o + 1] * 3 + 2] === n || e[t[o + 1] * 3 + 2] === 0) && l++,
        (e[t[o + 2] * 3 + 2] === n || e[t[o + 2] * 3 + 2] === 0) && l++,
        l === 3)
      )
        break;
    }
    if (
      (t[o + 1] === t[o + 3] && t[o + 2] === t[o + 5]) ||
      (t[o + 0] === t[o + 3] && t[o + 2] === t[o + 4])
    ) {
      Rf.set(e[t[o] * 3], e[t[o] * 3 + 1], e[t[o] * 3 + 2]),
        v0.set(e[t[o + 1] * 3], e[t[o + 1] * 3 + 1], e[t[o + 1] * 3 + 2]),
        y0.set(e[t[o + 4] * 3], e[t[o + 4] * 3 + 1], e[t[o + 4] * 3 + 2]),
        x0.set(e[t[o + 5] * 3], e[t[o + 5] * 3 + 1], e[t[o + 5] * 3 + 2]),
        v0.sub(Rf).normalize(),
        y0.sub(Rf).normalize(),
        x0.sub(Rf).normalize();
      let l = v0.cross(y0).dot(x0);
      Math.abs(l) > 0.005 ||
      (r && r.some((h, u) => (u % 2 === 1 ? !1 : o >= r[u] && o < r[u + 1])))
        ? (s.push(t[o], t[o + 1], t[o + 2]), a.push(3), (o += 3))
        : (s.push(t[o], t[o + 1], t[o + 4], t[o + 5]), a.push(4), (o += 6));
    } else s.push(t[o], t[o + 1], t[o + 2]), a.push(3), (o += 3);
  }
  if (i.useNgonForTopBottomFaceDuringBake) {
    let l = [],
      h = [],
      u = 0;
    for (let c = 0, d = 0; c < e.length; c += 3, d++)
      e[c + 2] === 0 && (l.push(d), u++), e[c + 2] === n && h.push(d);
    if (i.userData.parameters.extrudeBevelSize === 0) {
      let c = h[0];
      (h[0] = h[1]), (h[1] = c);
    }
    l.reverse(), s.push(...l, ...h), a.push(u, u);
  }
  return { indices: s, verticesPerFace: a };
}
var no = {};
OO(no, {
  calcBoolean: () => P7,
  calcBooleanTopological: () => T7,
  freeMeshSet: () => R7,
  getMeshSet: () => D7,
  hasOpenEdges: () => O7,
  transformMeshSet: () => I7,
});
var O3,
  M7 = new Promise((e) => {
    O3 = e;
  }),
  Lf;
function E7() {
  if (Lf) return Lf;
  async function e() {
    let t = "https://unpkg.com/@splinetool/boolean-wasm@1.0.31/build",
      i = import("./boolean.js"),
      [r, s] = await Promise.all([
        i,
        fetch(`${t}/boolean.wasm`).then((o) => o.arrayBuffer()),
      ]),
      a = r.default,
      n = await a({ wasmBinary: s });
    O3(n);
  }
  return (Lf = e()), Lf;
}
var $t, Bc;
M7.then((e) => ($t = e));
function C7(e, t, i) {
  let r, s;
  e.userData.parameters.type === "TorusGeometry" &&
  e.userData.parameters.arc === Math.PI * 2
    ? (s = e.getClosedTorusIndicesForBooleanOrSubdiv())
    : (s = e.getIndex());
  let { positions: a, triIndices: n } = kg(e.getAttribute("position"), s),
    o;
  if (t && i) {
    let { indices: l, verticesPerFace: h } = D3(a, n, e);
    (o = h.length), (r = []);
    for (let u = 0, c = 0; u < o; u++) {
      r.push(h[u]);
      for (let d = 0; d < h[u]; d++) r.push(l[c++]);
    }
  } else {
    let l = n.length;
    (r = Array(l + l / 3)), (o = 0);
    for (let h = 0, u = 0; u < r.length; )
      (r[u++] = 3),
        o++,
        (r[u++] = n[h++]),
        (r[u++] = n[h++]),
        (r[u++] = n[h++]);
  }
  return { positions: a, faceIndices: r, nFaces: o };
}
function I3(e) {
  let t = e.length,
    i = t * Uint32Array.BYTES_PER_ELEMENT,
    r = t * Float32Array.BYTES_PER_ELEMENT,
    s = Number.isInteger(e[0]) ? i : r,
    a = $t._malloc(s);
  return (
    (Number.isInteger(e[0])
      ? new Uint32Array($t.HEAPU32.buffer, a, t)
      : new Float32Array($t.HEAPF32.buffer, a, t)
    ).set(e, 0),
    a
  );
}
function R3(e) {
  switch (e) {
    case 0:
      return $t.OP.UNION;
    case 1:
      return $t.OP.INTERSECTION;
    case 2:
      return $t.OP.A_MINUS_B;
    case 3:
      return $t.OP.B_MINUS_A;
    case 4:
      return $t.OP.SYMMETRIC_DIFFERENCE;
    case 5:
      return $t.OP.ALL;
    default:
      throw new Error("Unknown boolean operation " + e);
  }
}
function T7(e, t) {
  Bc === void 0 && (Bc = $t.init_csg());
  let i = I3(e),
    r = $t.csg_calc_topological(Bc, i, e.length, R3(t));
  $t._free(i);
  let s = 6,
    a = $t.HEAPU32.subarray(r >> 2, (r >> 2) + s),
    n = a.subarray(3, 3 + 3),
    o = 0,
    l = $t.HEAPU32[a[o] >> 2],
    h = new Float32Array($t.HEAPF32.subarray(l >> 2, (l >> 2) + n[o]));
  o++;
  let u = $t.HEAPU32[a[o] >> 2],
    c = new Uint32Array($t.HEAPU32.subarray(u >> 2, (u >> 2) + n[o]));
  o++;
  let d = $t.HEAPU32[a[o] >> 2],
    p = new Uint8Array($t.HEAPU32.subarray(d >> 2, (d >> 2) + n[o]));
  return $t.free_mesh_data(r), { positions: h, indices: c, verticesPerFace: p };
}
function P7(e, t, i, r) {
  Bc === void 0 && (Bc = $t.init_csg());
  let s = I3(e),
    a = $t.csg_calc(Bc, s, e.length, r, R3(t));
  $t._free(s);
  let n = 5,
    o = $t.HEAPU32.subarray(a >> 2, (a >> 2) + n),
    l = o.subarray(2, 2 + 3),
    h = 0,
    u = $t.HEAPU32[o[h] >> 2],
    c = $t.HEAPF32.subarray(u >> 2, (u >> 2) + l[h]);
  h++;
  let d = $t.HEAPU32[o[h] >> 2],
    p = $t.HEAPF32.subarray(d >> 2, (d >> 2) + l[h]);
  h++;
  let f = l[h];
  i.setAttribute("position", new ot(c, 3)),
    i.setAttribute("normal", new ot(p, 3));
  let m = $t.HEAPF32.subarray((a >> 2) + 5, (a >> 2) + 5 + 6);
  return (
    i.boundingSphere === null && (i.boundingSphere = new Ws()),
    (i.boundingSphere.radius = -1),
    (i.userData.parameters = {
      width: m[3] * 2,
      height: m[4] * 2,
      depth: m[5] * 2,
    }),
    $t.free_mesh_data(a),
    f
  );
}
function D7(e, t, i) {
  if ($t === void 0) return -1;
  let r, s, a;
  if (t && e.userData.positions !== void 0) {
    let y = e.userData;
    (a = y.verticesPerFace.length),
      (r = y.positions),
      (s = Array(y.verticesPerFace.reduce((x, b) => x + b, 0) + a));
    for (let x = 0, b = 0, _ = 0; x < y.verticesPerFace.length; x++) {
      s[_++] = y.verticesPerFace[x];
      for (let S = 0; S < y.verticesPerFace[x]; S++) s[_++] = y.indices[b++];
    }
  } else ({ positions: r, faceIndices: s, nFaces: a } = C7(e, t, i));
  let n = r.length,
    o = s.length,
    l = r.length,
    h = s.length,
    u = l * Float32Array.BYTES_PER_ELEMENT + h * Uint32Array.BYTES_PER_ELEMENT,
    c = l * Float32Array.BYTES_PER_ELEMENT,
    d = h * Uint32Array.BYTES_PER_ELEMENT,
    p = $t._malloc(u),
    f = new Float32Array($t.HEAPF32.buffer, p, l),
    m = new Uint32Array($t.HEAPU32.buffer, p + c, h);
  f.set(r, 0), m.set(s, 0);
  let g = $t.get_csg_mesh(p, n, p + c, o, a);
  return $t._free(p), g;
}
function O7(e) {
  return $t.has_open_edges(e);
}
function I7(e, t) {
  $t.transform_csg_mesh(e, t.elements);
}
function R7(e) {
  $t.free_csg_mesh(e);
}
var L7 = {
    ConeGeometry: $9,
    CubeGeometry: eW,
    CylinderGeometry: n3,
    DodecahedronGeometry: iW,
    EllipseGeometry: pb,
    HelixGeometry: LW,
    IcosahedronGeometry: BW,
    LatheGeometry: zW,
    NonParametricGeometry: HW,
    PolygonGeometry: S3,
    PyramidGeometry: GW,
    RectangleGeometry: fb,
    SphereGeometry: YW,
    PlaneGeometry: XW,
    BackdropGeometry: QW,
    StarGeometry: A3,
    TextFrameGeometry: KW,
    TorusGeometry: JW,
    TorusKnotGeometry: e7,
    TriangleGeometry: t7,
    PathGeometry: g7,
    VectorGeometry: wh,
  },
  CA = (e) => L7[e.type].create(e);
function tc(e) {
  return e !== null && "booleanOp" in e;
}
var L3 = class extends ob(br) {
    constructor() {
      super(...arguments),
        (this.booleanMeshSetAddress = -1),
        (this.booleanWasTransformed = !1),
        (this.booleanMatrixInvOld = new je());
    }
    updateVisible(e) {
      super.updateVisible(e),
        (this.visible = !tc(this.parent) && this.visible),
        tc(this.parent) && this.parent.invalidateDownstreamBooleanData();
    }
    freeBooleanPointer() {
      this.booleanMeshSetAddress !== -1 &&
        (no.freeMeshSet(this.booleanMeshSetAddress),
        (this.booleanMeshSetAddress = -1));
    }
    invalidateDownstreamBooleanData(e = !1) {
      return (
        e ? (this.booleanWasTransformed = !0) : this.freeBooleanPointer(),
        tc(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this
      );
    }
    invalidateUpstreamBooleanData() {
      this.freeBooleanPointer();
      for (let e of this.children)
        e instanceof L3 &&
          (e.freeBooleanPointer(), tc(e) && e.invalidateUpstreamBooleanData());
    }
    updateTransformState(e, t) {
      let i = super.updateTransformState(e, t);
      return (
        i && tc(this.parent) && this.invalidateDownstreamBooleanData(!0), i
      );
    }
    onVariableUpdate(e = !1) {
      super.onVariableUpdate(e),
        tc(this.parent) && this.invalidateDownstreamBooleanData(!0);
    }
  },
  Bf = new ur();
function mb(e, t = 0, i = e.count, r, s) {
  let a = 1 / 0,
    n = 1 / 0,
    o = 1 / 0,
    l = -1 / 0,
    h = -1 / 0,
    u = -1 / 0;
  for (let c = t; c < i; c++) {
    let d = e.getX(c),
      p = e.getY(c),
      f = e.getZ(c);
    d < a && (a = d),
      p < n && (n = p),
      f < o && (o = f),
      d > l && (l = d),
      p > h && (h = p),
      f > u && (u = f);
  }
  Bf.min.set(a, n, o),
    Bf.max.set(l, h, u),
    Bf.getCenter(r),
    Bf.getSize(s).multiplyScalar(0.5);
}
var B7 = new yt(),
  z7 = new mh(),
  Is = class extends L3 {
    constructor(e, t) {
      super(B7, z7), this.super_Entity(e, t);
    }
    updateState(e, t) {
      this.updateState_Entity(e, t);
    }
    updateEntityBoxSize(e, t) {
      let i = this.geometry.getAttribute("position");
      i !== void 0
        ? mb(
            i,
            this.geometry.drawRange.start,
            this.geometry.drawRange.count < 1 / 0
              ? this.geometry.drawRange.count
              : i.count,
            e,
            t
          )
        : super.updateEntityBoxSize(e, t);
    }
  },
  TA = class {
    constructor(e) {
      (e = e ?? {}),
        (this.name = e.name),
        (this.type = e.type),
        (this.node = e.node),
        (this.size = e.size),
        (this.needsUpdate = e.needsUpdate);
    }
    get value() {
      return this.node.value;
    }
    set value(e) {
      this.node.value = e;
    }
  },
  vl = class {
    constructor(e) {
      (this.hashProperties = void 0),
        (this.isNode = !0),
        (this.shortcuts = {}),
        (this.uuid = dt.generateUUID()),
        (this.type = e),
        (this.name = "");
    }
    analyze(e, t) {
      (t = t ?? {}),
        (e.analyzing = !0),
        this.build(e.addFlow(t.slot, t.cache, t.context), "v4"),
        e.clearVertexNodeCode(),
        e.clearFragmentNodeCode(),
        e.removeFlow(),
        (e.analyzing = !1);
    }
    analyzeAndFlow(e, t, i) {
      return (i = i ?? {}), this.analyze(e, i), this.flow(e, t, i);
    }
    flow(e, t, i) {
      (i = i ?? {}), e.addFlow(i.slot, i.cache, i.context);
      let r = {
        result: this.build(e, t),
        code: e.clearNodeCode(),
        extra: e.context.extra,
      };
      return e.removeFlow(), r;
    }
    build(e, t, i) {
      t = t ?? this.getType(e, t);
      let r = e.getNodeData(i ?? this);
      return (
        e.analyzing && this.appendDepsNode(e, r, t),
        e.nodes.indexOf(this) === -1 && e.nodes.push(this),
        this.updateFrame !== void 0 &&
          e.updaters.indexOf(this) === -1 &&
          e.updaters.push(this),
        this.generate(e, t, i)
      );
    }
    updateFrame(e) {}
    generateReadonly(e, t, i, r, s, a) {
      return "";
    }
    generate(e, t, i, r, s) {
      return "";
    }
    parse(e, t, i, r) {}
    appendDepsNode(e, t, i) {
      t.deps = (t.deps || 0) + 1;
      let r = e.getTypeLength(i);
      (r > (t.outputMax || 0) || this.getType(e, i)) &&
        ((t.outputMax = r), (t.output = i));
    }
    setName(e) {
      this.name = e;
    }
    getName() {
      return this.name;
    }
    getType(e, t) {
      return t === "sampler2D" || t === "samplerCube" ? t : this.type;
    }
    getHash() {
      let e = "{",
        t,
        i;
      for (t in this)
        (i = this[t]),
          i instanceof vl && (e += '"' + t + '":' + i.getHash() + ",");
      if (this.hashProperties)
        for (let r = 0; r < this.hashProperties.length; r++)
          (t = this.hashProperties[r]),
            (i = this[t]),
            (e += '"' + t + '":"' + String(i) + '",');
      return (e += '"id":"' + this.uuid + '"}'), e;
    }
  },
  F7 = class {
    constructor() {
      (this.nodes = {}), (this.keywords = {});
    }
    add(e) {
      this.nodes[e.name] = e;
    }
    addKeyword(e, t, i) {
      (i = i !== void 0 ? i : !0),
        (this.keywords[e] = { callback: t, cache: i });
    }
    remove(e) {
      delete this.nodes[e.name];
    }
    removeKeyword(e) {
      delete this.keywords[e];
    }
    get(e) {
      return this.nodes[e];
    }
    getKeyword(e, t) {
      return this.keywords[e].callback(t);
    }
    getKeywordData(e) {
      return this.keywords[e];
    }
    contains(e) {
      return this.nodes[e] !== void 0;
    }
    containsKeyword(e) {
      return this.keywords[e] !== void 0;
    }
  },
  Vs = new F7(),
  Pi = class extends vl {
    constructor(e, t) {
      super(e),
        (this.scope = ""),
        (t = t ?? {}),
        (this.shared = t.shared !== void 0 ? t.shared : !0),
        (this.unique = t.unique !== void 0 ? t.unique : !1);
    }
    build(e, t, i, r) {
      if (((t = t ?? this.getType(e)), this.getShared(e, t))) {
        let s = this.getUnique(e, t);
        s && this.uuid === void 0 && (this.uuid = dt.generateUUID()),
          (i = e.getUUID(i ?? this.getUUID(), !s));
        let a = e.getNodeData(i),
          n = a.output || this.getType(e);
        if (e.analyzing)
          return (a.deps || 0) > 0 || this.getLabel()
            ? (this.appendDepsNode(e, a, t), this.generate(e, t, i))
            : super.build(e, t, i);
        if (s) return (a.name = a.name || super.build(e, t, i)), a.name;
        if (
          !this.getLabel() &&
          (!this.getShared(e, n) || e.context.ignoreCache || a.deps === 1)
        )
          return super.build(e, t, i);
        i = this.getUUID(!1);
        let o = this.getTemp(e, i);
        if (o) return e.format(o, n, t);
        {
          o = super.generate(e, t, i, a.output, r);
          let l = this.generate(e, n, i);
          return e.addNodeCode(o + " = " + l + ";"), e.format(o, n, t);
        }
      }
      return super.build(e, t, i);
    }
    getShared(e, t) {
      return t !== "sampler2D" && t !== "samplerCube" && this.shared;
    }
    getUnique(e, t) {
      return this.unique;
    }
    setLabel(e) {
      return (this.label = e), this;
    }
    getLabel() {
      return this.label;
    }
    getUUID(e) {
      let t = this.uuid;
      return typeof this.scope == "string" && (t = this.scope + "-" + t), t;
    }
    getTemp(e, t) {
      t = t || this.uuid;
      let i = e.getVars()[t];
      return i ? i.name : void 0;
    }
    generate(e, t, i, r, s) {
      return (
        this.getShared(e, t) || console.error("TempNode is not shared"),
        (i = i ?? this.uuid),
        e.getTempVar(i, r ?? this.getType(e), s, this.getLabel()).name
      );
    }
  },
  qs = class extends Pi {
    constructor(e, t) {
      (t = t ?? {}),
        (t.shared = t.shared !== void 0 ? t.shared : !1),
        super(e, t),
        (this.readonly = !1);
    }
    setReadonly(e) {
      return (
        (this.readonly = e),
        (this.hashProperties = this.readonly ? ["value"] : void 0),
        this
      );
    }
    getReadonly() {
      return this.readonly;
    }
    generate(e, t, i, r, s, a) {
      (i = e.getUUID(i ?? this.getUUID())), (r = r ?? this.getType(e));
      let n = e.getNodeData(i);
      return this.getReadonly() && this.generateReadonly !== void 0
        ? this.generateReadonly(e, t, i, r, s, a)
        : e.isShader("vertex")
        ? (n.vertex ||
            (n.vertex = e.createVertexUniform(r, this, s, a, this.getLabel())),
          e.format(n.vertex.name, r, t))
        : (n.fragment ||
            (n.fragment = e.createFragmentUniform(
              r,
              this,
              s,
              a,
              this.getLabel()
            )),
          e.format(n.fragment.name, r, t));
    }
  },
  ts = class extends qs {
    constructor(e = 0, t) {
      super("v2"),
        (this.nodeType = "Vector2"),
        (this.value = e instanceof re ? e : new re(e, t));
    }
    get x() {
      return this.value.x;
    }
    set x(e) {
      this.value.x = e;
    }
    get y() {
      return this.value.y;
    }
    set y(e) {
      this.value.y = e;
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format("vec2(" + this.value.x + ", " + this.value.y + ")", r, t);
    }
  },
  ya = class extends qs {
    constructor(e = 0, t, i) {
      super("v3"),
        (this.nodeType = "Vector3"),
        (this.value = e instanceof I ? e : new I(e, t, i));
    }
    get x() {
      return this.value.x;
    }
    set x(e) {
      this.value.x = e;
    }
    get y() {
      return this.value.y;
    }
    set y(e) {
      this.value.y = e;
    }
    get z() {
      return this.value.z;
    }
    set z(e) {
      this.value.z = e;
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format(
        "vec3(" +
          this.value.x +
          ", " +
          this.value.y +
          ", " +
          this.value.z +
          ")",
        r,
        t
      );
    }
  },
  os = class extends Et {
    constructor(e, t, i, r) {
      super(e, t, i), (this.isColorA = !0), (this.a = r);
    }
    setRGBA(e, t, i, r) {
      super.setRGB(e, t, i), (this.a = r);
    }
    copy(e) {
      return super.copy(e), (this.a = "a" in e ? e.a : 1), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b, this.a);
    }
    equals(e) {
      return super.equals(e) && this.a === e.a;
    }
    setStyle(e, t = "srgb") {
      let i;
      if (e === "transparent") return this.setRGBA(0, 0, 0, 0), this;
      if ((i = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(e))) {
        let r,
          s = i[1],
          a = i[2];
        switch (s) {
          case "rgb":
          case "rgba":
            if (
              (r =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                (this.a = s === "rgba" ? parseFloat(r[4]) : 1),
                super.setStyle(e, t)
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (r =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                (this.a = s === "hsla" ? parseFloat(r[4]) : 1),
                super.setStyle(e, t)
              );
            break;
        }
      }
      return super.setStyle(e, t);
    }
    get x() {
      return this.r;
    }
    get y() {
      return this.g;
    }
    get z() {
      return this.b;
    }
    get w() {
      return this.a;
    }
    set x(e) {
      this.r = e;
    }
    set y(e) {
      this.g = e;
    }
    set z(e) {
      this.b = e;
    }
    set w(e) {
      this.a = e;
    }
  },
  oo = class extends qs {
    constructor(e) {
      super("v4"),
        (this.nodeType = "Vector4"),
        (this.value = e instanceof os ? e : new os(e.r, e.g, e.b, e.a));
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format(
        "vec4(" +
          this.value.r +
          ", " +
          this.value.g +
          ", " +
          this.value.b +
          ", " +
          this.value.a +
          ")",
        r,
        t
      );
    }
  },
  k7 = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
  PA = /[a-z_0-9]+/gi,
  it = class extends Pi {
    constructor(e, t, i, r, s) {
      super(s),
        (this.src = ""),
        (this.nodeType = "Function"),
        (this.useKeywords = !0),
        (this.includes = []),
        (this.extensions = {}),
        (this.keywords = {}),
        (this.isMethod = s === void 0),
        (this.isInterface = !1),
        this.parse(e, t, i, r);
    }
    getShared(e, t) {
      return !this.isMethod;
    }
    getType(e) {
      return e.getTypeByFormat(this.type);
    }
    getInputByName(e) {
      if (this.inputs) {
        let t = this.inputs.length;
        for (; t--; ) if (this.inputs[t].name === e) return this.inputs[t];
      }
    }
    getIncludeByName(e) {
      if (this.includes) {
        let t = this.includes.length;
        for (; t--; ) if (this.includes[t].name === e) return this.includes[t];
      }
    }
    generate(e, t, i, r, s) {
      let a,
        n = 0,
        o = this.src;
      if (this.includes)
        for (let h = 0; h < this.includes.length; h++)
          e.include(this.includes[h], this);
      for (let h in this.extensions) e.extensions[h] = !0;
      let l = [];
      for (; (a = PA.exec(this.src)); ) l.push(a);
      for (let h = 0; h < l.length; h++) {
        let u = l[h],
          c = u[0],
          d = this.isMethod ? !this.getInputByName(c) : !0,
          p = c;
        if (
          this.keywords[c] ||
          (this.useKeywords && d && Vs.containsKeyword(c))
        ) {
          let f = this.keywords[c];
          if (!f) {
            let m = Vs.getKeywordData(c);
            m.cache && (f = e.keywords[c]),
              (f = f || Vs.getKeyword(c, e)),
              m.cache && (e.keywords[c] = f);
          }
          p = f.build(e);
        }
        c !== p &&
          o[u.index + n - 1] !== "." &&
          ((o =
            o.substring(0, u.index + n) +
            p +
            o.substring(u.index + c.length + n)),
          (n += p.length - c.length)),
          this.getIncludeByName(p) === void 0 &&
            Vs.contains(p) &&
            e.include(Vs.get(p));
      }
      return t === "source"
        ? o
        : this.isMethod
        ? (this.isInterface || e.include(this, void 0, o), this.name)
        : e.format("( " + o + " )", this.getType(e), t);
    }
    parse(e, t, i, r) {
      if (
        ((this.src = e || ""),
        (this.includes = t ?? []),
        (this.extensions = i ?? {}),
        (this.keywords = r ?? {}),
        this.isMethod)
      ) {
        let s = k7.exec(this.src);
        if (((this.inputs = []), s && s.length == 4)) {
          (this.type = s[1]), (this.name = s[2]);
          let a = s[3].match(PA);
          if (a) {
            let n = 0;
            for (; n < a.length; ) {
              let o = a[n++],
                l;
              o === "in" || o === "out" || o === "inout"
                ? (l = a[n++])
                : ((l = o), (o = ""));
              let h = a[n++];
              this.inputs.push({ name: h, type: l, qualifier: o });
            }
          }
          this.isInterface = this.src.indexOf("{") === -1;
        } else (this.type = ""), (this.name = "");
      }
    }
  },
  N7 = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,
  B3 = class extends Pi {
    constructor(e = "", t) {
      super(),
        (this.src = ""),
        (this.useDefine = !1),
        (this.nodeType = "Const"),
        this.parse(e || B3.PI, void 0, void 0, void 0, t);
    }
    getType(e) {
      return e.getTypeByFormat(this.type);
    }
    parse(e, t, i, r, s) {
      this.src = e || "";
      let a,
        n,
        o = "",
        l = N7.exec(e);
      (this.useDefine = s ?? this.src.charAt(0) === "#"),
        l && l.length > 1
          ? ((n = l[1]), (a = l[2]), (o = l[3]))
          : ((a = this.src), (n = "f")),
        (this.name = a),
        (this.type = n),
        (this.value = o);
    }
    build(e, t) {
      if (t === "source") {
        if (this.value)
          return this.useDefine
            ? "#define " + this.name + " " + this.value
            : "const " + this.type + " " + this.name + " = " + this.value + ";";
        if (this.useDefine) return this.src;
      }
      return e.include(this), e.format(this.name, this.getType(e), t);
    }
    generate(e, t, i, r, s) {
      return e.format(this.name, this.getType(e), t);
    }
  },
  Mi = B3;
(Mi.PI = "PI"),
  (Mi.PI2 = "PI2"),
  (Mi.RECIPROCAL_PI = "RECIPROCAL_PI"),
  (Mi.RECIPROCAL_PI2 = "RECIPROCAL_PI2"),
  (Mi.LOG2 = "LOG2"),
  (Mi.EPSILON = "EPSILON");
var U7 = new RegExp(
    `^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`,
    "gim"
  ),
  V7 = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim"),
  z3 = class extends Pi {
    constructor(e = "") {
      super(),
        (this.inputs = []),
        (this.src = ""),
        (this.nodeType = "Struct"),
        this.parse(e);
    }
    getType(e) {
      return e.getTypeByFormat(this.name);
    }
    getInputByName(e) {
      let t = this.inputs.length;
      for (; t--; ) if (this.inputs[t].name === e) return this.inputs[t];
    }
    generate(e, t, i, r, s) {
      return t === "source"
        ? this.src + ";"
        : e.format("( " + this.src + " )", this.getType(e), t);
    }
    parse(e = "") {
      (this.src = e), (this.inputs = []);
      let t = U7.exec(e);
      if (t) {
        let i = t[2],
          r;
        for (; (r = V7.exec(i)); ) this.inputs.push({ type: r[1], name: r[2] });
        this.name = t[1];
      } else this.name = "";
      this.type = this.name;
    }
  },
  gb = class extends Pi {
    constructor(e) {
      super("v2", { shared: !1 }),
        (this.nodeType = "UV"),
        (this.index = e ?? 0);
    }
    generate(e, t) {
      e.requires.uv[this.index] = !0;
      let i = this.index > 0 ? this.index + 1 : "",
        r = e.isShader("vertex") ? "uv" + i : "vUv" + i;
      return e.format(r, this.getType(e), t);
    }
  };
Vs.addKeyword("uv", function () {
  return new gb();
});
Vs.addKeyword("uv2", function () {
  return new gb(1);
});
var vc = class extends Pi {
    constructor(e, t) {
      super("v4"),
        (this.nodeType = "ColorSpace"),
        (this.input = e),
        (this.method = t ?? vc.LINEAR_TO_LINEAR),
        (this.hashProperties = ["method"]);
    }
    static getEncodingComponents(e) {
      switch (e) {
        case Qa:
          return ["Linear"];
        case jt:
          return ["sRGB"];
        default:
          return [];
      }
    }
    generate(e, t) {
      let i = this.input.build(e, "v4"),
        r = this.getType(e),
        s = vc.Nodes[this.method],
        a = e.include(s);
      if (a === vc.LINEAR_TO_LINEAR) return e.format(i, r, t);
      if (s.inputs?.length === 2) {
        let n = this.factor.build(e, "f");
        return e.format(a + "( " + i + ", " + n + " )", r, t);
      } else return e.format(a + "( " + i + " )", r, t);
    }
    fromEncoding(e) {
      let t = vc.getEncodingComponents(e);
      (this.method = "LinearTo" + t[0]), (this.factor = t[1]);
    }
    fromDecoding(e) {
      let t = vc.getEncodingComponents(e);
      (this.method = t[0] + "ToLinear"), (this.factor = t[1]);
    }
  },
  Mn = vc;
(Mn.Nodes = {
  LinearToLinear: new it(
    ["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)
  ),
  sRGBToLinear: new it(
    [
      "vec4 sRGBToLinear( in vec4 value ) {",
      "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
      "}",
    ].join(`
`)
  ),
  LinearTosRGB: new it(
    [
      "vec4 LinearTosRGB( in vec4 value ) {",
      "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
      "}",
    ].join(`
`)
  ),
}),
  (Mn.LINEAR_TO_LINEAR = "LinearToLinear"),
  (Mn.SRGB_TO_LINEAR = "sRGBToLinear"),
  (Mn.LINEAR_TO_SRGB = "LinearTosRGB");
var Fi = class extends it {
    constructor(e = "", t, i, r, s) {
      super(e, s, r, i, t), (this.nodeType = "Expression");
    }
  },
  fo = class extends qs {
    constructor(e = new Yi(), t, i, r) {
      super("v4", { shared: !0 }),
        (this.nodeType = "Texture"),
        (this.value = e),
        (this.uv = t ?? new gb()),
        (this.bias = i),
        (this.project = r !== void 0 ? r : !1);
    }
    getTexture(e, t) {
      return super.generate(e, t, this.value.uuid, "t");
    }
    generate(e, t) {
      if (t === "sampler2D") return this.getTexture(e, t);
      let i = this.getTexture(e, t),
        r = this.uv.build(e, this.project ? "v4" : "v2"),
        s = this.bias ? this.bias.build(e, "f") : void 0;
      s === void 0 &&
        e.context.bias &&
        (s = e.context.bias.setTexture(this).build(e, "f"));
      let a, n;
      this.project ? (a = "texture2DProj") : (a = s ? "tex2DBias" : "tex2D"),
        s
          ? (n = a + "( " + i + ", " + r + ", " + s + " )")
          : (n = a + "( " + i + ", " + r + " )");
      let o = { include: e.isShader("vertex"), ignoreCache: !0 },
        l = this.getType(e);
      return (
        e.addContext(o),
        (this.colorSpace = this.colorSpace ?? new Mn(new Fi("", l))),
        this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)),
        this.colorSpace.input.parse(n),
        (n = this.colorSpace.build(e, l)),
        e.removeContext(),
        e.format(n, l, t)
      );
    }
  },
  lt = class extends qs {
    constructor(e) {
      super("f"), (this.nodeType = "Float"), (this.value = e ?? 0);
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format(this.value + (this.value % 1 ? "" : ".0"), r, t);
    }
  },
  DA = class extends Pi {
    constructor(e, t) {
      super(),
        (this.inputs = []),
        (this.nodeType = "FunctionCall"),
        (this.value = e),
        (this.inputs = t ?? []);
    }
    getFunction() {
      return this.value;
    }
    getType(e) {
      return this.value.getType(e);
    }
    generate(e, t, i, r, s) {
      r = this.getType(e);
      let a = this.value,
        n = a.build(e, t) + "( ",
        o = [];
      if (a.inputs) {
        for (let l = 0; l < a.inputs.length; l++) {
          let h = a.inputs[l],
            u = this.inputs[l] || this.inputs[h.name];
          o.push(u.build(e, e.getTypeByFormat(h.type)));
        }
        n += o.join(", ") + " )";
      }
      return e.format(n, r, t);
    }
  },
  F3 = class extends Pi {
    constructor(e, t, i = F3.ADD) {
      super(),
        (this.nodeType = "Operator"),
        (this.type = e.type),
        (this.a = e),
        (this.b = t),
        (this.op = i);
    }
    getType(e) {
      let t = this.a.getType(e),
        i = this.b.getType(e);
      return e.isTypeMatrix(t)
        ? "v4"
        : e.getTypeLength(i) > e.getTypeLength(t)
        ? i
        : t;
    }
    generate(e, t) {
      let i = this.getType(e);
      this.type = i;
      let r = this.a.build(e, i),
        s = this.b.build(e, i);
      return e.format("( " + r + " " + this.op + " " + s + " )", i, t);
    }
  },
  ks = F3;
(ks.ADD = "+"), (ks.SUB = "-"), (ks.MUL = "*"), (ks.DIV = "/");
var Ai = class extends Pi {
    constructor(e, t = Ai.ABS, i, r) {
      super(),
        (this.nodeType = "Math"),
        (this.a = e),
        typeof t != "string" ? (this.b = t) : (r = t),
        typeof i != "string" ? (this.c = i) : (r = i),
        (this.method = r),
        (this.hashProperties = ["method"]);
    }
    getNumInputs(e) {
      switch (this.method) {
        case Ai.MIX:
        case Ai.CLAMP:
        case Ai.REFRACT:
        case Ai.SMOOTHSTEP:
        case Ai.FACEFORWARD:
          return 3;
        case Ai.MIN:
        case Ai.MAX:
        case Ai.MOD:
        case Ai.STEP:
        case Ai.REFLECT:
        case Ai.DISTANCE:
        case Ai.DOT:
        case Ai.CROSS:
        case Ai.POW:
          return 2;
        default:
          return 1;
      }
    }
    getInputType(e) {
      let t = e.getTypeLength(this.a.getType(e)),
        i = this.b ? e.getTypeLength(this.b.getType(e)) : 0,
        r = this.c ? e.getTypeLength(this.c.getType(e)) : 0;
      return t > i && t > r
        ? this.a.getType(e)
        : i > r
        ? this.b.getType(e)
        : this.c.getType(e);
    }
    getType(e) {
      switch (this.method) {
        case Ai.LENGTH:
        case Ai.DISTANCE:
        case Ai.DOT:
          return "f";
        case Ai.CROSS:
          return "v3";
      }
      return this.getInputType(e);
    }
    generate(e, t) {
      let i,
        r,
        s,
        a = this.a ? e.getTypeLength(this.a.getType(e)) : 0,
        n = this.b ? e.getTypeLength(this.b.getType(e)) : 0,
        o = this.c ? e.getTypeLength(this.c.getType(e)) : 0,
        l = this.getInputType(e),
        h = this.getType(e);
      switch (((this.type = h), this.method)) {
        case Ai.NEGATE:
          return e.format("( -" + this.a.build(e, l) + " )", l, t);
        case Ai.INVERT:
          return e.format("( 1.0 - " + this.a.build(e, l) + " )", l, t);
        case Ai.CROSS:
          (i = this.a.build(e, "v3")), (r = this.b.build(e, "v3"));
          break;
        case Ai.STEP:
          (i = this.a.build(e, a === 1 ? "f" : l)), (r = this.b.build(e, l));
          break;
        case Ai.MIN:
        case Ai.MAX:
        case Ai.MOD:
          (i = this.a.build(e, l)), (r = this.b.build(e, n === 1 ? "f" : l));
          break;
        case Ai.REFRACT:
          (i = this.a.build(e, l)),
            (r = this.b.build(e, l)),
            (s = this.c.build(e, "f"));
          break;
        case Ai.MIX:
          (i = this.a.build(e, l)),
            (r = this.b.build(e, l)),
            (s = this.c.build(e, o === 1 ? "f" : l));
          break;
        default:
          (i = this.a.build(e, l)),
            this.b && (r = this.b.build(e, l)),
            this.c && (s = this.c.build(e, l));
          break;
      }
      let u = [];
      u.push(i), r && u.push(r), s && u.push(s);
      let c = this.getNumInputs(e);
      if (u.length !== c)
        throw Error(
          `Arguments not match used in "${this.method}". Require ${c}, currently ${u.length}.`
        );
      return e.format(this.method + "( " + u.join(", ") + " )", h, t);
    }
  },
  Nt = Ai;
(Nt.RAD = "radians"),
  (Nt.DEG = "degrees"),
  (Nt.EXP = "exp"),
  (Nt.EXP2 = "exp2"),
  (Nt.LOG = "log"),
  (Nt.LOG2 = "log2"),
  (Nt.SQRT = "sqrt"),
  (Nt.INV_SQRT = "inversesqrt"),
  (Nt.FLOOR = "floor"),
  (Nt.CEIL = "ceil"),
  (Nt.NORMALIZE = "normalize"),
  (Nt.FRACT = "fract"),
  (Nt.SATURATE = "saturate"),
  (Nt.SIN = "sin"),
  (Nt.COS = "cos"),
  (Nt.TAN = "tan"),
  (Nt.ASIN = "asin"),
  (Nt.ACOS = "acos"),
  (Nt.ARCTAN = "atan"),
  (Nt.ABS = "abs"),
  (Nt.SIGN = "sign"),
  (Nt.LENGTH = "length"),
  (Nt.NEGATE = "negate"),
  (Nt.INVERT = "invert"),
  (Nt.MIN = "min"),
  (Nt.MAX = "max"),
  (Nt.MOD = "mod"),
  (Nt.STEP = "step"),
  (Nt.REFLECT = "reflect"),
  (Nt.DISTANCE = "distance"),
  (Nt.DOT = "dot"),
  (Nt.CROSS = "cross"),
  (Nt.POW = "pow"),
  (Nt.MIX = "mix"),
  (Nt.CLAMP = "clamp"),
  (Nt.REFRACT = "refract"),
  (Nt.SMOOTHSTEP = "smoothstep"),
  (Nt.FACEFORWARD = "faceforward");
var fd = class extends Pi {
    constructor(e, t, i) {
      super("v4"),
        (this.nodeType = "TextureCubeUV"),
        (this.value = e),
        (this.uv = t),
        (this.bias = i);
    }
    bilinearCubeUV(e, t, i, r) {
      let s = new DA(fd.Nodes.bilinearCubeUV, [t, i, r]);
      (this.colorSpaceTL = this.colorSpaceTL ?? new Mn(new Fi("", "v4"))),
        this.colorSpaceTL.fromDecoding(
          e.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceTL.input.parse(s.build(e) + ".tl"),
        (this.colorSpaceTR = this.colorSpaceTR ?? new Mn(new Fi("", "v4"))),
        this.colorSpaceTR.fromDecoding(
          e.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceTR.input.parse(s.build(e) + ".tr"),
        (this.colorSpaceBL = this.colorSpaceBL ?? new Mn(new Fi("", "v4"))),
        this.colorSpaceBL.fromDecoding(
          e.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceBL.input.parse(s.build(e) + ".bl"),
        (this.colorSpaceBR = this.colorSpaceBR ?? new Mn(new Fi("", "v4"))),
        this.colorSpaceBR.fromDecoding(
          e.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceBR.input.parse(s.build(e) + ".br");
      let a = { include: e.isShader("vertex"), ignoreCache: !0 };
      e.addContext(a),
        (this.colorSpaceTLExp = new Fi(this.colorSpaceTL.build(e, "v4"), "v4")),
        (this.colorSpaceTRExp = new Fi(this.colorSpaceTR.build(e, "v4"), "v4")),
        (this.colorSpaceBLExp = new Fi(this.colorSpaceBL.build(e, "v4"), "v4")),
        (this.colorSpaceBRExp = new Fi(this.colorSpaceBR.build(e, "v4"), "v4")),
        e.removeContext();
      let n = new Fi(
        "mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )",
        "v4"
      );
      return (
        (n.keywords.cubeUV_TL = this.colorSpaceTLExp),
        (n.keywords.cubeUV_TR = this.colorSpaceTRExp),
        (n.keywords.cubeUV_BL = this.colorSpaceBLExp),
        (n.keywords.cubeUV_BR = this.colorSpaceBRExp),
        (n.keywords.cubeUV = s),
        n
      );
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        let i = this.uv,
          r = this.bias || e.context.roughness,
          s = new DA(fd.Nodes.roughnessToMip, [r]),
          a = new Nt(s, fd.Nodes.m0, fd.Nodes.cubeUV_maxMipLevel, Nt.CLAMP),
          n = new Nt(a, Nt.FLOOR),
          o = new Nt(a, Nt.FRACT),
          l = this.bilinearCubeUV(e, this.value, i, n),
          h = this.bilinearCubeUV(
            e,
            this.value,
            i,
            new ks(n, new lt(1).setReadonly(!0), ks.ADD)
          ),
          u = new Nt(l, h, o, Nt.MIX);
        return e.format(u.build(e), "v4", t);
      } else
        return (
          console.warn(
            "TextureCubeUVNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec4( 0.0 )", this.getType(e), t)
        );
    }
  },
  D1 = fd;
D1.Nodes = (function () {
  let e = new z3(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`),
    t = new Mi("float cubeUV_maxMipLevel 8.0", !0),
    i = new Mi("float cubeUV_minMipLevel 4.0", !0),
    r = new Mi("float cubeUV_maxTileSize 256.0", !0),
    s = new Mi("float cubeUV_minTileSize 16.0", !0),
    a = new it(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
  a.useKeywords = !1;
  let n = new it(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
  n.useKeywords = !1;
  let o = new it(
    `TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`,
    [e, a, n, t, i, r, s]
  );
  o.useKeywords = !1;
  let l = new Mi("float r0 1.0", !0),
    h = new Mi("float v0 0.339", !0),
    u = new Mi("float m0 -2.0", !0),
    c = new Mi("float r1 0.8", !0),
    d = new Mi("float v1 0.276", !0),
    p = new Mi("float m1 -1.0", !0),
    f = new Mi("float r4 0.4", !0),
    m = new Mi("float v4 0.046", !0),
    g = new Mi("float m4 2.0", !0),
    y = new Mi("float r5 0.305", !0),
    x = new Mi("float v5 0.016", !0),
    b = new Mi("float m5 3.0", !0),
    _ = new Mi("float r6 0.21", !0),
    S = new Mi("float v6 0.0038", !0),
    M = new Mi("float m6 4.0", !0),
    C = [l, h, u, c, d, p, f, m, g, y, x, b, _, S, M],
    A = new it(
      `float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`,
      C
    );
  return { bilinearCubeUV: o, roughnessToMip: A, m0: u, cubeUV_maxMipLevel: t };
})();
var yc = class extends Pi {
    constructor(e) {
      super("v3"), (this.nodeType = "Normal"), (this.scope = e ?? yc.VIEW);
    }
    getShared() {
      return this.scope === yc.WORLD;
    }
    build(e, t, i, r) {
      let s = e.context[this.scope + "Normal"];
      return s ? s.build(e, t, i, r) : super.build(e, t, i);
    }
    generate(e, t, i, r, s) {
      let a;
      switch (this.scope) {
        case yc.VIEW:
          e.isShader("vertex")
            ? (a = "transformedNormal")
            : (a = "geometryNormal");
          break;
        case yc.LOCAL:
          e.isShader("vertex")
            ? (a = "objectNormal")
            : ((e.requires.normal = !0), (a = "vObjectNormal"));
          break;
        case yc.WORLD:
          e.isShader("vertex")
            ? (a =
                "inverseTransformDirection( transformedNormal, viewMatrix ).xyz")
            : ((e.requires.worldNormal = !0), (a = "vWNormal"));
          break;
      }
      return e.format(a, this.getType(e), t);
    }
  },
  Hs = yc;
(Hs.LOCAL = "local"),
  (Hs.WORLD = "world"),
  (Hs.VIEW = "view"),
  (Hs.NORMAL = "normal");
Vs.addKeyword("viewNormal", function () {
  return new Hs(Hs.VIEW);
});
Vs.addKeyword("localNormal", function () {
  return new Hs(Hs.NORMAL);
});
Vs.addKeyword("worldNormal", function () {
  return new Hs(Hs.WORLD);
});
var so = class extends Pi {
    constructor(e) {
      super("v3"), (this.nodeType = "Position"), (this.scope = e ?? so.LOCAL);
    }
    getType() {
      switch (this.scope) {
        case so.PROJECTION:
          return "v4";
      }
      return this.type;
    }
    getShader() {
      switch (this.scope) {
        case so.LOCAL:
        case so.WORLD:
          return !1;
      }
      return !0;
    }
    generate(e, t, i, r, s) {
      let a;
      switch (this.scope) {
        case so.LOCAL:
          e.isShader("vertex")
            ? (a = "transformed")
            : ((e.requires.position = !0), (a = "vPosition"));
          break;
        case so.WORLD:
          if (e.isShader("vertex"))
            return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
          (e.requires.worldPosition = !0), (a = "vWPosition");
          break;
        case so.VIEW:
          a = e.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
          break;
        case so.PROJECTION:
          a = e.isShader("vertex")
            ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )"
            : "vec4( 0.0 )";
          break;
      }
      return e.format(a, this.getType(), t);
    }
  },
  Ga = so;
(Ga.LOCAL = "local"),
  (Ga.WORLD = "world"),
  (Ga.VIEW = "view"),
  (Ga.PROJECTION = "projection");
Vs.addKeyword("position", function () {
  return new Ga();
});
Vs.addKeyword("worldPosition", function () {
  return new Ga(Ga.WORLD);
});
Vs.addKeyword("viewPosition", function () {
  return new Ga(Ga.VIEW);
});
var vn = class extends Pi {
    constructor(e) {
      super("v3"), (this.nodeType = "Reflect"), (this.scope = e ?? vn.CUBE);
    }
    getUnique(e) {
      return !e.context.viewNormal;
    }
    getType() {
      switch (this.scope) {
        case vn.SPHERE:
          return "v2";
      }
      return this.type;
    }
    generate(e, t) {
      let i = this.getUnique(e);
      if (e.isShader("fragment")) {
        let r;
        switch (this.scope) {
          case vn.VECTOR: {
            let s = new Hs(Hs.VIEW),
              a = e.context.roughness,
              n = s.build(e, "v3"),
              o = new Ga(Ga.VIEW).build(e, "v3"),
              l = a ? a.build(e, "f") : void 0,
              h = `reflect( -normalize( ${o} ), ${n} )`;
            l && (h = `normalize( mix( ${h}, ${n}, ${l} * ${l} ) )`);
            let u = `inverseTransformDirection( ${h}, viewMatrix )`;
            i
              ? (e.addNodeCode(`vec3 reflectVec = ${u};`), (r = "reflectVec"))
              : (r = u);
            break;
          }
          case vn.CUBE: {
            let s = new vn(vn.VECTOR).build(e, "v3"),
              a = "vec3( -" + s + ".x, " + s + ".yz )";
            i
              ? (e.addNodeCode(`vec3 reflectCubeVec = ${a};`),
                (r = "reflectCubeVec"))
              : (r = a);
            break;
          }
          case vn.SPHERE: {
            let s =
              "normalize( ( viewMatrix * vec4( " +
              new vn(vn.VECTOR).build(e, "v3") +
              ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
            i
              ? (e.addNodeCode(`vec2 reflectSphereVec = ${s};`),
                (r = "reflectSphereVec"))
              : (r = s);
            break;
          }
        }
        return e.format(r, this.getType(), t);
      } else
        return (
          console.warn(
            "ReflectNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.type, t)
        );
    }
  },
  zc = vn;
(zc.CUBE = "cube"), (zc.SPHERE = "sphere"), (zc.VECTOR = "vector");
var j7 = class extends Pi {
    constructor(e = new fo(), t, i) {
      super("v4"),
        (this.nodeType = "TextureCube"),
        (this.value = e),
        (this.radianceNode = new D1(this.value, t ?? new zc(zc.VECTOR), i)),
        (this.irradianceNode = new D1(
          this.value,
          new Hs(Hs.WORLD),
          new lt(1).setReadonly(!0)
        ));
    }
    generate(e, t) {
      return e.isShader("fragment")
        ? (e.require("irradiance"),
          e.context.bias && e.context.bias.setTexture(this.value),
          (e.slot === "irradiance"
            ? this.irradianceNode
            : this.radianceNode
          ).build(e, t))
        : (console.warn(
            "TextureCubeNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec4( 0.0 )", this.getType(e), t));
    }
  },
  H7 = class extends qs {
    constructor(e = new yx(), t, i) {
      super("v4", { shared: !0 }),
        (this.nodeType = "CubeTexture"),
        (this.value = e),
        (this.uv = t ?? new zc()),
        (this.bias = i);
    }
    getTexture(e, t) {
      return super.generate(e, t, this.value.uuid, "tc");
    }
    generate(e, t) {
      if (t === "samplerCube") return this.getTexture(e, t);
      let i = this.getTexture(e, t),
        r = this.uv?.build(e, "v3"),
        s = this.bias ? this.bias.build(e, "f") : void 0;
      s === void 0 &&
        e.context.bias &&
        (s = e.context.bias.setTexture(this).build(e, "f"));
      let a;
      s
        ? (a = "texCubeBias( " + i + ", " + r + ", " + s + " )")
        : (a = "texCube( " + i + ", " + r + " )");
      let n = { include: e.isShader("vertex"), ignoreCache: !0 },
        o = this.getType(e);
      return (
        e.addContext(n),
        (this.colorSpace = this.colorSpace ?? new Mn(new Fi("", o))),
        this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)),
        this.colorSpace.input.parse(a),
        (a = this.colorSpace.build(e, o)),
        e.removeContext(),
        e.format(a, o, t)
      );
    }
  },
  G7 = `
uniform int frameIndex;
uniform vec2 resolution;
uniform mat4 previousModelViewMatrix;
uniform mat4 previousProjectionMatrix;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
`,
  W7 = `
layout(location = 1) out vec4 gVelocity;

uniform int frameIndex;
uniform vec2 resolution;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;

const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos) {
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

`,
  q7 = `
// TODO: This could be generated CPU side and passed to the shader every frame
const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

// TODO: Pass correct view size
vec2 offset = haltonSequence[frameIndex];
offset.x /= resolution.x;
offset.y /= resolution.y;

vec4 currentPosition = gl_Position;
vec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);

// We want to calculate the velocity with unjittered positions
// so that things that are not moving get a velocity = 0
vCurrentPosition = currentPosition;
vPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);
#ifdef OUTLINE_COMPENSATION
vPreviousPosition.xy += OUTLINE_COMPENSATION;
#endif
gl_Position = currentPositionJittered;

`,
  Y7 = `
vec2 oldPos = vPreviousPosition.xy;
    oldPos /= vPreviousPosition.w;
    oldPos.xy = (oldPos.xy+1.)/2.0;

vec2 newPos = vCurrentPosition.xy;
    newPos /= vCurrentPosition.w;
    newPos.xy = (newPos.xy+1.)/2.0;

vec2 velocity = (newPos - oldPos);

// Discard fully transparent pixels 
if (gl_FragColor.a <= 0.0) discard;

gVelocity = vec4(velocity, 0.0, 1.0);
`,
  X7 = `
layout(location = 1) out vec4 gVelocity;
`,
  Q7 = `
    // Discard fully transparent pixels 
    if (gl_FragColor.a <= 0.0) discard;

    gVelocity = vec4(0.0, 0.0, 0.0, 1.0);
`,
  OA = ["x", "y", "z", "w"],
  Z7 = ["float", "vec2", "vec3", "vec4"],
  K7 = {
    float: "f",
    vec2: "v2",
    vec3: "v3",
    vec4: "v4",
    mat4: "v4",
    int: "i",
    bool: "b",
    "float[]": "f[]",
    "vec4[]": "v4[]",
  },
  J7 = {
    t: "sampler2D",
    tc: "samplerCube",
    b: "bool",
    i: "int",
    f: "float",
    c: "vec3",
    v2: "vec2",
    v3: "vec3",
    v4: "vec4",
    m3: "mat3",
    m4: "mat4",
    "f[]": "float[]",
    "v4[]": "vec4[]",
  },
  k3 = class {
    constructor() {
      (this.includes = { consts: {}, functions: {}, structs: {} }),
        (this.cache = ""),
        (this.slot = ""),
        (this.shader = ""),
        (this.context = {}),
        (this.needsJitter = !0),
        (this.getIncludesCode = (function () {
          function e(t, i) {
            return t.deps.length - i.deps.length;
          }
          return function (t, i) {
            let r = this.getIncludes(t, i);
            if (!r) return "";
            let s = "";
            r = r.sort(e);
            for (let a = 0; a < r.length; a++)
              r[a].src &&
                (s +=
                  r[a].src +
                  `
`);
            return s;
          };
        })()),
        (this.slots = []),
        (this.caches = []),
        (this.contexts = []),
        (this.keywords = {}),
        (this.nodeData = {}),
        (this.fragmentVariables = {}),
        (this.fragmentParsVariables = {}),
        (this.vertexParsVariables = {}),
        (this.requires = {
          uv: [],
          color: [],
          transparent: !1,
          irradiance: !1,
          position: !1,
          worldPosition: !1,
          normal: !1,
          worldNormal: !1,
          vWorldViewDir: !1,
          modelMatrix: !1,
          viewMatrix: !1,
          projectionMatrix: !1,
        }),
        (this.includes = { consts: [], functions: [], structs: [] }),
        (this.attributes = {}),
        (this.prefixCode = [
          "#ifdef TEXTURE_LOD_EXT",
          "	#define texCube(a, b) textureCube(a, b)",
          "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)",
          "	#define tex2D(a, b) texture2D(a, b)",
          "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)",
          "#else",
          "	#define texCube(a, b) textureCube(a, b)",
          "	#define texCubeBias(a, b, c) textureCube(a, b, c)",
          "	#define tex2D(a, b) texture2D(a, b)",
          "	#define tex2DBias(a, b, c) texture2D(a, b, c)",
          "#endif",
          `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,
          "#include <packing>",
          "#include <common>",
        ].join(`
`)),
        (this.parsCode = {
          vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`),
          fragment: [
            "float accumAlpha = 0.0;",
            `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,
            "",
          ].join(`
`),
        }),
        (this.code = { vertex: "", fragment: "" }),
        (this.nodeCode = { vertex: "", fragment: "" }),
        (this.resultCode = { vertex: "", fragment: "" }),
        (this.finalCode = { vertex: "", fragment: "" }),
        (this.inputs = {
          uniforms: { list: [], vertex: [], fragment: [] },
          arrayUniforms: { list: [], vertex: [], fragment: [] },
          vars: { varying: [], vertex: [], fragment: [] },
        }),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.updaters = []),
        (this.nodes = []),
        (this.analyzing = !1);
    }
    build(e, t) {
      this.addVertexParsCode(G7),
        this.addFragmentParsCode(W7),
        this.buildShader("vertex", e),
        this.buildShader("fragment", t);
      for (let i = 0; i < this.requires.uv.length; i++)
        if (this.requires.uv[i]) {
          let r = i > 0 ? i + 1 : "";
          this.addVaryCode("varying vec2 vUv" + r + ";"),
            i > 0 && this.addVertexParsCode("attribute vec2 uv" + r + ";"),
            this.addVertexFinalCode("vUv" + r + " = uv" + r + ";");
        }
      return (
        this.requires.color[0] &&
          (this.addVaryCode("varying vec4 vColor;"),
          this.addVertexParsCode("attribute vec4 color;"),
          this.addVertexFinalCode("vColor = color;")),
        this.requires.color[1] &&
          (this.addVaryCode("varying vec4 vColor2;"),
          this.addVertexParsCode("attribute vec4 color2;"),
          this.addVertexFinalCode("vColor2 = color2;")),
        this.requires.position &&
          (this.addVaryCode("varying vec3 vPosition;"),
          this.addVertexFinalCode("vPosition = transformed;")),
        this.requires.worldPosition,
        this.requires.normal &&
          (this.addVaryCode("varying vec3 vObjectNormal;"),
          this.addVertexFinalCode("vObjectNormal = normal;")),
        this.requires.modelMatrix &&
          this.addFragmentParsCode("uniform mat4 modelMatrix;"),
        this.requires.viewMatrix &&
          this.addFragmentParsCode("uniform mat4 viewMatrix;"),
        this.requires.projectionMatrix &&
          this.addFragmentParsCode("uniform mat4 projectionMatrix;"),
        this.requires.worldNormal &&
          (this.addVaryCode("varying vec3 vWNormal;"),
          this.addVertexFinalCode(
            "vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;"
          )),
        this.requires.vWorldViewDir &&
          (this.addVaryCode("varying vec3 vWorldViewDir;"),
          this.addVertexFinalCode(
            "vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );"
          )),
        this.needsJitter &&
          (this.addVertexFinalCode(q7), this.addFragmentFinalCode(Y7)),
        this
      );
    }
    buildShader(e, t) {
      this.resultCode[e] = t.build(this.setShader(e), "v4");
    }
    setMaterial(e, t) {
      return (this.defines = {}), this;
    }
    addFlow(e, t, i) {
      return this.addSlot(e).addCache(t).addContext(i);
    }
    removeFlow() {
      return this.removeSlot().removeCache().removeContext();
    }
    addCache(e) {
      return (this.cache = e ?? ""), this.caches.push(this.cache), this;
    }
    removeCache() {
      return (
        this.caches.pop(),
        (this.cache = this.caches[this.caches.length - 1] || ""),
        this
      );
    }
    addContext(e) {
      return (
        (this.context = Object.assign({}, this.context, e)),
        (this.context.extra = this.context.extra || {}),
        this.contexts.push(this.context),
        this
      );
    }
    removeContext() {
      return (
        this.contexts.pop(),
        (this.context = this.contexts[this.contexts.length - 1] || {}),
        this
      );
    }
    addSlot(e) {
      return (this.slot = e || ""), this.slots.push(this.slot), this;
    }
    removeSlot() {
      return (
        this.slots.pop(),
        (this.slot = this.slots[this.slots.length - 1] || ""),
        this
      );
    }
    addFragmentVariable(e, t) {
      this.fragmentVariables[e] === void 0 &&
        (this.addFragmentCode(`${t} ${e};`), (this.fragmentVariables[e] = ""));
    }
    addFragmentParsVariable(e, t) {
      this.fragmentParsVariables[e] === void 0 &&
        (this.addFragmentParsCode(`${t} ${e};`),
        (this.fragmentParsVariables[e] = ""));
    }
    addVertexParsVariable(e, t) {
      this.vertexParsVariables[e] === void 0 &&
        (this.addVertexParsCode(`${t} ${e};`),
        (this.vertexParsVariables[e] = ""));
    }
    addVertexCode(e) {
      this.addCode(e, "vertex");
    }
    addFragmentCode(e) {
      this.addCode(e, "fragment");
    }
    addCode(e, t) {
      this.code[t ?? this.shader] +=
        e +
        `
`;
    }
    addVertexNodeCode(e) {
      this.addNodeCode(e, "vertex");
    }
    addFragmentNodeCode(e) {
      this.addNodeCode(e, "fragment");
    }
    addNodeCode(e, t) {
      this.nodeCode[t ?? this.shader] +=
        e +
        `
`;
    }
    clearNodeCode(e) {
      e = e ?? this.shader;
      let t = this.nodeCode[e];
      return (this.nodeCode[e] = ""), t;
    }
    clearVertexNodeCode() {
      return this.clearNodeCode("vertex");
    }
    clearFragmentNodeCode() {
      return this.clearNodeCode("fragment");
    }
    addVertexFinalCode(e) {
      this.addFinalCode(e, "vertex");
    }
    addFragmentFinalCode(e) {
      this.addFinalCode(e, "fragment");
    }
    addFinalCode(e, t) {
      this.finalCode[t ?? this.shader] +=
        e +
        `
`;
    }
    addVertexParsCode(e) {
      this.addParsCode(e, "vertex");
    }
    addFragmentParsCode(e) {
      this.addParsCode(e, "fragment");
    }
    addParsCode(e, t) {
      this.parsCode[t ?? this.shader] +=
        e +
        `
`;
    }
    addVaryCode(e) {
      this.addVertexParsCode(e), this.addFragmentParsCode(e);
    }
    isCache(e) {
      return this.caches.indexOf(e) !== -1;
    }
    isSlot(e) {
      return this.slots.indexOf(e) !== -1;
    }
    define(e, t) {
      this.defines[e] = t === void 0 ? 1 : t;
    }
    require(e) {
      this.requires[e] = !0;
    }
    isDefined(e) {
      return this.defines[e] !== void 0;
    }
    getVar(e, t, i, r = "varying", s = "V", a = "") {
      let n = this.getVars(r),
        o = n[e];
      if (!o) {
        let l = n.length;
        (o = { name: i || "node" + s + l + (a ? "_" + a : ""), type: t }),
          n.push(o),
          (n[e] = o);
      }
      return o;
    }
    getTempVar(e, t, i, r) {
      return this.getVar(e, t, i, this.shader, "T", r);
    }
    getAttribute(e, t) {
      if (!this.attributes[e]) {
        let i = this.getVar(e, t);
        this.addVertexParsCode("attribute " + t + " " + e + ";"),
          this.addVertexFinalCode(i.name + " = " + e + ";"),
          (this.attributes[e] = { varying: i, name: e, type: t });
      }
      return this.attributes[e];
    }
    getCode(e) {
      return [
        this.prefixCode,
        this.parsCode[e],
        this.getVarListCode(this.getVars("varying"), "varying"),
        this.getVarListCode(this.inputs.uniforms[e], "uniform"),
        this.getVarListCode(this.inputs.arrayUniforms[e], "uniform"),
        this.getIncludesCode("consts", e),
        this.getIncludesCode("structs", e),
        this.getIncludesCode("functions", e),
        "void main() {",
        this.getVarListCode(this.getVars(e)),
        this.code[e],
        this.resultCode[e],
        this.finalCode[e],
        "}",
      ].join(`
`);
    }
    getVarListCode(e, t) {
      t = t ?? "";
      let i = "";
      for (let r = 0, s = e.length; r < s; ++r) {
        let a = e[r],
          n = a.type,
          o = a.name,
          l = a.size,
          h = this.getFormatByType(n);
        if (h === void 0) throw new Error("Node pars " + h + " not found.");
        h.includes("[]")
          ? (i +=
              t +
              " " +
              h.substring(0, h.length - 2) +
              " " +
              o +
              `[${l}];
`)
          : (i +=
              t +
              " " +
              h +
              " " +
              o +
              `;
`);
      }
      return i;
    }
    getVars(e) {
      return this.inputs.vars[e ?? this.shader];
    }
    getNodeData(e) {
      let t = e instanceof vl ? e.uuid : e;
      return (this.nodeData[t] = this.nodeData[t] || {});
    }
    createUniform(e, t, i, r, s, a) {
      if (t.includes("[]")) {
        let n = this.inputs.arrayUniforms,
          o = n.list.length,
          l = new TA({
            type: t,
            size: i.size,
            name: r || "nodeUA" + o + (a ? "_" + a : ""),
            node: i,
            needsUpdate: s,
          });
        return (
          n.list.push(l),
          n[e].push(l),
          (n[e][l.name] = l),
          (this.uniforms[l.name] = l),
          l
        );
      } else {
        let n = this.inputs.uniforms,
          o = n.list.length,
          l = new TA({
            type: t,
            name: r || "nodeU" + o + (a ? "_" + a : ""),
            node: i,
            needsUpdate: s,
          });
        return (
          n.list.push(l),
          n[e].push(l),
          (n[e][l.name] = l),
          (this.uniforms[l.name] = l),
          l
        );
      }
    }
    createVertexUniform(e, t, i, r, s) {
      return this.createUniform("vertex", e, t, i, r, s);
    }
    createFragmentUniform(e, t, i, r, s) {
      return this.createUniform("fragment", e, t, i, r, s);
    }
    include(e, t, i) {
      let r;
      if (
        ((e = typeof e == "string" ? Vs.get(e) : e),
        this.context.include === !1)
      )
        return e.name;
      e instanceof it
        ? (r = this.includes.functions)
        : e instanceof Mi
        ? (r = this.includes.consts)
        : e instanceof z3 && (r = this.includes.structs);
      let s = (r[this.shader] = r[this.shader] || []);
      if (e) {
        let a = s[e.name];
        if (
          (a ||
            ((a = s[e.name] = { node: e, deps: [] }),
            s.push(a),
            (a.src = e.build(this, "source"))),
          e instanceof it &&
            t &&
            s[t.name] &&
            s[t.name].deps.indexOf(e) === -1 &&
            (s[t.name].deps.push(e), e.includes?.length))
        ) {
          let n = 0;
          do this.include(e.includes[n++], t);
          while (n < e.includes.length);
        }
        return i && (a.src = i), e.name;
      } else throw new Error("Include not found.");
    }
    colorToVectorProperties(e) {
      return e
        .replace("r", "x")
        .replace("g", "y")
        .replace("b", "z")
        .replace("a", "w");
    }
    colorToVector(e) {
      return e.replace(/c/g, "v3");
    }
    getIncludes(e, t) {
      return this.includes[e][t || this.shader];
    }
    getConstructorFromLength(e) {
      return Z7[e - 1];
    }
    isTypeMatrix(e) {
      return /^m/.test(e);
    }
    getTypeLength(e) {
      return e === "f" ? 1 : parseInt(this.colorToVector(e).substr(1));
    }
    getTypeFromLength(e) {
      return e === 1 ? "f" : "v" + e;
    }
    findNode(...e) {
      for (let t = 0; t < arguments.length; t++) {
        let i = e[t];
        if (i?.isNode) return i;
      }
    }
    resolve(...e) {
      for (let t = 0; t < arguments.length; t++) {
        let i = e[t];
        if (i !== void 0) {
          if (i.isNode) return i;
          if (i.isTexture)
            switch (i.mapping) {
              case nh:
              case oh:
                return new H7(i);
              case rp:
                return new j7(new fo(i));
              default:
                return new fo(i);
            }
          else {
            if (i.isVector2) return new ts(i);
            if (i.isVector3) return new ya(i);
            if (i.isVector4) return new oo(i);
          }
        }
      }
    }
    format(e, t, i) {
      switch (this.colorToVector(i + " <- " + t)) {
        case "f <- v2":
          return e + ".x";
        case "f <- v3":
          return e + ".x";
        case "f <- v4":
          return e + ".x";
        case "f <- i":
        case "f <- b":
          return "float( " + e + " )";
        case "v2 <- f":
          return "vec2( " + e + " )";
        case "v2 <- v3":
          return e + ".xy";
        case "v2 <- v4":
          return e + ".xy";
        case "v2 <- i":
        case "v2 <- b":
          return "vec2( float( " + e + " ) )";
        case "v3 <- f":
          return "vec3( " + e + " )";
        case "v3 <- v2":
          return "vec3( " + e + ", 0.0 )";
        case "v3 <- v4":
          return e + ".xyz";
        case "v3 <- i":
        case "v3 <- b":
          return "vec2( float( " + e + " ) )";
        case "v4 <- f":
          return "vec4( " + e + " )";
        case "v4 <- v2":
          return "vec4( " + e + ", 0.0, 1.0 )";
        case "v4 <- v3":
          return "vec4( " + e + ", 1.0 )";
        case "v4 <- i":
        case "v4 <- b":
          return "vec4( float( " + e + " ) )";
        case "i <- f":
        case "i <- b":
          return "int( " + e + " )";
        case "i <- v2":
          return "int( " + e + ".x )";
        case "i <- v3":
          return "int( " + e + ".x )";
        case "i <- v4":
          return "int( " + e + ".x )";
        case "b <- f":
          return "( " + e + " != 0.0 )";
        case "b <- v2":
          return "( " + e + " != vec2( 0.0 ) )";
        case "b <- v3":
          return "( " + e + " != vec3( 0.0 ) )";
        case "b <- v4":
          return "( " + e + " != vec4( 0.0 ) )";
        case "b <- i":
          return "( " + e + " != 0 )";
      }
      return e;
    }
    getTypeByFormat(e) {
      return K7[e] || e;
    }
    getFormatByType(e) {
      return J7[e] || e;
    }
    getUUID(e, t) {
      return (
        (t = t !== void 0 ? t : !0),
        t && this.cache && (e = this.cache + "-" + e),
        e
      );
    }
    getElementByIndex(e) {
      return OA[e];
    }
    getIndexByElement(e) {
      return OA.indexOf(e);
    }
    isShader(e) {
      return this.shader === e;
    }
    setShader(e) {
      return (this.shader = e), this;
    }
    mergeDefines(e) {
      for (let t in e) this.defines[t] = e[t];
      return this.defines;
    }
    mergeUniform(e) {
      for (let t in e) this.uniforms[t] = e[t];
      return this.uniforms;
    }
    getTextureEncodingFromMap(e) {
      let t;
      return (
        e ? e.isTexture && (t = e.encoding) : (t = Qa),
        t === Qa && this.context.gamma && (t = jt),
        t
      );
    }
  },
  tr = class extends qs {
    constructor(e = 0, t, i, r) {
      super("c"),
        (this.nodeType = "Color"),
        (this.value = e instanceof os ? e : new os(e || 0, t, i, r));
    }
    setRGBA(e) {
      this.value.setRGBA(e.r, e.g, e.b, e.a);
    }
    generate(e, t, i, r, s, a) {
      (i = e.getUUID(i ?? this.getUUID())), (r = r ?? this.getType(e));
      let n = e.getNodeData(i),
        o = this.getReadonly() && this.generateReadonly !== void 0;
      if (this.alpha) {
        let l = this.alpha.build(e, "f");
        e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${l};`);
      }
      return o
        ? this.generateReadonly(e, t, i, r, s, a)
        : e.isShader("vertex")
        ? (n.vertex ||
            (n.vertex = e.createVertexUniform(r, this, s, a, this.getLabel())),
          e.format(n.vertex.name, r, t))
        : (n.fragment ||
            (n.fragment = e.createFragmentUniform(
              r,
              this,
              s,
              a,
              this.getLabel()
            )),
          e.format(n.fragment.name, r, t));
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format(
        "vec3(" +
          this.value.r +
          ", " +
          this.value.g +
          ", " +
          this.value.b +
          ")",
        r,
        t
      );
    }
  },
  Oi = class extends qs {
    constructor(e) {
      super("i"), (this.nodeType = "Int"), (this.value = Math.floor(e ?? 0));
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format(this.value.toString(), r, t);
    }
  },
  Ts = class extends qs {
    constructor(e) {
      super("b"), (this.nodeType = "Bool"), (this.value = e ?? !1);
    }
    generateReadonly(e, t, i, r) {
      return e.format(this.value ? "true" : "false", r, t);
    }
  },
  Bl = class extends qs {
    constructor(e = 1, t) {
      super("f[]"),
        (this.nodeType = "FloatArray"),
        (this.size = e),
        (this.value = Array.isArray(t)
          ? t
          : typeof t == "number"
          ? new Array(e).fill(t)
          : new Array(e).fill(0));
    }
  },
  vb = class extends qs {},
  $7 = class extends vb {
    constructor(e) {
      super("v3"), (this.image = e), (this._value = new I());
    }
    get value() {
      return (
        (this._value.x = this.image.isVideo
          ? this.image.img.videoWidth ?? 0
          : this.image.img.width),
        (this._value.y = this.image.isVideo
          ? this.image.img.videoHeight ?? 0
          : this.image.img.height),
        this._value
      );
    }
  },
  O1 = class extends vb {
    constructor(e, t, i = 1008) {
      super("t"), (this.image = e), (this.wrap = t), (this.minFilter = i);
    }
    get value() {
      return this.image.getTexture(this.wrap, this.minFilter);
    }
  },
  N3 = class extends qs {
    constructor(e) {
      super("m3"), (this.nodeType = "Matrix3"), (this.value = e ?? new lr());
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format("mat3(" + this.value.elements.join(", ") + ")", r, t);
    }
    get elements() {
      return this.value.elements;
    }
    set elements(e) {
      this.value.fromArray(e);
    }
  },
  Bn = class extends qs {
    constructor(e) {
      super("m4"), (this.nodeType = "Matrix4"), (this.value = e ?? new je());
    }
    generateReadonly(e, t, i, r, s, a) {
      return e.format("mat4(" + this.value.elements.join(", ") + ")", r, t);
    }
    get elements() {
      return this.value.elements;
    }
    set elements(e) {
      this.value.fromArray(e);
    }
  };
function IA(e, t, i) {
  e.setUvTransform(i[0], i[1], t[0], t[1], 0, 0, 0);
}
var eq = class extends N3 {
    constructor(e, t) {
      super(new lr()),
        (this.repeat = e),
        (this.offset = t),
        IA(this.value, e, t);
    }
    updateMatrix() {
      IA(this.value, this.repeat, this.offset);
    }
  },
  zl = class extends qs {
    constructor(e = 1, t) {
      super("v4[]"),
        (this.nodeType = "Vector4Array"),
        (this.size = e),
        (this.value = Array.isArray(t)
          ? t
          : t instanceof Lt
          ? new Array(e).fill(t)
          : new Array(e).fill(new Lt(0)));
    }
  },
  RA = class extends Pi {
    constructor(e, t, i, r) {
      super("v3"),
        (this.nodeType = "Blend"),
        (this.a = e),
        (this.b = t),
        (this.alpha = i),
        (this.mode = r);
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        let i = [];
        return (
          i.push(this.a.build(e, "c")),
          i.push(this.b.build(e, "c")),
          i.push(this.alpha.build(e, "f")),
          i.push(this.mode.build(e, "i")),
          e.format("spe_blend(" + i.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "BlendNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  U3 = class extends Pi {
    constructor(e, t) {
      super("v3"),
        (this.nodeType = "CustomColor"),
        (this.color = e),
        (this.alpha = t),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        let i = e.include(U3.Nodes.customColor);
        e.addFragmentVariable(this.calpha, "float");
        let r = [];
        return (
          r.push(this.color.build(e, "v3")),
          r.push(this.mask ? `luminance(${this.mask.build(e, "v3")})` : "1.0"),
          r.push(this.alpha.build(e, "f")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "CustomColorNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  I1 = U3;
I1.Nodes = (function () {
  return {
    customColor:
      new it(`vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color;
			}`),
  };
})();
var V3 = class extends Pi {
    constructor(e, t) {
      super("v3"),
        (this.nodeType = "CustomNormal"),
        (this.cnormal = e),
        (this.alpha = t),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        let i = e.include(V3.Nodes.customNormal);
        e.addFragmentVariable(this.calpha, "float");
        let r = [];
        return (
          r.push(this.cnormal.build(e, "v3")),
          r.push("normal"),
          r.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(e, "f")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "CustomNormalNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  j3 = V3;
j3.Nodes = (function () {
  return {
    customNormal:
      new it(`vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return normal;
			}`),
  };
})();
var md = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h, u, c) {
      super("v3"),
        (this.nodeType = "CustomTexture"),
        (this.texture = e),
        (this.textureSize = t),
        (this.crop = i),
        (this.projection = r),
        (this.axis = s),
        (this.side = a),
        (this.size = n),
        (this.blending = o),
        (this.mat = l),
        (this.isMask = c),
        (this.alpha = h),
        (this.mode = u),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      e.require("position"),
        e.require("normal"),
        e.require("uv"),
        (e.requires.uv = [!0]),
        (e.extensions.shaderTextureLOD = !0),
        (e.extensions.derivatives = !0);
      let i = `g${this.uuid.toString().replace(/-/g, "")}`,
        r;
      switch (this.projection.value) {
        case 3:
          r = e.include(md.Nodes.cylindrical);
          break;
        case 2:
          r = e.include(md.Nodes.spherical);
          break;
        case 1:
          let a = [
              "vec3(1.0, 0.0, 0.0)",
              "vec3(0.0, 1.0, 0.0)",
              "vec3(0.0, 0.0, 1.0)",
            ][this.axis.value],
            n = ["zy", "xz", "xy"][this.axis.value],
            o = new it(`
		vec3 ${i}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 projected = (1. + (position.${n})) / 2.;
				vec2 uvs = ( mat * vec3( (projected * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${
          this.side.value === 2
            ? ""
            : `lalpha *= step(0.0, ${
                this.side.value === 1 ? "-1.0 * " : ""
              }dot(vObjectNormal, ${a}));`
        }

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`);
          r = e.include(o);
          break;
        case 4:
          r = e.include(md.Nodes.triplanar);
          break;
        default:
          r = e.include(md.Nodes.uv);
          break;
      }
      e.addFragmentVariable(this.calpha, "float");
      let s = [];
      if (
        (s.push("normal"),
        s.push(this.texture.generate(e, "t")),
        s.push(this.textureSize.build(e, "v2")),
        s.push(this.crop.build(e, "f")),
        s.push(this.mat.build(e, "mat3")),
        s.push(this.size.build(e, "v2")),
        s.push(this.blending.build(e, "f")),
        s.push(this.isMask.build(e, "b")),
        s.push(
          this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
        ),
        s.push(this.alpha.build(e, "f")),
        s.push(this.mode.build(e, "i")),
        s.push(this.calpha),
        this.projection.value === 4)
      ) {
        let a = `${i}_writeUvs`,
          n = a + "0",
          o = a + "1",
          l = a + "2",
          h = `${i}_triplanarWeights`;
        e.addFragmentVariable(n, "vec2"),
          e.addFragmentVariable(o, "vec2"),
          e.addFragmentVariable(l, "vec2"),
          e.addFragmentVariable(h, "vec3"),
          s.push(n),
          s.push(o),
          s.push(l),
          s.push(h);
      } else {
        let a = `${i}_writeUvs`;
        e.addFragmentVariable(a, "vec2"), s.push(a);
      }
      return e.format(r + "(" + s.join(",") + ")", this.getType(e), t);
    }
  },
  yb = md;
yb.Nodes = (function () {
  let e = new it(`
vec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
    t = new it(`
vec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
    i =
      new it(`vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`),
    r =
      new it(`vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUvs0, out vec2 writeUvs1, out vec2 writeUvs2, out vec3 writeWeights) {
				vec3 p = position;
				vec2 uv0 = (1.0 + p.xy) / 2.0;     
				vec2 uv1 = (1.0 + p.zy) / 2.0;		
				vec2 uv2 = (1.0 + p.xz) / 2.0;		
	
				uv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;

				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));

				// Write out all sets of UVs that we generated
				writeUvs0 = uv0;
				writeUvs1 = uv1;
				writeUvs2 = uv2;
				writeWeights = weights;

				// Derivatives for LOD
				vec2 df0 = fwidth(uv0);
				vec2 df1 = fwidth(uv1);
				vec2 df2 = fwidth(uv2);
				if (df0.x > 0.5) df0.x = 0.0;
				if (df1.x > 0.5) df1.x = 0.0;
				if (df2.x > 0.5) df2.x = 0.0;

				#ifdef GL_EXT_shader_texture_lod
                	vec4 tmp = 
						texture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						texture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						texture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#else
                	vec4 tmp = 
						textureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						textureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						textureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;

				// Apply cropping across all 3 planes
				if ( crop > 0.5 ) {
					if ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;//n * 0.5 + 0.5;
			}			
			`);
  return { cylindrical: e, spherical: t, uv: i, triplanar: r };
})();
var gd = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h, u, c) {
      super("v3"),
        (this.nodeType = "Depth"),
        (this.gradientType = e),
        (this.smooth = t),
        (this.near = i),
        (this.far = r),
        (this.isVector = s),
        (this.isWorldSpace = a),
        (this.origin = n),
        (this.direction = o),
        (this.colors = l),
        (this.steps = h),
        (this.isMask = c),
        (this.alpha = u),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      let i = `g${this.uuid.toString().replace(/-/g, "")}`,
        r = new it(
          `vec3 ${i}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${i}_MAX_COLORS], float steps[${i}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${i}_IS_VECTOR
                   #ifdef ${i}_LINEAR
                       #ifdef ${i}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${i}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${i}_SMOOTH
				for ( int i = 1; i < ${i}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${i}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a * mask;
               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
			   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
			   
               return color.rgb;
			}`,
          [
            gd.Nodes.vectorLinearWorldSpaceDepth,
            gd.Nodes.vectorLinearObjectSpaceDepth,
            gd.Nodes.vectorSphericalObjectSpaceDepth,
            gd.Nodes.vectorSphericalWorldSpaceDepth,
          ]
        );
      if (e.isShader("fragment")) {
        e.define(`${i}_MAX_COLORS`, this.colors.value.length),
          this.smooth.value && e.define(`${i}_SMOOTH`),
          this.isVector.value > 0.5 && e.define(`${i}_IS_VECTOR`),
          this.gradientType.value === 0 && e.define(`${i}_LINEAR`),
          this.isWorldSpace.value > 0.5 && e.define(`${i}_WORLDSPACE`),
          e.require("worldPosition"),
          e.addFragmentVariable(this.calpha, "float");
        let s = e.include(r),
          a = [];
        return (
          a.push(this.near.build(e, "f")),
          a.push(this.far.build(e, "f")),
          a.push(this.origin.build(e, "v3")),
          a.push(this.direction.build(e, "v3")),
          a.push(this.colors.build(e, "v4[]")),
          a.push(this.steps.build(e, "f[]")),
          a.push(this.isMask.build(e, "b")),
          a.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          a.push(this.alpha.build(e, "f")),
          a.push(this.calpha),
          e.format(s + "(" + a.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "DepthNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  H3 = gd;
H3.Nodes = (function () {
  let e =
      new it(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
    t =
      new it(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
    i =
      new it(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),
    r =
      new it(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);
  return {
    vectorLinearWorldSpaceDepth: e,
    vectorLinearObjectSpaceDepth: t,
    vectorSphericalWorldSpaceDepth: i,
    vectorSphericalObjectSpaceDepth: r,
  };
})();
var tq = class extends Pi {
    constructor(e, t, i, r, s, a, n, o) {
      super("v3"),
        (this.nodeType = "Fresnel"),
        (this.color = e),
        (this.bias = t),
        (this.scale = i),
        (this.intensity = r),
        (this.factor = s),
        (this.isMask = o),
        (this.alpha = a),
        (this.mode = n),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (
        (e.require("vWorldViewDir"),
        e.require("worldNormal"),
        e.isShader("fragment"))
      ) {
        e.addFragmentVariable(this.calpha, "float");
        let i =
            new it(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {
					float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

					float lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return color;
				}`),
          r = e.include(i),
          s = [];
        return (
          s.push(this.color.build(e, "c")),
          s.push(this.bias.build(e, "f")),
          s.push(this.scale.build(e, "f")),
          s.push(this.intensity.build(e, "f")),
          s.push(this.factor.build(e, "f")),
          s.push(this.isMask.build(e, "b")),
          s.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          s.push(this.alpha.build(e, "f")),
          s.push(this.mode.build(e, "i")),
          s.push(this.calpha),
          e.format(r + "(" + s.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "FresnelNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  G3 = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l) {
      super("v3"),
        (this.nodeType = "Gradient"),
        (this.gradientType = e),
        (this.smooth = t),
        (this.colors = i),
        (this.steps = r),
        (this.offset = s),
        (this.morph = a),
        (this.angle = n),
        (this.isMask = l),
        (this.alpha = o),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        e.define("GRAD_MAX", 10),
          e.require("uv"),
          (e.requires.uv = [!0]),
          e.addFragmentVariable(this.calpha, "float");
        let i = e.include(G3.Nodes.gradient),
          r = [];
        return (
          r.push(this.gradientType.build(e, "i")),
          r.push(this.smooth.build(e, "b")),
          r.push(this.colors.build(e, "v4[]")),
          r.push(this.steps.build(e, "f[]")),
          r.push(this.offset.build(e, "v2")),
          r.push(this.morph.build(e, "v2")),
          r.push(this.angle.build(e, "f")),
          r.push(this.isMask.build(e, "b")),
          r.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(e, "f")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "GradientNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  W3 = G3;
W3.Nodes = (function () {
  return {
    gradient:
      new it(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
				
				return color.xyz;
			}`),
  };
})();
var q3 = class extends Pi {
    constructor(e, t, i, r) {
      super("v3"),
        (this.nodeType = "Matcap"),
        (this.texture = e),
        (this.isMask = r),
        (this.alpha = t),
        (this.mode = i),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        e.addFragmentVariable(this.calpha, "float");
        let i = e.include(q3.Nodes.matcap);
        e.require("normal"), (e.requires.normal = !0);
        let r = [];
        return (
          r.push(this.texture.generate(e, "t")),
          r.push("normal"),
          r.push(this.isMask.build(e, "b")),
          r.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(e, "f")),
          r.push(this.mode.build(e, "i")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "MatcapNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  Y3 = q3;
Y3.Nodes = (function () {
  return {
    matcap:
      new it(`vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {
					vec3 viewDir = normalize( vViewPosition );
					vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
					vec3 y = cross( viewDir, x );
					vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
					vec4 matcapColor = texture2D( matcapTex, uv );

					float lalpha = alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
					
					return matcapColor.rgb;
            	}`),
  };
})();
var xb = ((e) => (
    (e.SIMPLEX = "simplex3d"),
    (e.SIMPLEX_FRACTAL = "simplex3dFractal"),
    (e.ASHIMA = "simplexAshima"),
    (e.FBM = "fbm"),
    (e.PERLIN = "perlin"),
    (e.VORONOI = "voronoi"),
    e
  ))(xb || {}),
  Ns = (function () {
    let e = new it(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`),
      t = new it(
        `float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`,
        [e]
      );
    (t.keywords.F3 = new Mi("float F3 0.3333333")),
      (t.keywords.G3 = new Mi("float G3 0.1666667"));
    let i = new it(
        `float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`,
        [t]
      ),
      r = new it("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"),
      s = new it(
        "vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"
      ),
      a = new it(
        `float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`,
        [r, s]
      ),
      n = new it(
        "vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"
      ),
      o = new it("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [
        n,
      ]),
      l = new it(
        `float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`,
        [o]
      ),
      h = new it(
        `float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`,
        [l]
      );
    h.keywords.NUM_OCTAVES = new Mi(`int NUM_OCTAVES ${5}`);
    let u = new it("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"),
      c = new it(
        `float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`,
        [r, s, u]
      ),
      d = new it(`float hashwithoutsine13(vec3 p3)
		{
			p3  = fract(p3 * .1031);
			p3 += dot(p3, p3.yzx + 33.33);
			return fract((p3.x + p3.y) * p3.z);
		}`),
      p = new it(`vec3 hashwithoutsine33(vec3 p3)
		{
			p3 = fract(p3 * vec3(.1031, .1030, .0973));
			p3 += dot(p3, p3.yxz+33.33);
			return fract((p3.xxy + p3.yxx)*p3.zyx);
		}`),
      f = new it(`float metric(in vec3 p)
		{
			// L2 
			return length(p);

			// Chebyshev 
			// vec3 a = abs(p);
			// return max(a.x, max(a.y, a.z));
		}`),
      m = new it(`float smin( float a, float b, float k )
		{
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);
			float correction = k * h * (1.0 - h);
			return mix(b, a, h) - correction;
		}`),
      g = new it(`float smax( float a, float b, float k )
		{
			float h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);
			float correction = k * h * (1.0 - h);
			return mix(a, b, h) + correction;
		}`),
      y =
        new it(`float remap(float value, float input_min, float input_max, float output_min, float output_max) {
			// Compute width of each interval
			float input_width = input_max - input_min;
			float output_width = output_max - output_min;
		
			// Convert input range into a 0-1 range 
			float scaled = (value - input_min) / input_width;
		
			// Convert the 0-1 range into a value in output range
			return output_min + (scaled * output_width);
		}`),
      x = new it(
        `float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) 
		{
			// Integer and fractional parts of this point's coordinates
			ivec3 p = ivec3(floor(x));
			vec3 f = fract(x);

			// Different variables that we will use to construct noise:
			//
			// f1: distance to the closest feature point
			// f2: distance to the second closest feature point
			// e: distance to the closest edge (cell boundary)
			//
			// We also compute "smooth" versions of all of the above quantites, essentially
			// replacing "hard" minimums with "smooth" minimums (described by IQ)
			float f1_smooth = 8.0;
			float f1 = 8.0;
			float f2_smooth = 8.0;
			float f2 = 8.0;
			float e_smooth = 8.0;
			float e = 8.0;

			// Variables stored from closest cell
			ivec3 mb;
			vec3 mr; 

			int steps = quality;
			
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				ivec3 b = ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d = length(r);
				
				f1_smooth = smin(d, f1_smooth, smoothness);

				// Store un-smoothed distances too 
				if (d < f1) 
				{
					f2 = f1;
					f1 = d;

					mb = ivec3(x, y, z);
					mr = r;
				} 
				else if (d < f2) 
				{
					f2 = d;
				}
			}	
			
			float id = hashwithoutsine13(vec3(p + mb) + seed);

			// Second pass for edge distance  
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				// Start search at the cell that contains the closest point to "x" (found in 1st pass)
				ivec3 b = mb + ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d1 = dot(0.5 * (mr + r), (r - mr)); 				// IQ normalizes "r - mr" but that breaks things for the smooth version?
				float d2 = dot(0.5 * (mr + r), normalize(r - mr));

				e_smooth = smin(d1, e_smooth, smoothness);

				e = min(e, d2);

				// Also compute a smooth version of F2 in this pass
				{
					ivec3 b = ivec3(x, y, z);
					if (b != mb) 
					{
						vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
						float d = length(r);

						f2_smooth = smin(d, f2_smooth, smoothness);
					}
				}
			}

			// Different visualization modes 
			if (style == 0) 
			{
				return f1_smooth;
			}
			if (style == 1) 
			{
				return f2_smooth;
			}
			if (style == 2) 
			{
				return f2_smooth - f1_smooth;
				
				// "Pebbles" also cool
				//return step(0.2, f2_smooth - f1_smooth);
			}
			if (style == 3) 
			{
				// This one is really good for rock / stone effects
				float a = f1; 
				float b = f2;
				float k = 3.0;
				float h = max(k - abs(a - b), 0.0) / k;
				float final = min(a, b) - h * h * k * (1.0 / 4.0);
				return final;
			}
			if (style == 4) 
			{
				// Some random adjustments to make this style stand out more 
				return exp(5.0 * e_smooth);
			}
			if (style == 5) 
			{
				return pow(f1_smooth, 3.0);
			}
			if (style == 6) 
			{				
				const float eps = 0.0125;

				// Thicker lines as the user increases the smoothness slider
				float thickness = smoothness * 0.25 + eps;

				// Blurrier lines as the user increases the smoothness slider
				float blur = pow(smoothness, 3.0) * 0.25 + eps;

				return smoothstep(
					thickness - thickness * blur, 
					thickness + thickness * blur, 
					e
				);
			}
			if (style == 7) 
			{
				return hashwithoutsine13(vec3(p + mb) + seed);
			}
		}
	`,
        [d, p, f, m, g, y]
      );
    return {
      simplex: t,
      simplexFractal: i,
      simplexAshima: a,
      fbm: h,
      perlin: c,
      voronoi: x,
    };
  })(),
  X3 = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h, u, c, d, p, f, m, g, y, x) {
      super("v3"),
        (this.nodeType = "Noise"),
        (this.scale = e),
        (this.size = t),
        (this.move = i),
        (this.fA = r),
        (this.fB = s),
        (this.distortion = a),
        (this.colorA = n),
        (this.colorB = o),
        (this.colorC = l),
        (this.colorD = h),
        (this.noiseType = c),
        (this.voronoiStyle = p),
        (this.highCut = f),
        (this.lowCut = m),
        (this.smoothness = g),
        (this.seed = y),
        (this.quality = x),
        (this.isMask = d),
        (this.alpha = u),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t, i, r, s) {
      e.require("uv"),
        (e.requires.uv = [!0]),
        e.addFragmentVariable(this.calpha, "float");
      let a = Object.values(xb)[this.noiseType.value],
        n =
          a == "voronoi"
            ? `
		float v = ${a}(st + move, voronoiStyle, smoothness, seed, quality);

		// Apply clipping to colors
		v = remap(v, lowCut, highCut, 0.0, 1.0);
		v = smax(v, 0.0, smoothness * 0.25);
		v = smin(v, 1.0, smoothness * 0.25);

		// Note that the voronoi mode only uses colors "A" and "C" from the UI 
		vec4 color = mix(colorA, colorC, v); 
		`
            : `
		vec3 q = vec3(${a}(st),
					   ${a}(st + vec3(1.0)),
					   ${a}(st + vec3(1.0)));
		vec3 r = vec3(${a}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
					  ${a}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
					  ${a}(st * q));
		float f = ${a}(st + r);
		vec4 color;
		color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
		color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
		color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));
		`,
        o = new it(
          `vec3 ${a}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) 
			{
                // Prevent scale of zero 
				scale = max(abs(scale), 0.001);

				vec3 st = position / size;
				st /= scale;

				${n}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return clamp(color, 0.0, 1.0).rgb;
			}`,
          [
            Ns.simplex,
            Ns.simplexFractal,
            Ns.simplexAshima,
            Ns.fbm,
            Ns.perlin,
            Ns.voronoi,
          ]
        ),
        l = e.include(o),
        h = [];
      return (
        h.push(this.scale.build(e, "f")),
        h.push(this.size.build(e, "v3")),
        h.push(this.move.build(e, "f")),
        h.push(this.fA.build(e, "v2")),
        h.push(this.fB.build(e, "v2")),
        h.push(this.distortion.build(e, "v2")),
        h.push(this.colorA.build(e, "v4")),
        h.push(this.colorB.build(e, "v4")),
        h.push(this.colorC.build(e, "v4")),
        h.push(this.colorD.build(e, "v4")),
        h.push(this.voronoiStyle.build(e, "i")),
        h.push(this.highCut.build(e, "f")),
        h.push(this.lowCut.build(e, "f")),
        h.push(this.smoothness.build(e, "f")),
        h.push(this.seed.build(e, "f")),
        h.push(this.quality.build(e, "i")),
        h.push(this.isMask.build(e, "b")),
        h.push(
          this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
        ),
        h.push(this.alpha.build(e, "f")),
        h.push(this.calpha),
        e.format(l + "(" + h.join(",") + ")", this.getType(e), t)
      );
    }
  };
X3.numOctaves = 5;
var Q3 = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h, u, c, d, p, f, m) {
      super("v3"),
        (this.nodeType = "Outline"),
        (this.firstTime = !0),
        (this.outlineColor = e),
        (this.contourColor = t),
        (this.outlineWidth = i),
        (this.contourWidth = r),
        (this.contourThreshold = s),
        (this.outlineThreshold = a),
        (this.contourFrequency = n),
        (this.outlineSmoothing = o),
        (this.contourDirection = l),
        (this.positionalLines = h),
        (this.compensation = u),
        (this.resolution = c),
        (this.normalMap = d),
        (this.depthMap = p),
        (this.pixelRatio = f),
        (this.alpha = m),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      let i = `g${this.uuid.toString().replace(/-/g, "")}`;
      if (
        (e.require("vWorldViewDir"),
        e.require("worldNormal"),
        (e.extensions.derivatives = !0),
        this.compensation.value &&
          e.define("OUTLINE_COMPENSATION", `${i}_offset`),
        this.firstTime)
      ) {
        let r = this.outlineWidth.build(e, "f"),
          s = this.resolution.build(e, "v2"),
          a = this.compensation.build(e, "b"),
          n = this.pixelRatio.build(e, "f");
        e.addVertexParsVariable("randomColor", "attribute vec3"),
          e.addVertexParsVariable("extrudeNormal", "attribute vec3"),
          e.addVertexParsVariable(r, "uniform float"),
          e.addVertexParsVariable(s, "uniform vec2"),
          e.addVertexParsVariable(a, "uniform bool"),
          e.addVertexParsVariable(n, "uniform float"),
          e.addVertexParsVariable("vID", "flat out float"),
          e.addFragmentParsVariable("vID", "flat in float"),
          e.addVertexFinalCode(`
                vID = randomColor.r;
                vec2 ${i}_offset = vec2(0.0);
                if (${a}) {
                    vec4 ${i}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${i}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    ${i}_offset = normalize(${i}_clipNormal.xy) / ${s} * (${r} / 2.0) * ${i}_clipPosition.w * 2.0 * ${n};
                    ${i}_clipPosition.xy += ${i}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${i}_clipPosition;
                }
            `);
      }
      if (e.isShader("fragment")) {
        e.require("uv"),
          (e.requires.uv = [!0]),
          e.addFragmentVariable(this.calpha, "float");
        let r = e.include(Q3.Nodes.outline),
          s = [];
        return (
          s.push(this.outlineColor.build(e, "c")),
          s.push(this.contourColor.build(e, "c")),
          s.push(this.outlineWidth.build(e, "f")),
          s.push(this.contourWidth.build(e, "f")),
          s.push(this.contourThreshold.build(e, "f")),
          s.push(this.outlineThreshold.build(e, "f")),
          s.push(this.contourFrequency.build(e, "f")),
          s.push(this.outlineSmoothing.build(e, "f")),
          s.push(this.contourDirection.build(e, "v3")),
          s.push(this.positionalLines.build(e, "b")),
          s.push(this.resolution.build(e, "v2")),
          s.push(this.normalMap.getTexture(e, "t")),
          s.push(this.depthMap.getTexture(e, "t")),
          s.push(this.pixelRatio.build(e, "f")),
          s.push(this.compensation.build(e, "b")),
          s.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          s.push(this.alpha.build(e, "f")),
          s.push(this.calpha),
          (this.firstTime = !this.firstTime),
          e.format(r + "(" + s.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "OutlineNode is not compatible with " + e.shader + " shader."
          ),
          ""
        );
    }
  },
  Z3 = Q3;
Z3.Nodes = (function () {
  let e = new it(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    vec2 texelSize = (vec2(1.0) / resolution);
    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);
	uvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);
	uvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);
	uvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);
	uvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);
	uvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);
	uvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);
  	vec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);
  return {
    outline: new it(
      `vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                //resultAlpha = 1.0;
                //result = vec3(sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha * mask;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				 
                 return result;
             }`,
      [e]
    ),
  };
})();
var ao = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h, u, c, d, p, f, m, g, y) {
      super("v3"),
        (this.nodeType = "Pattern"),
        (this.style = e),
        (this.projection = t),
        (this.axis = i),
        (this.blending = r),
        (this.offset = s),
        (this.colorA = a),
        (this.colorB = n),
        (this.frequency = o),
        (this.size = l),
        (this.variation = h),
        (this.smoothness = u),
        (this.zigzag = c),
        (this.rotation = d),
        (this.vertical = p),
        (this.horizontal = f),
        (this.sides = m),
        (this.isMask = y),
        (this.alpha = g),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (e.isShader("fragment")) {
        e.require("position"),
          e.require("uv"),
          (e.requires.uv = [!0]),
          e.require("normal"),
          (e.requires.normal = !0),
          e.addFragmentVariable(this.calpha, "float");
        let i;
        switch (this.style.value) {
          case 0:
            i = "circle";
            break;
          case 1:
            i = "ring";
            break;
          case 2:
            i = "polygon";
            break;
          case 3:
            i = "xcross";
            break;
          case 4:
            i = "diamond";
            break;
          case 5:
            i = "checkerboard";
            break;
          case 6:
            i = "line";
            break;
          case 7:
            i = "wave";
            break;
          default:
            i = "circle";
            break;
        }
        let r = `g${this.uuid.toString().replace(/-/g, "")}`,
          s = new it(`float hashwithoutsine12(vec2 p)
				{
					vec3 p3 = fract(vec3(p.xyx) * .1031);
					p3 += dot(p3, p3.yzx + 33.33);
					return fract((p3.x + p3.y) * p3.z);
				}`),
          a = new it(`vec2 rotate_uv(in vec2 uv, float a, bool repeat) 
				{
					const float mid = 0.5;
					float radians = a * (PI / 180.0);
					vec2 rotated = vec2(
						cos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,
						cos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid
					);
					return repeat ? fract(rotated): rotated;
				}`),
          n = "";
        if (this.projection.value === 4) {
          let u =
              this.style.value === 2
                ? `${i}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
            c =
              this.style.value === 2
                ? `${i}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
            d =
              this.style.value === 2
                ? `${i}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`;
          n = `
				vec3 p = position;
				float factor = 0.0125;
				vec2 uv0 = fract(p.xy * factor);
				vec2 uv1 = fract(p.zy * factor);
				vec2 uv2 = fract(p.xz * factor);
				
				uv0 = rotate_uv(uv0 + offset, rotation, true);
				uv1 = rotate_uv(uv1 + offset, rotation, true);
				uv2 = rotate_uv(uv2 + offset, rotation, true);
	
				float d0 = ${u};
				float d1 = ${c};
				float d2 = ${d};
				
				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));
				d0 *= weights.z;
				d1 *= weights.x;
				d2 *= weights.y;
				float draw = d0 + d1 + d2;
	
				vec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;
				`;
        } else {
          let u =
              this.style.value === 2
                ? `${i}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
            c = "";
          this.axis.value === 0
            ? (c = `float radius = length(p);
					float theta = atan(p.y, p.z);
					float phi = acos(p.x / radius);`)
            : this.axis.value === 1
            ? (c = `float radius = length(p);
					float theta = atan(p.x, p.z);
					float phi = acos(p.y / radius);`)
            : (this.axis.value,
              (c = `float radius = length(p);
					float theta = atan(p.y, p.x);
					float phi = acos(p.z / radius);`));
          let d = "";
          switch (this.projection.value) {
            case 0:
              d = "custom_uv = vUv.st;";
              break;
            case 1:
              break;
            case 2:
              d = `
							vec3 p = position;
							${c}
							custom_uv = vec2(theta, phi);
							custom_uv /= PI;
							`;
              break;
            case 3:
              break;
            default:
              break;
          }
          n = `
				vec2 custom_uv;
				${d}
	
				custom_uv += offset;
				custom_uv = fract(custom_uv);
				custom_uv = rotate_uv(custom_uv, rotation, true);
	
				float draw = ${u};
				`;
        }
        let o = new it(
            `vec3 ${r}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {
					const float TWO_PI = PI * 2.0;
					float smoothness_remapped = pow(smoothness, 5.0);	

					${n}

					// Construct final output color
					vec4 color = mix(colorA, colorB, draw);
					color.a = clamp(color.a, 0.0, 1.0);

					// Apply cuts
					color.a *= 
						step(vertical.x, custom_uv.y) * 
						step(custom_uv.y, vertical.y);
					color.a *= 
						step(horizontal.x, abs(custom_uv.x)) * 
						step(abs(custom_uv.x), horizontal.y);

					// Accumulate alpha 
					float lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return clamp(color, 0.0, 1.0).rgb;
				}`,
            [
              a,
              s,
              ao.DrawFunctions.circle,
              ao.DrawFunctions.ring,
              ao.DrawFunctions.polygon,
              ao.DrawFunctions.cross,
              ao.DrawFunctions.diamond,
              ao.DrawFunctions.checkerboard,
              ao.DrawFunctions.line,
              ao.DrawFunctions.wave,
            ]
          ),
          l = e.include(o),
          h = [];
        return (
          h.push("normal"),
          h.push(this.blending.build(e, "f")),
          h.push(this.style.build(e, "i")),
          h.push(this.offset.build(e, "v2")),
          h.push(this.colorA.build(e, "v4")),
          h.push(this.colorB.build(e, "v4")),
          h.push(this.frequency.build(e, "v2")),
          h.push(this.size.build(e, "f")),
          h.push(this.variation.build(e, "f")),
          h.push(this.smoothness.build(e, "f")),
          h.push(this.zigzag.build(e, "f")),
          h.push(this.rotation.build(e, "f")),
          h.push(this.vertical.build(e, "v2")),
          h.push(this.horizontal.build(e, "v2")),
          h.push(this.sides.build(e, "i")),
          h.push(this.isMask.build(e, "b")),
          h.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          h.push(this.alpha.build(e, "f")),
          h.push(this.calpha),
          e.format(l + "(" + h.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "PatterNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3(0.0)", this.getType(e), t)
        );
    }
  },
  K3 = ao;
K3.DrawFunctions = (function () {
  let e = new it(`float hashwithoutsine12(vec2 p) {
				vec3 p3 = fract(vec3(p.xyx) * 0.1031);
				p3 += dot(p3, p3.yzx + 33.33);
				return fract((p3.x + p3.y) * p3.z);
			}`),
    t = new it(
      `vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {
                // Create tiles in UV-space
                uv *= frequency;

                // Integer coords
                vec2 i = floor(uv);

                // Offset every other row based on zigzag param, then compute fractional coords
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = fract(uv);

				// Rotate the tile itself:
				// const float mid = 0.5;
				// f = vec2(
				// 	cos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,
				// 	cos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid
				// );
				// f = fract(f);

                f = f * 2.0 - 1.0;

				// Recompute integer coords after shifting - then, random value per tile 
				i = floor(uv);
				float rand = (hashwithoutsine12(i) * 5.0 + 1.0);
				float jitter = mix(1.0, rand, variation);
				f *= jitter;

                return f;
            }`,
      [e]
    ),
    i = new it(
      `float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(
                    -smoothness, 
                     smoothness, 
                     length(f) - size
                );
            }`,
      [t]
    ),
    r = new it(
      `float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);

				float d = length(f);
                const float inner_width = 0.5;

                float outer = smoothstep(-smoothness, smoothness, d - size);
                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);
				return outer + (1.0 - inner);   
            }`,
      [t]
    ),
    s = new it(
      `float sdf_ngon(in vec2 p, in float r, in int n) {
                float an = (PI * 2.0) / float(n);
                float he = r * tan(0.5 * an);
                
                // Rotate to first sector
                p = -p.yx; 
                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);
                vec2  cs = vec2(cos(bn), sin(bn));
                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;
            
                // Side of polygon
                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);
            }
            
            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));
            }`,
      [t]
    ),
    a = new it(
      `float sdf_cross(in vec2 p, in vec2 b, float r ) {
                p = abs(p); 
				p = (p.y > p.x) ? p.yx : p.xy;
                vec2  q = p - b;
                float k = max(q.y, q.x);
                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);
                return sign(k) * length(max(w, 0.0)) + r;
            }
            
            // Avoid namespace conflicts 
            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));
            }`,
      [t]
    ),
    n = new it(
      `float ndot(vec2 a, vec2 b) { 
                return a.x*b.x - a.y*b.y; 
            }
            
            float sdf_diamond(in vec2 p, in vec2 b) {
                p = abs(p);
                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
            }

            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
	            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));
            }`,
      [t]
    ),
    o =
      new it(`float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                uv *= frequency;
                vec2 i = floor(uv);

                float offset = mod(i.y, 2.0);

                uv.x += offset + zigzag * offset;
                float x = floor(uv.x);
                
                return mod(x, 2.0);
            }`),
    l = new it(
      `float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);
				
				// Different approach for variation param here
				float row = floor(uv * frequency).y;
				float rand = hashwithoutsine12(vec2(row));
				float s = mix(size, size * rand, variation);

				return smoothstep(
					s - smoothness, 
					s + smoothness, 
					abs(f.y)
				);
            }`,
      [t]
    ),
    h = new it(`// Uses bisection 
            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {
                // Convert all data to a primitive cosine wave
                p = c * (p - vec2(d, a));
                
                const float TWO_PI = PI * 2.0;

                // Reduce to principal half cycle
                p.x = mod(p.x, TWO_PI); 
                if (p.x > PI) {
                    p.x = TWO_PI - p.x;
                }
            
                // Find zero of derivative (minimize distance)
                float xa = 0.0;
                float xb = TWO_PI;

                // 24 bit precision
                for (int i = 0; i < 24; i++) {
                    float x = 0.5 * (xa + xb);
                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));
                    if (y < 0.0) xa = x; 
                    else xb = x;
                }
                float x = 0.5 * (xa + xb);
                
                // Compute distance    
                vec2 q = vec2(x, b * c * cos(x));
                return length(p - q) / c;
            }

            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                float repeat = frequency.x;
                uv *= repeat;
                vec2 i = floor(uv);
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = vec2(uv.x, fract(uv.y));

                // Generalized cosine: y(x) = a + b * cos(cx + d)
                const float amplitude = 0.125;
                float wave_frequency = frequency.y * 0.1;
                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);

				// Different approach for variation param here
				float rand = hashwithoutsine12(vec2(i.y));
				float s = mix(size, size * rand, variation);

                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);
            }`);
  return {
    tileAndCenter: t,
    circle: i,
    ring: r,
    polygon: s,
    cross: a,
    diamond: n,
    checkerboard: o,
    line: l,
    wave: h,
  };
})();
var J3 = class extends Pi {
    constructor(e, t, i, r, s, a, n, o) {
      super("v3"),
        (this.nodeType = "Rainbow"),
        (this.filmThickness = e),
        (this.movement = t),
        (this.wavelengths = i),
        (this.noiseStrength = r),
        (this.noiseScale = s),
        (this.offset = a),
        (this.isMask = o),
        (this.alpha = n),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (
        (e.require("vWorldViewDir"),
        e.require("worldNormal"),
        e.isShader("fragment"))
      ) {
        e.require("uv"),
          (e.requires.uv = [!0]),
          e.addFragmentVariable(this.calpha, "float");
        let i = e.include(J3.Nodes.rainbow),
          r = [];
        return (
          r.push(this.filmThickness.build(e, "f")),
          r.push(this.movement.build(e, "f")),
          r.push(this.wavelengths.build(e, "v3")),
          r.push(this.noiseStrength.build(e, "f")),
          r.push(this.noiseScale.build(e, "f")),
          r.push(this.offset.build(e, "v3")),
          r.push(this.isMask.build(e, "b")),
          r.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(e, "f")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "RainbowNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  $3 = J3;
$3.Nodes = (function () {
  let e = new it(
    `vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`,
    [Ns.simplex]
  );
  return {
    rainbow: new it(
      `vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {
				vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

				float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);

				float lalpha = alpha * rainbowContribution * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return res;
             }`,
      [e]
    ),
  };
})();
var eP = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h) {
      super("v3"),
        (this.nodeType = "Toon"),
        (this.positioning = e),
        (this.colors = t),
        (this.steps = i),
        (this.source = r),
        (this.isWorldSpace = s),
        (this.noiseStrength = a),
        (this.noiseScale = n),
        (this.shadowColor = o),
        (this.offset = l),
        (this.alpha = h),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (
        (e.require("worldNormal"),
        e.require("worldPosition"),
        e.isShader("fragment"))
      ) {
        e.define("COLORS_MAX", 10), e.addFragmentVariable(this.calpha, "float");
        let i = e.include(eP.Nodes.toon),
          r = [];
        return (
          r.push(this.positioning.build(e, "i")),
          r.push(this.colors.build(e, "v4[]")),
          r.push(this.steps.build(e, "f[]")),
          r.push(this.source.build(e, "v3")),
          r.push(this.isWorldSpace.build(e, "b")),
          r.push(this.noiseStrength.build(e, "f")),
          r.push(this.noiseScale.build(e, "f")),
          r.push(this.shadowColor.build(e, "v4")),
          r.push(this.offset.build(e, "v3")),
          r.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(e, "f")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "ToonNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  tP = eP;
tP.Nodes = (function () {
  let e = new it(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`),
    t = new it(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`),
    i = new it(
      `float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`,
      [t]
    ),
    r = new it(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`),
    s = new it(
      `vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`,
      [r]
    );
  return {
    toon: new it(
      `vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`,
      [Ns.simplex, e, i, s]
    ),
  };
})();
var iq = (function () {
  return {
    textureBicubic: new it(`float w0( float a ) {
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
        }
    
        float w1( float a ) {
            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
        }
    
        float w2( float a ){
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
        }
    
        float w3( float a ) {
            return ( 1.0 / 6.0 ) * ( a * a * a );
        }
    
        // g0 and g1 are the two amplitude functions
        float g0( float a ) {
            return w0( a ) + w1( a );
        }
    
        float g1( float a ) {
            return w2( a ) + w3( a );
        }
    
        // h0 and h1 are the two offset functions
        float h0( float a ) {
            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
        }
    
        float h1( float a ) {
            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
        }
    
        vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
            uv = uv * texelSize.zw + 0.5;
    
            vec2 iuv = floor( uv );
            vec2 fuv = fract( uv );
    
            float g0x = g0( fuv.x );
            float g1x = g1( fuv.x );
            float h0x = h0( fuv.x );
            float h1x = h1( fuv.x );
            float h0y = h0( fuv.y );
            float h1y = h1( fuv.y );
    
            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    
            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + 
                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
        }

        vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
            vec2 fLodSizeInv = 1.0 / fLodSize;
            vec2 cLodSizeInv = 1.0 / cLodSize;
            vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
            vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
            return mix( fSample, cSample, fract( lod ) );
        }`),
  };
})();
function rq(e, t) {
  return e >= t ? new re(t / e, 1) : new re(1, e / t);
}
var iP = class extends Pi {
    constructor(e, t, i, r, s, a, n, o) {
      super("v3"),
        (this.nodeType = "Transmission"),
        (this.thickness = e),
        (this.ior = t),
        (this.roughness = i),
        (this.transmissionSamplerSize = r),
        (this.transmissionSamplerMap = s),
        (this.transmissionDepthMap = a),
        (this.aspectRatio = n),
        (this.alpha = o),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(e, t) {
      if (
        ((e.extensions.shaderTextureLOD = !0),
        (e.extensions.derivatives = !0),
        e.isShader("fragment"))
      ) {
        e.define("NUM_SAMPLES", 6),
          e.define("BLUR_SLOD", Math.pow(2, Tt.transmissionLod.value)),
          e.require("worldPosition"),
          (e.requires.worldNormal = !0),
          (e.requires.modelMatrix = !0),
          (e.requires.projectionMatrix = !0),
          e.addFragmentVariable(this.calpha, "float");
        let i = e.include(iP.Nodes.transmission),
          r = [];
        return (
          r.push(this.thickness.build(e, "f")),
          r.push(this.ior.build(e, "f")),
          r.push(this.roughness.build(e, "f")),
          r.push(this.transmissionSamplerSize.build(e, "v2")),
          r.push(this.transmissionSamplerMap.getTexture(e, "t")),
          r.push(this.transmissionDepthMap.getTexture(e, "t")),
          r.push(this.aspectRatio.build(e, "v2")),
          r.push("normal"),
          r.push(
            this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(e, "f")),
          r.push(this.calpha),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "TransmissionNode is not compatible with " + e.shader + " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  rP = iP;
rP.Nodes = (function () {
  let e =
      new it(`vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

				// Special case for blur == 0.0
				if (lod == 0.0) {
					#ifdef TEXTURE_LOD_EXT
					return texture2DLodEXT( sp, U, 0.0).rgb;
					#else
					return textureLod( sp, U, 0.0).rgb;
					#endif
				}
				
				vec2 texelSize = vec2(1.0) / resolution;
                vec2 halton = haltonSequence[frameIndex];
                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
                float temporalAngle  = temporalOffset * PI2;
				vec3 res = vec3(0.0);
                vec2 uv = vec2(0.0);
                vec2 offset = vec2(0.0);
                vec2 vogelSample = vec2(0.0);
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;
                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20
                    uv = U + offset;
                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    res += textureLod(sp, uv, lod).rgb;
                }
                return res / float(NUM_SAMPLES);
            }`),
    t =
      new it(`vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        
				// Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		        // The thickness is specified in local space
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`),
    i = new it(`float applyIorToRoughness( float roughness, float ior ) {
				// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
				// an IOR of 1.5 results in the default amount of microfacet refraction.
				return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
			}`),
    r = new it(
      `vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
				// Threejs exports do not pass a depth map to this shader, so we have to fallback to the "Threejs method of blurring" - see
				// also the code in convertTransmission.ts, which runs during export
				#ifdef IS_THREEJS_EXPORT
					float lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);
					return textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;
				#else
					float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
					float lod = applyIorToRoughness(roughness, ior);
					return blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
				#endif
			}`,
      [iq.textureBicubic, i, e]
    ),
    s = new it(
      `vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
				vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
				unrefractedCoords += 1.0;
				unrefractedCoords /= 2.0;

				// Sample framebuffer to get pixel the refracted ray hits.
				return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    		}`,
      [r, t]
    );
  return {
    transmission: new it(
      `vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return transmission;
            }`,
      [s]
    ),
  };
})();
var R1 = ((e) => ((e.NOISE = "noise"), (e.MAP = "map"), e))(R1 || {}),
  sP = class extends Pi {
    constructor(e, t, i, r, s, a, n, o, l, h, u) {
      super("v3"),
        (this.displacementTypeIndex = new Oi(0)),
        (this.nodeType = "VertexDisplacement"),
        (this.intensity = e),
        (this.movementOrTexture = t),
        Object.values(R1)[this.displacementTypeIndex.value] === "map" &&
          (this.mat = new N3(this.movementOrTexture.value.matrix)),
        (this.cropOrOffset = i),
        (this.scale = h),
        (this.noiseFunctionIndex = u),
        (this.voronoiStyle = r),
        (this.smoothness = s),
        (this.seed = a),
        (this.highCut = n),
        (this.lowCut = o),
        (this.quality = l);
    }
    generate(e, t) {
      if (e.isShader("vertex")) {
        e.define("USE_LAYER_DISPLACE");
        let i,
          r = [];
        switch (
          (r.push("displaced_position"),
          r.push("displaced_normal"),
          Object.values(R1)[this.displacementTypeIndex.value])
        ) {
          case "map": {
            (i = e.include(sP.Nodes.map)),
              r.push(this.movementOrTexture.getTexture(e, "t")),
              r.push("uv"),
              r.push(this.cropOrOffset.build(e, "f")),
              this.mat && r.push(this.mat.build(e, "mat3"));
            break;
          }
          case "noise": {
            let s = Object.values(xb)[this.noiseFunctionIndex.value],
              a = new it(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),
              n =
                s == "voronoi"
                  ? `
					float v = ${s}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);
					v = remap(v, lowCut, highCut, 0.0, 1.0);
					v = smax(v, 0.0, smoothness * 0.25);
					v = smin(v, 1.0, smoothness * 0.25);

					return p + n * v * intensity;
					`
                  : `
					return p + n * ${s}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
					`,
              o = new it(
                `vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {
							${n}
						}`,
                [
                  Ns.simplex,
                  Ns.simplexFractal,
                  Ns.simplexAshima,
                  Ns.fbm,
                  Ns.perlin,
                  Ns.voronoi,
                ]
              ),
              l = new it(
                `vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`,
                [o, a]
              );
            (i = e.include(l)),
              r.push(this.scale.build(e, "f")),
              r.push(this.cropOrOffset.build(e, "v3")),
              r.push(this.movementOrTexture.build(e, "f")),
              r.push(this.voronoiStyle.build(e, "i")),
              r.push(this.smoothness.build(e, "f")),
              r.push(this.seed.build(e, "f")),
              r.push(this.highCut.build(e, "f")),
              r.push(this.lowCut.build(e, "f")),
              r.push(this.quality.build(e, "i"));
            break;
          }
        }
        return (
          r.push(this.intensity.build(e, "f")),
          r.push("displaced_normal"),
          e.format(i + "(" + r.join(",") + ")", this.getType(e), t)
        );
      } else
        return (
          console.warn(
            "VertexDisplacementNode is not compatible with " +
              e.shader +
              " shader."
          ),
          e.format("vec3( 0.0 )", this.getType(e), t)
        );
    }
  },
  aP = sP;
aP.Nodes = (function () {
  let e = new it(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`),
    t =
      new it(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
  return {
    map: new it(
      `vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`,
      [e, t]
    ),
  };
})();
var Tt = {
  normalRenderTarget: new fo(),
  normalRenderTargetDepth: new fo(),
  transmissionRenderTarget: new fo(),
  aspectRatio: new ts(),
  transmissionSize: new ts(2048, 2048),
  transmissionRenderTargetDepth: new fo(),
  aoRenderTarget: new fo(),
  aoEnabled: new Ts(),
  pixelRatioNode: new lt(1),
  resolution: new ts(),
  penumbraSize: new Bl(5, 0.5),
  frameIndex: new Oi(0),
  transmissionLod: new Oi(2),
};
for (let e of Object.values(Tt)) e.isRenderGlobal = !0;
var nP = {
    skiaWasmUrl: "https://unpkg.com/@splinetool/ui-wasm@1.0.31/build/ui.wasm",
  },
  bb = class extends vl {
    constructor() {
      super("basic"),
        (this.nodeType = "Basic"),
        (this.color = new tr(ea)),
        (this.shadingAlpha = new lt(1)),
        (this.shadingBlend = new Oi(0)),
        (this.previousModelViewMatrix = new Bn()),
        (this.previouseProjectionMatrix = new Bn());
    }
    get category() {
      return "phong";
    }
    generate(e) {
      let t;
      if (e.isShader("vertex")) {
        let i = this.position
          ? this.position.analyzeAndFlow(e, "v3", { cache: "position" })
          : void 0;
        e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ resolution: Tt.resolution }),
          e.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          e.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          e.mergeUniform(au.merge([et.fog])),
          e.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
            ].join(`
`)
          );
        let r = [
          "#include <beginnormal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
        ];
        i &&
          r.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          r.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "	vNormal = transformedNormal;",
            "#endif"
          ),
          r.push(
            "#include <project_vertex>",
            "#include <fog_vertex>",
            "#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "#include <worldpos_vertex>"
          ),
          r.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (t = r.join(`
`));
      } else {
        this.color === void 0 && (this.color = new tr(ea)),
          this.color.analyze(e, { slot: "color" }),
          this.alpha && this.alpha.analyze(e),
          this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" });
        let i = this.color.flow(e, "c", { slot: "color" }),
          r = this.alpha ? this.alpha.flow(e, "f") : void 0,
          s = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0,
          a = this.afterColor
            ? this.afterColor.flow(e, "c", { slot: "afterColor" })
            : void 0;
        (e.requires.transparent = r !== void 0),
          e.addParsCode(
            [
              "varying vec3 vWPosition;",
              "#include <fog_pars_fragment>",
              "#include <dithering_pars_fragment>",
              "varying vec3 vViewPosition;",
              "#include <normal_pars_fragment>",
            ].join(`
`)
          );
        let n = ["#include <normal_fragment_begin>", i.code];
        r &&
          n.push(
            r.code,
            "#ifdef ALPHATEST",
            " if ( " + r.result + " <= ALPHATEST ) discard;",
            "#endif"
          ),
          a
            ? n.push(
                a.code,
                `vec3 outgoingLight = ${i.result};`,
                `vec3 finalColor = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`
              )
            : n.push(`vec3 finalColor = ${i.result};`);
        let o = "1.0";
        this.mask &&
          (this.mask.analyze(e),
          (o = `luminance(${this.mask.flow(e, "v3").result})`)),
          r
            ? n.push(
                `gl_FragColor = vec4( finalColor, accumAlpha * ${r.result} * ${o} );`
              )
            : n.push("gl_FragColor = vec4(" + i.result + ", 1.0 );"),
          s && n.push(`gl_FragColor.a *= ${s.result};`),
          n.push("#include <fog_fragment>", "#include <dithering_fragment>"),
          (t = n.join(`
`));
      }
      return t;
    }
  },
  sq = class extends vl {
    constructor() {
      super("lambert"),
        (this.nodeType = "Lambert"),
        (this.color = new tr(ea)),
        (this.emissive = new tr(0)),
        (this.emissiveIntensity = new lt(1)),
        (this.previousModelViewMatrix = new Bn()),
        (this.previouseProjectionMatrix = new Bn()),
        (this.shadingAlpha = new lt(1)),
        (this.shadingBlend = new Oi(0)),
        (this.occlusion = new Ts(!0));
    }
    get category() {
      return "lambert";
    }
    build(e) {
      let t;
      if (
        (e.define("LAMBERT"),
        (e.requires.lights = !0),
        (e.extensions.derivatives = !0),
        e.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(e, "v3", { cache: "position" })
          : void 0;
        e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ resolution: Tt.resolution }),
          e.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          e.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          e.mergeUniform(au.merge([et.fog, et.lights])),
          e.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "varying vec3 vLightFront;",
              "varying vec3 vIndirectFront;",
              "#ifndef DOUBLE_SIDED",
              "   #define DOUBLE_SIDED",
              "#endif",
              "#ifdef DOUBLE_SIDED",
              "	varying vec3 vLightBack;",
              "	varying vec3 vIndirectBack;",
              "#endif",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <color_pars_vertex>",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let r = [
          "#include <beginnormal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
        ];
        i &&
          r.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          r.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          r.push(
            "	#include <project_vertex>",
            "	#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "	#include <worldpos_vertex>",
            `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
				`
          ),
          r.push(
            `
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`,
            "	#include <shadowmap_vertex>",
            "	#include <fog_vertex>"
          ),
          r.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (t = r.join(`
`));
      } else {
        e.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          e.mergeUniform({ aoEnabled: Tt.aoEnabled }),
          this.color === void 0 && (this.color = new tr(ea)),
          this.color.analyze(e, { slot: "color" }),
          this.shadingAlpha.analyze(e),
          this.shadingBlend.analyze(e),
          this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(e);
        let i = this.color.flow(e, "c", { slot: "color" }),
          r = this.emissive.flow(e, "c", { slot: "emissive" }),
          s = this.emissiveIntensity.flow(e, "f", { slot: "emissive" }),
          a = this.occlusion.flow(e, "b", { slot: "occlusion" }),
          n = this.shadingAlpha.flow(e, "f"),
          o = this.shadingBlend.flow(e, "i"),
          l = this.afterColor
            ? this.afterColor.flow(e, "c", { slot: "afterColor" })
            : void 0,
          h = this.alpha ? this.alpha.flow(e, "f") : void 0,
          u = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0;
        (e.requires.transparent = h !== void 0),
          e.addParsCode(
            [
              `uniform float penumbraSize[${5}];`,
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "varying vec3 vLightFront;",
              "varying vec3 vIndirectFront;",
              "#ifndef DOUBLE_SIDED",
              "   #define DOUBLE_SIDED",
              "#endif",
              "#include <normal_pars_fragment>",
              "#ifdef DOUBLE_SIDED",
              "	varying vec3 vLightBack;",
              "	varying vec3 vIndirectBack;",
              "#endif",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <fog_pars_fragment>",
              "#include <shadowmap_pars_fragment>",
              "#include <shadowmask_pars_fragment>",
              "#include <clipping_planes_pars_fragment>",
              "#include <dithering_pars_fragment>",
            ].join(`
`)
          );
        let c = [
          "#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,
          "#include <clipping_planes_fragment>",
        ];
        c.push(
          i.code,
          "vec3 diffuseColor = " + i.result + ";",
          "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"
        ),
          h &&
            c.push(
              h.code,
              "#ifdef ALPHATEST",
              "if ( " + h.result + " <= ALPHATEST ) discard;",
              "#endif"
            ),
          c.push(
            "#ifdef DOUBLE_SIDED",
            "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;",
            "#else",
            "	reflectedLight.indirectDiffuse += vIndirectFront;",
            "#endif",
            "#include <lightmap_fragment>",
            "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );",
            "#ifdef DOUBLE_SIDED",
            "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;",
            "#else",
            "	reflectedLight.directDiffuse = vLightFront;",
            "#endif",
            "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"
          ),
          r &&
            c.push(
              r.code,
              "reflectedLight.directDiffuse += " +
                r.result +
                " * " +
                s.result +
                ";"
            ),
          c.push(
            "vec3 ao = aoEnabled && " +
              a.result +
              " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;"
          );
        let d = "1.0";
        this.mask &&
          (this.mask.analyze(e),
          (d = `luminance(${this.mask.flow(e, "v3").result})`)),
          c.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${n.result} * ${d} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${n.result} * ${d}, ${o.result} );

					outgoingLight *= ao;
				}
				`),
          l &&
            c.push(
              l.code,
              `outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          h
            ? c.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result} );`
              )
            : c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          u && c.push(`gl_FragColor.a *= ${u.result};`),
          c.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (t = c.join(`
`));
      }
      return t;
    }
  },
  iu = (function () {
    let e =
        new it(`vec2 dHdxy(sampler2D bumpMap, vec2 bumpMapUv, float bumpScale) {

            // Gradient of UVs w.r.t. X coordinate (in screen-space)
            vec2 dSTdx = dFdx(bumpMapUv);

            // Gradient of UVs w.r.t. Y coordinate (in screen-space)
            vec2 dSTdy = dFdy(bumpMapUv);
            
            // Forward differencing
            float Hll = bumpScale * luminance(texture(bumpMap, bumpMapUv).rgb);
            float dBx = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdx).rgb) - Hll;
            float dBy = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdy).rgb) - Hll;
            
            return vec2( dBx, dBy );
        }`),
      t =
        new it(`vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
            vec3 vSigmaX = dFdx( surf_pos.xyz );
            vec3 vSigmaY = dFdy( surf_pos.xyz );
            vec3 vN = surf_norm; // normalized
            
            vN = normalize(vN);

            vec3 R1 = cross( vSigmaY, vN );
            vec3 R2 = cross( vN, vSigmaX );

            R1 = normalize(R1);
            R2 = normalize(R2);
    
            float fDet = dot( vSigmaX, R1 ) * faceDirection;
    
            vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
            return normalize( abs( fDet ) * vN - vGrad );
        }`);
    return { dHdxy: e, perturbNormalArb: t };
  })(),
  aq = class extends vl {
    constructor() {
      super("phong"),
        (this.nodeType = "Phong"),
        (this.color = new tr(ea)),
        (this.specular = new tr(1118481)),
        (this.shininess = new lt(30)),
        (this.previousModelViewMatrix = new Bn()),
        (this.previouseProjectionMatrix = new Bn()),
        (this.shadingAlpha = new lt(1)),
        (this.shadingBlend = new Oi(0)),
        (this.occlusion = new Ts(!0));
    }
    get category() {
      return "phong";
    }
    build(e) {
      let t;
      if (
        (e.define("PHONG"),
        (e.requires.lights = !0),
        (e.extensions.derivatives = !0),
        e.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(e, "v3", { cache: "position" })
          : void 0;
        e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ resolution: Tt.resolution }),
          e.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          e.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          e.mergeUniform(au.merge([et.fog, et.lights])),
          e.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <skinning_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let r = [
          "#include <beginnormal_vertex>",
          `
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = objectNormal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
        ];
        i &&
          r.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          r.push(
            "transformed = displaced_position;",
            "#include <skinning_vertex>",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          r.push(
            "	#include <project_vertex>",
            "	#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "	#include <worldpos_vertex>",
            "	#include <shadowmap_vertex>",
            "	#include <fog_vertex>"
          ),
          r.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (t = r.join(`
`));
      } else {
        e.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          e.mergeUniform({ aoEnabled: Tt.aoEnabled }),
          this.color === void 0 && (this.color = new tr(ea)),
          this.color.analyze(e, { slot: "color" }),
          this.specular.analyze(e),
          this.shininess.analyze(e);
        let i = this.occlusion.flow(e, "b", { slot: "occlusion" });
        this.shadingAlpha.analyze(e),
          this.shadingBlend.analyze(e),
          this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(e);
        let r = this.color.flow(e, "c", { slot: "color" }),
          s = this.specular.flow(e, "c"),
          a = this.shininess.flow(e, "f"),
          n = this.shadingAlpha.flow(e, "f"),
          o = this.shadingBlend.flow(e, "i"),
          l = this.afterColor
            ? this.afterColor.flow(e, "c", { slot: "afterColor" })
            : void 0,
          h = this.alpha ? this.alpha.flow(e, "f") : void 0,
          u = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0;
        (e.requires.transparent = h !== void 0),
          e.addParsCode(
            [
              "varying vec3 vWPosition;",
              "uniform vec3 emissive;",
              `uniform float penumbraSize[${5}];`,
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "#include <normal_pars_fragment>",
              "#include <fog_pars_fragment>",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <lights_phong_pars_fragment>",
              "#include <shadowmap_pars_fragment>",
              "#include <dithering_pars_fragment>",
            ].join(`
`)
          );
        let c = [
          "#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
          "	BlinnPhongMaterial material;",
        ];
        if (this.bumpMap) {
          e.include(iu.dHdxy), e.include(iu.perturbNormalArb);
          let p = this.bumpMap.texture.flow(e, "t"),
            f = this.bumpMap.flow(e, "v3"),
            m = this.bumpMapIntensity
              ? this.bumpMapIntensity.flow(e, "f").result
              : "1.0",
            g = "";
          this.bumpMap.projection.value === 4
            ? (g = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${p.result}, uv0, ${m});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${p.result}, uv1, ${m});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${p.result}, uv2, ${m});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`)
            : (g = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${p.result}, bumpMapCachedUv, ${m});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
            c.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${f.result};
					${g}
					`);
        }
        c.push(
          r.code,
          "	vec3 diffuseColor = " + r.result + ";",
          "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
          "	vec3 totalEmissiveRadiance = emissive;",
          s.code,
          "	vec3 specular = " + s.result + ";",
          a.code,
          "	float shininess = max( 0.0001, " + a.result + " );",
          "	float specularStrength = 1.0;"
        ),
          h &&
            c.push(
              h.code,
              "#ifdef ALPHATEST",
              "if ( " + h.result + " <= ALPHATEST ) discard;",
              "#endif"
            ),
          c.push("material.diffuseColor = diffuseColor;"),
          c.push(
            "material.specularColor = specular;",
            "material.specularShininess = shininess;",
            "material.specularStrength = specularStrength;",
            "#include <lights_fragment_begin>",
            "#include <lights_fragment_end>"
          ),
          c.push(
            "vec3 ao = aoEnabled && " +
              i.result +
              " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"
          );
        let d = "1.0";
        this.mask &&
          (this.mask.analyze(e),
          (d = `luminance(${this.mask.flow(e, "v3").result})`)),
          c.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${n.result} * ${d} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${n.result} * ${d}, ${o.result} );
					
					outgoingLight *= ao;
				}
				`),
          l &&
            c.push(
              l.code,
              `outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          h
            ? c.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result});`
              )
            : c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          u && c.push(`gl_FragColor.a *= ${u.result};`),
          c.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (t = c.join(`
`));
      }
      return t;
    }
  },
  nq = class extends vl {
    constructor() {
      super("standard"),
        (this.nodeType = "Standard"),
        (this.color = new tr(ea)),
        (this.roughness = new lt(0.3)),
        (this.metalness = new lt(0)),
        (this.reflectivity = new lt(0.5)),
        (this.previousModelViewMatrix = new Bn()),
        (this.previouseProjectionMatrix = new Bn()),
        (this.shadingAlpha = new lt(1)),
        (this.shadingBlend = new Oi(0)),
        (this.occlusion = new Ts(!0));
    }
    get category() {
      return "physical";
    }
    build(e) {
      let t;
      if (
        (e.define("STANDARD"),
        (e.requires.lights = !0),
        (e.extensions.derivatives = !0),
        (e.extensions.shaderTextureLOD = !0),
        e.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(e, "v3", { cache: "position" })
          : void 0;
        e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ resolution: Tt.resolution }),
          e.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          e.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          e.mergeUniform(au.merge([et.fog, et.lights])),
          et.LTC_1 &&
            ((e.uniforms.ltc_1 = { value: void 0 }),
            (e.uniforms.ltc_2 = { value: void 0 })),
          e.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let r = [
          "#include <beginnormal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
        ];
        i &&
          r.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          r.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          r.push(
            "#include <project_vertex>",
            "#include <fog_vertex>",
            "#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "#include <worldpos_vertex>",
            "#include <shadowmap_vertex>"
          ),
          r.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (t = r.join(`
`));
      } else {
        e.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          e.mergeUniform({ aoEnabled: Tt.aoEnabled });
        let i = { gamma: !0 };
        this.color === void 0 && (this.color = new tr(ea)),
          this.color.analyze(e, { slot: "color", context: i }),
          this.roughness.analyze(e),
          this.metalness.analyze(e);
        let r = this.occlusion.flow(e, "b", { slot: "occlusion" });
        this.shadingAlpha.analyze(e),
          this.shadingBlend.analyze(e),
          this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(e),
          this.reflectivity && this.reflectivity.analyze(e);
        let s = this.color.flow(e, "c", { slot: "color", context: i }),
          a = this.roughness.flow(e, "f"),
          n = this.metalness.flow(e, "f"),
          o = this.shadingAlpha.flow(e, "f"),
          l = this.shadingBlend.flow(e, "i"),
          h = this.afterColor
            ? this.afterColor.flow(e, "c", { slot: "afterColor" })
            : void 0,
          u = this.alpha ? this.alpha.flow(e, "f") : void 0,
          c = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0,
          d = this.reflectivity ? this.reflectivity.flow(e, "f") : void 0;
        (e.requires.transparent = u !== void 0),
          e.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              `uniform float penumbraSize[${5}];`,
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "#include <normal_pars_fragment>",
              "#include <dithering_pars_fragment>",
              "#include <fog_pars_fragment>",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <lights_physical_pars_fragment>",
              "#include <shadowmap_pars_fragment>",
            ].join(`
`)
          );
        let p = [
          "#include <clipping_planes_fragment>",
          "	#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
          "	PhysicalMaterial material;",
          "	material.diffuseColor = vec3( 1.0 );",
        ];
        if (this.bumpMap) {
          e.include(iu.dHdxy), e.include(iu.perturbNormalArb);
          let m = this.bumpMap.texture.flow(e, "t"),
            g = this.bumpMap.flow(e, "v3"),
            y = this.bumpMapIntensity
              ? this.bumpMapIntensity.flow(e, "f").result
              : "1.0",
            x = "";
          this.bumpMap.projection.value === 4
            ? (x = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${m.result}, uv0, ${y});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${m.result}, uv1, ${y});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${m.result}, uv2, ${y});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`)
            : (x = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${m.result}, bumpMapCachedUv, ${y});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
            p.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${g.result};
					${x}
					`);
        }
        if (
          (p.push(
            s.code,
            "	vec3 diffuseColor = " + s.result + ";",
            "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
            n.code,
            "	float metalnessFactor = " + n.result + ";"
          ),
          this.roughnessMap)
        ) {
          let m = this.roughnessMap.texture.flow(e, "t"),
            g = this.roughnessMap.flow(e, "v3"),
            y = "";
          this.roughnessMap.projection.value === 4
            ? (y = `
					float roughnessChange = 1.0;
					{
						vec2 uv0 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.roughnessMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						float r0 = luminance(texture(${m.result}, uv0).rgb) * roughnessScale;
						float r1 = luminance(texture(${m.result}, uv1).rgb) * roughnessScale;
						float r2 = luminance(texture(${m.result}, uv2).rgb) * roughnessScale;

						roughnessChange = (r0 * weights.z + r1 * weights.x + r2 * weights.y);
					}
					float roughnessFactor = roughnessChange * ${a.result};
					`)
            : (y = `
					vec2 roughnessMapCachedUv = g${this.roughnessMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;

					vec4 vals = texture(${m.result},  roughnessMapCachedUv);
					float roughnessFactor = luminance(vals.rgb) * ${a.result};
					`),
            p.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${g.result};

					const float roughnessScale = 1.0;

					${y}
				`);
        } else p.push(a.code, "	float roughnessFactor = " + a.result + ";");
        u &&
          p.push(
            u.code,
            "#ifdef ALPHATEST",
            "	if ( " + u.result + " <= ALPHATEST ) discard;",
            "#endif"
          ),
          p.push(
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"
          ),
          p.push(
            "material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );",
            "material.roughness = max( roughnessFactor, 0.0525 );",
            "material.roughness += geometryRoughness;",
            "material.roughness = min( material.roughness, 1.0 );",
            "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"
          ),
          d
            ? p.push(
                d.code,
                "material.specularColor = mix( vec3( 0.16 * pow2( " +
                  d.result +
                  " ) ), diffuseColor, metalnessFactor );"
              )
            : p.push(
                "material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"
              ),
          p.push("#include <lights_fragment_begin>"),
          p.push("#include <lights_fragment_end>"),
          p.push(
            "vec3 ao = aoEnabled && " +
              r.result +
              " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"
          );
        let f = "1.0";
        this.mask &&
          (this.mask.analyze(e),
          (f = `luminance(${this.mask.flow(e, "v3").result})`)),
          p.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${o.result} * ${f} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${o.result} * ${f}, ${l.result} );
					
					outgoingLight *= ao;
				}
				`),
          h &&
            p.push(
              h.code,
              `outgoingLight = spe_blend(outgoingLight, ${h.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          u
            ? p.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`
              )
            : p.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          c && p.push(`gl_FragColor.a *= ${c.result};`),
          p.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (t = p.join(`
`));
      }
      return t;
    }
  },
  oq = class extends vl {
    constructor() {
      super("toon"),
        (this.nodeType = "Toon"),
        (this.color = new tr(ea)),
        (this.specular = new tr(1118481)),
        (this.shininess = new lt(30)),
        (this.previousModelViewMatrix = new Bn()),
        (this.previouseProjectionMatrix = new Bn()),
        (this.shadingAlpha = new lt(1)),
        (this.shadingBlend = new Oi(0));
    }
    get category() {
      return "toon";
    }
    build(e) {
      let t;
      if (
        (e.define("TOON"),
        (e.requires.lights = !0),
        (e.extensions.derivatives = !0),
        e.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(e, "v3", { cache: "position" })
          : void 0;
        e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ resolution: Tt.resolution }),
          e.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          e.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          e.mergeUniform(au.merge([et.fog, et.lights])),
          e.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let r = [
          "#include <beginnormal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
        ];
        i &&
          r.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          r.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          r.push(
            "	#include <project_vertex>",
            "	#include <fog_vertex>",
            "	#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "	#include <worldpos_vertex>",
            "	#include <shadowmap_vertex>",
            "	#include <fog_vertex>"
          ),
          r.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (t = r.join(`
`));
      } else {
        e.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          e.mergeUniform({ frameIndex: Tt.frameIndex }),
          e.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          e.mergeUniform({ aoEnabled: Tt.aoEnabled }),
          this.color === void 0 && (this.color = new tr(ea)),
          this.color.analyze(e, { slot: "color" }),
          this.specular.analyze(e),
          this.shininess.analyze(e),
          this.shadingAlpha.analyze(e),
          this.shadingBlend.analyze(e),
          this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(e);
        let i = this.color.flow(e, "c", { slot: "color" }),
          r = this.specular.flow(e, "c"),
          s = this.shininess.flow(e, "f"),
          a = this.shadingAlpha.flow(e, "f"),
          n = this.shadingBlend.flow(e, "i"),
          o = this.afterColor
            ? this.afterColor.flow(e, "c", { slot: "afterColor" })
            : void 0,
          l = this.alpha ? this.alpha.flow(e, "f") : void 0,
          h = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0;
        (e.requires.transparent = l !== void 0),
          e.addParsCode(
            [
              `uniform float penumbraSize[${5}];`,
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "varying vec3 vWPosition;",
              "#include <normal_pars_fragment>",
              "#include <gradientmap_pars_fragment>",
              "#include <fog_pars_fragment>",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <dithering_pars_fragment>",
              `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,
              "#include <shadowmap_pars_fragment>",
              "#include <bumpmap_pars_fragment>",
              "#include <normalmap_pars_fragment>",
            ].join(`
`)
          );
        let u = [
          "#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
          "	ToonMaterial material;",
        ];
        if (this.bumpMap) {
          e.include(iu.dHdxy), e.include(iu.perturbNormalArb);
          let d = this.bumpMap.texture.flow(e, "t"),
            p = this.bumpMap.flow(e, "v3"),
            f = this.bumpMapIntensity
              ? this.bumpMapIntensity.flow(e, "f").result
              : "1.0",
            m = "";
          this.bumpMap.projection.value === 4
            ? (m = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${d.result}, uv0, ${f});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${d.result}, uv1, ${f});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${d.result}, uv2, ${f});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`)
            : (m = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${d.result}, bumpMapCachedUv, ${f});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
            u.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${p.result};
					${m}
					`);
        }
        u.push(
          i.code,
          "	vec3 diffuseColor = " + i.result + ";",
          "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
          r.code,
          "	vec3 specular = " + r.result + ";",
          s.code,
          "	float shininess = max( 0.0001, " + s.result + " );",
          "	float specularStrength = 1.0;"
        ),
          l &&
            u.push(
              l.code,
              "#ifdef ALPHATEST",
              "if ( " + l.result + " <= ALPHATEST ) discard;",
              "#endif"
            ),
          u.push("material.diffuseColor = diffuseColor;"),
          u.push(
            "material.specularColor = specular;",
            "material.specularShininess = shininess;",
            "material.specularStrength = specularStrength;",
            "#include <lights_fragment_begin>",
            "#include <lights_fragment_end>"
          ),
          u.push(
            "vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;"
          );
        let c = "1.0";
        this.mask &&
          (this.mask.analyze(e),
          (c = `luminance(${this.mask.flow(e, "v3").result})`)),
          u.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * ${c} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result} * ${c}, ${n.result} );
				}
				`),
          o &&
            u.push(
              o.code,
              `outgoingLight = spe_blend(outgoingLight, ${o.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          l
            ? u.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${l.result} );`
              )
            : u.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          h && u.push(`gl_FragColor.a *= ${h.result};`),
          u.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (t = u.join(`
`));
      }
      return t;
    }
  },
  lq = class {
    constructor(e = 1e3 * 10) {
      (this.timeout = e),
        (this.cache = new Map()),
        (this.head = {
          data: null,
          time: 0,
          src: null,
          next: null,
          prev: null,
        }),
        (this.tail = {
          data: null,
          time: 1 / 0,
          src: null,
          next: null,
          prev: null,
        }),
        (this.hasClean = !1),
        (this.head.next = this.tail),
        (this.tail.prev = this.head);
    }
    log(...e) {}
    remove(e) {
      let t = this.cache.get(e);
      t &&
        (this.dispose(e, t.data),
        this.cache.delete(e),
        (t.prev.next = t.next),
        (t.next.prev = t.prev));
    }
    scheduleCleanup() {
      this.hasClean ||
        (this.log("scheduled cleanup"),
        (this.hasClean = !0),
        setTimeout(() => {
          (this.hasClean = !1), this.log("cleaning");
          let e = Date.now(),
            t = this.head.next;
          for (; t.time < e - this.timeout; )
            this.dispose(t.src, t.data),
              this.cache.delete(t.src),
              (t = t.next),
              (t.prev = this.head),
              (this.head.next = t);
          this.head.next !== this.tail
            ? this.scheduleCleanup()
            : this.log("no more cleanup");
        }, this.timeout + 1e3));
    }
    has(e) {
      return this.cache.get(e)?.data;
    }
    load(e) {
      let t = Date.now(),
        i = this.cache.get(e);
      return (
        i === void 0
          ? ((i = {
              data: this.create(e),
              src: e,
              time: t,
              next: null,
              prev: null,
            }),
            this.cache.set(e, i))
          : ((i.time = t), (i.prev.next = i.next), (i.next.prev = i.prev)),
        (i.prev = this.tail.prev),
        (i.next = this.tail),
        (this.tail.prev.next = i),
        (this.tail.prev = i),
        this.scheduleCleanup(),
        i.data
      );
    }
  },
  hq = class extends lq {
    create(e) {
      return URL.createObjectURL(new Blob([e]));
    }
    dispose(e, t) {
      URL.revokeObjectURL(t);
    }
  },
  b0;
function cq(e) {
  return typeof e == "string" ? e : (b0 || (b0 = new hq()), b0.load(e));
}
var uq = class {
    constructor(e, t) {
      (this.data = e), (this.cache = t), (this.refCount = 0);
    }
    deref() {
      this.refCount,
        (this.refCount -= 1),
        this.refCount === 0 && (this.cache.remove(this), this.dispose());
    }
    dispose() {
      this.refCount;
    }
  },
  dq = class {
    constructor() {
      this.cache = new Map();
    }
    remove(e) {
      this.cache.delete(e.data);
    }
    load(e) {
      let t = this.cache.get(e);
      return (
        t === void 0 && ((t = this.create(e)), this.cache.set(e, t)),
        (t.refCount += 1),
        t
      );
    }
  },
  oP = class extends uq {
    constructor(e, t) {
      super(e, t.imageHolderCache),
        (this.data = e),
        (this.shared = t),
        (this.loaded = !1),
        (this.isVideo = !1),
        (this.isCanvas = !1),
        (this._cache = { [1e3]: {}, [1001]: {}, [1002]: {} }),
        (this.isVideo = e.type === "video"),
        (this.isCanvas = e.nodeName === "CANVAS"),
        this.updateSrc(this.isCanvas ? e : e.data);
    }
    async updateSrc(e) {
      if (typeof document > "u") return;
      this.disposeTextures(), (this.loaded = !1);
      let t = () => {
        this.loaded = !0;
        for (let r of Object.values(this._cache))
          for (let s of Object.values(r))
            s && ((s.image = this.img), (s.needsUpdate = !0));
        this.shared.requestRender();
      };
      if (this.isCanvas) (this.img = e), (this.loaded = !0);
      else if (this.isVideo) {
        if (
          ((this.img = document.createElement("video")),
          (this.img.preload = "auto"),
          (this.img.playsInline = !0),
          (this.img.currentTime = 0.01),
          typeof e != "string")
        ) {
          var i = new FileReader();
          i.readAsDataURL(new Blob([e], { type: "video/mp4" }));
          let r;
          await new Promise((s) => {
            i.onloadend = (a) => {
              (r = a.target?.result), s(null);
            };
          }),
            (this.img.src = r);
        } else this.img.src = e;
        this.img.onloadeddata = () => {
          t();
        };
      } else
        (this.img = new Image()), (this.img.src = cq(e)), (this.img.onload = t);
    }
    getTexture(e, t = 1008) {
      let i = this._cache[e]?.[t];
      if (i) return i;
      {
        let r;
        return (
          this.isCanvas && (r = new rF(this.img, void 0, e, e, void 0, t)),
          this.isVideo
            ? (r = new iF(this.img, void 0, e, e))
            : (r = new Yi(this.img, void 0, e, e, void 0, t)),
          this.loaded && (r.needsUpdate = !0),
          this._cache[e] === void 0 && (this._cache[e] = {}),
          (this._cache[e][t] = r),
          r
        );
      }
    }
    setNeedsUpdate(e) {
      for (let t of Object.values(this._cache))
        for (let i of Object.values(t)) i && (i.needsUpdate = e);
    }
    disposeTextures() {
      for (let [e, t] of Object.entries(this._cache))
        for (let [i, r] of Object.entries(t))
          r?.dispose(), (this._cache[e][i] = void 0);
    }
    dispose() {
      super.dispose(), this.disposeTextures();
    }
  },
  Jo = class extends oP {};
function pq(e, t) {
  var i = vq(t);
  return i.formatToParts ? mq(i, e) : gq(i, e);
}
var fq = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 };
function mq(e, t) {
  try {
    for (var i = e.formatToParts(t), r = [], s = 0; s < i.length; s++) {
      var a = fq[i[s].type];
      a >= 0 && (r[a] = parseInt(i[s].value, 10));
    }
    return r;
  } catch (n) {
    if (n instanceof RangeError) return [NaN];
    throw n;
  }
}
function gq(e, t) {
  var i = e.format(t).replace(/\u200E/g, ""),
    r = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(i);
  return [r[3], r[1], r[2], r[4], r[5], r[6]];
}
var w0 = {};
function vq(e) {
  if (!w0[e]) {
    var t = new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: "America/New_York",
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      }).format(new Date("2014-06-25T04:00:00.123Z")),
      i =
        t === "06/25/2014, 00:00:00" ||
        t ===
          "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
    w0[e] = i
      ? new Intl.DateTimeFormat("en-US", {
          hour12: !1,
          timeZone: e,
          year: "numeric",
          month: "numeric",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        })
      : new Intl.DateTimeFormat("en-US", {
          hourCycle: "h23",
          timeZone: e,
          year: "numeric",
          month: "numeric",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });
  }
  return w0[e];
}
function lP(e, t, i, r, s, a, n) {
  var o = new Date(0);
  return o.setUTCFullYear(e, t, i), o.setUTCHours(r, s, a, n), o;
}
var LA = 36e5,
  yq = 6e4,
  _0 = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/,
  };
function hP(e, t, i) {
  var r, s;
  if (!e || ((r = _0.timezoneZ.exec(e)), r)) return 0;
  var a;
  if (((r = _0.timezoneHH.exec(e)), r))
    return (a = parseInt(r[1], 10)), BA(a) ? -(a * LA) : NaN;
  if (((r = _0.timezoneHHMM.exec(e)), r)) {
    a = parseInt(r[1], 10);
    var n = parseInt(r[2], 10);
    return BA(a, n) ? ((s = Math.abs(a) * LA + n * yq), a > 0 ? -s : s) : NaN;
  }
  if (wq(e)) {
    t = new Date(t || Date.now());
    var o = i ? t : xq(t),
      l = L1(o, e),
      h = i ? l : bq(t, l, e);
    return -h;
  }
  return NaN;
}
function xq(e) {
  return lP(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function L1(e, t) {
  var i = pq(e, t),
    r = lP(i[0], i[1] - 1, i[2], i[3] % 24, i[4], i[5], 0).getTime(),
    s = e.getTime(),
    a = s % 1e3;
  return (s -= a >= 0 ? a : 1e3 + a), r - s;
}
function bq(e, t, i) {
  var r = e.getTime(),
    s = r - t,
    a = L1(new Date(s), i);
  if (t === a) return t;
  s -= a - t;
  var n = L1(new Date(s), i);
  return a === n ? a : Math.max(a, n);
}
function BA(e, t) {
  return -23 <= e && e <= 23 && (t == null || (0 <= t && t <= 59));
}
var zA = {};
function wq(e) {
  if (zA[e]) return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), (zA[e] = !0), !0;
  } catch {
    return !1;
  }
}
var _q = Sr(zO(), 1),
  FA = Sr(FO(), 1),
  Sq =
    /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/,
  Aq = Sq,
  S0 = 36e5,
  kA = 6e4,
  Mq = 2,
  Ps = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    YY: /^(\d{2})$/,
    YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
    YYYY: /^(\d{4})/,
    YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    timeZone: Aq,
  };
function Eq(e, t) {
  if (arguments.length < 1)
    throw new TypeError(
      "1 argument required, but only " + arguments.length + " present"
    );
  if (e === null) return new Date(NaN);
  var i = t || {},
    r = i.additionalDigits == null ? Mq : (0, _q.default)(i.additionalDigits);
  if (r !== 2 && r !== 1 && r !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (
    e instanceof Date ||
    (typeof e == "object" &&
      Object.prototype.toString.call(e) === "[object Date]")
  )
    return new Date(e.getTime());
  if (
    typeof e == "number" ||
    Object.prototype.toString.call(e) === "[object Number]"
  )
    return new Date(e);
  if (
    !(
      typeof e == "string" ||
      Object.prototype.toString.call(e) === "[object String]"
    )
  )
    return new Date(NaN);
  var s = Cq(e),
    a = Tq(s.date, r),
    n = a.year,
    o = a.restDateString,
    l = Pq(o, n);
  if (isNaN(l)) return new Date(NaN);
  if (l) {
    var h = l.getTime(),
      u = 0,
      c;
    if (s.time && ((u = Dq(s.time)), isNaN(u))) return new Date(NaN);
    if (s.timeZone || i.timeZone) {
      if (((c = hP(s.timeZone || i.timeZone, new Date(h + u))), isNaN(c)))
        return new Date(NaN);
    } else
      (c = (0, FA.default)(new Date(h + u))),
        (c = (0, FA.default)(new Date(h + u + c)));
    return new Date(h + u + c);
  } else return new Date(NaN);
}
function Cq(e) {
  var t = {},
    i = Ps.dateTimePattern.exec(e),
    r;
  if (
    (i
      ? ((t.date = i[1]), (r = i[3]))
      : ((i = Ps.datePattern.exec(e)),
        i ? ((t.date = i[1]), (r = i[2])) : ((t.date = null), (r = e))),
    r)
  ) {
    var s = Ps.timeZone.exec(r);
    s
      ? ((t.time = r.replace(s[1], "")), (t.timeZone = s[1].trim()))
      : (t.time = r);
  }
  return t;
}
function Tq(e, t) {
  var i = Ps.YYY[t],
    r = Ps.YYYYY[t],
    s;
  if (((s = Ps.YYYY.exec(e) || r.exec(e)), s)) {
    var a = s[1];
    return { year: parseInt(a, 10), restDateString: e.slice(a.length) };
  }
  if (((s = Ps.YY.exec(e) || i.exec(e)), s)) {
    var n = s[1];
    return { year: parseInt(n, 10) * 100, restDateString: e.slice(n.length) };
  }
  return { year: null };
}
function Pq(e, t) {
  if (t === null) return null;
  var i, r, s, a;
  if (e.length === 0) return (r = new Date(0)), r.setUTCFullYear(t), r;
  if (((i = Ps.MM.exec(e)), i))
    return (
      (r = new Date(0)),
      (s = parseInt(i[1], 10) - 1),
      UA(t, s) ? (r.setUTCFullYear(t, s), r) : new Date(NaN)
    );
  if (((i = Ps.DDD.exec(e)), i)) {
    r = new Date(0);
    var n = parseInt(i[1], 10);
    return Rq(t, n) ? (r.setUTCFullYear(t, 0, n), r) : new Date(NaN);
  }
  if (((i = Ps.MMDD.exec(e)), i)) {
    (r = new Date(0)), (s = parseInt(i[1], 10) - 1);
    var o = parseInt(i[2], 10);
    return UA(t, s, o) ? (r.setUTCFullYear(t, s, o), r) : new Date(NaN);
  }
  if (((i = Ps.Www.exec(e)), i))
    return (a = parseInt(i[1], 10) - 1), VA(t, a) ? NA(t, a) : new Date(NaN);
  if (((i = Ps.WwwD.exec(e)), i)) {
    a = parseInt(i[1], 10) - 1;
    var l = parseInt(i[2], 10) - 1;
    return VA(t, a, l) ? NA(t, a, l) : new Date(NaN);
  }
  return null;
}
function Dq(e) {
  var t, i, r;
  if (((t = Ps.HH.exec(e)), t))
    return (
      (i = parseFloat(t[1].replace(",", "."))), A0(i) ? (i % 24) * S0 : NaN
    );
  if (((t = Ps.HHMM.exec(e)), t))
    return (
      (i = parseInt(t[1], 10)),
      (r = parseFloat(t[2].replace(",", "."))),
      A0(i, r) ? (i % 24) * S0 + r * kA : NaN
    );
  if (((t = Ps.HHMMSS.exec(e)), t)) {
    (i = parseInt(t[1], 10)), (r = parseInt(t[2], 10));
    var s = parseFloat(t[3].replace(",", "."));
    return A0(i, r, s) ? (i % 24) * S0 + r * kA + s * 1e3 : NaN;
  }
  return null;
}
function NA(e, t, i) {
  (t = t || 0), (i = i || 0);
  var r = new Date(0);
  r.setUTCFullYear(e, 0, 4);
  var s = r.getUTCDay() || 7,
    a = t * 7 + i + 1 - s;
  return r.setUTCDate(r.getUTCDate() + a), r;
}
var Oq = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  Iq = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function cP(e) {
  return e % 400 === 0 || (e % 4 === 0 && e % 100 !== 0);
}
function UA(e, t, i) {
  if (t < 0 || t > 11) return !1;
  if (i != null) {
    if (i < 1) return !1;
    var r = cP(e);
    if ((r && i > Iq[t]) || (!r && i > Oq[t])) return !1;
  }
  return !0;
}
function Rq(e, t) {
  if (t < 1) return !1;
  var i = cP(e);
  return !((i && t > 366) || (!i && t > 365));
}
function VA(e, t, i) {
  return !(t < 0 || t > 52 || (i != null && (i < 0 || i > 6)));
}
function A0(e, t, i) {
  return !(
    (e != null && (e < 0 || e >= 25)) ||
    (t != null && (t < 0 || t >= 60)) ||
    (i != null && (i < 0 || i >= 60))
  );
}
function Lq(e, t, i) {
  var r = Eq(e, i),
    s = hP(t, r, !0),
    a = new Date(r.getTime() - s),
    n = new Date(0);
  return (
    n.setFullYear(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate()),
    n.setHours(
      a.getUTCHours(),
      a.getUTCMinutes(),
      a.getUTCSeconds(),
      a.getUTCMilliseconds()
    ),
    n
  );
}
function Ds(e, t) {
  return t.color(e);
}
function jA(e = new Date(), t) {
  let i = t.format,
    r = e.getSeconds(),
    s = e;
  t && t.timeZone !== null && (s = Lq(new Date(), t.timeZone));
  let a = s.getHours(),
    n = s.getMinutes(),
    o;
  t.format12h24h === "12ampm" && (o = a >= 12 ? "PM" : "AM");
  let l = a;
  t.format12h24h !== "24" && ((l = a % 12), l === 0 && (l = 12));
  let h, u;
  switch (i) {
    case "HH:mm:ss":
      h = [l, n, r];
      break;
    case "HH:mm":
      h = [l, n];
      break;
    case "HH":
      (h = [l]), (o = void 0);
      break;
    case "mm":
      (h = [n]), (o = void 0);
      break;
    case "ss":
      (h = [r]), (o = void 0);
      break;
    case "year":
      u = s.getFullYear();
      break;
    case "month":
      u = s.getMonth() + 1;
      break;
    case "dayOfYear":
      u = Math.floor(
        (s.getTime() - new Date(s.getFullYear(), 0, 0).getTime()) / 864e5
      );
      break;
    case "dayOfMonth":
      u = s.getDate();
      break;
    case "secondOfDay":
      u = a * 60 * 60 + n * 60 + r;
      break;
    default:
      console.error("Unknown time format", i), (u = 0);
      break;
  }
  return h !== void 0 ? { textValue: h, suffix: o } : u;
}
function Bq(e, t) {
  switch (e.type) {
    case "fresnel":
      return kq(e, t);
    case "gradient":
      return Nq(e, t);
    case "depth":
      return Uq(e, t);
    case "normal":
      return Vq(e, t);
    case "noise":
      return jq(e, t);
    case "rainbow":
      return Hq(e, t);
    case "toon":
      return Gq(e, t);
    case "outline":
      return Wq(e, t);
    case "transmission":
      return qq(e, t);
    case "color":
      return Fq(e, t);
    case "pattern":
      return Yq(e, t);
  }
}
function zq(e) {
  return { type: e.type };
}
function $a(e, t) {
  let { alpha: i, mode: r, isMask: s } = e,
    a = typeof i == "string" ? (Number(t.getVariable(i)) ?? 100) / 100 : i;
  return { ...zq(e), alpha: a, mode: r, isMask: s };
}
function Fq(e, t) {
  return { ...$a(e, t), color: Ds(e.color, t) };
}
function kq(e, t) {
  let { bias: i, scale: r, intensity: s, factor: a, color: n } = e;
  return {
    ...$a(e, t),
    color: Ds(n, t),
    bias: i,
    scale: r,
    intensity: s,
    factor: a,
  };
}
function Nq(e, t) {
  let {
    gradientType: i,
    smooth: r,
    colors: s,
    steps: a,
    angle: n,
    offset: o,
    morph: l,
  } = e;
  return {
    ...$a(e, t),
    gradientType: i,
    smooth: r,
    colors: s.map((h) => new Lt(h[0], h[1], h[2], h[3])),
    num: s.length,
    steps: a,
    offset: new re(...o),
    morph: new re(...l),
    angle: n,
  };
}
function Uq(e, t) {
  let {
    gradientType: i,
    near: r,
    far: s,
    isVector: a,
    isWorldSpace: n,
    origin: o,
    direction: l,
    colors: h,
    steps: u,
    smooth: c,
  } = e;
  return {
    ...$a(e, t),
    gradientType: i,
    near: r,
    far: s,
    isVector: a,
    isWorldSpace: n,
    origin: new I(...o),
    direction: l ? new I(...l) : new I(1, 0, 0),
    colors: h.map((d) =>
      d !== void 0 ? new Lt(d[0], d[1], d[2], d[3]) : new Lt(0, 0, 0, 0)
    ),
    steps: u.slice(0, h.length),
    smooth: c,
  };
}
function Vq(e, t) {
  let { cnormal: i } = e;
  return { ...$a(e, t), cnormal: new I(i[0], i[1], i[2]) };
}
function jq(e, t) {
  return {
    ...$a(e, t),
    scale: e.scale,
    move: e.move,
    fA: new re(...e.fA),
    fB: new re(...e.fB),
    size: new I(...e.size),
    distortion: new re(...e.distortion),
    colorA: Ds(e.colorA, t),
    colorB: Ds(e.colorB, t),
    colorC: Ds(e.colorC, t),
    colorD: Ds(e.colorD, t),
    noiseType: e.noiseType,
    voronoiStyle: e.voronoiStyle,
    highCut: e.highCut,
    lowCut: e.lowCut,
    smoothness: e.smoothness,
    seed: e.seed,
    quality: e.quality,
  };
}
function Hq(e, t) {
  return {
    ...$a(e, t),
    filmThickness: e.filmThickness,
    movement: e.movement,
    wavelengths: new I(...e.wavelengths),
    noiseStrength: e.noiseStrength,
    noiseScale: e.noiseScale,
    offset: new I(...e.offset),
  };
}
function Gq(e, t) {
  return {
    ...$a(e, t),
    positioning: e.positioning,
    colors: e.colors.map((i) => new Lt(i[0], i[1], i[2], i[3])),
    num: e.colors.length,
    steps: e.steps,
    source: new I(...e.source),
    isWorldSpace: e.isWorldSpace,
    noiseStrength: e.noiseStrength,
    noiseScale: e.noiseScale,
    shadowColor: Ds(e.shadowColor, t),
    offset: new I(...e.offset),
  };
}
function Wq(e, t) {
  return {
    ...$a(e, t),
    outlineColor: Ds(e.outlineColor, t),
    contourColor: Ds(e.contourColor, t),
    outlineWidth: e.outlineWidth,
    contourWidth: e.contourWidth,
    outlineThreshold: e.outlineThreshold,
    contourThreshold: e.contourThreshold,
    outlineSmoothing: e.outlineSmoothing,
    contourFrequency: e.contourFrequency,
    contourDirection: new I(...e.contourDirection),
    positionalLines: e.positionalLines,
    compensation: e.compensation,
  };
}
function qq(e, t) {
  return {
    ...$a(e, t),
    thickness: e.thickness,
    ior: e.ior,
    roughness: e.roughness,
  };
}
function Yq(e, t) {
  return {
    ...$a(e, t),
    style: e.style,
    projection: e.projection,
    axis: e.axis,
    blending: e.blending,
    offset: new re(...e.offset),
    colorA: Ds(e.colorA, t),
    colorB: Ds(e.colorB, t),
    frequency: new re(...e.frequency),
    size: e.size,
    variation: e.variation,
    smoothness: e.smoothness,
    zigzag: e.zigzag,
    rotation: e.rotation,
    vertical: new re(...e.vertical),
    horizontal: new re(...e.horizontal),
    sides: e.sides,
  };
}
var hg = class extends os {},
  uP = {
    noise: ["noiseType"],
    texture: ["projection", "axis", "side"],
    video: ["projection", "axis", "side"],
    displace: ["noiseType"],
    light: ["roughnessMap", "bumpMap"],
    depth: ["smooth", "isWorldSpace", "gradientType", "isVector"],
    pattern: ["style", "projection", "axis"],
  },
  dP = { depth: ["colors"] };
function Xq(e, t, i) {
  if (t === "isMask") return !0;
  let r = uP[e.type],
    s = dP[e.type];
  if (s !== void 0) {
    let a = e.color;
    if (s.includes(t)) {
      let n = a[t]?.value?.length;
      if (n !== void 0 && n !== i.length) return !0;
    }
  }
  return r !== void 0 ? r.includes(t) : !1;
}
function pP(e, t, i) {
  let r = i.uniforms[`f${i.id}_texture`];
  if (!r) return !1;
  let s = !1,
    a = e;
  if ("image" in a) {
    let n = a.image,
      o = t.image(n),
      l = r;
    l.image instanceof Jo || l.image.deref(), (l.image = o);
  }
  if ("video" in a) {
    let n = a.video,
      o = t.video(n),
      l = r;
    l.image instanceof Jo || l.image.deref(), (l.image = o);
  }
  if ("wrapping" in a) {
    let n = r;
    n.wrap = a.wrapping;
  }
  if ("minFilter" in a) {
    let n = r;
    n.minFilter = a.minFilter;
  }
  if ("repeat" in a || "offset" in a) {
    let n = "mat",
      o = i.uniforms[`f${i.id}_${n}`];
    "repeat" in a && (o.repeat = a.repeat),
      "offset" in a && (o.offset = a.offset),
      o.updateMatrix();
  }
  return s;
}
function Qq(e, t, i, r) {
  let s = !1;
  for (let [a, n] of Object.entries(e)) {
    if (a === "bumpMap" || a === "roughnessMap") {
      s = !0;
      continue;
    }
    if (!a || n === void 0) continue;
    if (mP(a, i, r, t)) {
      a === "visible" && i.type === "light" && (s = !0);
      continue;
    }
    i.visible = r.visible;
    let o = i.uniforms[`f${i.id}_${a}`];
    if (!!o && !(o instanceof vb))
      switch (((s = s || Xq(i, a, n)), o.constructor)) {
        case tr:
          if (typeof n == "string") {
            let l = t.getColor(n);
            l && (o.value = l);
            break;
          } else {
            let l = n;
            o.value instanceof hg
              ? (o.value = new os(l.r, l.g, l.b, l.a))
              : o.setRGBA(l);
            break;
          }
        case oo:
          if (typeof n == "string") {
            let l = t.getColor(n);
            l && (o.value = l);
            break;
          } else {
            let l = n;
            o.value instanceof hg
              ? (o.value = new os(l.r, l.g, l.b, l.a))
              : o.value.setRGBA(l.r, l.g, l.b, l.a);
            break;
          }
        case ts: {
          let l = n;
          o.value.setX(l[0]), o.value.setY(l[1]);
          break;
        }
        case ya: {
          let l = n;
          o.value.setX(l[0]), o.value.setY(l[1]), o.value.setZ(l[2]);
          break;
        }
        case fo: {
          pP(n, t, i);
          break;
        }
        case zl: {
          o.value = n.map((l) => new Lt(...l));
          break;
        }
        default: {
          o.value = n;
          break;
        }
      }
  }
  return s;
}
var ph = (e, t, i) =>
    Math.max(
      0,
      Math.min(
        1,
        Number(t.getVariable(typeof e == "number" ? e * 100 : e, i) ?? 100) /
          100
      )
    ) ?? 1,
  ah = class {
    constructor(e, t, i, r, s) {
      (this.id = e), (this.uuid = t), (this.data = i), (this.uniforms = {});
      for (let a in r) this.uniforms[`f${this.id}_${a}`] = r[a];
      for (let a in i) mP(a, this, i, s);
    }
    get type() {
      return this.data.type;
    }
    static create(e, t, i, r) {
      if (i.type === "light") return xn.createLigherLayer(e, t, i, r);
      if (i.type === "texture" || i.type === "video") {
        let s =
            i.type === "texture"
              ? r.canvas(i.texture.image) ?? r.image(i.texture.image)
              : r.video(i.texture.video),
          a = new O1(s, i.texture.wrapping, i.texture.minFilter ?? 1008),
          n = new $7(s),
          o = new eq(i.texture.repeat, i.texture.offset),
          l = new lt(i.crop ? 1 : 0),
          h = new Oi(i.projection ?? 0),
          u = new Oi(["x", "y", "z"].indexOf(i.axis) ?? 0),
          c = new Oi(i.side ?? 0),
          d = new ts(i.size ? new re(i.size[0], i.size[1]) : new re(100, 100)),
          p = new lt(i.blending ?? 0),
          f = new lt(ph(i.alpha, r)),
          m = new Oi(i.mode ?? 0),
          g = new Ts(i.isMask ?? !1),
          y = new yb(a, n, l, h, u, c, d, p, o, f, m, g),
          x = new Fi(y.calpha, "f");
        return new Ji(
          e,
          t,
          i,
          {
            texture: a,
            textureSize: n,
            crop: l,
            projection: h,
            axis: u,
            side: c,
            size: d,
            blending: p,
            mat: o,
            alpha: f,
            mode: m,
            isMask: g,
          },
          y,
          m,
          x,
          g,
          r
        );
      } else if (i.type === "matcap") {
        let s = r.image(i.texture.image),
          a = new O1(s, i.texture.wrapping, i.texture.minFilter ?? 1008),
          n = new lt(ph(i.alpha, r)),
          o = new Oi(i.mode ?? 0),
          l = new Ts(i.isMask ?? !1),
          h = new Y3(a, n, o, l),
          u = new Fi(h.calpha, "f");
        return new Ji(
          e,
          t,
          i,
          { texture: a, alpha: n, mode: o, isMask: l },
          h,
          o,
          u,
          l,
          r
        );
      } else if (i.type === "displace")
        if (i.displacementType === "noise") {
          let s = new ya(new I(...i.offset)),
            a = new lt(i.scale ?? 10),
            n = new lt(i.intensity ?? 8),
            o = new lt(i.movement ?? 1),
            l = new Oi(i.noiseType ?? 0),
            h = new Oi(i.voronoiStyle ?? 0),
            u = new lt(i.smoothness ?? 0.5),
            c = new lt(i.seed ?? 0),
            d = new lt(i.highCut ?? 1),
            p = new lt(i.lowCut ?? 0),
            f = new Oi(i.quality ?? 1),
            m = new aP(n, o, s, h, u, c, d, p, f, a, l);
          return new fP(
            e,
            t,
            i,
            {
              offset: s,
              scale: a,
              intensity: n,
              movement: o,
              noiseType: l,
              voronoiStyle: h,
              smoothness: u,
              seed: c,
              highCut: d,
              lowCut: p,
              quality: f,
            },
            m,
            r
          );
        } else throw new Error();
      else return Jq(e, t, i, r);
    }
    updateByOp(e, t, i) {
      let r = e;
      if (r.path[0] === void 0) {
        if (r.type === 0)
          return "type" in r.props ||
            "category" in r.props ||
            "visible" in r.props
            ? (i.scene.markNeedsUpdateRendererDirty(), !0)
            : Qq(r.props, i.shared, this, t);
      } else if (r.path[0] === "texture")
        return "texture" in t || "video" in t
          ? pP(r.props, i.shared, this)
          : !0;
      return !1;
    }
    dispose() {
      if (Zq(this)) {
        let e = this.uniforms[`f${this.id}_texture`];
        if (!e) return !1;
        let t = e;
        t.image instanceof Jo || t.image.deref();
      }
    }
    hasValueByKey(e) {
      return this.uniforms[e] !== void 0;
    }
    hasValue(e) {
      return this.hasValueByKey(`f${this.id}_${e}`);
    }
    setValue(e, t) {
      let i = `f${this.id}_${e}`;
      this.hasValueByKey(i) && t !== void 0 && (this.uniforms[i].value = t);
    }
    getNode(e) {
      let t = `f${this.id}_${e}`;
      if (this.hasValueByKey(t)) return this.uniforms[t];
    }
    getValue(e) {
      let t = `f${this.id}_${e}`;
      if (this.hasValueByKey(t)) return this.uniforms[t].value;
    }
    getName(e) {
      let t = /f\d+_(.*)/.exec(e);
      if (t && t.length > 1) return t[1];
      console.log(`Layer.getName: error ${e}`);
    }
    getNames() {
      let e = [];
      for (let t in this.uniforms) {
        let i = this.getName(t);
        i && e.push(i);
      }
      return e;
    }
  },
  Ji = class extends ah {
    constructor(e, t, i, r, s, a, n, o, l) {
      super(e, t, i, r, l),
        (this.params = r),
        (this.color = s),
        (this.mode = a),
        (this.alpha = n),
        (this.isMask = o);
    }
  },
  fP = class extends ah {
    constructor(e, t, i, r, s, a) {
      super(e, t, i, r, a), (this.position = s);
    }
  },
  xn = class extends ah {
    constructor(e, t, i, r, s, a) {
      super(e, t, i, s, a), (this.node = r);
    }
    static createLigherLayer(e, t, i, r) {
      let s,
        a = new lt(ph(i.alpha, r)),
        n = new Oi(i.mode),
        o = new lt(i.bumpMapIntensity),
        l = new lt(ph(i.alphaOverride, r)),
        h;
      if (!i.visible) (s = new bb()), (h = {});
      else if (i.category === "lambert") {
        s = new sq();
        let u = new tr(r.color(i.emissive) ?? 0),
          c = new Ts(i.occlusion ?? !0);
        (h = { emissive: u, occlusion: c }),
          (s.emissive = u),
          (s.occlusion = c);
      } else if (i.category === "toon") {
        s = new oq();
        let u = new lt(i.shininess ?? 30),
          c = new tr(r.color(i.specular) ?? 1118481);
        (h = { shininess: u, specular: c }),
          (s.shininess = u),
          (s.specular = c);
      } else if (i.category === "physical") {
        s = new nq();
        let u = new lt(i.roughness ?? 0.3),
          c = new lt(i.metalness ?? 0),
          d = new lt(i.reflectivity ?? 0.5),
          p = new Ts(i.occlusion ?? !0);
        (h = { roughness: u, metalness: c, reflectivity: d, occlusion: p }),
          (s.roughness = u),
          (s.metalness = c),
          (s.reflectivity = d),
          (s.occlusion = p);
      } else {
        s = new aq();
        let u = new lt(i.shininess ?? 30),
          c = new tr(
            i.specular !== void 0 ? r.color(i.specular) ?? 1118481 : 1118481
          ),
          d = new Ts(i.occlusion ?? !0);
        (h = { shininess: u, specular: c, occlusion: d }),
          (s.shininess = u),
          (s.specular = c),
          (s.occlusion = d);
      }
      return (
        (s.alpha = new lt(1)),
        (s.shadingAlpha = a),
        (s.shadingBlend = n),
        (s.bumpMapIntensity = o),
        (s.alphaOverride = l),
        (h.alpha = s.shadingAlpha),
        (h.mode = s.shadingBlend),
        (h.bumpMapIntensity = s.bumpMapIntensity),
        (h.alphaOverride = s.alphaOverride),
        new xn(e, t, i, s, h, r)
      );
    }
    get category() {
      return this.node.category;
    }
  };
function Zq(e) {
  let t = e instanceof ah ? e.type : e;
  return (
    t === "texture" || t === "video" || t === "displace_map" || t === "matcap"
  );
}
function ua(e) {
  return {
    alpha: new lt(e.alpha ?? 1),
    mode: new Oi(e.mode ?? 0),
    isMask: new Ts(e.isMask ?? !1),
  };
}
function Kq(e, t, i, r, s) {
  switch (e.type) {
    case "color": {
      let a = new tr(r.color ?? ea),
        n = ua(r),
        o = new I1(a, n.alpha),
        l = new Fi(o.calpha, "f");
      return new Ji(t, i, e, { color: a, ...n }, o, n.mode, l, n.isMask, s);
    }
    case "fresnel": {
      let a = new tr(r.color ?? 16777215),
        n = new lt(r.bias ?? 0.1),
        o = new lt(r.scale ?? 1),
        l = new lt(r.intensity ?? 2),
        h = new lt(r.factor ?? 1),
        u = ua(r),
        c = new tq(a, n, o, l, h, u.alpha, u.mode, u.isMask),
        d = new Fi(c.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        { color: a, bias: n, scale: o, intensity: l, factor: h, ...u },
        c,
        u.mode,
        d,
        u.isMask,
        s
      );
    }
    case "rainbow": {
      let a = new lt(r.filmThickness ?? 30),
        n = new lt(r.movement ?? 0),
        o = new ya(r.wavelengths ?? new I(0, 0, 0)),
        l = new lt(r.noiseStrength ?? 0),
        h = new lt(r.noiseScale ?? 1),
        u = new ya(r.offset ?? new I(0, 0, 0)),
        c = ua(r),
        d = new $3(a, n, o, l, h, u, c.alpha, c.isMask),
        p = new Fi(d.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          filmThickness: a,
          movement: n,
          wavelengths: o,
          noiseStrength: l,
          noiseScale: h,
          offset: u,
          ...c,
        },
        d,
        c.mode,
        p,
        c.isMask,
        s
      );
    }
    case "transmission": {
      let a = new lt(r.thickness ?? 10),
        n = new lt(r.ior ?? 1.5),
        o = new lt(r.roughness ?? 0.5),
        l = Tt.transmissionSize,
        h = Tt.transmissionRenderTarget,
        u = Tt.transmissionRenderTargetDepth,
        c = window.innerWidth,
        d = window.innerHeight,
        p = c >= d ? new ts(d / c, 1) : new ts(1, c / d),
        f = ua(r),
        m = new rP(a, n, o, l, h, u, p, f.alpha),
        g = new Fi(m.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        { thickness: a, ior: n, roughness: o, aspectRatio: p, ...f },
        m,
        f.mode,
        g,
        f.isMask,
        s
      );
    }
    case "toon": {
      let a = new Oi(r.positioning ?? 0),
        n;
      r.colors
        ? (n = new zl(r.colors.length, r.colors))
        : ((n = new zl(10, new Lt(0, 0, 0, 1))),
          (n.value[1] = new Lt(1, 1, 1, 1)));
      let o;
      r.steps
        ? (o = new Bl(r.steps.length, r.steps))
        : ((o = new Bl(10, 1)), (o.value[0] = 0));
      let l = new ya(r.source ?? new I(0, 0, 0)),
        h = new Ts(r.isWorldSpace ?? !0),
        u = new lt(r.noiseStrength ?? 0),
        c = new lt(r.noiseScale ?? 1),
        d = new oo(r.shadowColor),
        p = new ya(r.offset ?? new I(0, 0, 0)),
        f = ua(r),
        m = new tP(a, n, o, l, h, u, c, d, p, f.alpha),
        g = new Fi(m.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          positioning: a,
          colors: n,
          steps: o,
          source: l,
          isWorldSpace: h,
          noiseStrength: u,
          noiseScale: c,
          shadowColor: d,
          offset: p,
          ...f,
        },
        m,
        f.mode,
        g,
        f.isMask,
        s
      );
    }
    case "outline": {
      let a = new tr(r.outlineColor ?? 16777215),
        n = new tr(r.contourColor ?? 16777215),
        o = new lt(r.outlineWidth ?? 0.1),
        l = new lt(r.contourWidth ?? 0.1),
        h = new lt(r.outlineThreshold ?? 0.1),
        u = new lt(r.contourThreshold ?? 0.1),
        c = new lt(r.outlineSmoothing ?? 0.1),
        d = new lt(r.contourFrequency ?? 0.1),
        p = new ya(r.contourDirection ?? new I(0, 1, 0)),
        f = new Ts(r.positionalLines ?? !1),
        m = new Ts(r.compensation ?? !0),
        g = Tt.normalRenderTarget,
        y = Tt.normalRenderTargetDepth,
        x = Tt.pixelRatioNode,
        b = Tt.resolution,
        _ = ua(r),
        S = new Z3(a, n, o, l, h, u, c, d, p, f, m, b, g, y, x, _.alpha),
        M = new Fi(S.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          outlineColor: a,
          contourColor: n,
          outlineWidth: o,
          contourWidth: l,
          outlineThreshold: h,
          contourThreshold: u,
          outlineSmoothing: c,
          contourFrequency: d,
          contourDirection: p,
          positionalLines: f,
          compensation: m,
          ..._,
        },
        S,
        _.mode,
        M,
        _.isMask,
        s
      );
    }
    case "depth": {
      let a = new Oi(r.gradientType ?? 0),
        n = new Ts(r.smooth ?? !1),
        o = new lt(r.near ?? 50),
        l = new lt(r.far ?? 200),
        h = new lt(r.isVector ?? 1),
        u = new lt(r.isWorldSpace ?? 0),
        c = new ya(r.origin ?? new I()),
        d = new ya(r.direction ?? new I()),
        p;
      r.colors
        ? (p = new zl(r.colors.length, r.colors))
        : ((p = new zl(2, new Lt(0, 0, 0, 1))),
          (p.value[1] = new Lt(1, 1, 1, 1)));
      let f;
      r.steps
        ? (f = new Bl(r.steps.length, r.steps))
        : ((f = new Bl(2, 1)), (f.value[0] = 0));
      let m = ua(r),
        g = new H3(a, n, o, l, h, u, c, d, p, f, m.alpha, m.isMask),
        y = new Fi(g.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          gradientType: a,
          smooth: n,
          near: o,
          far: l,
          isVector: h,
          isWorldSpace: u,
          origin: c,
          direction: d,
          colors: p,
          steps: f,
          ...m,
        },
        g,
        m.mode,
        y,
        m.isMask,
        s
      );
    }
    case "noise": {
      let a = new lt(r.scale ?? 1),
        n = new ya(r.size ?? new I(100, 100, 100)),
        o = new lt(r.move ?? 1),
        l = new ts(r.fA ?? new re(1.7, 9.2)),
        h = new ts(r.fB ?? new re(8.3, 2.8)),
        u = new ts(r.distortion ?? new re(1, 1)),
        c = new oo(r.colorA),
        d = new oo(r.colorB),
        p = new oo(r.colorC),
        f = new oo(r.colorD),
        m = new Oi(r.noiseType ?? 0),
        g = new Oi(r.voronoiStyle ?? 0),
        y = new lt(r.highCut ?? 1),
        x = new lt(r.lowCut ?? 0),
        b = new lt(r.smoothness ?? 0.5),
        _ = new lt(r.seed ?? 0.5),
        S = new Oi(r.quality ?? 1),
        M = ua(r),
        C = new X3(
          a,
          n,
          o,
          l,
          h,
          u,
          c,
          d,
          p,
          f,
          M.alpha,
          m,
          M.isMask,
          g,
          y,
          x,
          b,
          _,
          S
        ),
        A = new Fi(C.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          scale: a,
          size: n,
          move: o,
          fA: l,
          fB: h,
          distortion: u,
          colorA: c,
          colorB: d,
          colorC: p,
          colorD: f,
          noiseType: m,
          ...M,
          voronoiStyle: g,
          highCut: y,
          lowCut: x,
          smoothness: b,
          seed: _,
          quality: S,
        },
        C,
        M.mode,
        A,
        M.isMask,
        s
      );
    }
    case "normal": {
      let a = new ya(r.cnormal ?? new I(1, 1, 1)),
        n = ua(r),
        o = new j3(a, n.alpha),
        l = new Fi(o.calpha, "f");
      return new Ji(t, i, e, { cnormal: a, ...n }, o, n.mode, l, n.isMask, s);
    }
    case "gradient": {
      let a = new Oi(r.gradientType ?? 0),
        n = new Ts(r.smooth ?? !1),
        o;
      r.colors
        ? (o = new zl(r.colors.length, r.colors))
        : ((o = new zl(10, new Lt(0, 0, 0, 1))),
          (o.value[1] = new Lt(1, 1, 1, 1)));
      let l;
      r.steps
        ? (l = new Bl(r.steps.length, r.steps))
        : ((l = new Bl(10, 1)), (l.value[0] = 0));
      let h = new ts(r.offset ?? new re(0, 0)),
        u = new ts(r.morph ?? new re(0, 0)),
        c = new lt(r.angle ?? 0),
        d = ua(r),
        p = new W3(a, n, o, l, h, u, c, d.alpha, d.isMask),
        f = new Fi(p.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          gradientType: a,
          smooth: n,
          colors: o,
          steps: l,
          offset: h,
          morph: u,
          angle: c,
          ...d,
        },
        p,
        d.mode,
        f,
        d.isMask,
        s
      );
    }
    case "pattern": {
      let a = new Oi(r.style ?? 0),
        n = new Oi(r.projection ?? 0),
        o = new Oi(["x", "y", "z"].indexOf(r.axis) ?? 0),
        l = new lt(r.blending ?? 0),
        h = new ts(r.offset ?? new re(0, 0)),
        u = new oo(r.colorA),
        c = new oo(r.colorB),
        d = new ts(r.frequency ?? new re(10, 10)),
        p = new lt(r.size ?? 0.5),
        f = new lt(r.variation ?? 0),
        m = new lt(r.smoothness ?? 0.5),
        g = new lt(r.zigzag ?? 0),
        y = new lt(r.rotation ?? 0),
        x = new ts(r.vertical ?? new re(0, 1)),
        b = new ts(r.horizontal ?? new re(0, 1)),
        _ = new Oi(r.sides ?? 6),
        S = ua(r),
        M = new K3(
          a,
          n,
          o,
          l,
          h,
          u,
          c,
          d,
          p,
          f,
          m,
          g,
          y,
          x,
          b,
          _,
          S.alpha,
          S.isMask
        ),
        C = new Fi(M.calpha, "f");
      return new Ji(
        t,
        i,
        e,
        {
          style: a,
          projection: n,
          axis: o,
          blending: l,
          offset: h,
          colorA: u,
          colorB: c,
          frequency: d,
          size: p,
          variation: f,
          smoothness: m,
          zigzag: g,
          rotation: y,
          vertical: x,
          horizontal: b,
          sides: _,
          ...S,
        },
        M,
        S.mode,
        C,
        S.isMask,
        s
      );
    }
    default: {
      let a = new tr(1, 0, 0, 1),
        n = ua(r),
        o = new I1(a, n.alpha),
        l = new Fi(o.calpha, "f");
      return new Ji(t, i, e, { color: a, ...n }, o, n.mode, l, n.isMask, s);
    }
  }
}
function Jq(e, t, i, r) {
  let s = Bq(i, r);
  return Kq(i, e, t, s, r);
}
function mP(e, t, i, r) {
  if (i.type === "displace" && (e === "intensity" || e === "visible")) {
    let s = t.uniforms[`f${t.id}_intensity`];
    return s ? ((s.value = i.intensity * (i.visible ? 1 : 0)), s) : void 0;
  }
  if (i.type !== "displace" && (e === "alpha" || e === "visible")) {
    let s = t.uniforms[`f${t.id}_alpha`];
    if (!s) return;
    if (
      ((s.value = ph(i.alpha, r) * (i.visible ? 1 : 0)),
      i.type === "outline" && e === "visible")
    ) {
      let a = t.uniforms[`f${t.id}_compensation`];
      a && (a.value = i.compensation && i.visible);
    }
    return s;
  }
}
function Ac(e, t) {
  let i = 0,
    r = e.layers.find((s) => s.data.type === "light");
  if (r) {
    let s = r.data,
      a = Number(t.getVariable(s.alphaOverride));
    if ((typeof s.alphaOverride == "string" ? a / 100 : s.alphaOverride) < 1)
      return !0;
  }
  for (let s of e.layers) {
    if (s.data.type !== "displace" && s.data.isMask) return !0;
    if (
      s.data.type !== "displace" &&
      "alpha" in s.data &&
      s.data.type !== "light" &&
      s.data.type !== "fresnel" &&
      s.data.type !== "texture" &&
      s.data.type !== "matcap" &&
      s.data.type !== "rainbow" &&
      s.data.type !== "outline" &&
      s.data.type !== "pattern"
    ) {
      let a = s.data.visible ? s.data.alpha : 0;
      if (
        (typeof a == "string" &&
          (a = Math.max(0, Math.min(1, Number(t.getVariable(a) ?? 100) / 100))),
        (a === 1 && s.data.type === "depth") || s.data.type === "gradient")
      ) {
        for (let n of s.data.colors)
          if (n[3] < 1) {
            a = n[3];
            break;
          }
      } else if (a === 1 && s.data.type === "noise") {
        let n = t.color(s.data.colorA).a,
          o = t.color(s.data.colorB).a,
          l = t.color(s.data.colorC).a,
          h = t.color(s.data.colorD).a,
          u = Math.min(n, Math.min(o, Math.min(l, h)));
        u < 1 && (a = u);
      }
      i += (1 - i) * a;
    }
  }
  return i < 1;
}
var ml = class extends vi {
    constructor() {
      super(void 0),
        (this.flatShading = !1),
        (this.needsJitter = !0),
        (this.cacheKey = ""),
        (this.fog = !0),
        (this.dithering = !0),
        (this.vertexColors = !0),
        (this.transparent = !0);
    }
    customProgramCacheKey() {
      return this.cacheKey;
    }
  },
  $q = class extends ml {
    constructor(e, t, i, r) {
      super(),
        (this.flatShading = e),
        (this.side = t),
        (this.wireframe = i),
        (this.root = r);
    }
    updateAfterBuild() {
      let e = this.root;
      (this.lights = e.lights),
        (this.vertexShader = e.vertexShader),
        (this.fragmentShader = e.fragmentShader),
        (this.defines = e.defines),
        (this.uniforms = e.uniforms),
        (this.extensions = e.extensions),
        (this.transparent = e.transparent),
        (this.cacheKey =
          e.customProgramCacheKey() + "flat" + this.flatShading + this.side);
    }
    onBeforeCompile(e, t) {
      this.root.onBeforeCompile(e);
    }
    get data() {
      return this.root.data;
    }
    get category() {
      return this.root.category;
    }
    get hasAO() {
      return this.root.hasAO;
    }
    getFlavor(e, t, i) {
      return this.root.getFlavor(e, t, i);
    }
    get layers() {
      return this.root.layers;
    }
    get fragment() {
      return this.root.fragment;
    }
    getLayersOfType(e) {
      return this.root.getLayersOfType(e);
    }
    getLayerByUuid(e) {
      return this.root.getLayerByUuid(e);
    }
    updateByOp(e, t, i) {
      this.root.updateByOp(e, t, i);
    }
    nodeMaterialDispose() {
      this.root.nodeMaterialDispose();
    }
  },
  wb = class extends ml {
    constructor(e, t, i = !0) {
      super(),
        (this.data = e),
        (this.allowVariableSaves = i),
        (this.layerIdGen = 0),
        (this.flavors = []),
        (this.masks = {}),
        (this.type = "NodeMaterial"),
        (this.updaters = []),
        this.reset0(e, t);
    }
    get nodeMaterial() {
      return this;
    }
    getFlavor(e, t, i) {
      let r = i ? 6 : (e ? 3 : 0) + t;
      if (r === 0) return this;
      this.flavors === void 0 && (this.flavors = []), (r -= 1);
      let s = this.flavors[r];
      return (
        s === void 0 &&
          ((s = new $q(e, t, i, this)),
          (this.flavors[r] = s),
          (s.flatShading = e),
          (s.side = t),
          s.updateAfterBuild()),
        s
      );
    }
    get fragment() {
      return this.lightLayer.node;
    }
    get category() {
      return this.lightLayer.category;
    }
    get hasAO() {
      return this.lightLayer.getNode("occlusion")?.value ?? !1;
    }
    reset(e, t, i = !1) {
      (this.data !== e || i) && this.reset0(e, t);
    }
    reset0(e, t) {
      this.data = e;
      let i = e.layers ?? gs.defaultTwoLayerData("phong").layers;
      try {
        this.layers = i.map((r) =>
          ah.create(this.layerIdGen++, r.id, r.data, t.shared)
        );
      } catch {
        this.layers = [];
      }
      this.layers.reverse(),
        (this.name = e.name ?? "Untitled Material"),
        this.onUpdate(t.shared),
        (this.transparent = Ac(e, t.shared)),
        this.saveVariableLocations(t);
    }
    onVariableUpdate(e, t, i) {
      if (e[0] === "alphaOverride")
        (this.transparent = Ac(this.data, i.shared)),
          this.lightLayer.setValue(
            "alphaOverride",
            Math.max(0, Math.min(Number(t) / 100, 1))
          );
      else if (e[0] === "layer") {
        let r = e[1],
          s = e[2];
        if (r && s) {
          let a = this.layers.find((n) => n.uuid === r);
          a?.hasValue(s) &&
            (s === "alpha"
              ? ((this.transparent = Ac(this.data, i.shared)),
                a.setValue(s, Math.max(0, Math.min(Number(t) / 100, 1))))
              : a.setValue(s, t));
        }
      }
    }
    saveVariableLocations(e) {
      if (!this.allowVariableSaves) return;
      let t = this.data.layers.find((i) => i.data.type === "light");
      t &&
        e.shared.getVariable(t.data.alphaOverride, [
          "material",
          this.uuid,
          "alphaOverride",
        ]),
        this.data.layers.forEach((i) => {
          "alpha" in i.data &&
            typeof i.data.alpha == "string" &&
            e.shared.getVariable(i.data.alpha, [
              "material",
              this.uuid,
              "layer",
              i.id,
              "alpha",
            ]);
        });
    }
    getLayersOfType(e) {
      return this.layers.filter((t) => t.type === e);
    }
    getLayerByUuid(e) {
      return this.layers.find((t) => t.uuid === e);
    }
    onUpdate(e) {
      (this.cacheKey = this.computeCacheKey()),
        (this.lightLayer = this.layers.find((t) => t instanceof xn)),
        this.lightLayer === void 0 &&
          (this.lightLayer = new xn(
            0,
            "",
            { ...jr.defaultData("light", "phong"), visible: !1 },
            new bb(),
            {},
            e
          )),
        this.dispose();
      for (let t of this.flavors) t && t.dispose();
      this.applyTextureMaps(),
        this.applyMasks(),
        this.blendColors(),
        this.blendAfterColors(),
        this.blendPositions();
    }
    applyTextureMaps() {
      let e = this.layers.find((s) => s instanceof xn);
      if (!e) return;
      let t = e.data,
        i = t.bumpMap,
        r = t.roughnessMap;
      (e.node.bumpMap = void 0), (e.node.roughnessMap = void 0);
      for (let s = 0; s < this.layers.length; ++s) {
        let a = this.layers[s];
        a instanceof Ji &&
          a.color instanceof yb &&
          (a.uuid === i && (e.node.bumpMap = a.color),
          a.uuid === r && (e.node.roughnessMap = a.color));
      }
    }
    updateByOp(e, t, i) {
      if (
        (t !== void 0 ? (this.data = t) : (t = this.data),
        (this.transparent = Ac(t, i.shared)),
        e.path[0] === "layers")
      ) {
        this.data = t;
        let r = i.shared,
          s = e.path[1];
        if (s === void 0) {
          if ((this.layers.reverse(), e.type === 4)) {
            let a = ah.create(this.layerIdGen++, e.id, e.data, i.shared);
            this.layers.splice(e.localIndex, 0, a),
              i.scene.markNeedsUpdateRendererDirty();
          } else if (e.type === 5)
            this.layers.splice(e.localIndex, 1)[0].dispose(),
              i.scene.markNeedsUpdateRendererDirty();
          else if (e.type === 6) {
            let a = this.layers.findIndex((o) => o.uuid === e.id),
              n = this.layers[a];
            this.layers.splice(a, 1),
              this.layers.splice(e.localIndex, 0, n),
              i.scene.markNeedsUpdateRendererDirty();
          }
          this.layers.reverse(), this.onUpdate(i.shared);
        } else {
          e.type === 0 &&
            e.props.occlusion !== void 0 &&
            i.scene.markNeedsUpdateRendererDirty();
          let a = this.layers.find((n) => n.uuid === s);
          if (a) {
            let n = t.layers.data(s),
              o;
            if (
              (e.type === 0 &&
                ("alpha" in e.props || "alphaOverride" in e.props) &&
                ("alpha" in e.props
                  ? (o = {
                      ...e.props,
                      alpha: ph(e.props.alpha, r, [
                        "material",
                        this.uuid,
                        "layer",
                        s,
                        "alpha",
                      ]),
                    })
                  : (o = {
                      ...e.props,
                      alphaOverride: ph(e.props.alphaOverride, r, [
                        "material",
                        this.uuid,
                        "alphaOverride",
                      ]),
                    })),
              a.updateByOp(
                { ...e, ...(o ? { props: o } : {}), path: e.path.slice(2) },
                n,
                i
              ))
            ) {
              let l = ah.create(this.layerIdGen++, s, n, r);
              this.layers.splice(
                this.layers.findIndex((h) => h.uuid === s),
                1,
                l
              ),
                this.onUpdate(i.shared);
            }
          }
        }
      } else this.reset(t, i);
    }
    applyMasks() {
      for (let e = 0; e < this.layers.length; ++e) {
        let t = this.layers[e];
        t instanceof Ji
          ? (t.color.mask = void 0)
          : t instanceof xn && (t.node.mask = void 0);
      }
      for (let e = 0; e < this.layers.length; ++e) {
        let t = this.layers[e];
        if (t instanceof Ji && t.isMask.value && t.data.visible && e > 0) {
          let i = e - 1,
            r = this.layers[i];
          r instanceof xn
            ? (r.node.mask = new ks(t.color, t.alpha, ks.MUL))
            : r instanceof Ji &&
              (r.isMask.value ||
                (r.color.mask = new ks(t.color, t.alpha, ks.MUL)));
        }
      }
    }
    blendColors() {
      let e = this.layers.findIndex((i) => i instanceof Ji),
        t = this.layers.findIndex((i) => i instanceof xn);
      if (e !== -1 && e < t) {
        let i = this.layers[e].color;
        for (let r = e + 1; r < t; ++r) {
          let s = this.layers[r];
          if (s instanceof Ji) {
            if (s.isMask.value) continue;
            i = new RA(i, s.color, s.alpha, s.mode);
          }
        }
        this.fragment.color = i;
      } else this.fragment.color = void 0;
    }
    blendAfterColors() {
      let e = new Fi("outgoingLight", "f"),
        t = this.layers.findIndex((i) => i instanceof xn);
      if (this.layers.length > t + 1) {
        for (let i = t + 1; i < this.layers.length; ++i) {
          let r = this.layers[i];
          if (r instanceof Ji) {
            if (r.isMask.value) continue;
            e = new RA(e, r.color, r.alpha, r.mode);
          }
        }
        this.fragment.afterColor = e;
      } else this.fragment.afterColor = void 0;
    }
    blendPositions() {
      let e = this.layers.filter((t) => t instanceof fP);
      if (e.length > 0) {
        let t = e[0].position;
        for (let i = 1; i < e.length; ++i)
          e[i] &&
            ((t = new ks(t, e[i].position, ks.ADD)),
            (t = new ks(t, new lt(0.5).setReadonly(!0), ks.MUL)));
        this.fragment.position = t;
      } else this.fragment.position = void 0;
    }
    getDefines() {
      return this.defines;
    }
    getUniforms() {
      return this.uniforms;
    }
    getVertexShader() {
      return this.vertexShader;
    }
    getFragmentShader() {
      return this.fragmentShader;
    }
    onBeforeCompile(e) {
      this.build(),
        (e.defines = this.defines),
        (e.uniforms = this.uniforms),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader),
        (e.extensionDerivatives = this.extensions.derivatives === !0),
        (e.extensionFragDepth = this.extensions.fragDepth === !0),
        (e.extensionDrawBuffers = this.extensions.drawBuffers === !0),
        (e.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === !0);
    }
    clampUniformsForPreview(e, t) {
      let i = (r, s, a) => Math.min(Math.max(r, s), a);
      for (let r of this.layers)
        if (r.type === "displace") {
          let s = i(r.uniforms[`f${r.id}_intensity`].value, e, t);
          r.uniforms[`f${r.id}_intensity`].value = s;
        }
    }
    computeCacheKey() {
      let e = "[";
      for (let { data: t } of this.data.layers)
        if (t.type === "light")
          e += `"${t.visible ? t.category.toUpperCase() : "Basic"}"`;
        else {
          let i = (uP[t.type] ?? []).map((o) => t[o]),
            r = (dP[t.type] ?? []).map((o) => t[o]?.length ?? 0),
            s = [...i, ...r],
            a = "isMask" in t && t.isMask,
            n = `"${t.type}-${t.visible}-${a}"`;
          s.length ? (e += `[${n}, "${s.join('","')}"],`) : (e += n);
        }
      return (e = e.slice(0, -1) + "]"), e;
    }
    updateFrame(e) {
      for (let t = 0; t < this.updaters.length; ++t)
        e.updateNode(this.updaters[t]);
    }
    build() {
      let e = new k3();
      (e.needsJitter = this.needsJitter),
        (this.lights = this.lightLayer.data.visible),
        e.build(this.fragment, this.fragment),
        (this.vertexShader = e.getCode("vertex")),
        (this.fragmentShader = e.getCode("fragment")),
        (this.defines = e.defines),
        (this.uniforms = e.uniforms),
        (this.extensions = e.extensions),
        (this.updaters = e.updaters);
      for (let t of this.flavors) t && t.updateAfterBuild();
      return this;
    }
    nodeMaterialDispose() {
      this.layers.forEach((e) => e.dispose()), super.dispose();
      for (let e of this.flavors) e && e.dispose();
    }
    assetsLoaded() {
      for (let e of this.layers)
        if (e instanceof Ji) {
          let t = e.params.texture;
          if (t instanceof O1 && !t.image.loaded) return !1;
        }
      return !0;
    }
    getHash() {
      let e = "{";
      return (e += '"fragment":' + this.fragment.getHash()), (e += "}"), e;
    }
  };
Object.defineProperties(ml.prototype, {
  properties: {
    get: function () {
      return this.fragment.properties;
    },
  },
});
var B1 = class extends wb {
    constructor(e, t, i) {
      super(e, t, !1),
        (this.uuid = i),
        (this.allowVariableSaves = !0),
        this.saveVariableLocations(t);
    }
  },
  eY = Sr(kO()),
  HA = new Map();
function tY(e) {
  if (typeof e == "string") return e;
  let t = HA.get(e);
  return (
    t || ((t = { url: URL.createObjectURL(new Blob([e])) }), HA.set(e, t)),
    t.url
  );
}
var vd = class {
    constructor({ src: e, volume: t, delay: i, loop: r }) {
      (this._volume = 1),
        (this.delay = 0),
        (this._loop = 1),
        (this.loopsRemaining = 0),
        (this._status = "stopped"),
        (this.onEnd = () => {
          this.loopsRemaining === 1 / 0
            ? this.replay()
            : this.loopsRemaining > 1
            ? (this.replay(), this.loopsRemaining--)
            : ((this._status = "stopped"), (this.loopsRemaining = this._loop));
        });
      let s;
      typeof e == "string"
        ? (s = { src: e })
        : (s = { src: tY(e), format: "wav" }),
        (this.sound = new eY.Howl(s)),
        this.sound.on("end", this.onEnd),
        (this.src = e),
        t !== void 0 && (this.volume = t),
        i !== void 0 && (this.delay = i),
        r !== void 0 && (this.loop = r);
    }
    get status() {
      return this._status;
    }
    get volume() {
      return this._volume;
    }
    set volume(e) {
      (this._volume = e), this.sound.volume(e);
    }
    get loop() {
      return this._loop;
    }
    set loop(e) {
      (this._loop = e), (this.loopsRemaining = e);
    }
    replay() {
      this.clearDelay(),
        (this.delayTimerId = window.setTimeout(() => {
          this.sound.play(), this.clearDelay();
        }, this.delay));
    }
    fade(e, t = 1e3) {
      e
        ? (this.sound.volume(this._volume),
          this.clearFade(),
          (this.fadeTimerId = window.setTimeout(() => {
            this.sound.fade(this._volume, 0, t), this.clearFade();
          }, e)))
        : this.sound.fade(this._volume, 0, t);
    }
    on(e, t, i) {
      this.sound.on(e, t, i);
    }
    off(e, t, i) {
      this.sound.off(e, t, i);
    }
    play() {
      this._status === "playing" ||
        this.sound.playing() ||
        (this._status === "paused"
          ? (this.sound.seek() === 0 ? this.replay() : this.sound.play(),
            (this._status = "playing"))
          : this._status === "stopped" &&
            (this.replay(), (this._status = "playing")));
    }
    pause() {
      this._status === "playing" &&
        (this.sound.pause(),
        this.clearFade(),
        this.clearDelay(),
        (this._status = "paused"));
    }
    stop() {
      this.sound.stop(),
        (this.loopsRemaining = this._loop),
        this.clearFade(),
        this.clearDelay(),
        (this._status = "stopped");
    }
    clearFade() {
      this.fadeTimerId &&
        (clearTimeout(this.fadeTimerId), delete this.fadeTimerId);
    }
    clearDelay() {
      this.delayTimerId &&
        (clearTimeout(this.delayTimerId), delete this.delayTimerId);
    }
    dispose(e = !1) {
      this.off(), this.stop(), this.clearFade(), this.clearDelay();
    }
  },
  iY = class {
    constructor() {
      (this.type = "ShapePath"),
        (this.color = new Et()),
        (this.subPaths = []),
        (this.currentPath = null);
    }
    moveTo(e, t) {
      return (
        (this.currentPath = new Sm()),
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
      );
    }
    lineTo(e, t) {
      return this.currentPath?.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, i, r) {
      return this.currentPath?.quadraticCurveTo(e, t, i, r), this;
    }
    bezierCurveTo(e, t, i, r, s, a) {
      return this.currentPath?.bezierCurveTo(e, t, i, r, s, a), this;
    }
    splineThru(e) {
      return this.currentPath?.splineThru(e), this;
    }
    toShapes() {
      let e = {
          ORIGIN: 0,
          DESTINATION: 1,
          BETWEEN: 2,
          LEFT: 3,
          RIGHT: 4,
          BEHIND: 5,
          BEYOND: 6,
        },
        t = { loc: e.ORIGIN, t: 0 };
      function i(p, f, m, g) {
        let y = p.x,
          x = f.x,
          b = m.x,
          _ = g.x,
          S = p.y,
          M = f.y,
          C = m.y,
          A = g.y,
          T = (_ - b) * (S - C) - (A - C) * (y - b),
          P = (x - y) * (S - C) - (M - S) * (y - b),
          R = (A - C) * (x - y) - (_ - b) * (M - S),
          z = T / R,
          N = P / R;
        if ((R === 0 && T !== 0) || z <= 0 || z >= 1 || N < 0 || N > 1)
          return null;
        if (T === 0 && R === 0) {
          for (let L = 0; L < 2; L++)
            if ((r(L === 0 ? m : g, p, f), t.loc === e.ORIGIN)) {
              let G = L === 0 ? m : g;
              return { x: G.x, y: G.y, t: t.t };
            } else if (t.loc === e.BETWEEN) {
              let G = +(y + t.t * (x - y)).toPrecision(10),
                Y = +(S + t.t * (M - S)).toPrecision(10);
              return { x: G, y: Y, t: t.t };
            }
          return null;
        } else {
          for (let Y = 0; Y < 2; Y++)
            if ((r(Y === 0 ? m : g, p, f), t.loc === e.ORIGIN)) {
              let Z = Y === 0 ? m : g;
              return { x: Z.x, y: Z.y, t: t.t };
            }
          let L = +(y + z * (x - y)).toPrecision(10),
            G = +(S + z * (M - S)).toPrecision(10);
          return { x: L, y: G, t: z };
        }
      }
      function r(p, f, m) {
        let g = m.x - f.x,
          y = m.y - f.y,
          x = p.x - f.x,
          b = p.y - f.y,
          _ = g * b - x * y;
        if (p.x === f.x && p.y === f.y) {
          (t.loc = e.ORIGIN), (t.t = 0);
          return;
        }
        if (p.x === m.x && p.y === m.y) {
          (t.loc = e.DESTINATION), (t.t = 1);
          return;
        }
        if (_ < -Number.EPSILON) {
          t.loc = e.LEFT;
          return;
        }
        if (_ > Number.EPSILON) {
          t.loc = e.RIGHT;
          return;
        }
        if (g * x < 0 || y * b < 0) {
          t.loc = e.BEHIND;
          return;
        }
        if (Math.sqrt(g * g + y * y) < Math.sqrt(x * x + b * b)) {
          t.loc = e.BEYOND;
          return;
        }
        let S;
        g !== 0 ? (S = x / g) : (S = b / y), (t.loc = e.BETWEEN), (t.t = S);
      }
      function s(p, f) {
        let m = [],
          g = [];
        for (let y = 1; y < p.length; y++) {
          let x = p[y - 1],
            b = p[y];
          for (let _ = 1; _ < f.length; _++) {
            let S = f[_ - 1],
              M = f[_],
              C = i(x, b, S, M);
            C !== null &&
              m.find(
                (A) =>
                  A.t <= C.t + Number.EPSILON && A.t >= C.t - Number.EPSILON
              ) === void 0 &&
              (m.push(C), g.push(new re(C.x, C.y)));
          }
        }
        return g;
      }
      function a(p, f, m) {
        let g = new re();
        f.getCenter(g);
        let y = [];
        return (
          m.forEach((x) => {
            x.boundingBox.containsPoint(g) &&
              s(p, x.points).forEach((b) => {
                y.push({ identifier: x.identifier, isCW: x.isCW, point: b });
              });
          }),
          y.sort((x, b) => x.point.x - b.point.x),
          y
        );
      }
      function n(p, f, m, g, y) {
        (y == null || y === "") && (y = "nonzero");
        let x = new re();
        p.boundingBox.getCenter(x);
        let b = [new re(m, x.y), new re(g, x.y)],
          _ = a(b, p.boundingBox, f);
        _.sort((P, R) => P.point.x - R.point.x);
        let S = [],
          M = [];
        _.forEach((P) => {
          P.identifier === p.identifier ? S.push(P) : M.push(P);
        });
        let C = S[0].point.x,
          A = [],
          T = 0;
        for (; T < M.length && M[T].point.x < C; )
          A.length > 0 && A[A.length - 1] === M[T].identifier
            ? A.pop()
            : A.push(M[T].identifier),
            T++;
        if ((A.push(p.identifier), y === "evenodd")) {
          let P = A.length % 2 === 0,
            R = A[A.length - 2];
          return { identifier: p.identifier, isHole: P, for: R };
        } else if (y === "nonzero") {
          let P = !0,
            R = null,
            z = null;
          for (let N = 0; N < A.length; N++) {
            let L = A[N];
            f[L] &&
              (P
                ? ((z = f[L].isCW), (P = !1), (R = L))
                : z !== f[L].isCW && ((z = f[L].isCW), (P = !0)));
          }
          return { identifier: p.identifier, isHole: P, for: R };
        } else
          console.warn('fill-rule: "' + y + '" is currently not implemented.');
      }
      let o = 0,
        l = 999999999,
        h = -999999999,
        u = [];
      this.subPaths.forEach((p) => {
        let f = p.getPoints(),
          m = -999999999,
          g = 999999999,
          y = -999999999,
          x = 999999999;
        for (let b = 0; b < f.length; b++) {
          let _ = f[b];
          _.y > m && (m = _.y),
            _.y < g && (g = _.y),
            _.x > y && (y = _.x),
            _.x < x && (x = _.x);
        }
        h <= y && (h = y + 1),
          l >= x && (l = x - 1),
          f.length &&
            u.push({
              curves: p.curves,
              points: f,
              isCW: yC.isClockWise(f),
              identifier: o++,
              boundingBox: new DC(new re(x, g), new re(y, m)),
            });
      });
      let c = u.map((p) => n(p, u, l, h, this.userData?.style.fillRule)),
        d = [];
      return (
        u.forEach((p) => {
          let f = c[p.identifier];
          if (f && !f.isHole) {
            let m = new Am();
            (m.curves = p.curves),
              c
                .filter((g) => g?.isHole && g.for === p.identifier)
                .forEach((g) => {
                  if (g) {
                    let y = u[g.identifier],
                      x = new Sm();
                    (x.curves = y.curves), m.holes.push(x);
                  }
                }),
              d.push(m);
          }
        }),
        d
      );
    }
  },
  gP = !1,
  vP,
  GA = new Promise((e) => {
    vP = e;
  }),
  WA = !1,
  zf;
function rY() {
  if (((gP = !0), WA)) return;
  if (zf) return zf;
  async function e() {
    let t = await import("./opentype.js");
    vP(t), (WA = !0);
  }
  return (zf = e()), zf;
}
var sY = class {
  async load(e, t, i = () => {}) {
    let { load: r } = await GA;
    r(e, (s, a) => {
      s || !a ? i(s ?? "Something went wrong") : t(a);
    });
  }
  async parse(e) {
    let { parse: t, Bidi: i } = await GA;
    try {
      let r = t(e),
        s = new i(),
        a = (n) => r.charToGlyphIndex(n.char);
      return (
        s.registerModifier("glyphIndex", null, a),
        s.applyFeatures(r, r.defaultRenderOptions.features),
        { font: r, bidi: s }
      );
    } catch (r) {
      console.error(r);
    }
  }
};
async function aY(e) {
  return await (await fetch(e)).arrayBuffer();
}
var nY = new sY();
async function qA(e) {
  let t,
    i,
    r = !1;
  if (
    (e.url
      ? ((t = await aY(e.url)), (i = e.url), (r = e.url.startsWith("/")))
      : e.data &&
        (t = e.data.buffer.slice(
          e.data.byteOffset,
          e.data.byteOffset + e.data.byteLength
        )),
    t)
  )
    if (gP) {
      let s = await nY.parse(t);
      if (s)
        return { font: s.font, url: i, intercepted: r, arr: t, bidi: s.bidi };
    } else return { font: void 0, url: i, intercepted: r, arr: t, bidi: null };
}
function oY(e, t) {
  return (
    t.state.glyphIndex === e ||
    t.state.fina === e ||
    t.state.medi === e ||
    t.state.init === e
  );
}
var lY = class {
  constructor(e) {
    (this._arrayBuffer = new ArrayBuffer(1)),
      (this._isLoaded = !1),
      (this._intercepted = !1),
      (this._isUserFont = e.isUserFont ?? !1),
      (this._loadingPromise = qA(e).then((t) => {
        t &&
          ((this._arrayBuffer = t.arr),
          (this._url = t.url),
          (this.font = t.font),
          (this._intercepted = t.intercepted),
          (this._isLoaded = !0),
          (this._bidi = t.bidi));
      }));
  }
  update(e) {
    (this._isLoaded = !1),
      (this._isUserFont = e.isUserFont ?? !1),
      (this._loadingPromise = qA(e).then((t) => {
        t &&
          ((this._arrayBuffer = t.arr),
          (this._url = t.url),
          (this.font = t.font),
          (this._intercepted = t.intercepted),
          (this._isLoaded = !0),
          (this._bidi = t.bidi));
      }));
  }
  get url() {
    return this._url;
  }
  get intercepted() {
    return this._intercepted;
  }
  get isLoaded() {
    return this._isLoaded;
  }
  get loadingPromise() {
    return this._loadingPromise;
  }
  reverseLigaturesTable(e, t, i) {
    if (!this._bidi) return [];
    let r = this._bidi;
    r.getTextGlyphs(t);
    let s = r.tokenizer.tokens,
      a = [],
      n = 0,
      o = i.length === s.length;
    for (let l = 0; l < i.length; l++) {
      let h = i[l].index,
        u = String.fromCharCode(i[l].unicode),
        c = s[n];
      if (oY(h, c) || o)
        a.push({
          char: u,
          index: h,
          replacements: [c.state.glyphIndex],
          replacementChars: [c.char],
        }),
          n++;
      else {
        let d = c.char,
          p = "",
          f = [c.state.glyphIndex],
          m = [],
          g = !1;
        for (; !g; )
          n++,
            (p = t.charAt(n)),
            (d += p),
            f.push(e.charToGlyphIndex(p)),
            (m = e.stringToGlyphs(d)),
            m.length === 1 && m[0].index === h && (g = !0),
            n > t.length && (g = !0);
        a.push({
          char: u,
          index: h,
          replacements: f,
          replacementChars: Array.from(d),
        }),
          n++;
      }
    }
    return a;
  }
  generateShapes(e, t) {
    if (!this._isLoaded) return;
    let i = this.font,
      r = t.fontSize / this.unitsPerEm,
      s = t.fontSize * t.lineHeight,
      a = e.map((y) => this.getTextWidth(y, t)),
      n = t.width,
      o = this.getCharWidth(
        `
`,
        t
      ),
      l = t.horizontalAlign === 1 ? o : 0,
      h = this.computeSpaceWidthForLine(e, 0, t),
      u = this.getLineInitialOffsetX(a[0], n, t.horizontalAlign, e[0], o),
      c = this.getLineInitialOffsetY(s, e.length, t.height, r, t.verticalAlign),
      d = [],
      p = e.map((y) => []),
      f = e.map((y) => []),
      m;
    for (let y = 0; y < e.length; y++) {
      let x = e[y],
        b = { features: { liga: !0 } },
        _ = [];
      try {
        _ = i.stringToGlyphs(x, b);
      } catch (M) {
        console.warn(M);
      }
      u = this.getLineInitialOffsetX(a[y], n, t.horizontalAlign, x, o);
      let S = [];
      try {
        S = this.reverseLigaturesTable(i, x, _);
      } catch (M) {
        console.warn(M);
      }
      h = this.computeSpaceWidthForLine(e, y, t);
      for (let M = 0; M < _.length; M++) {
        let C = _[M],
          A =
            C.index === 0
              ? `
`
              : C.unicode
              ? String.fromCharCode(C.unicode)
              : void 0,
          T = S[M],
          P = 0,
          R = 0;
        M === 0 &&
          t.horizontalAlign === 2 &&
          C.leftSideBearing !== void 0 &&
          (R = -C.leftSideBearing * r),
          m && (P = i.getKerningValue(C, m) * r),
          (u += R + P);
        let z = 0;
        if (
          A ===
          `
`
        )
          z = l;
        else if (A === " ") z = h;
        else {
          let N = this.createPath(C, r, u, c, t);
          N && ((z = N.offsetX - (P + R)), d.push(N.path));
        }
        if (T.replacements.length === 1) f[y].push([u, c]), p[y].push(z);
        else {
          let N = T.replacements.map(
              (Z) => (i.glyphs.get(Z).advanceWidth ?? 0) * r
            ),
            L = N.reduce((Z, q) => (Z += q), 0),
            G = N.map((Z) => Z / L),
            Y = u;
          for (let Z = 0; Z < G.length; Z++) {
            let q = z * G[Z];
            f[y].push([Y, c]), p[y].push(q), (Y += q);
          }
        }
        (u += z), (m = C);
      }
      c -= s;
    }
    let g = [];
    for (let y = 0, x = d.length; y < x; y++) g.push(...d[y].toShapes());
    return { shapes: g, charWidths: p, lineWidths: a, charCoords: f };
  }
  get isUserFont() {
    return this._isUserFont;
  }
  get arrayBuffer() {
    return this._arrayBuffer;
  }
  get ascender() {
    return this.font?.ascender ?? 0;
  }
  get descender() {
    return this.font?.descender ?? 0;
  }
  get familyName() {
    return this.font?.names.fontFamily ?? "";
  }
  get subfamilyName() {
    return this.font?.names.fontSubfamily ?? "";
  }
  get unitsPerEm() {
    return this.font?.unitsPerEm ?? 1;
  }
  getLineInitialOffsetX(e, t, i, r, s) {
    return (
      (i === 3 || i === 2) &&
        r.indexOf(`
`) >= 0 &&
        (e -= s),
      i === 3 ? t * 0.5 - e * 0.5 : i === 2 ? t - e : 0
    );
  }
  getLineInitialOffsetY(e, t, i, r, s) {
    let a = t * e,
      n = Math.abs(this.ascender - this.descender) * r,
      o = e - n,
      l = -this.ascender * r - o / 2;
    return s === 3 ? -(i - a - l) : s === 2 ? -(i * 0.5 - a * 0.5 - l) : l;
  }
  createPath(e, t, i, r, s) {
    let a = e.getPath(i, -r, s.fontSize, {
      kerning: !1,
      letterSpacing: s.letterSpacing,
    });
    if (!a) {
      console.error(
        'THREE.Font: character "' +
          e +
          '" does not exists in font family ' +
          this.familyName +
          "."
      );
      return;
    }
    let n = new iY(),
      o = (e.advanceWidth ?? 1) * t;
    if (e)
      for (let l of a.commands) {
        let h = n.currentPath?.currentPoint;
        if (!(h && l.type !== "Z" && h.x === l.x && -h.y === l.y))
          switch (l.type) {
            case "M":
              n.moveTo(l.x, -l.y);
              break;
            case "L":
              n.lineTo(l.x, -l.y);
              break;
            case "Q":
              n.quadraticCurveTo(l.x1, -l.y1, l.x, -l.y);
              break;
            case "C":
              n.bezierCurveTo(l.x1, -l.y1, l.x2, -l.y2, l.x, -l.y);
              break;
          }
      }
    return (
      n.subPaths.forEach((l) => {
        let h = hY(l.curves);
        h !== void 0 && l.currentPoint.distanceTo(h) > 0 && l.lineTo(h.x, h.y);
      }),
      { offsetX: o + s.fontSize * s.letterSpacing, path: n }
    );
  }
  getCharWidth(e, t) {
    return (
      this.font?.getAdvanceWidth(e, t.fontSize, {
        kerning: !0,
        letterSpacing: t.letterSpacing,
      }) ?? 0
    );
  }
  getTextWidth(e, t) {
    return (
      this.font?.getAdvanceWidth(e, t.fontSize, {
        kerning: !0,
        letterSpacing: t.letterSpacing,
      }) ?? 0
    );
  }
  computeSpaceWidthForLine(e, t, i) {
    let r = this.getCharWidth(" ", i),
      s = e[t];
    if (s) {
      let a = this.countSpaces(s.trimEnd());
      if (i.horizontalAlign === 4 && t < e.length - 1 && a) {
        let n = i.width,
          o = this.getTextWidth(s, i);
        return (n - (o - a * r)) / a;
      }
    }
    return r;
  }
  countSpaces(e) {
    return (e.match(/ /g) || []).length;
  }
};
function hY(e) {
  if (e.length) {
    let t = e[0];
    if (t instanceof Ya) return t.v1;
    if (t instanceof Ha || t instanceof pl) return t.v0;
  }
}
var cY = class {
    constructor() {
      (this.objects = new Map()), (this.unreachable = new Set());
    }
    getCached(e) {
      return this.objects.get(e);
    }
    get size() {
      return this.objects.size;
    }
    get(e, t, i) {
      let r = this.objects.get(e);
      return (
        r === void 0
          ? ((r = this.createObject(e, t, i)), this.objects.set(e, r))
          : (r.isShared = !0),
        r
      );
    }
    forceDelete(e) {
      let t = this.objects.get(e);
      t && (this.disposeObject(t), this.objects.delete(e));
    }
    mutateIfUnique(e, t) {
      let i = this.objects.get(e);
      if (i && i.isShared !== !0)
        return this.objects.delete(e), this.objects.set(t, i), i;
    }
    startGc() {
      this.unreachable = new Set(this.objects.keys());
    }
    markAsReachable(e, t) {
      let i = this.objects.get(e);
      t === i && this.unreachable.delete(e);
    }
    endGc() {
      this.unreachable.forEach((e) => {
        this.disposeObject(this.objects.get(e)), this.objects.delete(e);
      }),
        this.unreachable.clear();
    }
    dispose() {
      this.objects.forEach((e) => {
        this.disposeObject(e);
      }),
        this.objects.clear();
    }
  },
  YA = class extends cY {
    constructor(e) {
      super(), (this.flatShading = e);
    }
    disposeObject(e) {
      e.dispose();
    }
    createObject(e, t, i) {
      let r = Jd(e, t, this.flatShading, i);
      return r.computeBoundingSphere(), r;
    }
  },
  uY = { markNeedsUpdateRendererDirty: () => {} },
  dY = class extends dq {
    constructor(e) {
      super(), (this.shared = e);
    }
    create(e) {
      return new oP(e, this.shared);
    }
  },
  _b = class {
    constructor(e, t = {}) {
      if (
        ((this.data = e),
        (this.geometryCache = new YA(!0)),
        (this.geometryCache2 = new YA(!1)),
        (this.imageHolderCache = new dY(this)),
        (this.thisContext = { scene: uY, shared: this }),
        (this.deletedMaterial = new B1(
          gs.defaultTwoLayerData("phong"),
          this.thisContext,
          ""
        )),
        (this.deletedImage = new Jo(Jm.emptyImage, this)),
        (this.deletedVideo = new Jo(Wm.defaultVideo, this)),
        (this.materials = {}),
        (this.images = {}),
        (this.canvases = {}),
        (this.videos = {}),
        (this.colors = {}),
        (this.audios = {}),
        (this.particles = {}),
        (this.fonts = {}),
        (this.variables = {}),
        (this.mouseProperty = null),
        (this.raycastProperty = null),
        (this.requestRender = () => {
          this._requestRender && this._requestRender();
        }),
        t.images)
      )
        for (let [i, r] of Object.entries(t.images)) this.addImage(i, r);
      if (t.videos)
        for (let [i, r] of Object.entries(t.videos)) this.addVideo(i, r);
      if (t.audios)
        for (let [i, r] of Object.entries(t.audios)) this.addAudio(i, r);
      if (t.particles)
        for (let [i, r] of Object.entries(t.particles)) this.addParticle(i, r);
      this.reset(e);
    }
    setRequestRender(e) {
      this._requestRender = e;
    }
    setEntityOpContext(e) {
      this.entityOpContext = e;
    }
    reset(e, t = !1) {
      this.resetLib(e.lib);
      for (let { id: i, data: r } of e.variables)
        this.addVariableHolder(i, r), t && this.updateVariableHolder(i, r);
      for (let [i, r] of Object.entries(e.images)) this.addImage(i, r);
      for (let [i, r] of Object.entries(e.videos)) this.addVideo(i, r);
      for (let [i, r] of Object.entries(e.colors)) this.addColor(i, r);
      for (let [i, r] of Object.entries(e.materials)) this.addMaterial(i, r);
      for (let [i, r] of Object.entries(e.audios)) this.addAudio(i, r);
      for (let [i, r] of Object.entries(e.particles)) this.addParticle(i, r);
      for (let [i, r] of Object.entries(e.fonts)) this.addFont(i, r);
    }
    addMaterial(e, t) {
      if (this.materials[e]) {
        let i = this.materials[e];
        i.reset(t, this.thisContext), i.dispose();
      } else {
        let i = new B1(t, this.thisContext, e);
        this.materials[e] = i;
      }
    }
    deleteMaterial(e) {
      this.materials[e] &&
        (this.materials[e].nodeMaterialDispose(), delete this.materials[e]);
    }
    getMaterial(e) {
      return this.materials[e];
    }
    getMaterialOrDeletedPlaceholder(e) {
      return this.materials[e] ?? this.deletedMaterial;
    }
    material(e) {
      return typeof e == "string"
        ? this.getMaterialOrDeletedPlaceholder(e)
        : e == null
        ? (console.error("material is undefined or null"), this.deletedMaterial)
        : new wb(e, this.thisContext);
    }
    getMaterials() {
      return this.materials;
    }
    addImage(e, t) {
      return this.images[e]
        ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
          this.images[e].updateSrc(t.data),
          !0)
        : ((this.images[e] = new Jo(t, this)), !1);
    }
    deleteImage(e) {
      let t = this.images[e];
      t && (t.dispose(), delete this.images[e]);
    }
    getDefaultImage() {
      return this.images.image_0;
    }
    getImage(e) {
      return this.images[e] ?? this.deletedImage;
    }
    image(e) {
      return typeof e == "string"
        ? this.getImage(e)
        : this.imageHolderCache.load(e);
    }
    addCanvas(e, t) {
      return this.canvases[e]
        ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
          this.canvases[e].updateSrc(t),
          !0)
        : ((this.canvases[e] = new Jo(t, this)), !1);
    }
    canvas(e) {
      return this.canvases[e];
    }
    addVideo(e, t) {
      return this.videos[e]
        ? (this.videos[e].updateSrc(t.data), !0)
        : ((this.videos[e] = new Jo(t, this)), !1);
    }
    deleteVideo(e) {
      let t = this.videos[e];
      t && (t.dispose(), delete this.videos[e]);
    }
    getVideo(e) {
      return this.videos[e] ?? this.deletedVideo;
    }
    video(e) {
      return typeof e == "string"
        ? this.getVideo(e)
        : this.imageHolderCache.load(e);
    }
    addColor(e, t) {
      return this.colors[e]
        ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
          "a" in t
            ? this.colors[e].setRGBA(t.r, t.g, t.b, t.a)
            : this.colors[e].setRGBA(t.r, t.g, t.b, 1),
          !0)
        : ("a" in t
            ? (this.colors[e] = new hg(t.r, t.g, t.b, t.a))
            : (this.colors[e] = new hg(t.r, t.g, t.b, 1)),
          !1);
    }
    updateColor(e, t) {
      if (this.colors[e]) {
        this.onColorOrImageUpdate && this.onColorOrImageUpdate();
        let i = this.colors[e];
        return (
          (this.colors[e].r = t.r ?? i.r),
          (this.colors[e].g = t.g ?? i.g),
          (this.colors[e].b = t.b ?? i.b),
          (this.colors[e].a = t.a ?? i.a),
          !0
        );
      }
      return !1;
    }
    deleteColor(e) {
      this.colors[e] && delete this.colors[e];
    }
    getColor(e) {
      return this.colors[e];
    }
    color(e) {
      let t;
      if (typeof e == "string") {
        let i = this.getColor(e);
        i
          ? (t = i)
          : (console.warn(
              "Tried to create color layer params with a color key that does not exist in the assets manager"
            ),
            (t = new os(0, 0, 0, 0)));
      } else
        return "a" in e ? new os(e.r, e.g, e.b, e.a) : new os(e.r, e.g, e.b, 1);
      return t;
    }
    addAudio(e, t) {
      this.audios[e] = t;
    }
    getAudio(e) {
      let t = this.audios[e];
      if (t instanceof vd) return t;
      {
        let i = new vd({ src: t.data });
        return (this.audios[e] = i), i;
      }
    }
    addParticle(e, t) {
      this.particles[e] = t;
    }
    getParticle(e) {
      return this.particles[e];
    }
    deleteParticle(e) {
      this.particles[e] && delete this.particles[e];
    }
    deleteAudio(e) {
      let t = this.audios[e];
      t && (t instanceof vd && t.dispose(), delete this.audios[e]);
    }
    addFont(e, t) {
      (this.fonts[e] = new lY(t)),
        this.fonts[e].loadingPromise.then(() => this.requestRender());
    }
    getFont(e) {
      return this.fonts[e];
    }
    deleteFont(e) {
      this.fonts[e] && delete this.fonts[e];
    }
    dispose() {
      Object.keys(this.materials).forEach((e) => this.deleteMaterial(e)),
        (this._requestRender = void 0),
        Object.values(this.audios).forEach((e) => {
          e instanceof vd && e.dispose();
        }),
        (this.audios = {}),
        (this.particles = {}),
        this.geometryCache.dispose(),
        this.geometryCache2.dispose();
    }
    addVariableHolder(e, t) {
      return this.variables[e] === void 0
        ? ((this.variables[e] = { value: t.value, locations: [] }),
          "dynamicVariableType" in t &&
            ((this.variables[e].dynamicVariablePlayState = "Playing"),
            (this.variables[e].dynamicVariableToggleIsForward = void 0)),
          !0)
        : ((this.variables[e].value = t.value), !1);
    }
    resetDynamicVariablePlayState() {
      for (let e in this.variables)
        this.variables[e].dynamicVariablePlayState !== void 0 &&
          ((this.variables[e].dynamicVariablePlayState = "Playing"),
          (this.variables[e].dynamicVariableToggleIsForward = void 0));
    }
    updateVariableHolder(e, t) {
      this.updateVariable(e, t.value);
    }
    updateVariable(e, t) {
      if (this.variables[e] === void 0) return !1;
      this.variables[e].value = t;
      let i = t;
      for (; typeof i == "string"; ) i = this.variables[i].value;
      let r = this.entityOpContext.scene;
      for (let s = this.variables[e].locations.length - 1; s >= 0; s--) {
        let a = this.variables[e].locations[s];
        if (a[0] === "material") {
          let n = a[1],
            o = i,
            l = { scene: r, shared: this },
            h = a.slice(2);
          r.traverseMaterial((c) => {
            let d = c.root ?? c;
            d.uuid === n && d.onVariableUpdate(h, o, l);
          });
          let u = this.materials[n];
          u && u.onVariableUpdate(h, o, l);
        } else {
          let n = r.find(a[0]);
          if (n === void 0) {
            this.variables[e].locations.splice(s, 1);
            continue;
          }
          if (a[1] !== "geometry" && a[1] !== "particles") {
            for (let o = 1; o < a.length - 1; o++) n = n[a[o]];
            a[1] === "rotation"
              ? (n[a[a.length - 1]] = i * dt.DEG2RAD)
              : (n[a[a.length - 1]] = i);
          }
          if (
            ((n = r.find(a[0])),
            n.type === "ParticleEmitter" && n.updateVariableState(i, a),
            si.is(n))
          ) {
            if (a[1] === "position" || a[1] === "rotation" || a[1] === "scale")
              n.onVariableUpdate();
            else if (a[1] === "geometry") {
              let o = n;
              n.component && (o = n.component);
              let l = o.dataPatched;
              o.chooseGeoemtryCache(this).forceDelete(l.geometry),
                o.createGeometryDelayed(this.entityOpContext),
                o.onVariableUpdate(!0),
                o.instances.forEach((h) => {
                  let u = h.dataPatched;
                  h.chooseGeoemtryCache(this).forceDelete(u.geometry),
                    h.createGeometryDelayed(this.entityOpContext),
                    h.onVariableUpdate(!0);
                });
            }
          }
        }
      }
      return this.requestRender(), !0;
    }
    deleteVariable(e) {
      this.variables[e] && delete this.variables[e];
    }
    getVariable(e, t) {
      if (Array.isArray(e)) {
        if (e[0] === "mouse") return this.mouseProperty?.[e[1]] ?? 0;
        if (e[0] === "raycast") return this.raycastProperty?.[e[1]] ?? 0;
        let i = this.entityOpContext.scene.find(e[0]);
        if (e[1] === "width" || e[1] === "height" || e[1] === "depth")
          return i.geometry.userData.parameters[e[1]];
        for (let r = 1; r < e.length; r++) i = i[e[r]];
        return e[1] === "rotation" && (i *= dt.RAD2DEG), i;
      }
      for (let i in this.variables) {
        if (t === void 0) break;
        let r = this.variables[i],
          s = r.locations?.findIndex((a) => ss.equal(a, t));
        s !== void 0 && s !== -1 && r.locations.splice(s, 1);
      }
      if (typeof e == "string") {
        let i = e,
          r = e;
        do {
          if (((r = i), this.variables[i] === void 0)) break;
          i = this.variables[i].value;
        } while (typeof i == "string");
        return (
          t &&
            this.variables[r] !== void 0 &&
            this.variables[r].locations.push(t),
          i
        );
      } else return e;
    }
    getVariables() {
      return this.variables;
    }
    getDynamicVariablePlayState(e) {
      return this.variables[e]?.dynamicVariablePlayState;
    }
    setDynamicVariablePlayState(e, t) {
      this.variables[e] !== void 0 &&
        (this.variables[e].dynamicVariablePlayState = t);
    }
    getDynamicVariableToggleIsForward(e) {
      return this.variables[e]?.dynamicVariableToggleIsForward;
    }
    setDynamicVariableToggleIsForward(e, t) {
      this.variables[e] !== void 0 &&
        (this.variables[e].dynamicVariableToggleIsForward = t);
    }
    resetLib(e) {
      for (let [t, i] of Object.entries(e.images)) this.addImage(t, i.asset);
      for (let [t, i] of Object.entries(e.audios)) this.addAudio(t, i.asset);
      for (let [t, i] of Object.entries(e.particles))
        this.addParticle(t, i.asset);
      for (let [t, i] of Object.entries(e.colors)) this.addColor(t, i.asset);
      for (let [t, i] of Object.entries(e.fonts)) this.addFont(t, i.asset);
      for (let [t, i] of Object.entries(e.materials))
        this.addMaterial(t, i.asset);
      for (let [t, i] of Object.entries(e.videos)) this.addVideo(t, i.asset);
      for (let [t, i] of Object.entries(e.variables))
        this.addVariableHolder(t, i.asset);
    }
    updateLibByOp(e, t) {
      e.path[0] === "images"
        ? e.path.length === 1 && e.type === 1
          ? this.addImage(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteImage(e.id)
        : e.path[0] === "videos"
        ? e.path.length === 1 && e.type === 1
          ? this.addVideo(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteVideo(e.id)
        : e.path[0] === "audios"
        ? e.path.length === 1 && e.type === 1
          ? this.addAudio(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteAudio(e.id)
        : e.path[0] === "particles"
        ? e.path.length === 1 && e.type === 1
          ? this.addParticle(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteParticle(e.id)
        : e.path[0] === "colors"
        ? e.path.length === 1 && e.type === 1
          ? this.addColor(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteColor(e.id)
        : e.path[0] === "materials"
        ? e.path.length === 1 && e.type === 1
          ? this.addMaterial(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteMaterial(e.id)
        : e.path[0] === "fonts"
        ? e.path.length === 1 && e.type === 1
          ? this.addFont(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteFont(e.id)
        : e.path[0] === "variables"
        ? e.path.length === 1 && e.type === 1
          ? this.addVariableHolder(e.id, e.data.asset)
          : e.path.length === 1 && e.type === 2 && this.deleteVariable(e.id)
        : e.path[0] === "components" && t.updateByLibOp(e, this);
    }
    updateByOp(e, t, i) {
      (this.data = t),
        e.path[0] === "images"
          ? e.path.length === 2 && e.type === 0
            ? e.props.data && this.getImage(e.path[1]).updateSrc(e.props.data)
            : e.path.length === 1 && e.type === 1
            ? this.addImage(e.id, e.data)
            : e.path.length === 1 && e.type === 2 && this.deleteImage(e.id)
          : e.path[0] === "videos"
          ? e.path.length === 2 && e.type === 0
            ? e.props.data && this.getVideo(e.path[1]).updateSrc(e.props.data)
            : e.path.length === 1 && e.type === 1
            ? this.addVideo(e.id, e.data)
            : e.path.length === 1 && e.type === 2 && this.deleteVideo(e.id)
          : e.path[0] === "audios"
          ? e.path.length === 2 && e.type === 0
            ? e.props.data && this.addAudio(e.path[1], t.audios[e.path[1]])
            : e.path.length === 1 && e.type === 1
            ? this.addAudio(e.id, e.data)
            : e.path.length === 1 && e.type === 2 && this.deleteAudio(e.id)
          : e.path[0] === "particles"
          ? e.path.length === 2 && e.type === 0
            ? e.props.data &&
              this.addParticle(e.path[1], t.particles[e.path[1]])
            : e.path.length === 1 && e.type === 1
            ? this.addParticle(e.id, e.data)
            : e.path.length === 1 && e.type === 2 && this.deleteParticle(e.id)
          : e.path[0] === "colors"
          ? e.path.length === 2 && e.type === 0
            ? this.updateColor(e.path[1], e.props)
            : e.path.length === 1 && e.type === 1
            ? this.addColor(e.id, e.data)
            : e.path.length === 1 && e.type === 2 && this.deleteColor(e.id)
          : e.path[0] === "materials"
          ? e.path.length === 1 && e.type === 1
            ? this.addMaterial(e.id, e.data)
            : e.path.length === 1 && e.type === 2
            ? this.deleteMaterial(e.id)
            : e.path.length > 1 &&
              this.getMaterial(e.path[1]).updateByOp(
                qr.drop(e, 2),
                t.materials[e.path[1]],
                { shared: this, scene: i }
              )
          : e.path[0] === "fonts"
          ? e.path.length === 2 && e.type === 0
            ? this.updateFont(e.path[1], e, i)
            : e.path.length === 1 && e.type === 1
            ? this.addFont(e.id, e.data)
            : e.path.length === 1 && e.type === 2 && this.deleteFont(e.id)
          : e.path[0] === "variables"
          ? e.path.length === 2 && e.type === 0 && "value" in e.props
            ? this.updateVariable(e.path[1], e.props.value)
            : e.path.length === 1 && e.type === 4
            ? this.addVariableHolder(e.id, e.data)
            : e.path.length === 1 && e.type === 5 && this.deleteVariable(e.id)
          : e.path[0] === "lib" && this.updateLibByOp(qr.drop(e, 1), i);
    }
    updateFont(e, t, i) {
      if (t.props.url) {
        let r = this.getFont(e),
          s = { ...this.data.fonts[e], url: t.props.url };
        r.update(s),
          r.loadingPromise.then(() => this.requestRender()),
          i.updateFont(e, this);
      }
    }
  },
  rte = new _b(wa.emptyData()),
  yu = class extends Is {
    updateByPatchedOp(e, t, i) {
      if (
        (super.updateByPatchedOp(e, t, i),
        aG(e.path, ["materials"]) !== null &&
          e.type === 0 &&
          Array.isArray(this.material))
      )
        for (let [r, s] of Object.entries(e.props)) {
          let a = i.shared.material(s);
          this.material[Number(r)] = a;
        }
      else if (Ii(e.path, ["material"]) && this.material instanceof ml)
        "material" in t &&
          typeof t.material != "string" &&
          this.material.updateByOp(qr.drop(e, 1), t.material, i);
      else if (Ii(e.path, ["materials", "*"]) && Array.isArray(this.material)) {
        let r = e.path[1];
        if ("materials" in t && r < this.material.length) {
          let s = t.materials[r];
          typeof s != "string" &&
            this.material[r].updateByOp(qr.drop(e, 2), s, i);
        }
      }
    }
    get needsAO() {
      return this.material !== void 0
        ? (Array.isArray(this.material) ? this.material[0] : this.material)
            .hasAO
        : !1;
    }
    updateState(e, t) {
      super.updateState(e, t),
        e.castShadow !== void 0 && (this.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (this.receiveShadow = e.receiveShadow);
      let i = this.dataPatched;
      if (
        (e.geometry?.type !== "NonParametricGeometry" &&
          "material" in e &&
          e.material !== void 0 &&
          (this.disposeMaterial(),
          (this.material = t.shared
            .material(e.material)
            .getFlavor(i.flatShading, i.side, i.wireframe)),
          t.scene.markNeedsUpdateRendererDirty()),
        (e.geometry?.type === "NonParametricGeometry" || "materials" in e) &&
          ("materials" in e && e.materials !== void 0
            ? (this.disposeMaterial(),
              (this.material = e.materials.map((r) =>
                t.shared
                  .material(r)
                  .getFlavor(i.flatShading, i.side, i.wireframe)
              )),
              t.scene.markNeedsUpdateRendererDirty())
            : "material" in e &&
              e.material !== void 0 &&
              (this.disposeMaterial(),
              (this.material = [
                t.shared
                  .material(e.material)
                  .getFlavor(i.flatShading, i.side, i.wireframe),
              ]),
              t.scene.markNeedsUpdateRendererDirty())),
        e.flatShading !== void 0 || e.wireframe !== void 0 || e.side !== void 0)
      )
        if (Array.isArray(this.material))
          for (let r = 0; r < this.material.length; r++)
            this.material[r] = this.material[r].getFlavor(
              i.flatShading,
              i.side,
              i.wireframe
            );
        else
          this.material = this.material.getFlavor(
            i.flatShading,
            i.side,
            i.wireframe
          );
    }
    disposeMaterial() {
      this.material &&
        fT(this.material).forEach((e) => {
          e instanceof ml && (e instanceof B1 || e.nodeMaterialDispose());
        });
    }
    dispose() {
      this.disposeMaterial(), super.dispose();
    }
  },
  XA = new I(),
  QA = new Lt(),
  ZA = new Lt(),
  pY = new I(),
  KA = new je(),
  ms = class extends yu {
    constructor(e, t, i) {
      super(e, t),
        (this.data = t),
        (this.isSkinnedMesh = !1),
        (this.localGeometry = void 0),
        t.bindMode &&
          t.bindMatrix &&
          ((this.bindMode = t.bindMode),
          (this.bindMatrix = new je().fromArray(t.bindMatrix)),
          (this.bindMatrixInverse = new je()));
    }
    chooseGeoemtryCache(e) {
      return e.geometryCache;
    }
    markGeometryAsReachable(e) {
      this.geometryCreateDeleyed instanceof yt &&
        this.chooseGeoemtryCache(e).markAsReachable(
          this.dataPatched.geometry,
          this.geometryCreateDeleyed
        );
    }
    get geometry() {
      if (this.localGeometry !== void 0) return this.localGeometry;
      if (this.geometryCreateDeleyed instanceof _b) {
        let e = this.geometryCreateDeleyed,
          t = this.chooseGeoemtryCache(e);
        this.geometryCreateDeleyed = t.get(this.dataPatched.geometry, e, this);
      }
      return this.geometryCreateDeleyed;
    }
    set geometry(e) {
      this.localGeometry = e;
    }
    get is2DAndNoDepth() {
      let e = this.dataPatched.geometry;
      return Xm.is2DParametricMesh(e.type) && e.depth === 0;
    }
    get is2DType() {
      return Xm.is2DParametricMesh(this.geometry.userData.type);
    }
    get isNonParametric() {
      return this.geometry.userData.type === "NonParametricGeometry";
    }
    updateByPatchedOp(e, t, i) {
      super.updateByPatchedOp(e, t, i),
        Ii(e.path, ["geometry"]) &&
          this.updateByPatchedOpGeometry(qr.drop(e, 1), t.geometry, i);
    }
    removeInteractionGeometry(e) {
      this.localGeometry?.dispose(), (this.localGeometry = void 0);
    }
    updateGeometryInteractions(e, t) {
      this.invalidateDownstreamBooleanData();
      let i = this.data.geometry.type;
      if (i === "NonParametricGeometry" || i === "SubdivGeometry") {
        let r = e;
        if (this.localGeometry === void 0) {
          let l = { ...this.data.geometry, ...r };
          this.localGeometry = Jd(l, t, this.data.flatShading, this);
        }
        let s, a, n;
        r.scaleBaked
          ? ([s, a, n] = r.scaleBaked)
          : ({ width: s, height: a, depth: n } = r);
        let o = this.localGeometry.userData;
        o.sxPrev !== void 0 &&
          P1(
            this.localGeometry.attributes,
            s / o.sxPrev,
            a / o.syPrev,
            n / o.szPrev
          ),
          (o.sxPrev = s),
          (o.syPrev = a),
          (o.szPrev = n);
      } else {
        let r = { ...this.data.geometry, ...e };
        this.localGeometry?.dispose(),
          (this.localGeometry = Jd(r, t, this.data.flatShading, this));
      }
    }
    refreshAttachedCloners(e) {
      for (let t of this.attachedSurfaceCloners)
        e.scene.addPendingUpdateCloner(t.object);
    }
    refreshAttachedPaths(e) {
      for (let t of this.attachedPaths)
        e.scene.addPendingCommand(() => t.updateShape());
    }
    createGeometryDelayed(e) {
      (this.geometryCreateDeleyed = e.shared),
        this.refreshAttachedCloners(e),
        this.refreshAttachedPaths(e);
    }
    updateByPatchedOpGeometry(e, t, i) {
      let r = !1;
      e.type === 0 &&
        e.path.length === 0 &&
        Object.keys(e.props).includes("scaleBaked") &&
        this.geometryCreateDeleyed instanceof Cs &&
        this.chooseGeoemtryCache(i.shared).mutateIfUnique(
          this.geometryCreateDeleyed.data,
          t
        ) === this.geometryCreateDeleyed &&
        ((r = !0),
        this.geometryCreateDeleyed.mutateDirectlyScaleBaked(
          t,
          e.props.scaleBaked
        ),
        this.refreshAttachedCloners(i),
        this.refreshAttachedPaths(i)),
        r || (i.scene?.markGeometryCacheDirty(), this.createGeometryDelayed(i)),
        this.resetBBoxNeedsUpdate(),
        this.invalidateDownstreamBooleanData();
    }
    updateGeometryOnStateUpdate(e, t) {
      this.createGeometryDelayed(t);
    }
    updateState(e, t) {
      e.geometry !== void 0 && this.updateGeometryOnStateUpdate(e.geometry, t),
        super.updateState(e, t);
    }
    updateGeometryGroupsIfNeeded() {
      Array.isArray(this.material) &&
        this.geometry.groups.length === 0 &&
        this.geometry.addGroup(
          0,
          Math.max(
            this.geometry.getIndex()?.count ?? 0,
            this.geometry.getAttribute("position").count
          ),
          0
        );
    }
    updateEntityBoxSize(e, t) {
      let i = this.geometry.userData.parameters;
      this.is2DType
        ? e.set(0, 0, i.depth * 0.5)
        : this.isNonParametric
        ? (e.setScalar(0),
          this.geometry.boundingSphere &&
            e.copy(this.geometry.boundingSphere.center),
          t.set(i.width, i.height, i.depth ?? 0).multiplyScalar(0.5))
        : e.setScalar(0),
        t.set(i.width, i.height, i.depth ?? 0).multiplyScalar(0.5);
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.bindMode === "attached"
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : this.bindMode === "detached" &&
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
    }
    bind(e, t) {
      (this.skeleton = e),
        (this.isSkinnedMesh = !0),
        t === void 0 &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (t = this.matrixWorld)),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights(e) {
      let t = new Lt(),
        i = this.geometry.attributes.skinWeight;
      for (let r = 0, s = i.count; r < s; r++) {
        t.fromBufferAttribute(i, r);
        let a = 1 / t.manhattanLength();
        a !== 1 / 0 ? t.multiplyScalar(a) : t.set(1, 0, 0, 0),
          i.setXYZW(r, t.x, t.y, t.z, t.w);
      }
    }
    boneTransform(e, t) {
      let i = this.skeleton;
      if (i === void 0) return;
      let r = this.geometry;
      QA.fromBufferAttribute(r.attributes.skinIndex, e),
        ZA.fromBufferAttribute(r.attributes.skinWeight, e),
        XA.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
      for (let s = 0; s < 4; s++) {
        let a = ZA.getComponent(s);
        if (a !== 0) {
          let n = QA.getComponent(s);
          KA.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]),
            t.addScaledVector(pY.copy(XA).applyMatrix4(KA), a);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    }
  };
function fY(e) {
  if (
    e.geometry.attributes.extrudeNormal ||
    !e.geometry.attributes.position ||
    !e.geometry.attributes.normal
  )
    return;
  let t = new Map(),
    i = e.geometry.attributes,
    r = i.position.array,
    s = i.normal.array,
    a = new Float32Array(r.length);
  for (let n = 0; n < r.length; n += 3) {
    let o = `${r[n]}_${r[n + 1]}_${r[n + 2]}`,
      l = new I(s[n], s[n + 1], s[n + 2]);
    t.has(o)
      ? t.get(o)?.normals.push(l)
      : t.set(o, { normals: [l], result: new I() });
  }
  t.forEach((n, o) => {
    for (let l of n.normals) n.result.add(l);
    n.result.divideScalar(n.normals.length);
  });
  for (let n = 0; n < r.length; n += 3) {
    let o = `${r[n]}_${r[n + 1]}_${r[n + 2]}`,
      l = t.get(o)?.result;
    l && ((a[n] = l.x), (a[n + 1] = l.y), (a[n + 2] = l.z));
  }
  e.geometry.setAttribute("extrudeNormal", new ot(a, 3));
}
function mY(e) {
  if (e.geometry.attributes.extrudeNormals || !e.geometry.attributes.position)
    return;
  let t = e.geometry.attributes.position.array,
    i = new Float32Array(t.length),
    r = new I();
  for (let s = 0; s < t.length; s += 3)
    r.set(t[s], t[s + 1], t[s + 2]).normalize(),
      (i[s] = r.x),
      (i[s + 1] = r.y),
      (i[s + 2] = r.z);
  e.geometry.setAttribute("extrudeNormal", new ot(i, 3));
}
function Sb(e) {
  if (Array.isArray(e.material)) {
    for (let t of e.material)
      if (t.getLayersOfType("outline").length === 0) return;
  } else if (
    !(e.material instanceof ml) ||
    e.material.getLayersOfType("outline").length === 0
  )
    return;
  e instanceof ms && e.is2DAndNoDepth ? mY(e) : fY(e);
}
function Ab(e) {
  if (!e.geometry.attributes.position) return;
  let t = e.geometry.attributes.position.array,
    i = new Float32Array(t.length),
    r = parseInt(e.uuid.replace(/\D/g, "")),
    s = [
      dt.seededRandom(r),
      dt.seededRandom(r + 1e4),
      dt.seededRandom(r + 2e4),
    ];
  for (let a = 0; a < t.length; a++) i[a] = s[a % 3];
  e.geometry.setAttribute("randomColor", new It(i, 3));
}
var cn = new ur(),
  $u = new I();
function gY(e) {
  let t = !1;
  return (
    e.scene.objects.traverse((i, r) => {
      r.type === "Mesh" && r.geometry.type === "SubdivGeometry" && (t = !0);
    }),
    t
  );
}
var $d = class extends ms {
    constructor(e, t, i) {
      super(e, t, i),
        (this.data = t),
        (this.hiddenMatrixOld = new je()),
        (this.smoothShading = !0),
        (this.skipReactionUpdate = !1);
    }
    chooseGeoemtryCache(e) {
      return this.dataPatched.flatShading ? e.geometryCache : e.geometryCache2;
    }
    get subdivPointerNew() {
      return this.localGeometry !== void 0
        ? this.subdivPointer
        : this.geometry.ensureSubdivPointer();
    }
    get originalGeometryNew() {
      return this.localGeometry !== void 0
        ? this.originalGeometry
        : this.geometry.originalGeometry;
    }
    get phongAngle() {
      return this.data.geometry.phongAngle ?? 45;
    }
    updateEntityBoxSize(e, t) {
      let i = this.geometry.userData.parameters;
      e.copy(this.originalGeometryNew.boundingSphere.center),
        t.set(i.width, i.height, i.depth ?? 0).multiplyScalar(0.5);
    }
    createGeometryByControls(e) {
      if (this.skipReactionUpdate === !0) return;
      let t = this.localGeometry?.uuid,
        {
          originalGeometry: i,
          subdividedGeometry: r,
          subdivPointer: s,
        } = Cs.build(
          e,
          this.subdivPointer,
          this.smoothShading,
          this.hasNonUniformScale ? this.shearScale : void 0
        );
      (this.subdivPointer = s),
        i !== void 0 &&
          (this.originalGeometry?.dispose(), (this.originalGeometry = i)),
        r !== void 0 &&
          (this.subdividedGeometry?.dispose(),
          (this.subdividedGeometry = r ?? void 0)),
        (this.localGeometry = this.subdividedGeometry ?? this.originalGeometry),
        Sb(this),
        Ab(this),
        this.calcBoundingBox(),
        t && (this.localGeometry.uuid = t);
    }
    updateState(e, t) {
      if ((super.updateState(e, t), e.flatShading !== void 0)) {
        let i = this.material;
        (this.material = Array.isArray(i)
          ? i.map((r) => r.getFlavor(!1, r.side, r.wireframe))
          : i.getFlavor(!1, i.side, i.wireframe)),
          (this.smoothShading = !e.flatShading),
          this.createGeometryDelayed(t);
      }
    }
    updateMesh(e = !1) {
      Cs.buildLevel(
        this.subdivPointer,
        !0,
        this.smoothShading ? this.phongAngle : -1,
        this.originalGeometry,
        e && this.hasNonUniformScale ? this.shearScaleInv : void 0
      ),
        this.subdividedGeometry &&
          Cs.buildLevel(
            this.subdivPointer,
            !1,
            this.smoothShading ? this.phongAngle : -1,
            this.subdividedGeometry,
            e && this.hasNonUniformScale ? this.shearScaleInv : void 0
          );
    }
    updateTopology() {
      this.originalGeometry.dispose(),
        (this.originalGeometry = Cs.buildLevel(
          this.subdivPointer,
          !0,
          this.smoothShading ? this.phongAngle : -1
        )),
        this.subdividedGeometry &&
          (this.subdividedGeometry.dispose(),
          (this.subdividedGeometry = Cs.buildLevel(
            this.subdivPointer,
            !1,
            this.smoothShading ? this.phongAngle : -1
          ))),
        (this.localGeometry = this.subdividedGeometry ?? this.originalGeometry);
    }
    raycast(e, t) {
      let i = this.localGeometry;
      (this.localGeometry = this.originalGeometryNew),
        Is.prototype.raycast.call(this, e, t),
        (this.localGeometry = i);
    }
    activateSVDCompensation() {
      !this.hasNonUniformScale ||
        (this.matrix.copy(this.matrixWorldRigid),
        this.hiddenMatrixOld.copy(this.hiddenMatrix),
        this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
    }
    deactivateSVDCompensation() {
      !this.hasNonUniformScale ||
        (this.updateMatrix(),
        (this.hasNonUniformScale = void 0),
        this.hiddenMatrix.copy(this.hiddenMatrixOld));
    }
    calcBoundingBox() {
      let e = this.originalGeometry;
      e.boundingSphere === null &&
        ((e.boundingSphere = new Ws()),
        this.subdividedGeometry &&
          (this.subdividedGeometry.boundingSphere = e.boundingSphere));
      let t = e.attributes.position,
        i = e.boundingSphere.center;
      cn.setFromBufferAttribute(t),
        cn.getCenter(i),
        (e.boundingSphere.radius = i.distanceTo(cn.max)),
        isNaN(e.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ),
        cn.getSize($u),
        this.hasNonUniformScale && $u.divide(this.scale);
      let r = { width: $u.x, height: $u.y, depth: $u.z };
      return (this.geometry.userData.parameters = r), r;
    }
    updateBoundingSphere(e) {
      let t = this.originalGeometry;
      cn.min.set(e[0], e[2], e[4]),
        cn.max.set(e[1], e[3], e[5]),
        this.hasNonUniformScale &&
          (cn.min.applyMatrix4(this.shearScaleInv),
          cn.max.applyMatrix4(this.shearScaleInv)),
        t.boundingSphere === null && (t.boundingSphere = new Ws());
      let i = t.boundingSphere.center;
      cn.getCenter(i), (t.boundingSphere.radius = i.distanceTo(cn.max));
    }
    freeSubdivPointer() {
      this.subdivPointer &&
        (Cs.freeSubdivPointer(this.subdivPointer), (this.subdivPointer = 0)),
        (this.localGeometry = void 0),
        this.originalGeometry?.dispose(),
        this.subdividedGeometry?.dispose();
    }
    dispose() {
      super.dispose(), this.freeSubdivPointer();
    }
    updateByPatchedOpGeometry(e, t, i) {
      super.updateByPatchedOpGeometry(e, t, i),
        this.localGeometry && this.createGeometryByControls(t);
    }
  },
  JA = -1,
  vY = 1,
  yY = {
    x: [1, 0, 0],
    "-x": [-1, 0, 0],
    y: [0, 1, 0],
    "-y": [0, -1, 0],
    z: [0, 0, 1],
    "-z": [0, 0, -1],
  },
  xY = { polygon_center: 0, edge: 1, vertex: 2 },
  Ff = (e, t) => (i, r) => !t || i === 0 || e === 0 ? 0 : (e * r) / 100,
  Vt = (e, t) => {
    let i = Math.abs(t),
      r = i * -1;
    return ((e - JA) * (i - r)) / (vY - JA) + r;
  };
function bY(e) {
  let t = [],
    i = {};
  for (var r = 0, s = e.length; r < s; r++) {
    var a = JSON.stringify(e[r].pos.map((n) => Math.round(n * 1e4) / 1e4));
    i[a] || (t.push(e[r]), (i[a] = !0));
  }
  return t;
}
var wY = new I(),
  kf = new I(),
  _Y = new I(),
  SY = new I();
function Fc(e, t) {
  let i = _Y.fromArray(e),
    r = SY.fromArray(t);
  kf.copy(r).sub(i);
  let s = kf.length();
  return kf.normalize().multiplyScalar(s * 0.5), wY.copy(i).add(kf).toArray();
}
var _a = new rs(),
  Nf = new I(),
  cg = new I(),
  Vl = new I();
function AY(e) {
  let t = [];
  for (let i = 0; i <= e.index.count; i++)
    if (
      (Nf.fromArray(e.index.array, i * 3),
      _a.setFromAttributeAndIndices(e.attributes.position, Nf.x, Nf.y, Nf.z),
      _a.getNormal(cg),
      _a.getMidpoint(Vl),
      !(isNaN(Vl.x) || isNaN(Vl.y) || isNaN(Vl.z)))
    ) {
      let { a: r, b: s, c: a } = _a,
        n = r.toArray(),
        o = s.toArray(),
        l = a.toArray(),
        h = r.distanceTo(s),
        u = s.distanceTo(a),
        c = a.distanceTo(r),
        d = Fc(n, o),
        p = Fc(o, l),
        f = Fc(l, n),
        m = [h, u, c],
        g = Math.max(...m),
        y = m.filter((_) => Math.round(_) === Math.round(g)).length > 1,
        x = [],
        b = _a.getMidpoint(Vl).toArray();
      g === h && !y && ((x = [p, f, f]), (b = d)),
        g === u && !y && ((x = [d, f, f]), (b = p)),
        g === c && !y && ((x = [d, p, p]), (b = f)),
        y && (x = [d, p, f]),
        t.push({
          vertices: [n, o, l],
          faceCenters: x,
          midpoint: b,
          norm: _a.getNormal(cg).toArray(),
        });
    }
  return t;
}
function MY(e) {
  let t = [],
    { position: i } = e.attributes;
  for (let r = 0; r < i.count; r++) {
    _a.setFromAttributeAndIndices(i, r * 3, r * 3 + 1, r * 3 + 2),
      _a.getNormal(cg),
      _a.getMidpoint(Vl);
    let s = _a.a.toArray(),
      a = _a.b.toArray(),
      n = _a.c.toArray();
    t.push({
      vertices: [s, a, n],
      faceCenters: [Fc(s, a), Fc(a, n), Fc(n, s)],
      midpoint: Vl.toArray(),
      norm: cg.toArray(),
    });
  }
  return t;
}
var EY = 4,
  CY = 0.5,
  M0 = (e) => 0.5 * (1 - Math.cos(e * Math.PI)),
  TY = class {
    constructor() {
      this.perlin = new Array(4095 + 1);
    }
    noise(e, t = 0, i = 0) {
      if (this.perlin == null) {
        this.perlin = new Array(4095 + 1);
        for (let g = 0; g < 4095 + 1; g++) this.perlin[g] = Math.random();
      }
      e < 0 && (e = -e), t < 0 && (t = -t), i < 0 && (i = -i);
      let r = Math.floor(e),
        s = Math.floor(t),
        a = Math.floor(i),
        n = e - r,
        o = t - s,
        l = i - a,
        h,
        u,
        c = 0,
        d = 0.5,
        p,
        f,
        m;
      for (let g = 0; g < EY; g++) {
        let y = r + (s << 4) + (a << 8);
        (h = M0(n)),
          (u = M0(o)),
          (p = this.perlin[y & 4095]),
          (p += h * (this.perlin[(y + 1) & 4095] - p)),
          (f = this.perlin[(y + 16) & 4095]),
          (f += h * (this.perlin[(y + 16 + 1) & 4095] - f)),
          (p += u * (f - p)),
          (y += 256),
          (f = this.perlin[y & 4095]),
          (f += h * (this.perlin[(y + 1) & 4095] - f)),
          (m = this.perlin[(y + 16) & 4095]),
          (m += h * (this.perlin[(y + 16 + 1) & 4095] - m)),
          (f += u * (m - f)),
          (p += M0(l) * (f - p)),
          (c += p * d),
          (d *= CY),
          (r <<= 1),
          (n *= 2),
          (s <<= 1),
          (o *= 2),
          (a <<= 1),
          (l *= 2),
          n >= 1 && (r++, n--),
          o >= 1 && (s++, o--),
          l >= 1 && (a++, l--);
      }
      return c;
    }
    noiseSeed(e) {
      let t = (() => {
        let i, r;
        return {
          setSeed(s) {
            r = i = (s ?? Math.random() * 4294967296) >>> 0;
          },
          getSeed() {
            return i;
          },
          rand() {
            return (
              (r = (1664525 * r + 1013904223) % 4294967296), r / 4294967296
            );
          },
        };
      })();
      t.setSeed(e), (this.perlin = new Array(4095 + 1));
      for (let i = 0; i < 4095 + 1; i++) this.perlin[i] = t.rand();
    }
  },
  PY = TY,
  $A = new I(),
  eM = new je(),
  tM = new su();
function iM(e) {
  let t = !1;
  return (
    e.scene.objects.traverse((i, r) => {
      r.type === "Mesh" && r.geometry.type === "TextGeometry" && (t = !0);
    }),
    t
  );
}
var yP = class extends ms {
    constructor(e, t, i) {
      super(e, t, i), (this.data = t);
    }
    get textGeometry() {
      return this.geometry;
    }
    get charWidths() {
      return this.textGeometry.charWidths;
    }
    get charCoords() {
      return this.textGeometry.charCoords;
    }
    get wrappedText() {
      return this.textGeometry.wrappedText;
    }
    get font() {
      return this.textGeometry.font;
    }
    get initialOffsetY() {
      let e = this.dataPatched;
      return (
        this.font?.getLineInitialOffsetY(
          this.lineHeight,
          this.wrappedText.length,
          e.geometry.height,
          this.fontScale,
          e.geometry.verticalAlign
        ) ?? 0
      );
    }
    get fontScale() {
      let e = this.dataPatched;
      return this.font ? e.geometry.fontSize / this.font.unitsPerEm : 1;
    }
    get AD() {
      return Math.abs(this.ascender - this.descender);
    }
    get ascender() {
      return (this.font?.ascender ?? 1) * this.fontScale;
    }
    get descender() {
      return (this.font?.descender ?? 1) * this.fontScale;
    }
    get lineHeight() {
      let e = this.dataPatched;
      return e.geometry.fontSize * e.geometry.lineHeight;
    }
    raycast(e, t) {
      let { matrixWorld: i } = this;
      if (
        !(
          isNaN(e.ray.origin.x) ||
          this.scale.x === 0 ||
          this.scale.y === 0 ||
          this.scale.z === 0
        ) &&
        (eM.copy(i).invert(),
        tM.copy(e.ray).applyMatrix4(eM),
        tM.intersectBox(this.singleBBox, $A))
      ) {
        let r = $A.applyMatrix4(i),
          s = e.ray.origin.distanceTo(r);
        t.push({ distance: s, point: r.clone(), object: this });
      }
    }
  },
  Ss = 1e-4,
  un,
  xP,
  bP,
  wP,
  rM = new I(),
  sM = new I();
P3.then((e) => {
  (un = e),
    (xP = [un.get_face_center, un.get_edge_midpoint, un.get_vertex_position]),
    (bP = [un.get_face_normal, un.get_edge_normal, un.get_vertex_normal]),
    (wP = [un.face_count, un.edge_count, un.vertex_count]);
});
var DY = new je(),
  OY = new je(),
  Uo = new I(),
  Uf = new I(),
  ed = new I(),
  E0 = new I(),
  IY = new I(),
  RY = new I(),
  Kn = new PY(),
  Wa = class extends nb(_i) {
    constructor(e, t) {
      super(),
        (this.parameters = t),
        (this.objectForSample = void 0),
        (this._pendingMediaLoad = !1),
        (this.object = e);
    }
    resetOnMove() {
      this.removeFromParent(), (this.parent = null);
    }
    expandClones(e) {
      if (this.parent === null) this.updateState(this.parameters, e);
      else for (let t of this.children) t instanceof fs && t.expand();
    }
    invalidateTransform(e) {
      (this.matrixWorldNeedsUpdate = !0),
        this.traverse((t) => {
          t instanceof fs && t.object === e && (t.matrixWorldNeedsUpdate = !0);
        });
    }
    onObjUpdateMatrix() {
      this.parameters.type !== "toObject" && (this.matrixWorldNeedsUpdate = !0);
    }
    update() {
      switch ((this._updateCount(), this.parameters.type)) {
        case "radial":
          this._updateRadial(this.parameters);
          break;
        case "linear":
          this._updateLinear(this.parameters);
          break;
        case "grid":
          this._updateGrid(this.parameters);
          break;
        case "toObject":
          this._updateToObject(this.parameters);
      }
      for (let e of this.children)
        e.updateMatrix(),
          e.hasNonUniformScale &&
            (e.updateMatrixWorld(), e.updateMatrixWorldSVD());
    }
    _updateCount(e) {
      let t;
      if (
        (e !== void 0
          ? (t = e)
          : (t =
              this.parameters.type === "grid"
                ? Math.round(this.parameters.grid.count[0]) *
                  Math.round(this.parameters.grid.count[1]) *
                  Math.round(this.parameters.grid.count[2])
                : this.parameters.count),
        this.parameters.type === "toObject" &&
          !this.parameters.toObject.object &&
          (t = 0),
        this.parameters.type === "toObject" && this.objectForSample)
      ) {
        for (let r = 0, s = this.children.length; r < s; ++r)
          this.remove(this.children[0]);
        let i = this.children;
        if (i.length === t) return;
        if (i.length < t)
          for (let r = 0, s = t - i.length; r < s; ++r) {
            let a = new fs(this.object);
            a.expand(), this.add(a);
          }
        else for (let r = 0, s = i.length - t; r < s; ++r) this.remove(i[r]);
      } else {
        if (this.children.length === t) return;
        if (this.children.length < t)
          for (let i = 0, r = t - this.children.length; i < r; ++i) {
            let s = new fs(this.object);
            s.expand(), this.add(s);
          }
        else
          for (let i = 0, r = this.children.length - t; i < r; ++i)
            this.remove(this.children[0]);
      }
    }
    _updateRadial(e) {
      let t = e.radial,
        i = t.start * dt.DEG2RAD,
        r = t.end * dt.DEG2RAD,
        s = i - r,
        a = new Ir(t.rotation[0], t.rotation[1], t.rotation[2]),
        n;
      switch (t.axis) {
        case "z":
          n = new I(0, 0, 1);
          break;
        case "y":
          n = new I(0, 1, 0);
          break;
        default:
        case "x":
          n = new I(1, 0, 0);
          break;
      }
      let o = e.randomnessObject ?? il.defaultData([1, 1, 1]).randomnessObject,
        l = o.noiseType === "perlin";
      Kn.noiseSeed(o.seed);
      let h = s0((0, Xu.default)(o.seed)),
        u = Ff(o.strength, this.parameters.randomness);
      for (let [c, d] of this.children.entries()) {
        let p = c * (o.freqScale / 10) + o.movement,
          f = l ? Kn.noise(p) : h(p, p),
          m = c + 1;
        (d.scale.x = t.scale[0] + u(m, Vt(f, o.scale[0])) || Ss),
          (d.scale.y = t.scale[1] + u(m, Vt(f, o.scale[1])) || Ss),
          (d.scale.z = t.scale[2] + u(m, Vt(f, o.scale[2])) || Ss),
          d.position.setScalar(0);
        let g = (s / e.count) * c - i;
        switch (t.axis) {
          case "x":
            d.rotation.set(0, g, 0);
            break;
          case "y":
            d.rotation.set(0, 0, g);
            break;
          case "z":
            d.rotation.set(g, 0, 0);
            break;
        }
        d.translateOnAxis(n, t.radius),
          (d.position.x += t.position[0] + u(m, Vt(f, o.position[0]))),
          (d.position.y += t.position[1] + u(m, Vt(f, o.position[1]))),
          (d.position.z += t.position[2] + u(m, Vt(f, o.position[2])));
        let y = u(m, Vt(f, o.rotation[0])),
          x = u(m, Vt(f, o.rotation[1])),
          b = u(m, Vt(f, o.rotation[2]));
        t.alignment === !0
          ? ((d.rotation.x += a.x + y),
            (d.rotation.y += a.y + x),
            (d.rotation.z += a.z + b))
          : d.rotation.set(a.x + y, a.y + x, a.z + b);
      }
    }
    _updateLinear(e) {
      if (e.type !== "linear") throw new Error();
      let t = e.linear,
        i = new Ir(t.rotation[0], t.rotation[1], t.rotation[2]),
        r = e.randomnessObject ?? il.defaultData([1, 1, 1]).randomnessObject,
        s = r.noiseType === "perlin";
      Kn.noiseSeed(r.seed);
      let a = s0((0, Xu.default)(r.seed)),
        n = Ff(r.strength, this.parameters.randomness);
      for (let [o, l] of this.children.entries()) {
        let h = o * (r.freqScale / 10) + r.movement,
          u = s ? Kn.noise(h) : a(h, h),
          c = o + 1,
          d = n(c, Vt(u, r.rotation[0])),
          p = n(c, Vt(u, r.rotation[1])),
          f = n(c, Vt(u, r.rotation[2]));
        (l.scale.x = 1 + (t.scale[0] - 1) * o + n(c, Vt(u, r.scale[0])) || Ss),
          (l.scale.y =
            1 + (t.scale[1] - 1) * o + n(c, Vt(u, r.scale[1])) || Ss),
          (l.scale.z =
            1 + (t.scale[2] - 1) * o + n(c, Vt(u, r.scale[2])) || Ss),
          (l.rotation.x = i.x * o + d),
          (l.rotation.y = i.y * o + p),
          (l.rotation.z = i.z * o + f),
          (l.position.x = t.position[0] * o + n(c, Vt(u, r.position[0]))),
          (l.position.y = t.position[1] * o + n(c, Vt(u, r.position[1]))),
          (l.position.z = t.position[2] * o + n(c, Vt(u, r.position[2])));
      }
    }
    _updateGrid(e) {
      let t = 0,
        i = e.grid,
        r = e.randomnessObject ?? il.defaultData([1, 1, 1]).randomnessObject,
        s = Ff(r.strength, this.parameters.randomness),
        a = r.noiseType === "perlin";
      Kn.noiseSeed(r.seed);
      let n = N9((0, Xu.default)(r.seed));
      if (i.useCenter === !0) {
        let o = {
            x: i.count[0] % 2 === 0 ? 2 : 1,
            y: i.count[1] % 2 === 0 ? 2 : 1,
            z: i.count[2] % 2 === 0 ? 2 : 1,
          },
          l = new I(
            i.size[0] * (i.count[0] - o.x) * 0.5,
            i.size[1] * (i.count[1] - o.y) * 0.5,
            i.size[2] * (i.count[2] - o.z) * 0.5
          );
        for (let h = 0; h < i.count[0]; h++)
          for (let u = 0; u < i.count[1]; u++)
            for (let c = 0; c < i.count[2]; c++) {
              let d = [
                  (h + 1) * (r.freqScale / 10) + r.movement,
                  (u + 1) * (r.freqScale / 10) + r.movement,
                  (c + 1) * (r.freqScale / 10) + r.movement,
                ],
                p = a ? Kn.noise(...d) : n(...d),
                f = this.children[t++];
              (f.scale.x = 1 + s(t, Vt(p, r.scale[0])) || Ss),
                (f.scale.y = 1 + s(t, Vt(p, r.scale[1])) || Ss),
                (f.scale.z = 1 + s(t, Vt(p, r.scale[2])) || Ss);
              let m = s(t, Vt(p, r.rotation[0])),
                g = s(t, Vt(p, r.rotation[1])),
                y = s(t, Vt(p, r.rotation[2]));
              f.rotation.set(m, g, y),
                (f.position.x =
                  i.size[0] * h - l.x + s(t, Vt(p, r.position[0]))),
                (f.position.y =
                  i.size[1] * u - l.y + s(t, Vt(p, r.position[1]))),
                (f.position.z =
                  i.size[2] * c - l.z + s(t, Vt(p, r.position[2])));
            }
      } else
        for (let o = 0; o < i.count[0]; o++)
          for (let l = 0; l < i.count[1]; l++)
            for (let h = 0; h < i.count[2]; h++) {
              let u = [
                  (o + 1) * (r.freqScale / 10) + r.movement,
                  (l + 1) * (r.freqScale / 10) + r.movement,
                  (h + 1) * (r.freqScale / 10) + r.movement,
                ],
                c = a ? Kn.noise(...u) : n(...u),
                d = this.children[t++];
              (d.scale.x = 1 + s(t, Vt(c, r.scale[0])) || Ss),
                (d.scale.y = 1 + s(t, Vt(c, r.scale[1])) || Ss),
                (d.scale.z = 1 + s(t, Vt(c, r.scale[2])) || Ss);
              let p = s(t, Vt(c, r.rotation[0])),
                f = s(t, Vt(c, r.rotation[1])),
                m = s(t, Vt(c, r.rotation[2]));
              d.rotation.set(p, f, m),
                (d.position.x = i.size[0] * o + s(t, Vt(c, r.position[0]))),
                (d.position.y = -i.size[1] * l + s(t, Vt(c, r.position[1]))),
                (d.position.z = -i.size[2] * h + s(t, Vt(c, r.position[2])));
            }
    }
    _updateToObject(e) {
      if (e.type !== "toObject") throw new Error();
      let { toObject: t } = e,
        i = new Ir(t.rotation[0], t.rotation[1], t.rotation[2]),
        r = e.randomnessObject ?? il.defaultData([1, 1, 1]).randomnessObject,
        s = r.noiseType === "perlin";
      Kn.noiseSeed(r.seed);
      let a = s0((0, Xu.default)(r.seed)),
        n = Ff(r.strength, this.parameters.randomness);
      if (!t.object) {
        for (let [, m] of this.children.entries())
          m.position.set(0, 0, 0),
            m.scale.setScalar(1),
            m.rotation.set(0, 0, 0);
        this.objectForSample = void 0;
        return;
      }
      if (!this.objectForSample) return;
      if (this.objectForSample instanceof yP)
        if (
          !this.objectForSample.font?.isLoaded ||
          this.objectForSample.geometry.attributes.position === void 0
        ) {
          this._pendingMediaLoad = !0;
          return;
        } else this._pendingMediaLoad = !1;
      if (
        this.objectForSample.geometry === void 0 &&
        this.objectForSample.isAncestorOf(this.object.uuid)
      ) {
        console.warn(
          `Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`
        );
        return;
      }
      let o = this.getSubdivData(),
        l = [],
        h = (m) => {
          let g = m.length,
            y = m.map((_) => _[0]).reduce((_, S) => _ + S, 0),
            x = m.map((_) => _[1]).reduce((_, S) => _ + S, 0),
            b = m.map((_) => _[2]).reduce((_, S) => _ + S, 0);
          return [y / g, x / g, b / g];
        },
        u = (m) => Math.round(m * 1e6) / 1e6;
      o.forEach((m) => {
        let g = o.filter(
          (y) =>
            u(m.pos[0]) === u(y.pos[0]) &&
            u(m.pos[1]) === u(y.pos[1]) &&
            u(m.pos[2]) === u(y.pos[2])
        );
        g.length > 1
          ? l.push({ pos: m.pos, norm: h(g.map((y) => y.norm)) })
          : l.push(m);
      });
      let c = bY(l);
      if (c.length > 0) {
        let m = Math.round((c.length * t.count) / 100);
        this._updateCount(m);
      } else {
        let m = this.objectForSample.geometry.getAttribute("position");
        if (!m || isNaN(m.count) || m.count === 0) {
          console.warn(
            `Oh no! The object "${this.object.name}" (${this.object.uuid}) cannot be cloned on the surface of "${this.objectForSample.name}" (${this.objectForSample.uuid}) because the latter does not have a valid geometry.`
          );
          return;
        }
      }
      this.objectForSample.updateMatrixWorld();
      let d = new U9(this.objectForSample).build(),
        p = yY[t.axis],
        f = this.children;
      d.setRandomGenerator((0, Xu.default)(this.object.uuid + t.seed));
      for (let [m, g] of f.entries()) {
        let y = m * (r.freqScale / 10) + r.movement,
          x = s ? Kn.noise(y) : a(y, y),
          b = m + 1,
          _ = n(b, Vt(x, r.rotation[0])),
          S = n(b, Vt(x, r.rotation[1])),
          M = n(b, Vt(x, r.rotation[2]));
        t.spreadType === "random"
          ? d.sample(ed, E0)
          : (c.length && (ed.fromArray(c[m].pos), E0.fromArray(c[m].norm)),
            this.objectForSample instanceof $d &&
              ed.applyMatrix4(
                DY.copy(this.objectForSample.matrixWorld).invert()
              )),
          ed.applyMatrix4(this.object.hiddenMatrix.clone().invert()),
          g.position.copy(ed),
          Uo.fromArray(p);
        let C = t.align === "normal" ? E0 : this.object.getWorldDirection(RY),
          A = Uf.fromArray(t.position);
        (Uf.x += n(b, Vt(x, r.position[0]))),
          (Uf.y += n(b, Vt(x, r.position[1]))),
          (Uf.z += n(b, Vt(x, r.position[2])));
        let T = Math.acos(C.dot(Uo)),
          P = IY.crossVectors(Uo, C).normalize(),
          R = OY.makeRotationAxis(P, T),
          z = C.clone().cross(this.object.up).normalize(),
          N = z.clone().cross(C).normalize(),
          L = new je().makeBasis(z, C, N),
          G = new I(Uo.y, Uo.z, Uo.x).normalize(),
          Y = G.clone().cross(Uo).normalize(),
          Z = new je().makeBasis(G, Uo, Y).invert(),
          q = new je().multiplyMatrices(L, Z);
        g.rotation.setFromRotationMatrix(q),
          A.applyMatrix4(R),
          g.position.add(A),
          (g.rotation.x = g.rotation.x + i.x + _),
          (g.rotation.y = g.rotation.y + i.y + S),
          (g.rotation.z = g.rotation.z + i.z + M),
          g.scale.setScalar(1),
          (g.scale.x = g.scale.x + t.scale[0] + n(b, Vt(x, r.scale[0])) || Ss),
          (g.scale.y = g.scale.y + t.scale[1] + n(b, Vt(x, r.scale[1])) || Ss),
          (g.scale.z = g.scale.z + t.scale[2] + n(b, Vt(x, r.scale[2])) || Ss),
          g.scale.multiply(this.object.scale),
          (g.hiddenMatrix = this.object.hiddenMatrix);
      }
    }
    getSubdivData() {
      if (!this.objectForSample) return [];
      let e = this.parameters.toObject.spreadType;
      if (e === "random") return [];
      if (this.objectForSample instanceof $d) {
        let t = this.objectForSample,
          i = xY[e],
          r = wP[i],
          s = xP[i],
          a = bP[i],
          n = [],
          o = r(t.subdivPointerNew);
        for (let l = 0; l <= o - 1; l++) {
          let h = s(t.subdivPointerNew, l),
            u = a(t.subdivPointerNew, l);
          rM.fromArray(h).applyMatrix4(t.matrixWorld),
            sM.fromArray(u),
            n.push({ pos: rM.toArray(), norm: sM.toArray() });
        }
        return n;
      } else
        return (
          this.objectForSample.geometry.index
            ? AY(this.objectForSample.geometry)
            : MY(this.objectForSample.geometry)
        )
          .map((t, i) =>
            e === "polygon_center"
              ? { pos: t.midpoint, norm: t.norm }
              : e === "vertex"
              ? [
                  { pos: t.vertices[0], norm: t.norm },
                  { pos: t.vertices[1], norm: t.norm },
                  { pos: t.vertices[2], norm: t.norm },
                ]
              : e === "edge"
              ? [
                  { pos: t.faceCenters[0], norm: t.norm },
                  { pos: t.faceCenters[1], norm: t.norm },
                  { pos: t.faceCenters[2], norm: t.norm },
                ]
              : []
          )
          .flat();
    }
    updateState(e, t) {
      if (((this.parameters = Dg(e)), this.parameters.type !== "toObject"))
        (this.parent === null || this.parent !== this.object) &&
          (this.removeFromParent(),
          this.object.parent?.add(this),
          (this.matrix = this.object.matrix),
          (this.hiddenMatrix = this.object.hiddenMatrix),
          (this.matrixWorldNeedsUpdate = !0),
          (this.matrixAutoUpdate = !1));
      else if (
        this.parent === null ||
        this.parent.uuid !== this.parameters.toObject.object
      ) {
        this.removeFromParent();
        let i = t.find(this.parameters.toObject.object);
        i instanceof Is
          ? (this.objectForSample = i)
          : (this.objectForSample = void 0),
          (this.matrix = new je()),
          (this.hiddenMatrix = new je()),
          (this.matrixWorldNeedsUpdate = !0),
          (this.matrixAutoUpdate = !1),
          i && i.add(this);
      }
      this.update();
    }
    get pendingMediaLoad() {
      return this._pendingMediaLoad;
    }
  },
  up = (e) => {
    var t;
    return (t = class extends e {}), (t.geometryHelper = new Za(30, 30, 30)), t;
  },
  Vf = new su(),
  C0 = new Ws(),
  aM = new je(),
  dp = (e, t, i, r, s = !1) => {
    let a = t,
      n = e.matrixWorld;
    if (
      (a.boundingSphere === null && a.computeBoundingSphere(),
      C0.copy(a.boundingSphere),
      C0.applyMatrix4(n),
      i.ray.intersectsSphere(C0) === !1 ||
        (aM.copy(n).invert(),
        Vf.copy(i.ray).applyMatrix4(aM),
        a.boundingBox !== null && Vf.intersectsBox(a.boundingBox) === !1))
    )
      return;
    let o,
      l,
      h,
      u,
      c = a.index,
      d = a.attributes.position,
      p = a.drawRange,
      f,
      m;
    if (s === !1) {
      let y = Math.max(0, p.start),
        x = Math.min(c.count, p.start + p.count);
      for (f = y, m = x; f < m; f += 3)
        if (
          ((l = c.getX(f)),
          (h = c.getX(f + 1)),
          (u = c.getX(f + 2)),
          (o = g(e, i, Vf, d, l, h, u)),
          o)
        ) {
          (o.faceIndex = Math.floor(f / 3)), r.push(o);
          return;
        }
    } else {
      let y = a.attributes.position,
        x = new I(),
        b = new I(),
        _ = new I(),
        S = new I(),
        M = 2,
        C = 1 / ((e.scale.x + e.scale.y + e.scale.z) / 3),
        A = C * C,
        T = Math.max(0, p.start),
        P = Math.min(y.count, p.start + p.count);
      for (let R = T, z = P - 1; R < z; R += M) {
        if (
          (x.fromBufferAttribute(y, R),
          b.fromBufferAttribute(y, R + 1),
          Vf.distanceSqToSegment(x, b, S, _) > A)
        )
          continue;
        S.applyMatrix4(e.matrixWorld);
        let N = i.ray.origin.distanceTo(S);
        N < i.near ||
          N > i.far ||
          r.push({
            distance: N,
            point: _.clone().applyMatrix4(e.matrixWorld),
            object: e,
          });
      }
    }
    function g(y, x, b, _, S, M, C) {
      let A = new I(),
        T = new I(),
        P = new I(),
        R = new I(),
        z = new I();
      if (
        (A.fromBufferAttribute(_, S),
        T.fromBufferAttribute(_, M),
        P.fromBufferAttribute(_, C),
        b.intersectTriangle(A, T, P, !1, R) === null)
      )
        return null;
      z.copy(R), z.applyMatrix4(y.matrixWorld);
      let N = x.ray.origin.distanceTo(z);
      return N < x.near || N > x.far
        ? null
        : { faceIndex: 1, distance: N, point: z.clone(), object: y };
    }
  },
  jf = new I(),
  da = new gh(),
  LY = class extends ap {
    constructor(e) {
      let t = new yt(),
        i = new gl({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
        r = [],
        s = [],
        a = {},
        n = new Et(15711266),
        o = new Et(15711266),
        l = new Et(2857471);
      h("n1", "n2", n),
        h("n2", "n4", n),
        h("n4", "n3", n),
        h("n3", "n1", n),
        h("f1", "f2", n),
        h("f2", "f4", n),
        h("f4", "f3", n),
        h("f3", "f1", n),
        h("n1", "f1", n),
        h("n2", "f2", n),
        h("n3", "f3", n),
        h("n4", "f4", n),
        h("p", "n1", o),
        h("p", "n2", o),
        h("p", "n3", o),
        h("p", "n4", o),
        h("u1", "u2", l),
        h("u2", "u3", l),
        h("u3", "u1", l);
      function h(c, d, p) {
        u(c, p), u(d, p);
      }
      function u(c, d) {
        r.push(0, 0, 0),
          s.push(d.r, d.g, d.b),
          a[c] === void 0 && (a[c] = []),
          a[c].push(r.length / 3 - 1);
      }
      t.setAttribute("position", new ot(r, 3)),
        t.setAttribute("color", new ot(s, 3)),
        super(t, i),
        (this.type = "CameraHelper"),
        (this.camera = e),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = e.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = a),
        this.update();
    }
    update() {
      let e = this.geometry,
        t = this.pointMap,
        i = !0;
      da.projectionMatrixInverse.elements = [
        0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0, -0, -0,
        -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001,
      ];
      let r = 1,
        s = 1,
        a = i ? 0.8 : 1e-4;
      Fa("n1", t, e, da, -r, -s, a),
        Fa("n2", t, e, da, r, -s, a),
        Fa("n3", t, e, da, -r, s, a),
        Fa("n4", t, e, da, r, s, a);
      let n = a;
      Fa("f1", t, e, da, -r, -s, n),
        Fa("f2", t, e, da, r, -s, n),
        Fa("f3", t, e, da, -r, s, n),
        Fa("f4", t, e, da, r, s, n);
      let o = n,
        l = 0.5;
      Fa("u1", t, e, da, r * 0.7 * l, s * 1.1, o),
        Fa("u2", t, e, da, -r * 0.7 * l, s * 1.1, o),
        Fa("u3", t, e, da, 0, s * (1.1 + 0.9 * l), o),
        (e.getAttribute("position").needsUpdate = !0);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
function Fa(e, t, i, r, s, a, n) {
  jf.set(s, a, n).unproject(r);
  let o = t[e];
  if (o !== void 0) {
    let l = i.getAttribute("position");
    for (let h = 0, u = o.length; h < u; h++) l.setXYZ(o[h], jf.x, jf.y, jf.z);
  }
}
var BY = class extends up(LY) {
    constructor(e) {
      super(e),
        (this.object = e),
        (this.object = e),
        (this.name = `CombinedCameraHelper: ${e.uuid}`);
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.updateTarget();
    }
    updateTarget() {
      let e = this.object.getTarget();
      this.updateWorldMatrix(!0, !1), this.worldToLocal(e);
    }
    raycast(e, t) {
      dp(this.object, this.geometry, e, t, !0);
    }
  },
  z1;
((e) => (e.is = (t) => "objectHelper" in t))(z1 || (z1 = {}));
var xu = (e, t) =>
    class extends ob(e) {
      constructor() {
        super(...arguments),
          (this.objectHelper = new t(this)),
          (this.gizmos = {});
      }
      get geometryHelper() {
        return t.geometryHelper;
      }
      raycast(i, r) {
        this.objectHelper.raycast(i, r);
      }
      showGizmos() {
        for (let i in this.gizmos) {
          let r = this.gizmos[i];
          r instanceof Pm && (r.visible = !0);
        }
      }
      updateEntityBoxSize(i, r) {
        this.objectHelper.visible && this.geometryHelper instanceof Za
          ? (i.setScalar(0),
            r
              .set(
                this.geometryHelper.parameters.width,
                this.geometryHelper.parameters.height,
                this.geometryHelper.parameters.height
              )
              .multiplyScalar(0.5))
          : super.updateEntityBoxSize(i, r);
      }
      hideGizmos() {
        for (let i in this.gizmos) {
          let r = this.gizmos[i];
          r instanceof Pm && (r.visible = !1);
        }
      }
    },
  Hf = 790,
  ic = new I(),
  T0 = new I(),
  P0 = new Rt(),
  D0 = new I(),
  td = new I(),
  O0 = new I(),
  vs = class extends xu(gh, BY) {
    constructor(e = "", t = { ...Gd.defaultData, name: "" }) {
      super(),
        (this._cameraType = "OrthographicCamera"),
        (this.targetOffset = Qc.DefaultTargetOffset),
        (this.isUpVectorFlipped = !1),
        (this.angleOffsetFromUp = 0),
        (this.wasMovedByUser = !1),
        (this.wasMovedBySwitchCameraAction = !1),
        this.super_Entity(e, t),
        (this.previousProjectionMatrix = new je()),
        (this.matrixAutoUpdate = !0),
        (this.width = window.innerWidth),
        (this.height = window.innerHeight);
      let i = this.width,
        r = this.height;
      (this.orthoCamera = new bx(
        i * -0.5,
        i * 0.5,
        r * 0.5,
        r * -0.5,
        -5e4,
        1e4
      )),
        (this.perspCamera = new ds(45, i / r, 50, 1e4)),
        (this.left = this.orthoCamera.left),
        (this.right = this.orthoCamera.right),
        (this.top = this.orthoCamera.top),
        (this.bottom = this.orthoCamera.bottom),
        (this.far = this.orthoCamera.far),
        (this.view = this.orthoCamera.view),
        (this.aspect = this.perspCamera.aspect),
        (this.focus = this.perspCamera.focus),
        (this.filmGauge = this.perspCamera.filmGauge),
        (this.filmOffset = this.perspCamera.filmOffset),
        this.objectHelper.update();
    }
    get isPerspectiveCamera() {
      return this.cameraType === "PerspectiveCamera";
    }
    get isOrthographicCamera() {
      return !this.isPerspectiveCamera;
    }
    get cameraType() {
      return this._cameraType;
    }
    set fov(e) {
      this.perspCamera.fov = e;
    }
    get fov() {
      return this.perspCamera.fov;
    }
    setNear(e, t) {
      e === "PerspectiveCamera"
        ? (this.perspCamera.near = t)
        : (this.orthoCamera.near = t);
    }
    setZoom(e, t) {
      t >= 0 &&
        (e === "PerspectiveCamera"
          ? (this.perspCamera.zoom = t)
          : (this.orthoCamera.zoom = t));
    }
    set cameraType(e) {
      e === "PerspectiveCamera"
        ? this.toPerspective()
        : e === "OrthographicCamera" && this.toOrthographic();
    }
    get near() {
      return this._cameraType === "PerspectiveCamera"
        ? this.perspCamera.near
        : this.orthoCamera.near;
    }
    set near(e) {
      this._cameraType === "PerspectiveCamera"
        ? (this.perspCamera.near = e)
        : (this.orthoCamera.near = e);
    }
    get zoom() {
      return this._cameraType === "PerspectiveCamera"
        ? this.perspCamera.zoom
        : this.orthoCamera.zoom;
    }
    set zoom(e) {
      e >= 0 &&
        (this._cameraType === "PerspectiveCamera"
          ? (this.perspCamera.zoom = e)
          : (this.orthoCamera.zoom = e));
    }
    lookAt(e, t, i) {
      typeof e == "number" && (e = new I(e, t, i)),
        super.lookAt(e),
        this.getWorldPosition(ic),
        (this.targetOffset = ic.distanceTo(e));
    }
    getTarget(e = new I()) {
      return (
        this.getWorldDirection(T0),
        this.getWorldPosition(ic),
        T0.multiplyScalar(this.targetOffset),
        e.copy(ic).add(T0),
        e
      );
    }
    getDistanceToTarget() {
      let e = this.getTarget();
      return this.getWorldPosition(ic), ic.distanceTo(e);
    }
    updateUp() {
      this.getWorldQuaternion(P0),
        D0.set(0, 0, 1).applyQuaternion(P0),
        td.copy(_i.DEFAULT_UP),
        this.isUpVectorFlipped && td.negate(),
        td.applyQuaternion(P0),
        O0.copy(_i.DEFAULT_UP).projectOnPlane(D0),
        (this.angleOffsetFromUp = O0.angleTo(td)),
        (this.angleOffsetFromUp *= O0.cross(td).dot(D0) >= 0 ? 1 : -1);
    }
    updateTransformState(e, t) {
      let i = super.updateTransformState(e, t);
      return (
        e.isUpVectorFlipped !== void 0 &&
          (this.isUpVectorFlipped = e.isUpVectorFlipped),
        this.updateUp(),
        i
      );
    }
    getViewFrontToObject(e) {
      let t = e.getWorldPosition(new I()),
        i = e.getWorldDirection(new I()).multiplyScalar(this.targetOffset);
      return { position: t.clone().add(i), target: t };
    }
    getViewToTarget(e) {
      let t = this.getWorldDirection(new I()).multiplyScalar(this.targetOffset);
      return { position: e.clone().sub(t), target: e };
    }
    getViewToObject(e) {
      let t = new I(),
        i = e.getWorldPosition(t);
      return this.getViewToTarget(t);
    }
    setViewplaneSize(e, t, i = !1) {
      if (((this.aspect = e / t), i)) {
        let r = e > t ? this.aspect : 1,
          s = e > t ? 1 : this.aspect;
        (this.left = -Hf * 0.5 * r),
          (this.right = Hf * 0.5 * r),
          (this.top = Hf * 0.5 * (1 / s)),
          (this.bottom = -Hf * 0.5 * (1 / s));
      } else
        (this.left = -e * 0.5),
          (this.right = e * 0.5),
          (this.top = t * 0.5),
          (this.bottom = -t * 0.5);
      this.updateProjectionMatrix();
    }
    copyViewPlaneSize(e) {
      (this.aspect = e.aspect),
        (this.left = e.left),
        (this.right = e.right),
        (this.top = e.top),
        (this.bottom = e.bottom),
        this.updateProjectionMatrix();
    }
    toOrthographic() {
      (this.orthoCamera.left = this.left),
        (this.orthoCamera.right = this.right),
        (this.orthoCamera.top = this.top),
        (this.orthoCamera.bottom = this.bottom),
        (this.orthoCamera.view = this.view),
        (this.orthoCamera.far = this.far),
        this.orthoCamera.updateProjectionMatrix(),
        (this.projectionMatrix = this.orthoCamera.projectionMatrix),
        (this.projectionMatrixInverse =
          this.orthoCamera.projectionMatrixInverse),
        (this._cameraType = "OrthographicCamera"),
        this.objectHelper && this.objectHelper.update();
    }
    toPerspective() {
      (this.perspCamera.aspect = this.aspect),
        (this.perspCamera.fov = this.fov),
        (this.perspCamera.view = this.view),
        (this.perspCamera.far = this.far),
        this.perspCamera.updateProjectionMatrix(),
        (this.projectionMatrix = this.perspCamera.projectionMatrix),
        (this.projectionMatrixInverse =
          this.perspCamera.projectionMatrixInverse),
        (this._cameraType = "PerspectiveCamera"),
        this.objectHelper && this.objectHelper.update();
    }
    setFocalLength(e) {
      this.perspCamera.setFocalLength(e), this.toPerspective();
    }
    getFocalLength() {
      return this.perspCamera.getFocalLength();
    }
    getEffectiveFOV() {
      return this.perspCamera.getEffectiveFOV();
    }
    getFilmWidth() {
      return this.perspCamera.getFilmWidth();
    }
    getFilmHeight() {
      return this.perspCamera.getFilmHeight();
    }
    setViewOffset(e, t, i, r, s, a) {
      this._cameraType === "PerspectiveCamera"
        ? this.perspCamera.setViewOffset(e, t, i, r, s, a)
        : this.orthoCamera.setViewOffset(e, t, i, r, s, a);
    }
    clearViewOffset() {
      this._cameraType === "PerspectiveCamera"
        ? (this.perspCamera.clearViewOffset(), this.toPerspective())
        : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
    }
    copyHistory() {
      this.previousProjectionMatrix &&
        this.previousProjectionMatrix.copy(this.projectionMatrix);
    }
    updateProjectionMatrix() {
      this._cameraType === "PerspectiveCamera"
        ? this.toPerspective()
        : this._cameraType === "OrthographicCamera" && this.toOrthographic();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.parent = e.parent),
        this.orthoCamera.copy(e.orthoCamera),
        this.perspCamera.copy(e.perspCamera),
        (this.left = e.left),
        (this.right = e.right),
        (this.top = e.top),
        (this.bottom = e.bottom),
        (this.far = e.far),
        (this.view = e.view === null ? null : Object.assign({}, e.view)),
        (this._cameraType = e._cameraType),
        (this.aspect = e.aspect),
        (this.fov = e.fov),
        (this.focus = e.focus),
        (this.filmGauge = e.filmGauge),
        (this.filmOffset = e.filmOffset),
        (this.targetOffset = e.targetOffset),
        this.updateProjectionMatrix(),
        this
      );
    }
    toCameraState(e = []) {
      let t = {
        type: this.cameraType,
        far: this.far,
        orthographic: {
          near: this.orthoCamera.near,
          zoom: this.orthoCamera.zoom,
        },
        perspective: {
          near: this.perspCamera.near,
          fov: this.perspCamera.fov,
          zoom: this.perspCamera.zoom,
        },
        up: this.up.toArray(),
        targetOffset: this.targetOffset,
        isUpVectorFlipped: this.isUpVectorFlipped,
      };
      return Oy(t, e);
    }
    updateCameraSubtype(e, t) {
      let i = e === "perspective" ? "PerspectiveCamera" : "OrthographicCamera";
      t.zoom !== void 0 && this.setZoom(i, t.zoom),
        t.near !== void 0 && this.setNear(i, t.near),
        t.fov !== void 0 && i === "PerspectiveCamera" && (this.fov = t.fov);
    }
    updateState(e, t) {
      this.updateCameraState(e, t);
    }
    updateCameraState(e, t) {
      this.updateState_Entity(e, t),
        e.far !== void 0 && (this.far = e.far),
        e.orthographic !== void 0 &&
          this.updateCameraSubtype("orthographic", e.orthographic),
        e.perspective !== void 0 &&
          this.updateCameraSubtype("perspective", e.perspective),
        e.type !== void 0 && (this.cameraType = e.type),
        e.up !== void 0 && this.up.fromArray(e.up),
        e.targetOffset !== void 0 && (this.targetOffset = e.targetOffset),
        e.isUpVectorFlipped !== void 0 &&
          (this.isUpVectorFlipped = e.isUpVectorFlipped),
        this.updateProjectionMatrix();
    }
    updateByPatchedOp(e, t, i) {
      super.updateByPatchedOp(e, t, i),
        e.path.length === 1 &&
          e.type === 0 &&
          this.updateCameraSubtype(e.path[0], e.props);
    }
    toState(e) {
      return {
        ...super.toState(e),
        ...this.toCameraState(e),
        type: this.cameraType,
      };
    }
  },
  rc = new je(),
  zY = new je(),
  Gf = new je(),
  nM = new I(),
  oM = new I();
function lM(e) {
  let t = !1;
  return (
    e.scene.objects.traverse((i, r) => {
      r.geometry?.type === "BooleanGeometry" && (t = !0);
    }),
    t
  );
}
var fh = class extends yu {
    constructor(e, t, i) {
      super(e, t),
        (this.data = t),
        (this.meshSetAddresses = []),
        (this.needsTransformForDownstream = !1),
        (this.geometry = new yt()),
        (this.onAfterRender = (r, s, a, n, o, l) => {
          super.onAfterRender(r, s, a, n, o, l), this.recomputeBoolean();
        }),
        (this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 });
    }
    get booleanOp() {
      return this.data.geometry.operation;
    }
    get phongAngle() {
      return this.data.geometry.phongAngle ?? 45;
    }
    get isLOD() {
      return this.recomputeBoolean(), !1;
    }
    updateByPatchedOp(e, t, i) {
      super.updateByPatchedOp(e, t, i),
        e.path.length === 1 &&
          e.path[0] === "geometry" &&
          e.type === 0 &&
          e.props.operation !== void 0 &&
          (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate());
    }
    freeBooleanPointer() {
      super.freeBooleanPointer(), this.geometry.dispose();
    }
    recomputeBoolean(e, t = !0) {
      if (this.booleanMeshSetAddress !== -1 && !e) return;
      for (let r = 0; r < this.children.length; r++) {
        let s = this.children[r];
        s instanceof fh &&
          s.dataPatched.visible === !0 &&
          s.recomputeBoolean(e === !0, t);
      }
      this.meshSetAddresses = [];
      for (let r = 0; r < this.children.length; r++) {
        let s = this.children[r];
        if (
          s instanceof Is &&
          s.dataPatched.visible === !0 &&
          s.geometry.attributes.position?.count > 0 &&
          s.geometry.drawRange.count > 0 &&
          s.booleanMeshSetAddress !== 0
        ) {
          rc.multiplyMatrices(s.hiddenMatrix, s.matrix);
          try {
            if (s.booleanMeshSetAddress === -1) {
              if (
                ((s.geometry.index ?? s.geometry.getAttribute("position"))
                  .count /
                  3 <
                  15e5 &&
                  (s.booleanMeshSetAddress = no.getMeshSet(
                    s.geometry,
                    e === !0,
                    t
                  )),
                s.booleanMeshSetAddress === -1)
              )
                return;
              no.transformMeshSet(s.booleanMeshSetAddress, rc),
                s.booleanMatrixInvOld.copy(rc).invert(),
                (s.booleanWasTransformed = !1);
            } else
              s instanceof fh && s.needsTransformForDownstream === !0
                ? (no.transformMeshSet(s.booleanMeshSetAddress, rc),
                  (s.needsTransformForDownstream = !1))
                : s.booleanWasTransformed === !0 &&
                  (no.transformMeshSet(
                    s.booleanMeshSetAddress,
                    zY.multiplyMatrices(rc, s.booleanMatrixInvOld)
                  ),
                  s.booleanMatrixInvOld.copy(rc).invert(),
                  (s.booleanWasTransformed = !1));
          } catch (a) {
            console.error(a),
              (s.booleanMeshSetAddress = 0),
              (s.geometry.userData.booleanOperationDidFail = !0);
            continue;
          }
          no.hasOpenEdges(s.booleanMeshSetAddress) === !1 ||
          (r === this.children.length - 1 && this.booleanOp === 2)
            ? (this.meshSetAddresses.push(s.booleanMeshSetAddress),
              (s.geometry.userData.booleanOperationDidFail = !1))
            : (s.geometry.userData.booleanOperationDidFail = "openEdges");
        }
      }
      if (this.meshSetAddresses.length === 0) {
        this.geometry.setAttribute("position", new ot([], 0)),
          this.geometry.setDrawRange(0, 0);
        return;
      }
      if (e === !0)
        return no.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
      let i = this.geometry;
      i.dispose(),
        (this.geometry = new yt()),
        (this.geometry.userData = i.userData),
        (this.geometry.boundingSphere = i.boundingSphere);
      try {
        this.booleanMeshSetAddress = no.calcBoolean(
          this.meshSetAddresses,
          this.booleanOp,
          this.geometry,
          this.phongAngle
        );
      } catch (r) {
        (this.booleanMeshSetAddress = 0),
          (this.geometry.userData.booleanOperationDidFail = !0),
          console.error(r);
      }
      this.booleanMatrixInvOld.copy(this.matrix).invert(),
        (this.needsTransformForDownstream = !0),
        Sb(this),
        Ab(this);
    }
    dispose() {
      super.dispose(), this.geometry.dispose();
    }
    get recursiveBBox() {
      let e = super.recursiveBBox;
      return (
        this.geometry.boundingSphere?.radius === -1 &&
          (e.getCenter(this.geometry.boundingSphere.center),
          Gf.copy(this.matrixWorld).invert(),
          this.geometry.boundingSphere.center.applyMatrix4(Gf),
          nM.copy(e.max).applyMatrix4(Gf),
          oM.copy(e.min).applyMatrix4(Gf),
          (this.geometry.boundingSphere.radius = nM.distanceTo(oM) / 2)),
        e
      );
    }
  },
  F1;
((e) => {
  function t(i) {
    return si.is(i) && i instanceof lp;
  }
  e.is = t;
})(F1 || (F1 = {}));
var Mb = (e, t) =>
    class extends xu(e, t) {
      updateState_Light(i, r) {
        this.updateState_Entity(i, r),
          i.color !== void 0 && (this.color = r.shared.color(i.color)),
          i.intensity !== void 0 && (this.intensity = i.intensity),
          i.depth !== void 0 &&
            ((this.shadow.camera.far = i.depth),
            (this.shadow.needsUpdate = !0)),
          i.shadows !== void 0 && (this.castShadow = i.shadows);
      }
    },
  ja = (e) => e instanceof Is,
  yo = (e) => e !== null && e instanceof fh,
  FY = (e) => e instanceof vs,
  kY = (e) => F1.is(e),
  k1 = (e) => z1.is(e),
  pp = class extends up(dk) {
    constructor(e, t = 15) {
      super(t),
        (this.object = e),
        this.object.updateMatrixWorld(),
        (this.name = `EmptyObjectHelper: ${e.uuid}`),
        (this.matrix = e.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.object.isBone && (this.visible = !1);
    }
    raycast(e, t) {
      dp(this.object, pp.geometryHelper, e, t);
    }
    update() {}
  },
  kc = class extends xu(Hl, pp) {
    constructor(e, t) {
      super(), this.super_Entity(e, t), this.objectHelper.update();
    }
    updateState(e, t) {
      this.updateState_Entity(e, t),
        "buffer" in e && Object.keys(e).length === 1 && t.scene.reloadSplats();
    }
  },
  N1 = class extends xu(Hl, pp) {
    constructor(e, t, i) {
      super(),
        this.super_Entity(e, t),
        (this.context = i),
        this.objectHelper.update();
    }
    updateState(e, t) {
      this.updateState_Entity(e, t);
    }
  },
  _P = { RED: 0, GREEN: 1, BLUE: 2, ALPHA: 3 },
  fp =
    "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
  NY = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,
  Wf = class extends vi {
    constructor(e = !1, t = !1) {
      super({
        name: "BokehMaterial",
        defines: { PASS: e ? "2" : "1" },
        uniforms: {
          kernel64: new Ve(null),
          kernel16: new Ve(null),
          inputBuffer: new Ve(null),
          cocBuffer: new Ve(null),
          texelSize: new Ve(new re()),
          scale: new Ve(1),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: NY,
        vertexShader: fp,
      }),
        (this.toneMapped = !1),
        t && (this.defines.FOREGROUND = "1"),
        this.generateKernel();
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    set cocBuffer(e) {
      this.uniforms.cocBuffer.value = e;
    }
    setCoCBuffer(e) {
      this.uniforms.cocBuffer.value = e;
    }
    get scale() {
      return this.uniforms.scale.value;
    }
    set scale(e) {
      this.uniforms.scale.value = e;
    }
    getScale(e) {
      return (this.uniforms.scale.value = e);
    }
    setScale(e) {
      this.uniforms.scale.value = e;
    }
    generateKernel() {
      let e = 2.39996323,
        t = new Float32Array(128),
        i = new Float32Array(32),
        r = 0,
        s = 0;
      for (let o = 0; o < 80; ++o) {
        let l = o * e,
          h = Math.sqrt(o) / Math.sqrt(80),
          u = h * Math.cos(l),
          c = h * Math.sin(l);
        o % 5 === 0
          ? ((i[s++] = u), (i[s++] = c))
          : ((t[r++] = u), (t[r++] = c));
      }
      let a = [],
        n = [];
      for (let o = 0; o < 128; ) a.push(new Lt(t[o++], t[o++], t[o++], t[o++]));
      for (let o = 0; o < 32; ) n.push(new Lt(i[o++], i[o++], i[o++], i[o++]));
      (this.uniforms.kernel64.value = a), (this.uniforms.kernel16.value = n);
    }
    setTexelSize(e, t) {
      this.uniforms.texelSize.value.set(e, t);
    }
    setSize(e, t) {
      this.uniforms.texelSize.value.set(1 / e, 1 / t);
    }
  };
function hM(e, t, i) {
  return e * (t - i) - t;
}
function U1(e, t, i) {
  return Math.min(Math.max((e + t) / (t - i), 0), 1);
}
var UY = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,
  VY = class extends vi {
    constructor(e) {
      super({
        name: "CircleOfConfusionMaterial",
        defines: { DEPTH_PACKING: "0" },
        uniforms: {
          depthBuffer: new Ve(null),
          focusDistance: new Ve(0),
          focusRange: new Ve(0),
          cameraNear: new Ve(0.3),
          cameraFar: new Ve(1e3),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: UY,
        vertexShader: fp,
      }),
        (this.toneMapped = !1),
        (this.uniforms.focalLength = this.uniforms.focusRange),
        this.adoptCameraSettings(e);
    }
    get near() {
      return this.uniforms.cameraNear.value;
    }
    get far() {
      return this.uniforms.cameraFar.value;
    }
    set depthBuffer(e) {
      this.uniforms.depthBuffer.value = e;
    }
    set depthPacking(e) {
      (this.defines.DEPTH_PACKING = e.toFixed(0)), (this.needsUpdate = !0);
    }
    setDepthBuffer(e, t = Eo) {
      (this.depthBuffer = e), (this.depthPacking = t);
    }
    get focusDistance() {
      return this.uniforms.focusDistance.value;
    }
    set focusDistance(e) {
      this.uniforms.focusDistance.value = e;
    }
    get worldFocusDistance() {
      return -hM(this.focusDistance, this.near, this.far);
    }
    set worldFocusDistance(e) {
      this.focusDistance = U1(-e, this.near, this.far);
    }
    getFocusDistance(e) {
      this.uniforms.focusDistance.value = e;
    }
    setFocusDistance(e) {
      this.uniforms.focusDistance.value = e;
    }
    get focalLength() {
      return this.focusRange;
    }
    set focalLength(e) {
      this.focusRange = e;
    }
    get focusRange() {
      return this.uniforms.focusRange.value;
    }
    set focusRange(e) {
      this.uniforms.focusRange.value = e;
    }
    get worldFocusRange() {
      return -hM(this.focusRange, this.near, this.far);
    }
    set worldFocusRange(e) {
      this.focusRange = U1(-e, this.near, this.far);
    }
    getFocalLength(e) {
      return this.focusRange;
    }
    setFocalLength(e) {
      this.focusRange = e;
    }
    adoptCameraSettings(e) {
      e &&
        ((this.uniforms.cameraNear.value = e.near),
        (this.uniforms.cameraFar.value = e.far),
        e instanceof ds
          ? (this.defines.PERSPECTIVE_CAMERA = "1")
          : delete this.defines.PERSPECTIVE_CAMERA,
        (this.needsUpdate = !0));
    }
  },
  jY = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`,
  HY =
    "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
  cM = class extends vi {
    constructor(e = new re()) {
      super({
        name: "KawaseBlurMaterial",
        uniforms: {
          inputBuffer: new Ve(null),
          texelSize: new Ve(new re()),
          halfTexelSize: new Ve(new re()),
          kernel: new Ve(0),
          scale: new Ve(1),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: jY,
        vertexShader: HY,
      }),
        (this.toneMapped = !1),
        this.setTexelSize(e.x, e.y);
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.inputBuffer = e;
    }
    get scale() {
      return this.uniforms.scale.value;
    }
    set scale(e) {
      this.uniforms.scale.value = e;
    }
    getScale() {
      return this.uniforms.scale.value;
    }
    setScale(e) {
      this.uniforms.scale.value = e;
    }
    getKernel() {
      return null;
    }
    get kernel() {
      return this.uniforms.kernel.value;
    }
    set kernel(e) {
      this.uniforms.kernel.value = e;
    }
    setKernel(e) {
      this.kernel = e;
    }
    setTexelSize(e, t) {
      this.uniforms.texelSize.value.set(e, t),
        this.uniforms.halfTexelSize.value.set(e, t).multiplyScalar(0.5);
    }
    setSize(e, t) {
      let i = this.uniforms;
      i.texelSize.value.set(1 / e, 1 / t),
        i.halfTexelSize.value.copy(i.texelSize.value).multiplyScalar(0.5);
    }
  },
  GY = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`,
  WY = class extends vi {
    constructor() {
      super({
        name: "CopyMaterial",
        uniforms: { inputBuffer: new Ve(null), opacity: new Ve(1) },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: GY,
        vertexShader: fp,
      }),
        (this.toneMapped = !1);
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    getOpacity(e) {
      return this.uniforms.opacity.value;
    }
    setOpacity(e) {
      this.uniforms.opacity.value = e;
    }
  },
  qY = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,
  YY = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`,
  Ng = { DEPTH: 0, LUMA: 1, COLOR: 2 },
  XY = { DISABLED: 0, DEPTH: 1, CUSTOM: 2 },
  QY = class extends vi {
    constructor(e = new re(), t = Ng.COLOR) {
      super({
        name: "EdgeDetectionMaterial",
        defines: {
          THREE_REVISION: ru.replace(/\D+/g, ""),
          LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
          EDGE_THRESHOLD: "0.1",
          DEPTH_THRESHOLD: "0.01",
          PREDICATION_MODE: "0",
          PREDICATION_THRESHOLD: "0.01",
          PREDICATION_SCALE: "2.0",
          PREDICATION_STRENGTH: "1.0",
          DEPTH_PACKING: "0",
        },
        uniforms: {
          inputBuffer: new Ve(null),
          depthBuffer: new Ve(null),
          predicationBuffer: new Ve(null),
          texelSize: new Ve(e),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: qY,
        vertexShader: YY,
      }),
        (this.toneMapped = !1),
        (this.edgeDetectionMode = t);
    }
    set depthBuffer(e) {
      this.uniforms.depthBuffer.value = e;
    }
    set depthPacking(e) {
      (this.defines.DEPTH_PACKING = e.toFixed(0)), (this.needsUpdate = !0);
    }
    setDepthBuffer(e, t = Eo) {
      (this.depthBuffer = e), (this.depthPacking = t);
    }
    get edgeDetectionMode() {
      return Number(this.defines.EDGE_DETECTION_MODE);
    }
    set edgeDetectionMode(e) {
      (this.defines.EDGE_DETECTION_MODE = e.toFixed(0)),
        (this.needsUpdate = !0);
    }
    getEdgeDetectionMode() {
      return this.edgeDetectionMode;
    }
    setEdgeDetectionMode(e) {
      this.edgeDetectionMode = e;
    }
    get localContrastAdaptationFactor() {
      return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
    }
    set localContrastAdaptationFactor(e) {
      (this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6")),
        (this.needsUpdate = !0);
    }
    getLocalContrastAdaptationFactor() {
      return this.localContrastAdaptationFactor;
    }
    setLocalContrastAdaptationFactor(e) {
      this.localContrastAdaptationFactor = e;
    }
    get edgeDetectionThreshold() {
      return Number(this.defines.EDGE_THRESHOLD);
    }
    set edgeDetectionThreshold(e) {
      (this.defines.EDGE_THRESHOLD = e.toFixed("6")),
        (this.defines.DEPTH_THRESHOLD = (e * 0.1).toFixed("6")),
        (this.needsUpdate = !0);
    }
    getEdgeDetectionThreshold() {
      return this.edgeDetectionThreshold;
    }
    setEdgeDetectionThreshold(e) {
      this.edgeDetectionThreshold = e;
    }
    get predicationMode() {
      return Number(this.defines.PREDICATION_MODE);
    }
    set predicationMode(e) {
      (this.defines.PREDICATION_MODE = e.toFixed(0)), (this.needsUpdate = !0);
    }
    getPredicationMode() {
      return this.predicationMode;
    }
    setPredicationMode(e) {
      this.predicationMode = e;
    }
    set predicationBuffer(e) {
      this.uniforms.predicationBuffer.value = e;
    }
    setPredicationBuffer(e) {
      this.uniforms.predicationBuffer.value = e;
    }
    get predicationThreshold() {
      return Number(this.defines.PREDICATION_THRESHOLD);
    }
    set predicationThreshold(e) {
      (this.defines.PREDICATION_THRESHOLD = e.toFixed("6")),
        (this.needsUpdate = !0);
    }
    getPredicationThreshold() {
      return this.predicationThreshold;
    }
    setPredicationThreshold(e) {
      this.predicationThreshold = e;
    }
    get predicationScale() {
      return Number(this.defines.PREDICATION_SCALE);
    }
    set predicationScale(e) {
      (this.defines.PREDICATION_SCALE = e.toFixed("6")),
        (this.needsUpdate = !0);
    }
    getPredicationScale() {
      return this.predicationScale;
    }
    setPredicationScale(e) {
      this.predicationScale = e;
    }
    get predicationStrength() {
      return Number(this.defines.PREDICATION_STRENGTH);
    }
    set predicationStrength(e) {
      (this.defines.PREDICATION_STRENGTH = e.toFixed("6")),
        (this.needsUpdate = !0);
    }
    getPredicationStrength() {
      return this.predicationStrength;
    }
    setPredicationStrength(e) {
      this.predicationStrength = e;
    }
    setSize(e, t) {
      this.uniforms.texelSize.value.set(1 / e, 1 / t);
    }
  },
  ZY = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,
  KY =
    "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}",
  ka = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT",
  },
  V1 = class extends vi {
    constructor(e, t, i, r, s = !1) {
      super({
        name: "EffectMaterial",
        defines: {
          THREE_REVISION: ru.replace(/\D+/g, ""),
          DEPTH_PACKING: "0",
          ENCODE_OUTPUT: "1",
        },
        uniforms: {
          inputBuffer: new Ve(null),
          depthBuffer: new Ve(null),
          resolution: new Ve(new re()),
          texelSize: new Ve(new re()),
          cameraNear: new Ve(0.3),
          cameraFar: new Ve(1e3),
          aspect: new Ve(1),
          time: new Ve(0),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        dithering: s,
      }),
        (this.toneMapped = !1),
        e && this.setShaderParts(e),
        t && this.setDefines(t),
        i && this.setUniforms(i),
        this.adoptCameraSettings(r);
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    get depthBuffer() {
      return this.uniforms.depthBuffer.value;
    }
    set depthBuffer(e) {
      this.uniforms.depthBuffer.value = e;
    }
    get depthPacking() {
      return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(e) {
      (this.defines.DEPTH_PACKING = e.toFixed(0)), (this.needsUpdate = !0);
    }
    setDepthBuffer(e, t = Eo) {
      (this.depthBuffer = e), (this.depthPacking = t);
    }
    setShaderParts(e) {
      return (
        (this.fragmentShader = ZY.replace(
          ka.FRAGMENT_HEAD,
          e.get(ka.FRAGMENT_HEAD)
        )
          .replace(ka.FRAGMENT_MAIN_UV, e.get(ka.FRAGMENT_MAIN_UV))
          .replace(ka.FRAGMENT_MAIN_IMAGE, e.get(ka.FRAGMENT_MAIN_IMAGE))),
        (this.vertexShader = KY.replace(
          ka.VERTEX_HEAD,
          e.get(ka.VERTEX_HEAD)
        ).replace(ka.VERTEX_MAIN_SUPPORT, e.get(ka.VERTEX_MAIN_SUPPORT))),
        (this.needsUpdate = !0),
        this
      );
    }
    setDefines(e) {
      for (let t of e.entries()) this.defines[t[0]] = t[1];
      return (this.needsUpdate = !0), this;
    }
    setUniforms(e) {
      for (let t of e.entries()) this.uniforms[t[0]] = t[1];
      return this;
    }
    setExtensions(e) {
      this.extensions = {};
      for (let t of e) this.extensions[t] = !0;
      return this;
    }
    get encodeOutput() {
      return this.defines.ENCODE_OUTPUT !== void 0;
    }
    set encodeOutput(e) {
      this.encodeOutput !== e &&
        (e
          ? (this.defines.ENCODE_OUTPUT = "1")
          : delete this.defines.ENCODE_OUTPUT,
        (this.needsUpdate = !0));
    }
    isOutputEncodingEnabled(e) {
      return this.encodeOutput;
    }
    setOutputEncodingEnabled(e) {
      this.encodeOutput = e;
    }
    get time() {
      return this.uniforms.time.value;
    }
    set time(e) {
      this.uniforms.time.value = e;
    }
    setDeltaTime(e) {
      this.uniforms.time.value += e;
    }
    adoptCameraSettings(e) {
      e &&
        ((this.uniforms.cameraNear.value = e.near),
        (this.uniforms.cameraFar.value = e.far),
        e instanceof ds
          ? (this.defines.PERSPECTIVE_CAMERA = "1")
          : delete this.defines.PERSPECTIVE_CAMERA,
        (this.needsUpdate = !0));
    }
    setSize(e, t) {
      let i = this.uniforms;
      i.resolution.value.set(e, t),
        i.texelSize.value.set(1 / e, 1 / t),
        (i.aspect.value = e / t);
    }
    static get Section() {
      return ka;
    }
  },
  JY = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,
  $Y = class extends vi {
    constructor(e = !1, t = null) {
      super({
        name: "LuminanceMaterial",
        defines: { THREE_REVISION: ru.replace(/\D+/g, "") },
        uniforms: {
          inputBuffer: new Ve(null),
          threshold: new Ve(0),
          smoothing: new Ve(1),
          range: new Ve(null),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: JY,
        vertexShader: fp,
      }),
        (this.toneMapped = !1),
        (this.colorOutput = e),
        (this.luminanceRange = t);
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    get threshold() {
      return this.uniforms.threshold.value;
    }
    set threshold(e) {
      this.smoothing > 0 || e > 0
        ? (this.defines.THRESHOLD = "1")
        : delete this.defines.THRESHOLD,
        (this.uniforms.threshold.value = e);
    }
    getThreshold() {
      return this.threshold;
    }
    setThreshold(e) {
      this.threshold = e;
    }
    get smoothing() {
      return this.uniforms.smoothing.value;
    }
    set smoothing(e) {
      this.threshold > 0 || e > 0
        ? (this.defines.THRESHOLD = "1")
        : delete this.defines.THRESHOLD,
        (this.uniforms.smoothing.value = e);
    }
    getSmoothingFactor() {
      return this.smoothing;
    }
    setSmoothingFactor(e) {
      this.smoothing = e;
    }
    get useThreshold() {
      return this.threshold > 0 || this.smoothing > 0;
    }
    set useThreshold(e) {}
    get colorOutput() {
      return this.defines.COLOR !== void 0;
    }
    set colorOutput(e) {
      e ? (this.defines.COLOR = "1") : delete this.defines.COLOR,
        (this.needsUpdate = !0);
    }
    isColorOutputEnabled(e) {
      return this.colorOutput;
    }
    setColorOutputEnabled(e) {
      this.colorOutput = e;
    }
    get useRange() {
      return this.luminanceRange !== null;
    }
    set useRange(e) {
      this.luminanceRange = null;
    }
    get luminanceRange() {
      return this.uniforms.range.value;
    }
    set luminanceRange(e) {
      e !== null ? (this.defines.RANGE = "1") : delete this.defines.RANGE,
        (this.uniforms.range.value = e),
        (this.needsUpdate = !0);
    }
    getLuminanceRange() {
      return this.luminanceRange;
    }
    setLuminanceRange(e) {
      this.luminanceRange = e;
    }
  },
  eX = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,
  SP = { DISCARD: 0, MULTIPLY: 1, MULTIPLY_RGB_SET_ALPHA: 2 },
  tX = class extends vi {
    constructor(e = null) {
      super({
        name: "MaskMaterial",
        uniforms: {
          maskTexture: new Ve(e),
          inputBuffer: new Ve(null),
          strength: new Ve(1),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: eX,
        vertexShader: fp,
      }),
        (this.toneMapped = !1),
        this.setColorChannel(_P.RED),
        this.setMaskFunction(SP.DISCARD);
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    set maskTexture(e) {
      (this.uniforms.maskTexture.value = e),
        delete this.defines.MASK_PRECISION_HIGH,
        e.type !== ys && (this.defines.MASK_PRECISION_HIGH = "1"),
        (this.needsUpdate = !0);
    }
    setMaskTexture(e) {
      this.maskTexture = e;
    }
    set colorChannel(e) {
      (this.defines.COLOR_CHANNEL = e.toFixed(0)), (this.needsUpdate = !0);
    }
    setColorChannel(e) {
      this.colorChannel = e;
    }
    set maskFunction(e) {
      (this.defines.MASK_FUNCTION = e.toFixed(0)), (this.needsUpdate = !0);
    }
    setMaskFunction(e) {
      this.maskFunction = e;
    }
    get inverted() {
      return this.defines.INVERTED !== void 0;
    }
    set inverted(e) {
      this.inverted && !e
        ? delete this.defines.INVERTED
        : e && (this.defines.INVERTED = "1"),
        (this.needsUpdate = !0);
    }
    isInverted() {
      return this.inverted;
    }
    setInverted(e) {
      this.inverted = e;
    }
    get strength() {
      return this.uniforms.strength.value;
    }
    set strength(e) {
      this.uniforms.strength.value = e;
    }
    getStrength() {
      return this.strength;
    }
    setStrength(e) {
      this.strength = e;
    }
  },
  iX = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,
  rX =
    "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
  sX = class extends vi {
    constructor(e = new re(), t = new re()) {
      super({
        name: "SMAAWeightsMaterial",
        defines: {
          MAX_SEARCH_STEPS_INT: "16",
          MAX_SEARCH_STEPS_FLOAT: "16.0",
          MAX_SEARCH_STEPS_DIAG_INT: "8",
          MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
          CORNER_ROUNDING: "25",
          CORNER_ROUNDING_NORM: "0.25",
          AREATEX_MAX_DISTANCE: "16.0",
          AREATEX_MAX_DISTANCE_DIAG: "20.0",
          AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
          AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
          SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
          SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)",
        },
        uniforms: {
          inputBuffer: new Ve(null),
          searchTexture: new Ve(null),
          areaTexture: new Ve(null),
          resolution: new Ve(t),
          texelSize: new Ve(e),
        },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: iX,
        vertexShader: rX,
      }),
        (this.toneMapped = !1);
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    setInputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
    get searchTexture() {
      return this.uniforms.searchTexture.value;
    }
    set searchTexture(e) {
      this.uniforms.searchTexture.value = e;
    }
    get areaTexture() {
      return this.uniforms.areaTexture.value;
    }
    set areaTexture(e) {
      this.uniforms.areaTexture.value = e;
    }
    setLookupTextures(e, t) {
      (this.searchTexture = e), (this.areaTexture = t);
    }
    get orthogonalSearchSteps() {
      return Number(this.defines.MAX_SEARCH_STEPS_INT);
    }
    set orthogonalSearchSteps(e) {
      let t = Math.min(Math.max(e, 0), 112);
      (this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0")),
        (this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1")),
        (this.needsUpdate = !0);
    }
    setOrthogonalSearchSteps(e) {
      this.orthogonalSearchSteps = e;
    }
    get diagonalSearchSteps() {
      return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
    }
    set diagonalSearchSteps(e) {
      let t = Math.min(Math.max(e, 0), 20);
      (this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0")),
        (this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1")),
        (this.needsUpdate = !0);
    }
    setDiagonalSearchSteps(e) {
      this.diagonalSearchSteps = e;
    }
    get diagonalDetection() {
      return this.defines.DISABLE_DIAG_DETECTION === void 0;
    }
    set diagonalDetection(e) {
      e
        ? delete this.defines.DISABLE_DIAG_DETECTION
        : (this.defines.DISABLE_DIAG_DETECTION = "1"),
        (this.needsUpdate = !0);
    }
    isDiagonalDetectionEnabled() {
      return this.diagonalDetection;
    }
    setDiagonalDetectionEnabled(e) {
      this.diagonalDetection = e;
    }
    get cornerRounding() {
      return Number(this.defines.CORNER_ROUNDING);
    }
    set cornerRounding(e) {
      let t = Math.min(Math.max(e, 0), 100);
      (this.defines.CORNER_ROUNDING = t.toFixed("4")),
        (this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4")),
        (this.needsUpdate = !0);
    }
    setCornerRounding(e) {
      this.cornerRounding = e;
    }
    get cornerDetection() {
      return this.defines.DISABLE_CORNER_DETECTION === void 0;
    }
    set cornerDetection(e) {
      e
        ? delete this.defines.DISABLE_CORNER_DETECTION
        : (this.defines.DISABLE_CORNER_DETECTION = "1"),
        (this.needsUpdate = !0);
    }
    isCornerRoundingEnabled() {
      return this.cornerDetection;
    }
    setCornerRoundingEnabled(e) {
      this.cornerDetection = e;
    }
    setSize(e, t) {
      let i = this.uniforms;
      i.texelSize.value.set(1 / e, 1 / t), i.resolution.value.set(e, t);
    }
  },
  aX = new gh(),
  Vo = null;
function nX() {
  if (Vo === null) {
    let e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
      t = new Float32Array([0, 0, 2, 0, 0, 2]);
    (Vo = new yt()),
      Vo.setAttribute !== void 0
        ? (Vo.setAttribute("position", new It(e, 3)),
          Vo.setAttribute("uv", new It(t, 2)))
        : (Vo.addAttribute("position", new It(e, 3)),
          Vo.addAttribute("uv", new It(t, 2)));
  }
  return Vo;
}
var Ls = class {
    constructor(e = "Pass", t = new xo(), i = aX) {
      (this.name = e),
        (this.renderer = null),
        (this.scene = t),
        (this.camera = i),
        (this.screen = null),
        (this.rtt = !0),
        (this.needsSwap = !0),
        (this.needsDepthTexture = !1),
        (this.enabled = !0);
    }
    get renderToScreen() {
      return !this.rtt;
    }
    set renderToScreen(e) {
      if (this.rtt === e) {
        let t = this.getFullscreenMaterial();
        t !== null && (t.needsUpdate = !0), (this.rtt = !e);
      }
    }
    setRenderer(e) {
      this.renderer = e;
    }
    isEnabled() {
      return this.enabled;
    }
    setEnabled(e) {
      this.enabled = e;
    }
    get fullscreenMaterial() {
      return this.screen !== null ? this.screen.material : null;
    }
    set fullscreenMaterial(e) {
      let t = this.screen;
      t !== null
        ? (t.material = e)
        : ((t = new br(nX(), e)),
          (t.frustumCulled = !1),
          this.scene === null && (this.scene = new xo()),
          this.scene.add(t),
          (this.screen = t));
    }
    getFullscreenMaterial() {
      return this.fullscreenMaterial;
    }
    setFullscreenMaterial(e) {
      this.fullscreenMaterial = e;
    }
    getDepthTexture() {
      return null;
    }
    setDepthTexture(e, t = Eo) {}
    render(e, t, i, r, s) {
      throw new Error("Render method not implemented!");
    }
    setSize(e, t) {}
    initialize(e, t, i) {}
    dispose() {
      for (let e of Object.keys(this)) {
        let t = this[e];
        if (t !== null && typeof t.dispose == "function") {
          if (t instanceof xo || t === this.renderer) continue;
          this[e].dispose();
        }
      }
    }
  },
  j1 = class extends Ls {
    constructor(e, t = !0) {
      super("CopyPass"),
        (this.fullscreenMaterial = new WY()),
        (this.needsSwap = !1),
        (this.renderTarget = e),
        e === void 0 &&
          ((this.renderTarget = new gi(1, 1, {
            minFilter: Wt,
            magFilter: Wt,
            stencilBuffer: !1,
            depthBuffer: !1,
          })),
          (this.renderTarget.texture.name = "CopyPass.Target")),
        (this.autoResize = t);
    }
    get resize() {
      return this.autoResize;
    }
    set resize(e) {
      this.autoResize = e;
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    setAutoResizeEnabled(e) {
      this.autoResize = e;
    }
    render(e, t, i, r, s) {
      (this.fullscreenMaterial.inputBuffer = t.texture),
        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        e.render(this.scene, this.camera);
    }
    setSize(e, t) {
      this.autoResize && this.renderTarget.setSize(e, t);
    }
    initialize(e, t, i) {
      i !== void 0 &&
        ((this.renderTarget.texture.type = i),
        i !== ys
          ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
          : e.outputEncoding === jt &&
            (this.renderTarget.texture.encoding = jt));
    }
  },
  oX = class extends Ls {
    constructor() {
      super("ClearMaskPass", null, null), (this.needsSwap = !1);
    }
    render(e, t, i, r, s) {
      let a = e.state.buffers.stencil;
      a.setLocked(!1), a.setTest(!1);
    }
  },
  I0 = new Et(),
  Eb = class extends Ls {
    constructor(e = !0, t = !0, i = !1) {
      super("ClearPass", null, null),
        (this.needsSwap = !1),
        (this.color = e),
        (this.depth = t),
        (this.stencil = i),
        (this.overrideClearColor = null),
        (this.overrideClearAlpha = -1);
    }
    setClearFlags(e, t, i) {
      (this.color = e), (this.depth = t), (this.stencil = i);
    }
    getOverrideClearColor() {
      return this.overrideClearColor;
    }
    setOverrideClearColor(e) {
      this.overrideClearColor = e;
    }
    getOverrideClearAlpha() {
      return this.overrideClearAlpha;
    }
    setOverrideClearAlpha(e) {
      this.overrideClearAlpha = e;
    }
    render(e, t, i, r, s) {
      let a = this.overrideClearColor,
        n = this.overrideClearAlpha,
        o = e.getClearAlpha(),
        l = a !== null,
        h = n >= 0;
      l
        ? (I0.copy(e.getClearColor(I0)), e.setClearColor(a, h ? n : o))
        : h && e.setClearAlpha(n),
        e.setRenderTarget(this.renderToScreen ? null : t),
        e.clear(this.color, this.depth, this.stencil),
        l ? e.setClearColor(I0, o) : h && e.setClearAlpha(o);
    }
  },
  jo = -1,
  Gs = class extends ls {
    constructor(e, t = jo, i = jo, r = 1) {
      super(),
        (this.resizable = e),
        (this.base = new re(1, 1)),
        (this.preferred = new re(t, i)),
        (this.target = this.preferred),
        (this.s = r);
    }
    get width() {
      let { base: e, preferred: t, scale: i } = this,
        r;
      return (
        t.width !== jo
          ? (r = t.width)
          : t.height !== jo
          ? (r = Math.round(t.height * (e.width / Math.max(e.height, 1))))
          : (r = Math.round(e.width * i)),
        r
      );
    }
    set width(e) {
      this.preferredWidth = e;
    }
    get height() {
      let { base: e, preferred: t, scale: i } = this,
        r;
      return (
        t.height !== jo
          ? (r = t.height)
          : t.width !== jo
          ? (r = Math.round(
              t.width / Math.max(e.width / Math.max(e.height, 1), 1)
            ))
          : (r = Math.round(e.height * i)),
        r
      );
    }
    set height(e) {
      this.preferredHeight = e;
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    get scale() {
      return this.s;
    }
    set scale(e) {
      this.s !== e &&
        ((this.s = e),
        this.preferred.setScalar(jo),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    getScale() {
      return this.scale;
    }
    setScale(e) {
      this.scale = e;
    }
    get baseWidth() {
      return this.base.width;
    }
    set baseWidth(e) {
      this.base.width !== e &&
        ((this.base.width = e),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    getBaseWidth() {
      return this.base.width;
    }
    setBaseWidth(e) {
      this.base.width !== e &&
        ((this.base.width = e),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    get baseHeight() {
      return this.base.height;
    }
    set baseHeight(e) {
      this.base.height !== e &&
        ((this.base.height = e),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    getBaseHeight() {
      return this.baseHeight;
    }
    setBaseHeight(e) {
      this.baseHeight = e;
    }
    setBaseSize(e, t) {
      (this.base.width !== e || this.base.height !== t) &&
        (this.base.set(e, t),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    get preferredWidth() {
      return this.preferred.width;
    }
    set preferredWidth(e) {
      this.preferred.width !== e &&
        ((this.preferred.width = e),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    getPreferredWidth() {
      return this.preferredWidth;
    }
    setPreferredWidth(e) {
      this.preferredWidth = e;
    }
    get preferredHeight() {
      return this.preferred.height;
    }
    set preferredHeight(e) {
      this.preferred.height !== e &&
        ((this.preferred.height = e),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    getPreferredHeight() {
      return this.preferredHeight;
    }
    setPreferredHeight(e) {
      this.preferredHeight = e;
    }
    setPreferredSize(e, t) {
      (this.preferred.width !== e || this.preferred.height !== t) &&
        (this.preferred.set(e, t),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height));
    }
    copy(e) {
      this.base.set(e.getBaseWidth(), e.getBaseHeight()),
        this.preferred.set(e.getPreferredWidth(), e.getPreferredHeight()),
        this.dispatchEvent({ type: "change" }),
        this.resizable.setSize(this.base.width, this.base.height);
    }
    static get AUTO_SIZE() {
      return jo;
    }
  },
  R0 = !1,
  uM = class {
    constructor(e = null) {
      (this.originalMaterials = new Map()),
        (this.material = null),
        (this.materials = null),
        (this.materialsBackSide = null),
        (this.materialsDoubleSide = null),
        (this.materialsFlatShaded = null),
        (this.materialsFlatShadedBackSide = null),
        (this.materialsFlatShadedDoubleSide = null),
        this.setMaterial(e),
        (this.meshCount = 0),
        (this.replaceMaterial = (t) => {
          if (t.isMesh) {
            let i;
            if (t.material.flatShading)
              switch (t.material.side) {
                case js:
                  i = this.materialsFlatShadedDoubleSide;
                  break;
                case Yr:
                  i = this.materialsFlatShadedBackSide;
                  break;
                default:
                  i = this.materialsFlatShaded;
                  break;
              }
            else
              switch (t.material.side) {
                case js:
                  i = this.materialsDoubleSide;
                  break;
                case Yr:
                  i = this.materialsBackSide;
                  break;
                default:
                  i = this.materials;
                  break;
              }
            this.originalMaterials.set(t, t.material),
              t.isSkinnedMesh
                ? (t.material = i[2])
                : t.isInstancedMesh
                ? (t.material = i[1])
                : (t.material = i[0]),
              ++this.meshCount;
          }
        });
    }
    setMaterial(e) {
      if ((this.disposeMaterials(), (this.material = e), e !== null)) {
        let t = (this.materials = [e.clone(), e.clone(), e.clone()]);
        for (let i of t)
          (i.uniforms = Object.assign({}, e.uniforms)), (i.side = Xa);
        (t[2].skinning = !0),
          (this.materialsBackSide = t.map((i) => {
            let r = i.clone();
            return (
              (r.uniforms = Object.assign({}, e.uniforms)), (r.side = Yr), r
            );
          })),
          (this.materialsDoubleSide = t.map((i) => {
            let r = i.clone();
            return (
              (r.uniforms = Object.assign({}, e.uniforms)), (r.side = js), r
            );
          })),
          (this.materialsFlatShaded = t.map((i) => {
            let r = i.clone();
            return (
              (r.uniforms = Object.assign({}, e.uniforms)),
              (r.flatShading = !0),
              r
            );
          })),
          (this.materialsFlatShadedBackSide = t.map((i) => {
            let r = i.clone();
            return (
              (r.uniforms = Object.assign({}, e.uniforms)),
              (r.flatShading = !0),
              (r.side = Yr),
              r
            );
          })),
          (this.materialsFlatShadedDoubleSide = t.map((i) => {
            let r = i.clone();
            return (
              (r.uniforms = Object.assign({}, e.uniforms)),
              (r.flatShading = !0),
              (r.side = js),
              r
            );
          }));
      }
    }
    render(e, t, i) {
      let r = e.shadowMap.enabled;
      if (((e.shadowMap.enabled = !1), R0)) {
        let s = this.originalMaterials;
        (this.meshCount = 0), t.traverse(this.replaceMaterial), e.render(t, i);
        for (let a of s) a[0].material = a[1];
        this.meshCount !== s.size && s.clear();
      } else {
        let s = t.overrideMaterial;
        (t.overrideMaterial = this.material),
          e.render(t, i),
          (t.overrideMaterial = s);
      }
      e.shadowMap.enabled = r;
    }
    disposeMaterials() {
      if (this.material !== null) {
        let e = this.materials
          .concat(this.materialsBackSide)
          .concat(this.materialsDoubleSide)
          .concat(this.materialsFlatShaded)
          .concat(this.materialsFlatShadedBackSide)
          .concat(this.materialsFlatShadedDoubleSide);
        for (let t of e) t.dispose();
      }
    }
    dispose() {
      this.originalMaterials.clear(), this.disposeMaterials();
    }
    static get workaroundEnabled() {
      return R0;
    }
    static set workaroundEnabled(e) {
      R0 = e;
    }
  },
  lX = class extends Ls {
    constructor(e, t, i = null) {
      super("RenderPass", e, t),
        (this.needsSwap = !1),
        (this.clearPass = new Eb()),
        (this.overrideMaterialManager = i === null ? null : new uM(i)),
        (this.ignoreBackground = !1),
        (this.skipShadowMapUpdate = !1),
        (this.selection = null);
    }
    get renderToScreen() {
      return super.renderToScreen;
    }
    set renderToScreen(e) {
      (super.renderToScreen = e), (this.clearPass.renderToScreen = e);
    }
    get overrideMaterial() {
      let e = this.overrideMaterialManager;
      return e !== null ? e.material : null;
    }
    set overrideMaterial(e) {
      let t = this.overrideMaterialManager;
      e !== null
        ? t !== null
          ? t.setMaterial(e)
          : (this.overrideMaterialManager = new uM(e))
        : t !== null && (t.dispose(), (this.overrideMaterialManager = null));
    }
    getOverrideMaterial() {
      return this.overrideMaterial;
    }
    setOverrideMaterial(e) {
      this.overrideMaterial = e;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(e) {
      this.clearPass.enabled = e;
    }
    getSelection() {
      return this.selection;
    }
    setSelection(e) {
      this.selection = e;
    }
    isBackgroundDisabled() {
      return this.ignoreBackground;
    }
    setBackgroundDisabled(e) {
      this.ignoreBackground = e;
    }
    isShadowMapDisabled() {
      return this.skipShadowMapUpdate;
    }
    setShadowMapDisabled(e) {
      this.skipShadowMapUpdate = e;
    }
    getClearPass() {
      return this.clearPass;
    }
    render(e, t, i, r, s) {
      let a = this.scene,
        n = this.camera,
        o = this.selection,
        l = n.layers.mask,
        h = a.background,
        u = e.shadowMap.autoUpdate,
        c = this.renderToScreen ? null : t;
      o !== null && n.layers.set(o.getLayer()),
        this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
        (this.ignoreBackground || this.clearPass.overrideClearColor !== null) &&
          (a.background = null),
        this.clearPass.enabled && this.clearPass.render(e, t),
        e.setRenderTarget(c),
        this.overrideMaterialManager !== null
          ? this.overrideMaterialManager.render(e, a, n)
          : e.render(a, n),
        (n.layers.mask = l),
        (a.background = h),
        (e.shadowMap.autoUpdate = u);
    }
  },
  dM = class extends Ls {
    constructor(
      e,
      t,
      {
        resolutionScale: i = 1,
        width: r = Gs.AUTO_SIZE,
        height: s = Gs.AUTO_SIZE,
        renderTarget: a,
      } = {}
    ) {
      super("DepthPass"),
        (this.needsSwap = !1),
        (this.renderPass = new lX(e, t, new oC({ depthPacking: YE })));
      let n = this.renderPass;
      (n.skipShadowMapUpdate = !0), (n.ignoreBackground = !0);
      let o = n.getClearPass();
      (o.overrideClearColor = new Et(16777215)),
        (o.overrideClearAlpha = 1),
        (this.renderTarget = a),
        this.renderTarget === void 0 &&
          ((this.renderTarget = new gi(1, 1, {
            minFilter: mi,
            magFilter: mi,
            stencilBuffer: !1,
          })),
          (this.renderTarget.texture.name = "DepthPass.Target"));
      let l = (this.resolution = new Gs(this, r, s, i));
      l.addEventListener("change", (h) =>
        this.setSize(l.baseWidth, l.baseHeight)
      );
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    getResolution() {
      return this.resolution;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(e) {
      this.resolution.scale = e;
    }
    render(e, t, i, r, s) {
      let a = this.renderToScreen ? null : this.renderTarget;
      this.renderPass.render(e, a);
    }
    setSize(e, t) {
      let i = this.resolution;
      i.setBaseSize(e, t), this.renderTarget.setSize(i.width, i.height);
    }
  },
  ste = new Float32Array([
    255 / 256 / 256 ** 3,
    255 / 256 / 256 ** 2,
    255 / 256 / 256,
    255 / 256,
  ]),
  li = {
    SKIP: 0,
    ADD: 1,
    ALPHA: 2,
    AVERAGE: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    EXCLUSION: 8,
    LIGHTEN: 9,
    MULTIPLY: 10,
    DIVIDE: 11,
    NEGATION: 12,
    NORMAL: 13,
    OVERLAY: 14,
    REFLECT: 15,
    SCREEN: 16,
    SOFT_LIGHT: 17,
    SUBTRACT: 18,
  },
  hX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}",
  cX =
    "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}",
  uX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}",
  dX =
    "float blend(const in float x,const in float y){return(y==0.0)?y:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
  pX =
    "float blend(const in float x,const in float y){return(y==1.0)?y:min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
  fX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}",
  mX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}",
  gX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}",
  vX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}",
  yX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}",
  xX =
    "float blend(const in float x,const in float y){return(y>0.0)?min(x/y,1.0):1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
  bX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}",
  wX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}",
  _X =
    "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
  SX =
    "float blend(const in float x,const in float y){return(y==1.0)?y:min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
  AX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}",
  MX =
    "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",
  EX =
    "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}",
  CX = new Map([
    [li.SKIP, null],
    [li.ADD, hX],
    [li.ALPHA, cX],
    [li.AVERAGE, uX],
    [li.COLOR_BURN, dX],
    [li.COLOR_DODGE, pX],
    [li.DARKEN, fX],
    [li.DIFFERENCE, mX],
    [li.EXCLUSION, gX],
    [li.LIGHTEN, vX],
    [li.MULTIPLY, yX],
    [li.DIVIDE, xX],
    [li.NEGATION, bX],
    [li.NORMAL, wX],
    [li.OVERLAY, _X],
    [li.REFLECT, SX],
    [li.SCREEN, AX],
    [li.SOFT_LIGHT, MX],
    [li.SUBTRACT, EX],
  ]),
  TX = class extends ls {
    constructor(e, t = 1) {
      super(), (this.f = e), (this.opacity = new Ve(t));
    }
    getOpacity() {
      return this.opacity.value;
    }
    setOpacity(e) {
      this.opacity.value = e;
    }
    get blendFunction() {
      return this.f;
    }
    set blendFunction(e) {
      (this.f = e), this.dispatchEvent({ type: "change" });
    }
    getBlendFunction() {
      return this.blendFunction;
    }
    setBlendFunction(e) {
      this.blendFunction = e;
    }
    getShaderCode() {
      return CX.get(this.blendFunction);
    }
  },
  Pn = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
  kn = class extends ls {
    constructor(
      e,
      t,
      {
        attributes: i = Pn.NONE,
        blendFunction: r = li.SCREEN,
        defines: s = new Map(),
        uniforms: a = new Map(),
        extensions: n = null,
        vertexShader: o = null,
      } = {}
    ) {
      super(),
        (this.name = e),
        (this.renderer = null),
        (this.attributes = i),
        (this.fragmentShader = t),
        (this.vertexShader = o),
        (this.defines = s),
        (this.uniforms = a),
        (this.extensions = n),
        (this.blendMode = new TX(r)),
        this.blendMode.addEventListener("change", (l) => this.setChanged());
    }
    getName() {
      return this.name;
    }
    setRenderer(e) {
      this.renderer = e;
    }
    getDefines() {
      return this.defines;
    }
    getUniforms() {
      return this.uniforms;
    }
    getExtensions() {
      return this.extensions;
    }
    getBlendMode() {
      return this.blendMode;
    }
    getAttributes() {
      return this.attributes;
    }
    setAttributes(e) {
      (this.attributes = e), this.setChanged();
    }
    getFragmentShader() {
      return this.fragmentShader;
    }
    setFragmentShader(e) {
      (this.fragmentShader = e), this.setChanged();
    }
    getVertexShader() {
      return this.vertexShader;
    }
    setVertexShader(e) {
      (this.vertexShader = e), this.setChanged();
    }
    setChanged() {
      this.dispatchEvent({ type: "change" });
    }
    setDepthTexture(e, t = Eo) {}
    update(e, t, i) {}
    setSize(e, t) {}
    initialize(e, t, i) {}
    dispose() {
      for (let e of Object.keys(this)) {
        let t = this[e];
        if (t !== null && typeof t.dispose == "function") {
          if (t instanceof xo || t === this.renderer) continue;
          this[e].dispose();
        }
      }
    }
  };
function pM(e, t, i) {
  for (let r of t) {
    let s = "$1" + e + r.charAt(0).toUpperCase() + r.slice(1),
      a = new RegExp("([^\\.])(\\b" + r + "\\b)", "g");
    for (let n of i.entries()) n[1] !== null && i.set(n[0], n[1].replace(a, s));
  }
}
function PX(e, t, i, r, s, a, n) {
  let o = new Map([
      ["fragment", t.getFragmentShader()],
      ["vertex", t.getVertexShader()],
    ]),
    l = o.get("fragment") !== void 0 && /mainImage/.test(o.get("fragment")),
    h = o.get("fragment") !== void 0 && /mainUv/.test(o.get("fragment")),
    u = [],
    c = [],
    d = !1,
    p = !1;
  if (o.get("fragment") === void 0) console.error("Missing fragment shader", t);
  else if (h && (n & Pn.CONVOLUTION) !== 0)
    console.error(
      "Effects that transform UV coordinates are incompatible with convolution effects",
      t
    );
  else if (!l && !h)
    console.error(
      "The fragment shader contains neither a mainImage nor a mainUv function",
      t
    );
  else {
    let f = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,
      m = V1.Section;
    if (h) {
      let y = `	${e}MainUv(UV);
`;
      i.set(m.FRAGMENT_MAIN_UV, i.get(m.FRAGMENT_MAIN_UV) + y), (d = !0);
    }
    if (o.get("vertex") !== null && /mainSupport/.test(o.get("vertex"))) {
      let y = `	${e}MainSupport(`;
      (y += /mainSupport *\([\w\s]*?uv\s*?\)/.test(o.get("vertex"))
        ? `vUv);
`
        : `);
`),
        i.set(m.VERTEX_MAIN_SUPPORT, i.get(m.VERTEX_MAIN_SUPPORT) + y),
        (u = u.concat(
          [...o.get("vertex").matchAll(/(?:varying\s+\w+\s+(\w*))/g)].map(
            (x) => x[1]
          )
        )),
        (c = c
          .concat(u)
          .concat([...o.get("vertex").matchAll(f)].map((x) => x[1])));
    }
    (c = c.concat([...o.get("fragment").matchAll(f)].map((y) => y[1]))),
      (c = c.concat(
        [...t.defines.keys()].map((y) => y.replace(/\([\w\s,]*\)/g, ""))
      )),
      (c = c.concat([...t.uniforms.keys()])),
      t.uniforms.forEach((y, x) =>
        a.set(e + x.charAt(0).toUpperCase() + x.slice(1), y)
      ),
      t.defines.forEach((y, x) =>
        s.set(e + x.charAt(0).toUpperCase() + x.slice(1), y)
      ),
      pM(e, c, s),
      pM(e, c, o);
    let g = t.blendMode;
    if ((r.set(g.blendFunction, g), l)) {
      let y = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/,
        x = `${e}MainImage(color0, UV, `;
      (n & Pn.DEPTH) !== 0 &&
        y.test(o.get("fragment")) &&
        ((x += "depth, "), (p = !0)),
        (x += `color1);
	`);
      let b = e + "BlendOpacity";
      a.set(b, g.opacity),
        (x += `color0 = blend${g.blendFunction}(color0, color1, ${b});

	`),
        i.set(m.FRAGMENT_MAIN_IMAGE, i.get(m.FRAGMENT_MAIN_IMAGE) + x),
        (x = `uniform float ${b};

`),
        i.set(m.FRAGMENT_HEAD, i.get(m.FRAGMENT_HEAD) + x);
    }
    i.set(
      m.FRAGMENT_HEAD,
      i.get(m.FRAGMENT_HEAD) +
        o.get("fragment") +
        `
`
    ),
      o.get("vertex") !== null &&
        i.set(
          m.VERTEX_HEAD,
          i.get(m.VERTEX_HEAD) +
            o.get("vertex") +
            `
`
        );
  }
  return { varyings: u, transformedUv: d, readDepth: p };
}
var ug = class extends Ls {
    constructor(e, ...t) {
      super("EffectPass"),
        (this.fullscreenMaterial = new V1(null, null, null, e)),
        (this.effects = t.sort((i, r) => r.attributes - i.attributes)),
        (this.skipRendering = !1),
        (this.uniformCount = 0),
        (this.varyingCount = 0),
        (this.minTime = 1),
        (this.maxTime = Number.POSITIVE_INFINITY);
    }
    get encodeOutput() {
      return this.fullscreenMaterial.encodeOutput;
    }
    set encodeOutput(e) {
      this.fullscreenMaterial.encodeOutput = e;
    }
    get dithering() {
      return this.fullscreenMaterial.dithering;
    }
    set dithering(e) {
      let t = this.fullscreenMaterial;
      (t.dithering = e), (t.needsUpdate = !0);
    }
    verifyResources() {
      let e = this.renderer.capabilities,
        t = Math.min(e.maxFragmentUniforms, e.maxVertexUniforms);
      this.uniformCount > t &&
        console.warn(
          "The current rendering context doesn't support more than " +
            t +
            " uniforms, but " +
            this.uniformCount +
            " were defined"
        ),
        (t = e.maxVaryings),
        this.varyingCount > t &&
          console.warn(
            "The current rendering context doesn't support more than " +
              t +
              " varyings, but " +
              this.varyingCount +
              " were defined"
          );
    }
    updateMaterial() {
      let e = V1.Section,
        t = new Map([
          [e.FRAGMENT_HEAD, ""],
          [e.FRAGMENT_MAIN_UV, ""],
          [e.FRAGMENT_MAIN_IMAGE, ""],
          [e.VERTEX_HEAD, ""],
          [e.VERTEX_MAIN_SUPPORT, ""],
        ]),
        i = new Map(),
        r = new Map(),
        s = new Map(),
        a = new Set(),
        n = 0,
        o = 0,
        l = 0,
        h = !1,
        u = !1;
      for (let d of this.effects)
        if (d.blendMode.blendFunction === li.SKIP)
          l |= d.getAttributes() & Pn.DEPTH;
        else if ((l & d.getAttributes() & Pn.CONVOLUTION) !== 0)
          console.error("Convolution effects cannot be merged", d);
        else {
          l |= d.getAttributes();
          let p = "e" + n++,
            f = PX(p, d, t, i, r, s, l);
          if (
            ((o += f.varyings.length),
            (h = h || f.transformedUv),
            (u = u || f.readDepth),
            d.extensions !== null)
          )
            for (let m of d.extensions) a.add(m);
        }
      let c = /\bblend\b/g;
      for (let d of i.values()) {
        let p = d.getShaderCode().replace(c, `blend${d.blendFunction}`);
        t.set(
          e.FRAGMENT_HEAD,
          t.get(e.FRAGMENT_HEAD) +
            p +
            `
`
        );
      }
      if ((l & Pn.DEPTH) !== 0) {
        if (u) {
          let d = `float depth = readDepth(UV);

	`;
          t.set(e.FRAGMENT_MAIN_IMAGE, d + t.get(e.FRAGMENT_MAIN_IMAGE));
        }
        this.needsDepthTexture = this.getDepthTexture() === null;
      } else this.needsDepthTexture = !1;
      if (h) {
        let d = `vec2 transformedUv = vUv;
`;
        t.set(e.FRAGMENT_MAIN_UV, d + t.get(e.FRAGMENT_MAIN_UV)),
          r.set("UV", "transformedUv");
      } else r.set("UV", "vUv");
      t.forEach((d, p, f) =>
        f.set(
          p,
          d.trim().replace(
            /^#/,
            `
#`
          )
        )
      ),
        (this.uniformCount = s.size),
        (this.varyingCount = o),
        (this.skipRendering = n === 0),
        (this.needsSwap = !this.skipRendering),
        this.fullscreenMaterial
          .setShaderParts(t)
          .setExtensions(a)
          .setUniforms(s)
          .setDefines(r);
    }
    recompile() {
      this.updateMaterial(), this.verifyResources();
    }
    getDepthTexture() {
      return this.fullscreenMaterial.depthBuffer;
    }
    setDepthTexture(e, t = Eo) {
      (this.fullscreenMaterial.depthBuffer = e),
        (this.fullscreenMaterial.depthPacking = t);
      for (let i of this.effects) i.setDepthTexture(e, t);
    }
    render(e, t, i, r, s) {
      for (let a of this.effects) a.update(e, t, r);
      if (!this.skipRendering || this.renderToScreen) {
        let a = this.fullscreenMaterial;
        (a.inputBuffer = t.texture),
          (a.time += r),
          e.setRenderTarget(this.renderToScreen ? null : i),
          e.render(this.scene, this.camera);
      }
    }
    setSize(e, t) {
      this.fullscreenMaterial.setSize(e, t);
      for (let i of this.effects) i.setSize(e, t);
    }
    initialize(e, t, i) {
      this.renderer = e;
      for (let r of this.effects)
        r.initialize(e, t, i),
          r.addEventListener("change", (s) => this.handleEvent(s));
      this.updateMaterial(),
        this.verifyResources(),
        i !== void 0 &&
          i !== ys &&
          (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
    }
    dispose() {
      super.dispose();
      for (let e of this.effects) e.dispose();
    }
    handleEvent(e) {
      switch (e.type) {
        case "change":
          this.recompile();
          break;
      }
    }
  },
  DX = [
    new Float32Array([0, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([0, 1, 1, 2]),
    new Float32Array([0, 1, 2, 2, 3]),
    new Float32Array([0, 1, 2, 3, 4, 4, 5]),
    new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
  ],
  Cb = class extends Ls {
    constructor({
      resolutionScale: e = 0.5,
      width: t = Gs.AUTO_SIZE,
      height: i = Gs.AUTO_SIZE,
      kernelSize: r = Ug.LARGE,
    } = {}) {
      super("KawaseBlurPass"),
        (this.renderTargetA = new gi(1, 1, {
          minFilter: Wt,
          magFilter: Wt,
          stencilBuffer: !1,
          depthBuffer: !1,
        })),
        (this.renderTargetA.texture.name = "Blur.Target.A"),
        (this.renderTargetB = this.renderTargetA.clone()),
        (this.renderTargetB.texture.name = "Blur.Target.B");
      let s = (this.resolution = new Gs(this, t, i, e));
      s.addEventListener("change", (a) =>
        this.setSize(s.baseWidth, s.baseHeight)
      ),
        (this.blurMaterial = new cM()),
        (this.ditheredBlurMaterial = new cM()),
        (this.ditheredBlurMaterial.uniforms.scale =
          this.blurMaterial.uniforms.scale),
        (this.ditheredBlurMaterial.dithering = !0),
        (this.dithering = !1),
        (this.kernelSize = r);
    }
    getResolution() {
      return this.resolution;
    }
    get width() {
      return this.resolution.width;
    }
    set width(e) {
      this.resolution.preferredWidth = e;
    }
    get height() {
      return this.resolution.height;
    }
    set height(e) {
      this.resolution.preferredHeight = e;
    }
    get scale() {
      return this.blurMaterial.scale;
    }
    set scale(e) {
      this.blurMaterial.scale = e;
    }
    getScale() {
      return this.blurMaterial.scale;
    }
    setScale(e) {
      this.blurMaterial.scale = e;
    }
    getKernelSize() {
      return this.kernelSize;
    }
    setKernelSize(e) {
      this.kernelSize = e;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(e) {
      this.resolution.scale = e;
    }
    render(e, t, i, r, s) {
      let a = this.scene,
        n = this.camera,
        o = this.renderTargetA,
        l = this.renderTargetB,
        h = DX[this.kernelSize],
        u = this.blurMaterial,
        c = t,
        d,
        p;
      for (this.fullscreenMaterial = u, d = 0, p = h.length - 1; d < p; ++d) {
        let f = (d & 1) === 0 ? o : l;
        (u.kernel = h[d]),
          (u.inputBuffer = c.texture),
          e.setRenderTarget(f),
          e.render(a, n),
          (c = f);
      }
      this.dithering &&
        ((u = this.ditheredBlurMaterial), (this.fullscreenMaterial = u)),
        (u.kernel = h[d]),
        (u.inputBuffer = c.texture),
        e.setRenderTarget(this.renderToScreen ? null : i),
        e.render(a, n);
    }
    setSize(e, t) {
      let i = this.resolution;
      i.setBaseSize(e, t);
      let r = i.width,
        s = i.height;
      this.renderTargetA.setSize(r, s),
        this.renderTargetB.setSize(r, s),
        this.blurMaterial.setSize(r, s),
        this.ditheredBlurMaterial.setSize(r, s);
    }
    initialize(e, t, i) {
      i !== void 0 &&
        ((this.renderTargetA.texture.type = i),
        (this.renderTargetB.texture.type = i),
        i !== ys
          ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"),
            (this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
              "1"))
          : e.outputEncoding === jt &&
            ((this.renderTargetA.texture.encoding = jt),
            (this.renderTargetB.texture.encoding = jt)));
    }
    static get AUTO_SIZE() {
      return Gs.AUTO_SIZE;
    }
  },
  OX = class extends Ls {
    constructor({
      width: e = Gs.AUTO_SIZE,
      height: t = Gs.AUTO_SIZE,
      renderTarget: i,
      luminanceRange: r,
      colorOutput: s,
    } = {}) {
      super("LuminancePass"),
        (this.fullscreenMaterial = new $Y(s, r)),
        (this.needsSwap = !1),
        (this.renderTarget = i),
        this.renderTarget === void 0 &&
          ((this.renderTarget = new gi(1, 1, {
            minFilter: Wt,
            magFilter: Wt,
            stencilBuffer: !1,
            depthBuffer: !1,
          })),
          (this.renderTarget.texture.name = "LuminancePass.Target"),
          (this.renderTarget.texture.generateMipmaps = !1));
      let a = (this.resolution = new Gs(this, e, t));
      a.addEventListener("change", (n) =>
        this.setSize(a.baseWidth, a.baseHeight)
      );
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    getResolution() {
      return this.resolution;
    }
    render(e, t, i, r, s) {
      let a = this.fullscreenMaterial;
      (a.inputBuffer = t.texture),
        e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        e.render(this.scene, this.camera);
    }
    setSize(e, t) {
      let i = this.resolution;
      i.setBaseSize(e, t), this.renderTarget.setSize(i.width, i.height);
    }
    initialize(e, t, i) {
      i !== void 0 &&
        i !== ys &&
        (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
    }
  },
  IX = class extends Ls {
    constructor(e, t) {
      super("MaskPass", e, t),
        (this.needsSwap = !1),
        (this.clearPass = new Eb(!1, !1, !0)),
        (this.inverse = !1);
    }
    get inverted() {
      return this.inverse;
    }
    set inverted(e) {
      this.inverse = e;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(e) {
      this.clearPass.enabled = e;
    }
    getClearPass() {
      return this.clearPass;
    }
    isInverted() {
      return this.inverted;
    }
    setInverted(e) {
      this.inverted = e;
    }
    render(e, t, i, r, s) {
      let a = e.getContext(),
        n = e.state.buffers,
        o = this.scene,
        l = this.camera,
        h = this.clearPass,
        u = this.inverted ? 0 : 1,
        c = 1 - u;
      n.color.setMask(!1),
        n.depth.setMask(!1),
        n.color.setLocked(!0),
        n.depth.setLocked(!0),
        n.stencil.setTest(!0),
        n.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE),
        n.stencil.setFunc(a.ALWAYS, u, 4294967295),
        n.stencil.setClear(c),
        n.stencil.setLocked(!0),
        this.clearPass.enabled &&
          (this.renderToScreen
            ? h.render(e, null)
            : (h.render(e, t), h.render(e, i))),
        this.renderToScreen
          ? (e.setRenderTarget(null), e.render(o, l))
          : (e.setRenderTarget(t),
            e.render(o, l),
            e.setRenderTarget(i),
            e.render(o, l)),
        n.color.setLocked(!1),
        n.depth.setLocked(!1),
        n.stencil.setLocked(!1),
        n.stencil.setFunc(a.EQUAL, 1, 4294967295),
        n.stencil.setOp(a.KEEP, a.KEEP, a.KEEP),
        n.stencil.setLocked(!0);
    }
  },
  Va = class extends Ls {
    constructor(e, t = "inputBuffer") {
      super("ShaderPass"),
        (this.fullscreenMaterial = e),
        (this.inputBufferUniform = null),
        this.setInput(t);
    }
    setInput(e) {
      if (
        ((this.inputBufferUniform = null), this.fullscreenMaterial !== null)
      ) {
        let t = this.fullscreenMaterial.uniforms;
        t !== void 0 && t[e] !== void 0 && (this.inputBufferUniform = t[e]);
      }
    }
    render(e, t, i, r, s) {
      this.inputBufferUniform !== null &&
        t !== null &&
        (this.inputBufferUniform.value = t.texture),
        e.setRenderTarget(this.renderToScreen ? null : i),
        e.render(this.scene, this.camera);
    }
    initialize(e, t, i) {
      i !== void 0 &&
        i !== ys &&
        (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
    }
  },
  L0 = 1 / 1e3,
  RX = 1e3,
  LX = class {
    constructor() {
      (this.previousTime = 0),
        (this.currentTime = 0),
        (this.delta = 0),
        (this.fixedDelta = 1e3 / 60),
        (this.elapsed = 0),
        (this.timescale = 1),
        (this.fixedDeltaEnabled = !1),
        (this.autoReset = !1);
    }
    setFixedDeltaEnabled(e) {
      return (this.fixedDeltaEnabled = e), this;
    }
    isAutoResetEnabled(e) {
      return this.autoReset;
    }
    setAutoResetEnabled(e) {
      return (
        typeof document < "u" &&
          document.hidden !== void 0 &&
          (e
            ? document.addEventListener("visibilitychange", this)
            : document.removeEventListener("visibilitychange", this),
          (this.autoReset = e)),
        this
      );
    }
    getDelta() {
      return this.delta * L0;
    }
    getFixedDelta() {
      return this.fixedDelta * L0;
    }
    setFixedDelta(e) {
      return (this.fixedDelta = e * RX), this;
    }
    getElapsed() {
      return this.elapsed * L0;
    }
    getTimescale() {
      return this.timescale;
    }
    setTimescale(e) {
      return (this.timescale = e), this;
    }
    update(e) {
      return (
        this.fixedDeltaEnabled
          ? (this.delta = this.fixedDelta)
          : ((this.previousTime = this.currentTime),
            (this.currentTime = e !== void 0 ? e : performance.now()),
            (this.delta = this.currentTime - this.previousTime)),
        (this.delta *= this.timescale),
        (this.elapsed += this.delta),
        this
      );
    }
    reset() {
      return (
        (this.delta = 0),
        (this.elapsed = 0),
        (this.currentTime = performance.now()),
        this
      );
    }
    handleEvent(e) {
      document.hidden || (this.currentTime = performance.now());
    }
    dispose() {
      this.setAutoResetEnabled(!1);
    }
  },
  Ug = { VERY_SMALL: 0, SMALL: 1, MEDIUM: 2, LARGE: 3, VERY_LARGE: 4, HUGE: 5 },
  BX = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`,
  zX = class extends kn {
    constructor({
      blendFunction: e = li.SCREEN,
      luminanceThreshold: t = 0.9,
      luminanceSmoothing: i = 0.025,
      resolutionScale: r = 0.5,
      intensity: s = 1,
      width: a = Gs.AUTO_SIZE,
      height: n = Gs.AUTO_SIZE,
      kernelSize: o = Ug.LARGE,
    } = {}) {
      super("BloomEffect", BX, {
        blendFunction: e,
        uniforms: new Map([
          ["map", new Ve(null)],
          ["intensity", new Ve(s)],
        ]),
      }),
        (this.renderTarget = new gi(1, 1, {
          minFilter: Wt,
          magFilter: Wt,
          stencilBuffer: !1,
          depthBuffer: !1,
        })),
        (this.renderTarget.texture.name = "Bloom.Target"),
        (this.renderTarget.texture.generateMipmaps = !1),
        (this.uniforms.get("map").value = this.renderTarget.texture),
        (this.luminancePass = new OX({
          renderTarget: this.renderTarget,
          colorOutput: !0,
        })),
        (this.luminanceMaterial.threshold = t),
        (this.luminanceMaterial.smoothingFactor = i),
        (this.blurPass = new Cb({
          resolutionScale: r,
          width: a,
          height: n,
          kernelSize: o,
        }));
      let l = this.blurPass.getResolution();
      l.addEventListener("change", (h) =>
        this.setSize(l.baseWidth, l.baseHeight)
      );
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    get resolution() {
      return this.blurPass.resolution;
    }
    getResolution() {
      return this.blurPass.resolution;
    }
    getBlurPass() {
      return this.blurPass;
    }
    getLuminancePass() {
      return this.luminancePass;
    }
    get luminanceMaterial() {
      return this.luminancePass.fullscreenMaterial;
    }
    getLuminanceMaterial() {
      return this.luminancePass.fullscreenMaterial;
    }
    get width() {
      return this.resolution.width;
    }
    set width(e) {
      this.resolution.preferredWidth = e;
    }
    get height() {
      return this.resolution.height;
    }
    set height(e) {
      this.resolution.preferredHeight = e;
    }
    get dithering() {
      return this.blurPass.dithering;
    }
    set dithering(e) {
      this.blurPass.dithering = e;
    }
    get kernelSize() {
      return this.blurPass.kernelSize;
    }
    set kernelSize(e) {
      this.blurPass.kernelSize = e;
    }
    get distinction() {
      return console.warn(this.name, "distinction was removed"), 1;
    }
    set distinction(e) {
      console.warn(this.name, "distinction was removed");
    }
    get intensity() {
      return this.uniforms.get("intensity").value;
    }
    set intensity(e) {
      this.uniforms.get("intensity").value = e;
    }
    getIntensity() {
      return this.intensity;
    }
    setIntensity(e) {
      this.intensity = e;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(e) {
      this.resolution.scale = e;
    }
    update(e, t, i) {
      let r = this.renderTarget;
      this.luminancePass.enabled
        ? (this.luminancePass.render(e, t, r), this.blurPass.render(e, r, r))
        : this.blurPass.render(e, t, r);
    }
    setSize(e, t) {
      let i = this.resolution;
      i.setBaseSize(e, t),
        this.renderTarget.setSize(i.width, i.height),
        this.luminancePass.resolution.copy(i);
    }
    initialize(e, t, i) {
      this.blurPass.initialize(e, t, i),
        i !== void 0 &&
          ((this.renderTarget.texture.type = i),
          e.outputEncoding === jt && (this.renderTarget.texture.encoding = jt));
    }
  },
  FX =
    "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}",
  kX = class extends kn {
    constructor({
      blendFunction: e = li.NORMAL,
      brightness: t = 0,
      contrast: i = 0,
    } = {}) {
      super("BrightnessContrastEffect", FX, {
        blendFunction: e,
        uniforms: new Map([
          ["brightness", new Ve(t)],
          ["contrast", new Ve(i)],
        ]),
      });
    }
    get brightness() {
      return this.uniforms.get("brightness").value;
    }
    set brightness(e) {
      this.uniforms.get("brightness").value = e;
    }
    getBrightness(e) {
      return this.brightness;
    }
    setBrightness(e) {
      this.brightness = e;
    }
    get contrast() {
      return this.uniforms.get("contrast").value;
    }
    set contrast(e) {
      this.uniforms.get("contrast").value = e;
    }
    getContrast(e) {
      return this.contrast;
    }
    setContrast(e) {
      this.contrast = e;
    }
  },
  NX =
    "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}",
  UX = class extends kn {
    constructor(e = li.NORMAL) {
      super("ColorAverageEffect", NX, { blendFunction: e });
    }
  },
  VX =
    "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}",
  jX =
    "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}",
  HX = class extends kn {
    constructor({
      blendFunction: e = li.NORMAL,
      offset: t = new re(0.001, 5e-4),
    } = {}) {
      super("ChromaticAberrationEffect", VX, {
        vertexShader: jX,
        blendFunction: e,
        attributes: Pn.CONVOLUTION,
        uniforms: new Map([["offset", new Ve(t)]]),
      });
    }
    get offset() {
      return this.uniforms.get("offset").value;
    }
    set offset(e) {
      this.uniforms.get("offset").value = e;
    }
    getOffset() {
      return this.offset;
    }
    setOffset(e) {
      this.offset = e;
    }
  },
  GX = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`,
  WX = class extends kn {
    constructor(
      e,
      {
        blendFunction: t = li.NORMAL,
        worldFocusDistance: i,
        worldFocusRange: r,
        focusDistance: s = 0,
        focalLength: a = 0.1,
        focusRange: n = a,
        bokehScale: o = 1,
        width: l = Gs.AUTO_SIZE,
        height: h = Gs.AUTO_SIZE,
      } = {}
    ) {
      super("DepthOfFieldEffect", GX, {
        blendFunction: t,
        attributes: Pn.DEPTH,
        uniforms: new Map([
          ["nearColorBuffer", new Ve(null)],
          ["farColorBuffer", new Ve(null)],
          ["nearCoCBuffer", new Ve(null)],
          ["scale", new Ve(1)],
        ]),
      }),
        (this.camera = e),
        (this.renderTarget = new gi(1, 1, {
          minFilter: Wt,
          magFilter: Wt,
          stencilBuffer: !1,
          depthBuffer: !1,
        })),
        (this.renderTarget.texture.name = "DoF.Intermediate"),
        (this.renderTarget.texture.generateMipmaps = !1),
        (this.renderTargetMasked = this.renderTarget.clone()),
        (this.renderTargetMasked.texture.name = "DoF.Masked.Far"),
        (this.renderTargetNear = this.renderTarget.clone()),
        (this.renderTargetNear.texture.name = "DoF.Bokeh.Near"),
        (this.uniforms.get("nearColorBuffer").value =
          this.renderTargetNear.texture),
        (this.renderTargetFar = this.renderTarget.clone()),
        (this.renderTargetFar.texture.name = "DoF.Bokeh.Far"),
        (this.uniforms.get("farColorBuffer").value =
          this.renderTargetFar.texture),
        (this.renderTargetCoC = this.renderTarget.clone()),
        (this.renderTargetCoC.texture.name = "DoF.CoC"),
        (this.renderTargetCoCBlurred = this.renderTargetCoC.clone()),
        (this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred"),
        (this.uniforms.get("nearCoCBuffer").value =
          this.renderTargetCoCBlurred.texture),
        (this.cocPass = new Va(new VY(e)));
      let u = this.cocMaterial;
      (u.focusDistance = s),
        (u.focusRange = n),
        i !== void 0 && (u.worldFocusDistance = i),
        r !== void 0 && (u.worldFocusRange = r),
        (this.blurPass = new Cb({
          kernelSize: Ug.MEDIUM,
          width: l,
          height: h,
        }));
      let c = this.blurPass.getResolution();
      c.addEventListener("change", (p) =>
        this.setSize(c.getBaseWidth(), c.getBaseHeight())
      ),
        (this.maskPass = new Va(new tX(this.renderTargetCoC.texture)));
      let d = this.maskPass.fullscreenMaterial;
      (d.maskFunction = SP.MULTIPLY),
        (d.colorChannel = _P.GREEN),
        (this.bokehNearBasePass = new Va(new Wf(!1, !0))),
        (this.bokehNearBasePass.fullscreenMaterial.cocBuffer =
          this.renderTargetCoCBlurred.texture),
        (this.bokehNearFillPass = new Va(new Wf(!0, !0))),
        (this.bokehNearFillPass.fullscreenMaterial.cocBuffer =
          this.renderTargetCoCBlurred.texture),
        (this.bokehFarBasePass = new Va(new Wf(!1, !1))),
        (this.bokehFarBasePass.fullscreenMaterial.cocBuffer =
          this.renderTargetCoC.texture),
        (this.bokehFarFillPass = new Va(new Wf(!0, !1))),
        (this.bokehFarFillPass.fullscreenMaterial.cocBuffer =
          this.renderTargetCoC.texture),
        (this.target = null),
        (this.bokehScale = o);
    }
    get cocTexture() {
      return this.renderTargetCoC.texture;
    }
    get cocMaterial() {
      return this.cocPass.fullscreenMaterial;
    }
    get circleOfConfusionMaterial() {
      return this.cocMaterial;
    }
    getCircleOfConfusionMaterial() {
      return this.circleOfConfusionMaterial;
    }
    getBlurPass() {
      return this.blurPass;
    }
    get resolution() {
      return this.blurPass.getResolution();
    }
    getResolution() {
      return this.blurPass.getResolution();
    }
    get bokehScale() {
      return this.uniforms.get("scale").value;
    }
    set bokehScale(e) {
      let t = [
        this.bokehNearBasePass,
        this.bokehNearFillPass,
        this.bokehFarBasePass,
        this.bokehFarFillPass,
      ];
      for (let i of t) i.fullscreenMaterial.setScale(e);
      this.maskPass.fullscreenMaterial.setStrength(e),
        (this.uniforms.get("scale").value = e);
    }
    getBokehScale() {
      return this.bokehScale;
    }
    setBokehScale(e) {
      this.bokehScale = e;
    }
    getTarget() {
      return this.target;
    }
    setTarget(e) {
      this.target = e;
    }
    calculateFocusDistance(e) {
      let t = this.camera,
        i = t.position.distanceTo(e);
      return U1(-i, t.near, t.far);
    }
    setDepthTexture(e, t = Eo) {
      (this.circleOfConfusionMaterial.depthBuffer = e),
        (this.circleOfConfusionMaterial.depthPacking = t);
    }
    update(e, t, i) {
      let r = this.renderTarget,
        s = this.renderTargetCoC,
        a = this.renderTargetCoCBlurred,
        n = this.renderTargetMasked;
      if (this.target !== null) {
        let o = this.calculateFocusDistance(this.target);
        this.circleOfConfusionMaterial.focusDistance = o;
      }
      this.cocPass.render(e, null, s),
        this.blurPass.render(e, s, a),
        this.maskPass.render(e, t, n),
        this.bokehFarBasePass.render(e, n, r),
        this.bokehFarFillPass.render(e, r, this.renderTargetFar),
        this.bokehNearBasePass.render(e, t, r),
        this.bokehNearFillPass.render(e, r, this.renderTargetNear);
    }
    setSize(e, t) {
      let i = this.resolution;
      i.setBaseSize(e, t);
      let r = i.width,
        s = i.height,
        a = [
          this.cocPass,
          this.blurPass,
          this.maskPass,
          this.bokehNearBasePass,
          this.bokehNearFillPass,
          this.bokehFarBasePass,
          this.bokehFarFillPass,
        ];
      a.push(this.renderTargetCoC, this.renderTargetMasked),
        a.forEach((n) => n.setSize(e, t)),
        (a = [
          this.renderTarget,
          this.renderTargetNear,
          this.renderTargetFar,
          this.renderTargetCoCBlurred,
        ]),
        a.forEach((n) => n.setSize(r, s)),
        [
          this.bokehNearBasePass,
          this.bokehNearFillPass,
          this.bokehFarBasePass,
          this.bokehFarFillPass,
        ].forEach((n) => n.fullscreenMaterial.setSize(r, s));
    }
    initialize(e, t, i) {
      [
        this.cocPass,
        this.maskPass,
        this.bokehNearBasePass,
        this.bokehNearFillPass,
        this.bokehFarBasePass,
        this.bokehFarFillPass,
      ].forEach((r) => r.initialize(e, t, i)),
        this.blurPass.initialize(e, t, ys),
        i !== void 0 &&
          ((this.renderTarget.texture.type = i),
          (this.renderTargetNear.texture.type = i),
          (this.renderTargetFar.texture.type = i),
          (this.renderTargetMasked.texture.type = i),
          e.outputEncoding === jt &&
            ((this.renderTarget.texture.encoding = jt),
            (this.renderTargetNear.texture.encoding = jt),
            (this.renderTargetFar.texture.encoding = jt),
            (this.renderTargetMasked.texture.encoding = jt)));
    }
  },
  ate = new I(),
  nte = new je(),
  qX =
    "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
  YX = class extends kn {
    constructor({
      blendFunction: e = li.NORMAL,
      hue: t = 0,
      saturation: i = 0,
    } = {}) {
      super("HueSaturationEffect", qX, {
        blendFunction: e,
        uniforms: new Map([
          ["hue", new Ve(new I())],
          ["saturation", new Ve(i)],
        ]),
      }),
        (this.hue = t);
    }
    get saturation() {
      return this.uniforms.get("saturation").value;
    }
    set saturation(e) {
      this.uniforms.get("saturation").value = e;
    }
    getSaturation() {
      return this.saturation;
    }
    setSaturation(e) {
      this.saturation = e;
    }
    get hue() {
      let e = this.uniforms.get("hue").value;
      return Math.acos((e.x * 3 - 1) / 2);
    }
    set hue(e) {
      let t = Math.sin(e),
        i = Math.cos(e);
      this.uniforms
        .get("hue")
        .value.set(
          (2 * i + 1) / 3,
          (-Math.sqrt(3) * t - i + 1) / 3,
          (Math.sqrt(3) * t - i + 1) / 3
        );
    }
    getHue() {
      return this.hue;
    }
    setHue(e) {
      this.hue = e;
    }
  },
  ote = new Et(),
  XX = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,
  QX = class extends kn {
    constructor({ blendFunction: e = li.SCREEN, premultiply: t = !1 } = {}) {
      super("NoiseEffect", XX, { blendFunction: e }), (this.premultiply = t);
    }
    get premultiply() {
      return this.defines.has("PREMULTIPLY");
    }
    set premultiply(e) {
      this.premultiply !== e &&
        (e
          ? this.defines.set("PREMULTIPLY", "1")
          : this.defines.delete("PREMULTIPLY"),
        this.setChanged());
    }
    isPremultiplied() {
      return this.premultiply;
    }
    setPremultiplied(e) {
      this.premultiply = e;
    }
  },
  ZX =
    "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}",
  KX = class extends kn {
    constructor(e = 30) {
      super("PixelationEffect", ZX, {
        uniforms: new Map([
          ["active", new Ve(!1)],
          ["d", new Ve(new re())],
        ]),
      }),
        (this.resolution = new re()),
        (this.d = 0),
        (this.granularity = e);
    }
    get granularity() {
      return this.d;
    }
    set granularity(e) {
      let t = Math.floor(e);
      t % 2 > 0 && (t += 1),
        (this.d = t),
        (this.uniforms.get("active").value = t > 0),
        this.setSize(this.resolution.width, this.resolution.height);
    }
    getGranularity() {
      return this.granularity;
    }
    setGranularity(e) {
      this.granularity = e;
    }
    setSize(e, t) {
      this.resolution.set(e, t),
        this.uniforms.get("d").value.setScalar(this.d).divide(this.resolution);
    }
  },
  lte = Math.PI * 0.5,
  hte = new I(),
  cte = new I(),
  fM =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
  mM =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
  JX =
    "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
  $X =
    "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
  jl = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 },
  AP = class extends kn {
    constructor({
      preset: e = jl.MEDIUM,
      edgeDetectionMode: t = Ng.COLOR,
      predicationMode: i = XY.DISABLED,
    } = {}) {
      super("SMAAEffect", JX, {
        vertexShader: $X,
        blendFunction: li.NORMAL,
        attributes: Pn.CONVOLUTION | Pn.DEPTH,
        uniforms: new Map([["weightMap", new Ve(null)]]),
      });
      let r, s;
      arguments.length > 1 &&
        ((r = arguments[0]),
        (s = arguments[1]),
        arguments.length > 2 && (e = arguments[2]),
        arguments.length > 3 && (t = arguments[3])),
        (this.renderTargetEdges = new gi(1, 1, {
          minFilter: Wt,
          stencilBuffer: !1,
          depthBuffer: !1,
        })),
        (this.renderTargetEdges.texture.name = "SMAA.Edges"),
        (this.renderTargetWeights = this.renderTargetEdges.clone()),
        (this.renderTargetWeights.texture.name = "SMAA.Weights"),
        (this.uniforms.get("weightMap").value =
          this.renderTargetWeights.texture),
        (this.clearPass = new Eb(!0, !1, !1)),
        (this.clearPass.overrideClearColor = new Et(0)),
        (this.clearPass.overrideClearAlpha = 1),
        (this.edgeDetectionPass = new Va(new QY())),
        (this.edgeDetectionMaterial.edgeDetectionMode = t),
        (this.edgeDetectionMaterial.predicationMode = i),
        (this.weightsPass = new Va(new sX()));
      let a = new EC();
      (a.onLoad = () => {
        let n = new Yi(r);
        (n.name = "SMAA.Search"),
          (n.magFilter = mi),
          (n.minFilter = mi),
          (n.generateMipmaps = !1),
          (n.needsUpdate = !0),
          (n.flipY = !0),
          (this.weightsMaterial.searchTexture = n);
        let o = new Yi(s);
        (o.name = "SMAA.Area"),
          (o.magFilter = Wt),
          (o.minFilter = Wt),
          (o.generateMipmaps = !1),
          (o.needsUpdate = !0),
          (o.flipY = !1),
          (this.weightsMaterial.areaTexture = o),
          this.dispatchEvent({ type: "load" });
      }),
        a.itemStart("search"),
        a.itemStart("area"),
        r !== void 0 && s !== void 0
          ? (a.itemEnd("search"), a.itemEnd("area"))
          : typeof Image < "u" &&
            ((r = new Image()),
            (s = new Image()),
            r.addEventListener("load", () => a.itemEnd("search")),
            s.addEventListener("load", () => a.itemEnd("area")),
            (r.src = fM),
            (s.src = mM)),
        this.applyPreset(e);
    }
    get edgesTexture() {
      return this.renderTargetEdges.texture;
    }
    getEdgesTexture() {
      return this.edgesTexture;
    }
    get weightsTexture() {
      return this.renderTargetWeights.texture;
    }
    getWeightsTexture() {
      return this.weightsTexture;
    }
    get edgeDetectionMaterial() {
      return this.edgeDetectionPass.fullscreenMaterial;
    }
    get colorEdgesMaterial() {
      return this.edgeDetectionMaterial;
    }
    getEdgeDetectionMaterial() {
      return this.edgeDetectionMaterial;
    }
    get weightsMaterial() {
      return this.weightsPass.fullscreenMaterial;
    }
    getWeightsMaterial() {
      return this.weightsMaterial;
    }
    setEdgeDetectionThreshold(e) {
      this.edgeDetectionMaterial.edgeDetectionThreshold = e;
    }
    setOrthogonalSearchSteps(e) {
      this.weightsMaterial.orthogonalSearchSteps = e;
    }
    applyPreset(e) {
      let t = this.edgeDetectionMaterial,
        i = this.weightsMaterial;
      switch (e) {
        case jl.LOW:
          (t.edgeDetectionThreshold = 0.15),
            (i.orthogonalSearchSteps = 4),
            (i.diagonalDetection = !1),
            (i.cornerDetection = !1);
          break;
        case jl.MEDIUM:
          (t.edgeDetectionThreshold = 0.1),
            (i.orthogonalSearchSteps = 8),
            (i.diagonalDetection = !1),
            (i.cornerDetection = !1);
          break;
        case jl.HIGH:
          (t.edgeDetectionThreshold = 0.1),
            (i.orthogonalSearchSteps = 16),
            (i.diagonalSearchSteps = 8),
            (i.cornerRounding = 25),
            (i.diagonalDetection = !0),
            (i.cornerDetection = !0);
          break;
        case jl.ULTRA:
          (t.edgeDetectionThreshold = 0.05),
            (i.orthogonalSearchSteps = 32),
            (i.diagonalSearchSteps = 16),
            (i.cornerRounding = 25),
            (i.diagonalDetection = !0),
            (i.cornerDetection = !0);
          break;
      }
    }
    setDepthTexture(e, t = Eo) {
      (this.edgeDetectionMaterial.depthBuffer = e),
        (this.edgeDetectionMaterial.depthPacking = t);
    }
    update(e, t, i) {
      this.clearPass.render(e, this.renderTargetEdges),
        this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
        this.weightsPass.render(
          e,
          this.renderTargetEdges,
          this.renderTargetWeights
        );
    }
    setSize(e, t) {
      this.edgeDetectionMaterial.setSize(e, t),
        this.weightsMaterial.setSize(e, t),
        this.renderTargetEdges.setSize(e, t),
        this.renderTargetWeights.setSize(e, t);
    }
    dispose() {
      let { searchTexture: e, areaTexture: t } = this.weightsMaterial;
      e !== null && t !== null && (e.dispose(), t.dispose()), super.dispose();
    }
    static get searchImageDataURL() {
      return fM;
    }
    static get areaImageDataURL() {
      return mM;
    }
  },
  eQ = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,
  qf = { DEFAULT: 0, ESKIL: 1 },
  tQ = class extends kn {
    constructor({
      blendFunction: e = li.NORMAL,
      technique: t = qf.DEFAULT,
      eskil: i = !1,
      offset: r = 0.5,
      darkness: s = 0.5,
    } = {}) {
      super("VignetteEffect", eQ, {
        blendFunction: e,
        defines: new Map([["VIGNETTE_TECHNIQUE", t.toFixed(0)]]),
        uniforms: new Map([
          ["offset", new Ve(r)],
          ["darkness", new Ve(s)],
        ]),
      });
    }
    get technique() {
      return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
    }
    set technique(e) {
      this.technique !== e &&
        (this.defines.set("VIGNETTE_TECHNIQUE", e.toFixed(0)),
        this.setChanged());
    }
    get eskil() {
      return this.technique === qf.ESKIL;
    }
    set eskil(e) {
      this.technique = e ? qf.ESKIL : qf.DEFAULT;
    }
    getTechnique() {
      return this.technique;
    }
    setTechnique(e) {
      this.technique = e;
    }
    get offset() {
      return this.uniforms.get("offset").value;
    }
    set offset(e) {
      this.uniforms.get("offset").value = e;
    }
    getOffset() {
      return this.offset;
    }
    setOffset(e) {
      this.offset = e;
    }
    get darkness() {
      return this.uniforms.get("darkness").value;
    }
    set darkness(e) {
      this.uniforms.get("darkness").value = e;
    }
    getDarkness() {
      return this.darkness;
    }
    setDarkness(e) {
      this.darkness = e;
    }
  },
  ute = [new Float32Array(3), new Float32Array(3)],
  dte = [
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
  ],
  pte = [
    [
      new Float32Array([0, 0, 0]),
      new Float32Array([1, 0, 0]),
      new Float32Array([1, 1, 0]),
      new Float32Array([1, 1, 1]),
    ],
    [
      new Float32Array([0, 0, 0]),
      new Float32Array([1, 0, 0]),
      new Float32Array([1, 0, 1]),
      new Float32Array([1, 1, 1]),
    ],
    [
      new Float32Array([0, 0, 0]),
      new Float32Array([0, 0, 1]),
      new Float32Array([1, 0, 1]),
      new Float32Array([1, 1, 1]),
    ],
    [
      new Float32Array([0, 0, 0]),
      new Float32Array([0, 1, 0]),
      new Float32Array([1, 1, 0]),
      new Float32Array([1, 1, 1]),
    ],
    [
      new Float32Array([0, 0, 0]),
      new Float32Array([0, 1, 0]),
      new Float32Array([0, 1, 1]),
      new Float32Array([1, 1, 1]),
    ],
    [
      new Float32Array([0, 0, 0]),
      new Float32Array([0, 0, 1]),
      new Float32Array([0, 1, 1]),
      new Float32Array([1, 1, 1]),
    ],
  ],
  fte = [new Float32Array(2), new Float32Array(2)],
  mte = new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]),
  gte = [
    new Float32Array([0, 0]),
    new Float32Array([0.25, -0.25]),
    new Float32Array([-0.25, 0.25]),
    new Float32Array([0.125, -0.125]),
    new Float32Array([-0.125, 0.125]),
  ],
  vte = [
    new Uint8Array([0, 0]),
    new Uint8Array([3, 0]),
    new Uint8Array([0, 3]),
    new Uint8Array([3, 3]),
    new Uint8Array([1, 0]),
    new Uint8Array([4, 0]),
    new Uint8Array([1, 3]),
    new Uint8Array([4, 3]),
    new Uint8Array([0, 1]),
    new Uint8Array([3, 1]),
    new Uint8Array([0, 4]),
    new Uint8Array([3, 4]),
    new Uint8Array([1, 1]),
    new Uint8Array([4, 1]),
    new Uint8Array([1, 4]),
    new Uint8Array([4, 4]),
  ],
  yte = [
    new Uint8Array([0, 0]),
    new Uint8Array([1, 0]),
    new Uint8Array([0, 2]),
    new Uint8Array([1, 2]),
    new Uint8Array([2, 0]),
    new Uint8Array([3, 0]),
    new Uint8Array([2, 2]),
    new Uint8Array([3, 2]),
    new Uint8Array([0, 1]),
    new Uint8Array([1, 1]),
    new Uint8Array([0, 3]),
    new Uint8Array([1, 3]),
    new Uint8Array([2, 1]),
    new Uint8Array([3, 1]),
    new Uint8Array([2, 3]),
    new Uint8Array([3, 3]),
  ],
  xte = new Map([
    [cs(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
    [cs(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
    [cs(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
    [cs(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
    [cs(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
    [cs(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
    [cs(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
    [cs(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
    [cs(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
    [cs(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
    [cs(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
    [cs(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
    [cs(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
    [cs(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
    [cs(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
    [cs(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])],
  ]);
function B0(e, t, i) {
  return e + (t - e) * i;
}
function cs(e, t, i, r) {
  let s = B0(e, t, 0.75),
    a = B0(i, r, 1 - 0.25);
  return B0(s, a, 1 - 0.125);
}
var Co = class {
    constructor(e, t) {
      (this.enabled = !1),
        (this.effect = new e(t)),
        Object.defineProperty(this, "opacity", {
          enumerable: !0,
          set(i) {
            this.effect.blendMode.opacity.value = i;
          },
          get() {
            return this.effect.blendMode.opacity.value;
          },
        }),
        Object.defineProperty(this, "blendFunction", {
          enumerable: !0,
          set(i) {
            this.effect.blendMode.setBlendFunction(Number(i));
          },
          get() {
            return this.effect.blendMode.blendFunction;
          },
        }),
        (this.blendFunction = li.NORMAL);
    }
  },
  iQ = class extends Co {
    constructor() {
      super(zX), (this.blendFunction = li.SCREEN);
    }
    set intensity(e) {
      this.effect.intensity = e;
    }
    get intensity() {
      return this.effect.intensity;
    }
    set luminanceThreshold(e) {
      this.effect.luminanceMaterial.threshold = e;
    }
    get luminanceThreshold() {
      return this.effect.luminanceMaterial.threshold;
    }
    set luminanceSmoothing(e) {
      this.effect.luminanceMaterial.smoothing = e;
    }
    get luminanceSmoothing() {
      return this.effect.luminanceMaterial.smoothing;
    }
    set blurScale(e) {
      this.effect.blurPass.scale = e;
    }
    get blurScale() {
      return this.effect.blurPass.scale;
    }
    set kernelSize(e) {
      this.effect.blurPass.kernelSize = e;
    }
    get kernelSize() {
      return this.effect.blurPass.kernelSize;
    }
  },
  rQ = class extends Co {
    constructor() {
      super(kX);
    }
    set contrast(e) {
      this.effect.uniforms.get("contrast").value = e;
    }
    get contrast() {
      return this.effect.uniforms.get("contrast").value;
    }
    set brightness(e) {
      this.effect.uniforms.get("brightness").value = e;
    }
    get brightness() {
      return this.effect.uniforms.get("brightness").value;
    }
  },
  sQ = class extends Co {
    constructor() {
      super(HX), (this.effect.offset = new re(0.01, 0.01));
    }
    set offset(e) {
      this.effect.offset.set(e[0] / 1e3, e[1] / 1e3);
    }
    get offset() {
      return [this.effect.offset.x * 1e3, this.effect.offset.y * 1e3];
    }
  },
  aQ = class extends Co {
    constructor() {
      super(UX);
    }
  },
  nQ = class extends Co {
    constructor() {
      super(YX), (this._hue = 0);
    }
    set hue(e) {
      (this._hue = e), this.effect.setHue(e);
    }
    get hue() {
      return this._hue;
    }
    set saturation(e) {
      this.effect.uniforms.get("saturation").value = e;
    }
    get saturation() {
      return this.effect.uniforms.get("saturation").value;
    }
  },
  oQ = class extends Co {
    constructor() {
      super(QX), (this.blendFunction = li.OVERLAY);
    }
  },
  lQ = class extends Co {
    constructor() {
      super(tQ);
    }
    get eskil() {
      return this.effect.eskil;
    }
    set eskil(e) {
      this.effect.eskil = e;
    }
    get darkness() {
      return this.effect.uniforms.get("darkness").value;
    }
    set darkness(e) {
      this.effect.uniforms.get("darkness").value = e;
    }
    get offset() {
      return this.effect.uniforms.get("offset").value;
    }
    set offset(e) {
      this.effect.uniforms.get("offset").value = e;
    }
  },
  hQ = class extends Co {
    constructor(e) {
      super(WX, e);
    }
    set focalLength(e) {
      this.effect.circleOfConfusionMaterial.uniforms.focalLength.value = e;
    }
    get focalLength() {
      return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value;
    }
    set focusDistance(e) {
      this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value = e;
    }
    get focusDistance() {
      return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value;
    }
    get bokehScale() {
      return this.effect.bokehScale;
    }
    set bokehScale(e) {
      this.effect.bokehScale = e;
    }
  },
  cQ = class extends Co {
    constructor() {
      super(KX);
    }
    get granularity() {
      return this.effect.getGranularity();
    }
    set granularity(e) {
      this.effect.setGranularity(e);
    }
  },
  uQ = `#define GLSLIFY 1
varying vec2 vUv;varying vec2 vTexCoords[9];uniform vec2 resolution;void main(){vUv=position.xy*0.5+0.5;vec2 texelSize=vec2(1.0)/resolution;vTexCoords[0]=vUv+vec2(-texelSize.x,-texelSize.y);vTexCoords[1]=vUv+vec2(0.0,-texelSize.y);vTexCoords[2]=vUv+vec2(texelSize.x,-texelSize.y);vTexCoords[3]=vUv+vec2(-texelSize.x,0.0);vTexCoords[4]=vUv+vec2(0.0,0.0);vTexCoords[5]=vUv+vec2(texelSize.x,0.0);vTexCoords[6]=vUv+vec2(-texelSize.x,texelSize.y);vTexCoords[7]=vUv+vec2(0.0,texelSize.y);vTexCoords[8]=vUv+vec2(texelSize.x,texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}`,
  dQ = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;varying vec2 vTexCoords[9];uniform sampler2D inputBuffer;uniform sampler2D historyBuffer;uniform sampler2D velocityBuffer;uniform sampler2D depthBuffer;uniform vec2 resolution;
#define USE_YCOCG
#define USE_CATMULL_ROM
const float feedback_min=0.5;const float feedback_max=0.95;vec3 RGB_YCoCg(vec3 c){return vec3(c.x/4.0+c.y/2.0+c.z/4.0,c.x/2.0-c.z/2.0,-c.x/4.0+c.y/2.0-c.z/4.0);}vec3 YCoCg_RGB(vec3 c){return clamp(vec3(c.x+c.y-c.z,c.x+c.z,c.x-c.y-c.z),vec3(0.0),vec3(1.0));}vec4 sample_color(sampler2D tex,vec2 uv){
#ifdef USE_YCOCG
vec4 c=texture(tex,uv);return vec4(RGB_YCoCg(c.rgb),c.a);
#else
return texture(tex,uv);
#endif
}vec4 sample_catmull_rom(sampler2D tex,vec2 uv,vec2 texSize){vec2 samplePos=uv*texSize;vec2 texPos1=floor(samplePos-0.5)+0.5;vec2 f=samplePos-texPos1;vec2 w0=f*(-0.5+f*(1.0-0.5*f));vec2 w1=1.0+f*f*(-2.5+1.5*f);vec2 w2=f*(0.5+f*(2.0-1.5*f));vec2 w3=f*f*(-0.5+0.5*f);vec2 w12=w1+w2;vec2 offset12=w2/(w1+w2);vec2 texPos0=texPos1-1.0;vec2 texPos3=texPos1+2.0;vec2 texPos12=texPos1+offset12;texPos0/=texSize;texPos3/=texSize;texPos12/=texSize;vec4 result=vec4(0.0);result+=texture2D(tex,vec2(texPos12.x,texPos0.y))*w12.x*w0.y;result+=texture2D(tex,vec2(texPos0.x,texPos12.y))*w0.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos12.y))*w12.x*w12.y;result+=texture2D(tex,vec2(texPos3.x,texPos12.y))*w3.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos3.y))*w12.x*w3.y;return result;}vec3 choose_motion_vector(){
#ifdef CHOOSE_LONGEST_MOTION_VECTOR
float longest=-1.0;vec3 v_choose=vec3(-1.0);for(int i=0;i<9;i++){vec3 v=texture2D(velocityBuffer,vTexCoords[i]).rgb;float l=length(v.xy);if(l>longest){longest=l;v_choose=v;}}return v_choose;
#else
float closest_depth=1000.0;vec2 closest_uv_offset=vec2(0.0);for(int i=0;i<9;i++){float neighbor_depth=texture2D(depthBuffer,vTexCoords[i]).r;if(neighbor_depth<closest_depth){closest_uv_offset=vTexCoords[i];closest_depth=neighbor_depth;}}return texture2D(velocityBuffer,closest_uv_offset).rgb;
#endif
}vec4 clipAabb(vec3 aabb_min,vec3 aabb_max,vec4 avg,vec4 input_texel){const float FLT_EPS=0.00000001;vec3 p_clip=0.5*(aabb_max+aabb_min);vec3 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=input_texel-vec4(p_clip,avg.w);vec3 v_unit=v_clip.xyz/e_clip;vec3 a_unit=abs(v_unit);float ma_unit=max(a_unit.x,max(a_unit.y,a_unit.z));if(ma_unit>1.0){return vec4(p_clip,avg.w)+v_clip/ma_unit;}else{return input_texel;}}vec3 clip_aabb_variance(in vec3 cOld,in vec3 cNew,in vec3 centre,in vec3 halfSize){if(all(lessThanEqual(abs(cOld-centre),halfSize))){return cOld;}vec3 dir=(cNew-cOld);vec3 near=centre-sign(dir)*halfSize;vec3 tAll=(near-cOld)/dir;float t=0.0001;for(int i=0;i<3;i++){if(tAll[i]>=0.0&&tAll[i]<t){t=tAll[i];}}if(t>=0.0001){return cOld;}return cOld+dir*t;}void main(){vec3 v=choose_motion_vector();vec2 velocity=v.rg;vec2 previousPixelPos=vUv-velocity;vec4 currentColor=sample_color(inputBuffer,vUv);
#ifdef USE_CATMULL_ROM
vec4 previousColor=sample_catmull_rom(historyBuffer,previousPixelPos,resolution);
#else
vec4 previousColor=sample_color(historyBuffer,previousPixelPos);
#endif
#ifdef USE_YCOCG
previousColor=vec4(RGB_YCoCg(previousColor.rgb),previousColor.a);
#endif
vec4 ctl=sample_color(inputBuffer,vTexCoords[0]);vec4 ctc=sample_color(inputBuffer,vTexCoords[1]);vec4 ctr=sample_color(inputBuffer,vTexCoords[2]);vec4 cml=sample_color(inputBuffer,vTexCoords[3]);vec4 cmc=sample_color(inputBuffer,vTexCoords[4]);vec4 cmr=sample_color(inputBuffer,vTexCoords[5]);vec4 cbl=sample_color(inputBuffer,vTexCoords[6]);vec4 cbc=sample_color(inputBuffer,vTexCoords[7]);vec4 cbr=sample_color(inputBuffer,vTexCoords[8]);vec4 cmin=min(ctl,min(ctc,min(ctr,min(cml,min(cmc,min(cmr,min(cbl,min(cbc,cbr))))))));vec4 cmax=max(ctl,max(ctc,max(ctr,max(cml,max(cmc,max(cmr,max(cbl,max(cbc,cbr))))))));vec4 cavg=(ctl+ctc+ctr+cml+cmc+cmr+cbl+cbc+cbr)/9.0;vec4 cmin5=min(ctc,min(cml,min(cmc,min(cmr,cbc))));vec4 cmax5=max(ctc,max(cml,max(cmc,max(cmr,cbc))));vec4 cavg5=(ctc+cml+cmc+cmr+cbc)/5.0;cmin=0.5*(cmin+cmin5);cmax=0.5*(cmax+cmax5);cavg=0.5*(cavg+cavg5);
#ifdef USE_YCOCG
vec2 chroma_extent=vec2(0.25*0.5*(cmax.r-cmin.r));vec2 chroma_center=currentColor.gb;cmin.yz=chroma_center-chroma_extent;cmax.yz=chroma_center+chroma_extent;cavg.yz=chroma_center;
#endif
vec4 previousColorClipped=clamp(previousColor,cmin,cmax);
#ifdef LUMINANCE_DIFFERENCES
#ifdef USE_YCOCG
float lum0=currentColor.r;float lum1=previousColorClipped.r;
#else
float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColorClipped.rgb);
#endif
float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.0-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedback_min,feedback_max,unbiased_weight_sqr);vec4 result=mix(currentColor,previousColorClipped,vec4(k_feedback));
#else
const float alpha=0.1;vec4 result=mix(currentColor,previousColorClipped,1.0-alpha);
#endif
#ifdef USE_YCOCG
gl_FragColor=vec4(YCoCg_RGB(result.rgb).rgb,result.a);
#else
gl_FragColor=result;
#endif
}`,
  pQ = `#define GLSLIFY 1
varying vec2 vUv;void main(){gl_Position=vec4(position.xy,1.0,1.0);vUv=position.xy*0.5+0.5;}`,
  fQ = `#define GLSLIFY 1
layout(location=1)out vec4 gVelocity;varying vec2 vUv;uniform sampler2D inputBuffer;void main(){gl_FragColor=texture2D(inputBuffer,vUv);gVelocity=vec4(0.0);}`,
  H1 = class extends vi {
    constructor() {
      super({
        name: "PassthroughMaterial",
        uniforms: { inputBuffer: new Ve(null) },
        blending: wr,
        depthWrite: !1,
        depthTest: !1,
        vertexShader: pQ,
        fragmentShader: fQ,
      });
    }
    set inputBuffer(e) {
      this.uniforms.inputBuffer.value = e;
    }
  },
  mQ = class extends Ls {
    constructor() {
      super("TAAResolvePass"),
        (this.MRTCompatible = !0),
        (this.needsSwap = !1),
        (this.passThroughMaterial = new H1()),
        (this.resolutionVector = new re()),
        (this.resolveMaterial = new vi({
          name: "TAAResolveMaterial",
          uniforms: {
            inputBuffer: new Ve(null),
            historyBuffer: new Ve(null),
            velocityBuffer: new Ve(null),
            depthBuffer: new Ve(null),
            resolution: new Ve(new re()),
          },
          blending: wr,
          depthWrite: !1,
          depthTest: !1,
          vertexShader: uQ,
          fragmentShader: dQ,
        })),
        (this.historyRenderTarget = new gi(1024, 1024, {
          minFilter: Wt,
          stencilBuffer: !1,
          depthBuffer: !1,
        })),
        (this.historyRenderTarget.texture.name = "TAA.History"),
        (this.resultRenderTarget = new gi(1024, 1024, {
          minFilter: Wt,
          stencilBuffer: !1,
          depthBuffer: !1,
        })),
        (this.resultRenderTarget.texture.name = "TAA.Output");
    }
    setSize(e, t) {
      this.historyRenderTarget.setSize(e, t),
        this.resultRenderTarget.setSize(e, t);
    }
    render(e, t) {
      (this.fullscreenMaterial = this.resolveMaterial),
        (this.resolveMaterial.uniforms.inputBuffer.value = t.texture[0]),
        (this.resolveMaterial.uniforms.velocityBuffer.value = t.texture[1]),
        (this.resolveMaterial.uniforms.depthBuffer.value = t.depthTexture),
        (this.resolveMaterial.uniforms.historyBuffer.value =
          this.historyRenderTarget.texture),
        this.resolveMaterial.uniforms.resolution.value.set(t.width, t.height),
        e.setRenderTarget(this.resultRenderTarget),
        e.render(this.scene, this.camera),
        (this.fullscreenMaterial = this.passThroughMaterial),
        (this.passThroughMaterial.inputBuffer =
          this.resultRenderTarget.texture),
        e.setRenderTarget(this.historyRenderTarget),
        e.render(this.scene, this.camera);
      let i = this.renderToScreen ? null : t;
      (this.fullscreenMaterial = this.passThroughMaterial),
        (this.passThroughMaterial.inputBuffer =
          this.resultRenderTarget.texture),
        e.setRenderTarget(i),
        e.render(this.scene, this.camera);
    }
    dispose() {
      this.resultRenderTarget.dispose(),
        this.historyRenderTarget.dispose(),
        this.resolveMaterial.dispose(),
        this.passThroughMaterial.dispose();
    }
  },
  gQ = class extends Ls {
    constructor(e, t, i) {
      super("TransmissionPass", void 0, t),
        (this.MRTCompatible = !0),
        (this.depthPass = new dM(e, t, {
          renderTarget: i.transmissionDepthTarget,
        })),
        (this.passThroughMaterial = new H1()),
        (this.splineScene = e),
        (this.needsSwap = !1);
    }
    updatePasses(e) {
      (this.passThroughMaterial = new H1()),
        (this.depthPass = new dM(this.splineScene, this.camera, {
          renderTarget: e.transmissionDepthTarget,
        }));
    }
    setCamera(e) {
      this.camera = e;
    }
    setScene(e) {
      this.splineScene = e;
    }
    render(e, t, i) {
      let r = this.camera.layers.mask,
        s = e;
      s.setRenderTarget(s.transmissionRenderTarget),
        (this.fullscreenMaterial = this.passThroughMaterial),
        (this.passThroughMaterial.inputBuffer = t.texture[0]),
        s.clear(),
        s.render(this.scene, this.camera),
        this.camera.layers.disable(3),
        this.depthPass.render(e, t, i),
        (s.shadowMap.needsUpdate = !1),
        (s.shadowMap.autoUpdate = !1);
      let a = this.renderToScreen ? null : t;
      this.camera.layers.set(3),
        e.setRenderTarget(a),
        e.render(this.splineScene, this.camera),
        (this.camera.layers.mask = r);
    }
  },
  gM = new xo(),
  vQ = new vi({
    transparent: !0,
    vertexShader: `
        void main() {
            gl_Position = vec4(0.0);
        }
    `,
    fragmentShader: `
        layout(location = 1) out vec4 gVelocity;

        void main() {
            gl_FragColor = vec4(0.0);
			gVelocity = vec4(0.0);
        }
    `,
  }),
  G1 = class extends Ls {
    constructor(e, t, i) {
      super("OpaquePass", t ?? gM, i),
        (this.MRTCompatible = !0),
        (this.hasTransmissionPass = !1),
        (this.clear = !0),
        (this.clearColorOnly = !1),
        (this.clearDepth = !1),
        (this.needsSwap = !1),
        (this.originalMaterials = new Map()),
        (this.MRTCompatible = e);
    }
    set splatViewer(e) {
      this._splatViewer = e;
    }
    get splatViewer() {
      return this._splatViewer;
    }
    setCamera(e) {
      this.camera = e;
    }
    setScene(e) {
      this.scene = e ?? gM;
    }
    getScene() {
      return this.scene;
    }
    render(e, t) {
      this.camera.layers.enable(3),
        this.hasTransmissionPass &&
          (this.originalMaterials.clear(),
          this.scene.traverse((r) => {
            r.layers.isEnabled(3) &&
              r instanceof Is &&
              (this.originalMaterials.set(r.id, r.material), (r.material = vQ));
          }),
          (e.shadowMap.needsUpdate = !0),
          (e.shadowMap.autoUpdate = !0)),
        this.camera.layers.enable(8);
      let i = this.renderToScreen ? null : t;
      if (
        (e.setRenderTarget(i),
        this.clearColorOnly && e.clear(!0, !1, !0),
        this.clear && e.clear(),
        this._splatViewer?.splatRenderingInitialized === !0)
      ) {
        let r = e.autoClear;
        (e.autoClear = !1),
          e.render(this.scene, this.camera),
          this._splatViewer.update(),
          e.render(this._splatViewer.splatMesh, this.camera),
          (e.autoClear = r);
      } else e.render(this.scene, this.camera);
      this.clearDepth && e.clear(!1, !0, !1),
        this.hasTransmissionPass &&
          this.originalMaterials.forEach((r, s) => {
            let a = this.scene.getObjectById(s);
            a && (a.material = r);
          });
    }
  },
  yQ = class {
    constructor(
      e,
      {
        depthBuffer: t = !0,
        stencilBuffer: i = !1,
        multisampling: r = 0,
        frameBufferType: s = 0,
      } = {}
    ) {
      (this.renderer = e),
        (this.helperStartIndex = 0),
        (this.copyPass = new j1()),
        (this.depthTexture = null),
        (this.timer = new LX()),
        (this._width = 1),
        (this._height = 1),
        (this.passes = []),
        (this.helperPasses = []),
        (this.autoRenderToScreen = !0),
        (this.inputBuffer = this.createBuffer(
          t,
          i,
          s,
          r,
          !0,
          "input buffer mrt"
        )),
        (this.inputBufferSingle = this.createBuffer(
          t,
          i,
          s,
          r,
          !1,
          " input buffer single"
        )),
        this.inputBufferSingle.texture.dispose(),
        this.inputBufferSingle.depthTexture.dispose(),
        (this.inputBufferSingle.texture = this.inputBuffer.texture[0]),
        (this.inputBufferSingle.depthTexture = this.inputBuffer.depthTexture),
        (this.outputBuffer = this.inputBuffer.clone()),
        (this.outputBuffer.name = "output buffer mrt"),
        (this.outputBufferSingle = this.createBuffer(
          t,
          i,
          s,
          r,
          !1,
          "output buffer single"
        )),
        this.outputBufferSingle.texture.dispose(),
        this.outputBufferSingle.depthTexture.dispose(),
        (this.outputBufferSingle.texture = this.outputBuffer.texture[0]),
        (this.outputBufferSingle.depthTexture = this.outputBuffer.depthTexture),
        this.setRenderer(e);
    }
    get multisampling() {
      return this.inputBuffer.samples || 0;
    }
    set multisampling(e) {
      let t = this.inputBuffer,
        i = this.multisampling;
      i > 0 && e > 0
        ? ((this.inputBuffer.samples = e),
          (this.outputBuffer.samples = e),
          this.inputBuffer.dispose(),
          this.outputBuffer.dispose())
        : i !== e &&
          (this.inputBuffer.dispose(),
          this.outputBuffer.dispose(),
          console.log("creating new input buffer"),
          (this.inputBuffer = this.createBuffer(
            t.depthBuffer,
            t.stencilBuffer,
            t.texture.type,
            e,
            !0,
            "new input buffer"
          )),
          (this.inputBuffer.depthTexture = this.depthTexture),
          (this.outputBuffer = this.inputBuffer.clone()));
    }
    getTimer() {
      return this.timer;
    }
    getRenderer() {
      return this.renderer;
    }
    setRenderer(e) {
      if (((this.renderer = e), e !== null)) {
        let t = e.getSize(new re()),
          i = e.getContext().getContextAttributes()?.alpha ?? !1,
          r = this.inputBuffer.texture[0].type;
        r === ys &&
          e.outputEncoding === jt &&
          ((this.inputBuffer.texture[0].encoding = jt),
          (this.outputBuffer.texture[0].encoding = jt),
          this.inputBuffer.dispose(),
          this.outputBuffer.dispose(),
          console.log("doing some kinda dispose??")),
          (e.autoClear = !1),
          this.setSize(t.width, t.height, !1);
        for (let s of this.passes) s.initialize(e, i, r);
      }
    }
    replaceRenderer(e, t = !0) {
      let i = this.renderer,
        r = i.domElement.parentNode;
      return (
        this.setRenderer(e),
        t &&
          r !== null &&
          (r.removeChild(i.domElement), r.appendChild(e.domElement)),
        i
      );
    }
    createDepthTexture() {
      let e = (this.depthTexture = new Gc(this._width, this._height));
      return (
        (this.inputBuffer.depthTexture = e),
        this.inputBuffer.dispose(),
        this.inputBuffer.stencilBuffer
          ? ((e.format = hh), (e.type = $l))
          : (e.type = go),
        e
      );
    }
    deleteDepthTexture() {
      if (this.depthTexture !== null) {
        this.depthTexture.dispose(),
          (this.depthTexture = null),
          (this.inputBuffer.depthTexture = null),
          this.inputBuffer.dispose();
        for (let e of this.passes) e.setDepthTexture(null);
      }
    }
    createBuffer(e, t, i, r, s, a) {
      let n = this.renderer,
        o = n === null ? new re() : n.getDrawingBufferSize(new re()),
        l = {
          minFilter: Wt,
          magFilter: Wt,
          wrapS: Ui,
          wrapT: Ui,
          stencilBuffer: t,
          depthBuffer: e,
        },
        h;
      return (
        r > 0
          ? ((h = new gi(o.width, o.height, l)), (h.samples = r))
          : (s
              ? ((h = new rR(o.width, o.height, 2, l)),
                (h.texture[1].type = lh))
              : (h = new gi(o.width, o.height, l)),
            (h.depthTexture = new Gc(2048, 2048)),
            (h.depthTexture.type = xr)),
        i === ys &&
          n !== null &&
          n.outputEncoding === jt &&
          (Array.isArray(h.texture)
            ? h.texture.forEach((u) => (u.encoding = jt))
            : (h.texture.encoding = jt)),
        Array.isArray(h.texture)
          ? h.texture.forEach((u, c) => {
              (u.name = `EffectComposer.Buffer ${s} ${c}`),
                (u.generateMipmaps = !1);
            })
          : ((h.texture.name = `EffectComposer.Buffer ${s}`),
            (h.texture.generateMipmaps = !1)),
        (h.name = a),
        h
      );
    }
    addPass(e, t) {
      let i = this.passes,
        r = this.renderer,
        s = r.getDrawingBufferSize(new re()),
        a = r.getContext().getContextAttributes()?.alpha ?? !1,
        n;
      if (
        (e.MRTCompatible && (n = this.inputBuffer.texture[0].type),
        e.MRTCompatible || (n = this.inputBuffer.texture.type),
        e.setRenderer(r),
        e.setSize(s.width, s.height),
        e.initialize(r, a, n),
        this.autoRenderToScreen &&
          (i.length > 0 && (i[i.length - 1].renderToScreen = !1),
          e.renderToScreen && (this.autoRenderToScreen = !1)),
        t !== void 0 ? i.splice(t, 0, e) : i.push(e),
        this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !0),
        e.needsDepthTexture || this.depthTexture !== null)
      )
        if (this.depthTexture === null) {
          let o = this.createDepthTexture();
          for (e of i) e.setDepthTexture(o);
        } else e.setDepthTexture(this.depthTexture);
    }
    setHelperStartIndex(e) {
      this.helperStartIndex = e;
    }
    removePass(e) {
      let t = this.passes,
        i = t.indexOf(e);
      if (i !== -1 && t.splice(i, 1).length > 0) {
        if (this.depthTexture !== null) {
          let r = (s, a) => s || a.needsDepthTexture;
          t.reduce(r, !1) ||
            (e.getDepthTexture() === this.depthTexture &&
              e.setDepthTexture(null),
            this.deleteDepthTexture());
        }
        this.autoRenderToScreen &&
          i === t.length &&
          ((e.renderToScreen = !1),
          t.length > 0 && (t[t.length - 1].renderToScreen = !0));
      }
    }
    removeAllPasses() {
      let e = this.passes;
      this.deleteDepthTexture(),
        e.length > 0 &&
          (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1),
          (this.passes = []));
    }
    render(e) {
      let t = this.renderer,
        i = this.copyPass,
        r = this.inputBuffer,
        s = this.outputBuffer,
        a = this.inputBufferSingle,
        n = this.outputBufferSingle,
        o = !1,
        l,
        h,
        u,
        c;
      e === void 0 && (e = this.timer.update().getDelta());
      for (let d of this.passes)
        d.enabled &&
          (d.MRTCompatible ? d.render(t, r, s, e, o) : d.render(t, a, n, e, o),
          d.needsSwap &&
            (o &&
              ((i.renderToScreen = d.renderToScreen),
              (l = t.getContext()),
              (h = t.state.buffers.stencil),
              h.setFunc(l.NOTEQUAL, 1, 4294967295),
              i.render(t, r, s, e, o),
              h.setFunc(l.EQUAL, 1, 4294967295)),
            (u = r),
            (c = a),
            (r = s),
            (a = n),
            (s = u),
            (n = c)),
          d instanceof IX ? (o = !0) : d instanceof oX && (o = !1));
    }
    setSize(e, t, i) {
      let r = this.renderer;
      if (
        ((this._width = e), (this._height = t), e === void 0 || t === void 0)
      ) {
        let a = r.getSize(new re());
        (e = a.width), (t = a.height);
      }
      r.setSize(e, t, i);
      let s = r.getDrawingBufferSize(new re());
      this.inputBuffer.setSize(s.width, s.height),
        this.outputBuffer.setSize(s.width, s.height),
        this.inputBufferSingle.setSize(s.width, s.height),
        this.outputBufferSingle.setSize(s.width, s.height);
      for (let a of this.passes) a.setSize(s.width, s.height);
    }
    reset() {
      let e = this.timer.isAutoResetEnabled();
      this.dispose(),
        (this.autoRenderToScreen = !0),
        this.timer.setAutoResetEnabled(e);
    }
    dispose() {
      for (let e of this.passes) e.dispose();
      (this.passes = []),
        this.inputBuffer !== null && this.inputBuffer.dispose(),
        this.outputBuffer !== null && this.outputBuffer.dispose(),
        this.inputBufferSingle !== null && this.inputBufferSingle.dispose(),
        this.outputBufferSingle !== null && this.outputBufferSingle.dispose(),
        this.deleteDepthTexture(),
        this.copyPass.dispose(),
        this.timer.dispose();
    }
  },
  xQ = new vi({
    name: "CombineMaterial",
    uniforms: { inputBufferA: new Ve(null), inputBufferB: new Ve(null) },
    blending: wr,
    depthWrite: !1,
    depthTest: !1,
    vertexShader: `
varying vec2 vUv;
void main() {
    gl_Position = vec4(position.xy, 1.0, 1.0);
    vUv = position.xy * 0.5 + 0.5;
}
`,
    fragmentShader: `
    varying vec2 vUv;
    uniform sampler2D inputBufferA;
    uniform sampler2D inputBufferB;

    // TODO: Why do we need these when postpro of framemode is enabled???
    layout(location = 1) out vec4 gVelocity;

    void main() {
	vec4 resA = texture2D(inputBufferA, vUv);
	vec4 resB = texture2D(inputBufferB, vUv);
    float a = resA.a + resB.a * ( 1.0 - resA.a );

	vec4 res;
	res.rgb =  resA.rgb + (resB.rgb * (1.0 - resA.a));
	res.a = resA.a + resB.a * (1.0 - resA.a);
	gl_FragColor = res;
    gVelocity = vec4(0.0);
    }
`,
  }),
  bQ = class extends Ls {
    constructor(e) {
      super("HelperPass", void 0, e),
        (this.MRTCompatible = !1),
        (this.fullscreenMaterial = xQ),
        (this.helperPass = new G1(!1, void 0, this.camera)),
        (this.helperPass.hasTransmissionPass = !1),
        (this.helperPass.clear = !1),
        (this.helperPass.renderToScreen = !1),
        (this.helperPassOnTop = new G1(!1, void 0, this.camera)),
        (this.helperPassOnTop.hasTransmissionPass = !1),
        (this.helperPassOnTop.clear = !1),
        (this.helperPassOnTop.renderToScreen = !1);
      let t = new AP({ preset: jl.LOW, edgeDetectionMode: Ng.COLOR });
      (this.effectPass = new ug(this.camera, t)),
        (this.rt = new gi(10, 10, {
          minFilter: Wt,
          magFilter: Wt,
          wrapS: Ui,
          wrapT: Ui,
          depthBuffer: !0,
        }));
    }
    setSize(e, t) {
      this.rt.setSize(e, t), this.effectPass.setSize(e, t);
    }
    set sceneHelpers(e) {
      this.helperPass.setScene(e);
    }
    get sceneHelpers() {
      return this.helperPass.getScene();
    }
    set sceneHelpersOnTop(e) {
      this.helperPassOnTop.setScene(e);
    }
    get sceneHelpersOnTop() {
      return this.helperPassOnTop.getScene();
    }
    setCamera(e) {
      this.helperPass.setCamera(e), this.helperPassOnTop.setCamera(e);
    }
    initialize(e, t, i) {
      super.initialize(e, t, i), this.effectPass.initialize(e, t, i);
    }
    dispose() {
      super.dispose(), this.rt.dispose(), this.effectPass.dispose();
    }
    render(e, t, i) {
      this.rt.depthTexture = t.depthTexture;
      let r = e.getClearAlpha();
      e.setClearAlpha(0),
        (this.helperPass.clearDepth = !0),
        (this.helperPass.clearColorOnly = !0),
        this.helperPass.render(e, this.rt),
        this.helperPassOnTop.render(e, this.rt),
        (this.effectPass.renderToScreen = !1),
        this.effectPass.render(e, this.rt, i),
        (this.fullscreenMaterial.uniforms.inputBufferA.value = i.texture),
        (this.fullscreenMaterial.uniforms.inputBufferB.value = t.texture),
        e.setClearAlpha(r),
        e.setRenderTarget(null),
        e.clear(),
        e.render(this.scene, this.camera);
    }
  },
  wQ = `#define GLSLIFY 1
#include <skinning_pars_vertex>
out vec3 n;void main(){
#include <beginnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <skinning_vertex>
vec4 view_space=viewMatrix*modelMatrix*vec4(transformed,1.0);gl_Position=projectionMatrix*view_space;n=normalize(transformedNormal);}`,
  _Q = `#define GLSLIFY 1
in vec3 n;void main(){gl_FragColor=vec4(n,1.0);}`,
  SQ = `#define GLSLIFY 1
out vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy,1.0,1.0);}`,
  AQ = `#define GLSLIFY 1
in vec2 v_uv;const float pi=3.14159265;const float num_steps=4.0;const float num_directions=4.0;uniform float near;uniform float far;uniform float fov;uniform vec4 proj_info;uniform bool is_ortho;uniform vec2 resolution;uniform float radius_of_influence;uniform float radius_in_screen_space;uniform float exponent;uniform vec3 ao_color;uniform float bias;uniform sampler2D texture_depth;uniform sampler2D texture_normals;uniform sampler2D texture_blue_noise;uniform sampler2D texture_blue_noise_in_disk;uniform sampler2D texture_color_pass;uniform int frame_index;uniform bool fog_enabled;uniform float fog_near;uniform float fog_far;vec3 uv_to_view_space(vec2 uv,float eye_z){return vec3((uv*proj_info.xy+proj_info.zw)*(is_ortho ? 1.0 : eye_z),eye_z);}float linearize_depth(float depth_sampled){float z=is_ortho ? depth_sampled : depth_sampled*2.0-1.0;return mix((2.0*near*far)/(far+near-z*(far-near)),near+z*(far-near),float(is_ortho));}vec3 get_view_position(vec2 uv_coords){float linear_depth=linearize_depth(texture(texture_depth,uv_coords).x);return uv_to_view_space(uv_coords,linear_depth);}vec3 min_difference(vec3 p,vec3 right,vec3 left){vec3 v1=right-p;vec3 v2=p-left;return(dot(v1,v1)<dot(v2,v2))? v1 : v2;}vec3 rebuild_normal(in vec2 uv,in vec3 p){vec2 one_over_resolution=1.0/resolution;vec3 r=get_view_position(uv+vec2(one_over_resolution.x,0));vec3 l=get_view_position(uv+vec2(-one_over_resolution.x,0));vec3 t=get_view_position(uv+vec2(0,one_over_resolution.y));vec3 b=get_view_position(uv+vec2(0,-one_over_resolution.y));return normalize(cross(min_difference(p,r,l),min_difference(p,t,b)));}float falloff(float distance_squared){float neg_inv_r2=-1.0/(radius_of_influence*radius_of_influence);return distance_squared*neg_inv_r2+1.0;}float ao_contribution(vec3 P,vec3 N,vec3 S){vec3 to_sample=S-P;float norm_squared=dot(to_sample,to_sample);float norm=sqrt(norm_squared);float cos_theta=dot(N,to_sample)/norm;return clamp(cos_theta-bias,0.0,1.0)*clamp(falloff(norm_squared),0.0,1.0);}float compute_ambient_occlusion(vec2 uv,float radius_in_screen_space,vec3 pc,vec3 view_space_n){vec2 one_over_resolution=1.0/resolution;ivec2 noise_uv=ivec2(int(mod(gl_FragCoord.x,128.0)),int(mod(gl_FragCoord.y,128.0)));float noise=texelFetch(texture_blue_noise,noise_uv,0).r;noise=fract(noise+0.61803398875*float(frame_index));float theta=noise*2.0*3.1415;float ct=cos(theta);float st=sin(theta);float step_size=radius_in_screen_space/(num_steps+1.0);const float angle_step=2.0*pi/num_directions;float contribution=0.0;for(int i=0;i<int(num_directions);++i){float current_pixel=step_size+1.0;for(int j=0;j<int(num_steps);++j){int index=i*int(num_steps)+j;vec2 blue_noise_sample=texelFetch(texture_blue_noise_in_disk,ivec2(index,0),0).rg;vec2 disk_point;disk_point.x=blue_noise_sample.x*ct-blue_noise_sample.y*st;disk_point.y=blue_noise_sample.x*st+blue_noise_sample.y*ct;vec2 sample_direction=disk_point;vec2 snapped_uv=round(current_pixel*sample_direction)*one_over_resolution+uv;vec3 ps=get_view_position(snapped_uv);current_pixel+=step_size;contribution+=ao_contribution(pc,view_space_n,ps);}}float mult=1.0/(1.0-bias);contribution*=mult/(num_directions*num_steps);return clamp(1.0-contribution*2.0,0.0,1.0);}
#define USE_GBUFFER_NORMALS
void main(){vec3 view_space_p=get_view_position(v_uv);
#ifdef USE_GBUFFER_NORMALS
vec3 view_space_n=texture(texture_normals,v_uv).rgb;view_space_n.z*=-1.0;
#else
vec3 view_space_n=-rebuild_normal(v_uv,view_space_p);
#endif
float radius_ss=radius_in_screen_space/(is_ortho ? 1.0 : view_space_p.z);float ao=compute_ambient_occlusion(v_uv,radius_ss,view_space_p,view_space_n);float final=pow(ao,exponent);if(view_space_p.z>=far){final=1.0;}vec3 color=mix(ao_color,vec3(1.0),final);if(fog_enabled){float fog_factor=smoothstep(fog_near,fog_far,view_space_p.z);color=mix(color,vec3(1.0),fog_factor);}gl_FragColor=vec4(color,1.0);}`,
  MQ = `#define GLSLIFY 1
out vec2 v_uv;void main(){gl_Position=vec4(position.xy,1.0,1.0);v_uv=uv;}`,
  EQ = `#define GLSLIFY 1
in vec2 v_uv;uniform sampler2D texture_ao_lrez;uniform sampler2D texture_depth_lrez;uniform sampler2D texture_depth_hrez;uniform float near;uniform float far;float linearize_depth(float depth_sampled){float z=depth_sampled*2.0-1.0;return(2.0*near*far)/(far+near-z*(far-near));}vec2 nearest_depth_filter(in vec2 uv){vec2 resolution=vec2(textureSize(texture_depth_lrez,0));vec2 texel_size=1.0/resolution;vec2 offset=uv-0.5*texel_size;float d_hrez=texture(texture_depth_hrez,uv).r;float a=abs(d_hrez-texture(texture_depth_lrez,offset).r);float b=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,0.0)).r);float c=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(0.0,texel_size.y)).r);float d=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,texel_size.y)).r);float min_diff=min(a,min(b,min(c,d)));if(min_diff==a)return offset;if(min_diff==b)return offset+vec2(texel_size.x,0.0);if(min_diff==c)return offset+vec2(0.0,texel_size.y);if(min_diff==d)return offset+vec2(texel_size.x,texel_size.y);}void main(){
#ifdef DEBUG
float d_lrez=texture(texture_depth_lrez,v_uv).r;float d_hrez=texture(texture_depth_hrez,v_uv).r;float output_d=mix(linearize_depth(d_lrez)/far,linearize_depth(d_hrez)/far,step(0.5,v_uv.x));gl_FragColor=vec4(vec3(output_d),1.0);
#else
vec2 filtered_uv=nearest_depth_filter(v_uv);vec4 ao=texture(texture_ao_lrez,filtered_uv);gl_FragColor=vec4(ao.rgb,1.0);gl_FragColor=ao;
#endif
}`,
  id = [
    [0.478712, 0.875764],
    [-0.337956, -0.793959],
    [-0.955259, -0.028164],
    [0.864527, 0.325689],
    [0.209342, -0.395657],
    [-0.106779, 0.672585],
    [0.156213, 0.235113],
    [-0.413644, -0.082856],
    [-0.415667, 0.323909],
    [0.141896, -0.93998],
    [0.954932, -0.182516],
    [-0.766184, 0.410799],
    [-0.434912, -0.458845],
    [0.415242, -0.078724],
    [0.728335, -0.491777],
    [-0.058086, -0.066401],
    [0.20299, 0.686837],
    [-0.808362, -0.556402],
    [0.507386, -0.640839],
    [-0.723494, -0.22924],
    [0.48974, 0.317826],
    [-0.622663, 0.765301],
    [-0.01064, 0.929347],
    [0.663146, 0.647618],
    [-0.096674, -0.413835],
    [0.525945, -0.321063],
    [-0.122533, 0.366019],
    [0.195235, -0.687983],
    [-0.563203, 0.098748],
    [0.418563, 0.561335],
    [-0.378595, 0.800367],
    [0.826922, 0.001024],
    [-0.085372, -0.766651],
    [-0.92192, 0.183673],
    [-0.590008, -0.721799],
    [0.167751, -0.164393],
    [0.032961, -0.56253],
    [0.6329, -0.107059],
    [-0.46408, 0.569669],
    [-0.173676, -0.958758],
    [-0.242648, -0.234303],
    [-0.275362, 0.157163],
    [0.382295, -0.795131],
    [0.562955, 0.115562],
    [0.190586, 0.470121],
    [0.770764, -0.297576],
    [0.237281, 0.93105],
    [-0.666642, -0.455871],
    [-0.905649, -0.298379],
    [0.33952, 0.157829],
    [0.701438, -0.7041],
    [-0.062758, 0.160346],
    [-0.220674, 0.957141],
    [0.642692, 0.432706],
    [-0.77339, -0.015272],
    [-0.671467, 0.24688],
    [0.158051, 0.062859],
    [0.806009, 0.527232],
    [-0.05762, -0.247071],
    [0.333436, -0.51671],
    [-0.550658, -0.315773],
    [-0.652078, 0.589846],
    [0.008818, 0.530556],
    [-0.210004, 0.519896],
  ],
  CQ = new vi({ vertexShader: wQ, fragmentShader: _Q }),
  Yf = new vi({
    vertexShader: MQ,
    fragmentShader: EQ,
    uniforms: {
      texture_ao_lrez: new Ve(null),
      texture_depth_lrez: new Ve(null),
      texture_depth_hrez: new Ve(null),
      near: new Ve(null),
      far: new Ve(null),
    },
  }),
  TQ = class extends Ls {
    constructor(e, t) {
      super("AmbientOcclusionPass", void 0, t),
        (this.fogEnabled = !1),
        (this.fogNear = 1),
        (this.fogFar = 1e3),
        (this.frameIndex = 0),
        (this._runHalfRes = !0),
        (this._width = 1),
        (this._height = 1);
      let i = 1024,
        r = 1024;
      (this.gBuffer = new gi(i, r, {
        type: xr,
        depthTexture: new Gc(i, r),
        minFilter: Wt,
        magFilter: Wt,
      })),
        (this.depthBufferHighRes = new gi(i, r, {
          depthTexture: new Gc(i, r),
        })),
        (this.aoBuffer = new gi(i, r, { minFilter: Wt, magFilter: Wt })),
        (this.splineScene = e),
        (this.splineCamera = t);
      let s = new Float32Array(id.length * 2);
      for (let n = 0; n < id.length; n++) {
        let o = n * 2;
        (s[o + 0] = id[n][0]), (s[o + 1] = id[n][1]);
      }
      (this.blueNoiseInDiskTexture = new Sa(s, id.length, 1, gm, xr)),
        (this.blueNoiseInDiskTexture.wrapS = mo),
        (this.blueNoiseInDiskTexture.wrapT = mo),
        (this.blueNoiseInDiskTexture.needsUpdate = !0),
        (this.hbaoMaterial = new vi({
          vertexShader: SQ,
          fragmentShader: AQ,
          uniforms: {
            near: new Ve(null),
            far: new Ve(null),
            fov: new Ve(null),
            proj_info: new Ve(new Lt()),
            is_ortho: new Ve(!1),
            resolution: new Ve(new re()),
            radius_of_influence: new Ve(8),
            radius_in_screen_space: new Ve(1),
            exponent: new Ve(1),
            ao_color: new Ve(new I()),
            bias: new Ve(0.5),
            texture_depth: new Ve(null),
            texture_normals: new Ve(null),
            texture_blue_noise: new Ve(null),
            texture_blue_noise_in_disk: new Ve(this.blueNoiseInDiskTexture),
            frame_index: new Ve(0),
            fog_enabled: new Ve(!1),
            fog_near: new Ve(1),
            fog_far: new Ve(1e3),
          },
        })),
        (this.radius = 128),
        (this.aoColor = { r: 0, g: 0, b: 0 }),
        (this.bias = 0.5),
        (this.hbaoMaterial.uniforms.texture_depth.value =
          this.gBuffer.depthTexture),
        (this.hbaoMaterial.uniforms.texture_normals.value =
          this.gBuffer.texture),
        (this.needsSwap = !0),
        (this.aaBuffer = new gi(i, r, {
          minFilter: Wt,
          magFilter: Wt,
          wrapS: Ui,
          wrapT: Ui,
          depthBuffer: !1,
          type: xr,
        }));
      let a = new AP({ preset: jl.ULTRA, edgeDetectionMode: Ng.COLOR });
      this.effectPass = new ug(this.camera, a);
    }
    initialize(e, t, i) {
      super.initialize(e, t, i), this.effectPass.initialize(e, t, i);
    }
    setBlueNoiseTexture(e) {
      this.hbaoMaterial.uniforms.texture_blue_noise.value = e;
    }
    setSize(e, t) {
      (this._width = e),
        (this._height = t),
        this.depthBufferHighRes.setSize(e, t);
      let i = this._runHalfRes ? 0.5 : 1,
        r = e * i,
        s = t * i;
      this.gBuffer.setSize(r, s),
        this.aoBuffer.setSize(r, s),
        this.hbaoMaterial.uniforms.resolution.value.set(r, s),
        this.aaBuffer.setSize(r, s),
        this.effectPass.setSize(r, s);
    }
    get runHalfRes() {
      return this._runHalfRes;
    }
    set runHalfRes(e) {
      (this._runHalfRes = e), this.setSize(this._width, this._height);
    }
    setCamera(e) {
      this.splineCamera = e;
    }
    setScene(e) {
      this.splineScene = e;
    }
    render(e, t, i) {
      this.splineScene.overrideMaterial = CQ;
      let r = this.splineCamera.layers.mask;
      if (
        (this.splineCamera.layers.set(5),
        e.setRenderTarget(this.gBuffer),
        e.clear(),
        e.render(this.splineScene, this.splineCamera),
        e.setRenderTarget(this.depthBufferHighRes),
        e.clear(),
        e.render(this.splineScene, this.splineCamera),
        (this.splineScene.overrideMaterial = null),
        (this.splineCamera.layers.mask = r),
        (this.hbaoMaterial.uniforms.radius_of_influence.value = this.radius),
        this.hbaoMaterial.uniforms.ao_color.value.set(
          this.aoColor.r,
          this.aoColor.g,
          this.aoColor.b
        ),
        (this.hbaoMaterial.uniforms.bias.value = this.bias),
        (this.hbaoMaterial.uniforms.fog_enabled.value = this.fogEnabled),
        (this.hbaoMaterial.uniforms.fog_near.value = this.fogNear),
        (this.hbaoMaterial.uniforms.fog_far.value = this.fogFar),
        (this.hbaoMaterial.uniforms.frame_index.value = this.frameIndex),
        this.frameIndex++,
        this.splineCamera.isPerspectiveCamera)
      ) {
        (this.hbaoMaterial.uniforms.near.value =
          this.splineCamera.perspCamera.near),
          (this.hbaoMaterial.uniforms.far.value =
            this.splineCamera.perspCamera.far);
        let s = this.splineCamera.perspCamera.projectionMatrix.elements,
          a = 2 / s[0],
          n = 2 / s[5],
          o = -(1 - s[8]) / s[0],
          l = -(1 + s[9]) / s[5];
        this.hbaoMaterial.uniforms.proj_info.value.set(a, n, o, l);
        let h = this.splineCamera.perspCamera.fov * (Math.PI / 180),
          u =
            this.hbaoMaterial.uniforms.resolution.value.y /
            (Math.tan(h * 0.5) * 2),
          c = this.hbaoMaterial.uniforms.radius_of_influence.value * 0.5 * u;
        (this.hbaoMaterial.uniforms.radius_in_screen_space.value = c),
          (this.hbaoMaterial.uniforms.is_ortho.value = !1);
      } else {
        (this.hbaoMaterial.uniforms.near.value =
          this.splineCamera.orthoCamera.near),
          (this.hbaoMaterial.uniforms.far.value =
            this.splineCamera.orthoCamera.far);
        let s = this.splineCamera.orthoCamera.projectionMatrix.elements,
          a = 2 / s[0],
          n = 2 / s[5],
          o = -(1 + s[12]) / s[0],
          l = -(1 - s[13]) / s[5];
        this.hbaoMaterial.uniforms.proj_info.value.set(a, n, o, l);
        let h = 0.5 * (this.hbaoMaterial.uniforms.resolution.value.y / n),
          u = this.hbaoMaterial.uniforms.radius_of_influence.value * h;
        (this.hbaoMaterial.uniforms.radius_in_screen_space.value = u),
          (this.hbaoMaterial.uniforms.is_ortho.value = !0);
      }
      this.runHalfRes
        ? ((this.fullscreenMaterial = this.hbaoMaterial),
          e.setRenderTarget(this.aoBuffer),
          e.clear(),
          e.render(this.scene, this.camera),
          (this.fullscreenMaterial = Yf),
          (Yf.uniforms.texture_ao_lrez.value = this.aoBuffer.texture),
          (Yf.uniforms.texture_depth_lrez.value = this.gBuffer.depthTexture),
          (Yf.uniforms.texture_depth_hrez.value =
            this.depthBufferHighRes.depthTexture),
          e.setRenderTarget(e.aoRenderTarget),
          e.clear(),
          e.render(this.scene, this.camera))
        : ((this.fullscreenMaterial = this.hbaoMaterial),
          e.setRenderTarget(this.aaBuffer),
          e.clear(),
          e.render(this.scene, this.camera),
          (this.effectPass.renderToScreen = !1),
          this.effectPass.render(e, this.aaBuffer, e.aoRenderTarget));
    }
    dispose() {
      this.gBuffer.dispose(),
        this.depthBufferHighRes.dispose(),
        this.aoBuffer.dispose();
    }
  },
  PQ = `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  DQ = `
uniform sampler2D tInput;
uniform sampler2D tMap;
uniform vec2 resolution;
varying vec2 vUv;

uniform vec2 uResolution;
uniform vec2 uCoords;

// Draws a rectangle at center <st> with size <size>
float rectangle(vec2 st, vec2 size) {
    size = vec2(0.5) - size * 0.5;
    vec2 uv = vec2(step(size.x, st.x), step(size.y, st.y));
    uv *= vec2(step(size.x, 1.0 - st.x), step(size.y, 1.0 - st.y));

    return uv.x * uv.y;
}

uniform vec2 uSize;
uniform float uScale;
uniform float uDPR;
uniform float uCurrent;
uniform vec3 uSceneColor;

void main() {
    vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
    screenUv *= 1.0 / uDPR;

    vec2 center = vec2(0.5, -0.5);
    vec2 outsideUv = screenUv;
    outsideUv += center;
    outsideUv -= uCoords.xy / uResolution.xy;
    outsideUv = (outsideUv - 0.5) + 0.5;
    outsideUv -= center;
    vec2 s = (uSize / uResolution) * uScale;
    float isOutside = 1.0 - rectangle(outsideUv, s);
    
    vec2 mid = vec2(0.5);
    vec2 insideUv = (screenUv - mid + s * mid) / s;
    vec4 background = texture2D(tInput, screenUv);
    vec4 image = texture2D(tMap, insideUv);
    gl_FragColor = mix(image, background, isOutside);
}
`,
  OQ = class extends Va {
    constructor() {
      super(
        new vi({
          vertexShader: PQ,
          fragmentShader: DQ,
          uniforms: {
            tInput: new Ve(null),
            tMap: new Ve(null),
            uResolution: new Ve(new re()),
            uSize: new Ve(new re()),
            uCoords: new Ve(new re()),
            uScale: new Ve(1),
            uSceneColor: new Ve(new Et(16711680)),
            uDPR: new Ve(1),
            uCurrent: new Ve(0),
          },
        }),
        "tInput"
      ),
        (this.needsSwap = !0);
    }
    get uniforms() {
      return this.fullscreenMaterial.uniforms;
    }
    get texture() {
      return this.uniforms.tMap.value;
    }
    set texture(e) {
      this.uniforms.tMap.value = e;
    }
  },
  IQ = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  RQ = `
uniform sampler2D toScene;
uniform sampler2D fromScene;
uniform vec2 resolution;

uniform vec2 uResolution;
uniform float uDPR;

uniform float mixRatio;
uniform sampler2D tMixTexture;
uniform int useTexture;
uniform float threshold;

void main() {
	vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
	screenUv *= 1.0 / uDPR;

	vec4 texel1 = texture2D( fromScene, screenUv );
	vec4 texel2 = texture2D( toScene, screenUv );

	if (useTexture==1) {
		
		vec4 transitionTexel = texture2D( tMixTexture, screenUv );
		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;
		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);
		
		gl_FragColor = mix( texel1, texel2, mixf );
	} else {
		
		gl_FragColor = mix( texel1, texel2, mixRatio );
		
	}
}
`,
  LQ = [],
  BQ = class extends Va {
    constructor() {
      super(
        new vi({
          vertexShader: IQ,
          fragmentShader: RQ,
          uniforms: {
            toScene: new Ve(null),
            fromScene: new Ve(null),
            uResolution: new Ve(new re()),
            uDPR: new Ve(1),
            mixRatio: new Ve(0),
            threshold: new Ve(0.1),
            useTexture: new Ve(0),
            tMixTexture: { value: LQ[0] },
          },
        }),
        "toScene"
      ),
        (this.needsSwap = !0);
    }
    get uniforms() {
      return this.fullscreenMaterial.uniforms;
    }
    get texture() {
      return this.uniforms.fromScene.value;
    }
    set texture(e) {
      this.uniforms.fromScene.value = e;
    }
  },
  zQ = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  FQ = `
uniform sampler2D inputBuffer;
uniform sampler2D blurredInputBuffer;
uniform sampler2D overlay;
uniform float blurIntensity;

uniform vec2 uResolution;
uniform float uDPR;

void main() {
	vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
	screenUv *= 1.0 / uDPR;

	vec4 texel1 = texture2D( overlay, screenUv );
	vec4 texel2 = texture2D( inputBuffer, screenUv );
	vec4 texel3 = texture2D( blurredInputBuffer, screenUv );

	float blurMask2 = max(sign(texel1.a), 0.0) * blurIntensity;
    gl_FragColor = mix( mix(texel2, texel3, blurMask2), texel1, texel1.a );
	gl_FragColor.a = 1.0;
}
`,
  kQ = class extends Va {
    constructor() {
      super(
        new vi({
          vertexShader: zQ,
          fragmentShader: FQ,
          uniforms: {
            inputBuffer: new Ve(null),
            blurredInputBuffer: new Ve(null),
            overlay: new Ve(null),
            uResolution: new Ve(new re()),
            uDPR: new Ve(1),
            blurIntensity: new Ve(0),
          },
        })
      ),
        (this._blurEnabled = !1),
        (this.blurTarget = new gi(1, 1, {
          minFilter: Wt,
          magFilter: Wt,
          wrapS: Ui,
          wrapT: Ui,
        })),
        (this.blurPass = new Cb({
          width: window.innerWidth,
          height: window.innerHeight,
          kernelSize: Ug.HUGE,
          resolutionScale: 0.25,
        })),
        (this.blurPass.renderToScreen = !1),
        (this.uniforms.blurredInputBuffer.value = this.blurTarget.texture);
    }
    get uniforms() {
      return this.fullscreenMaterial.uniforms;
    }
    get texture() {
      return this.uniforms.overlay.value;
    }
    set texture(e) {
      this.uniforms.overlay.value = e;
    }
    setResolution(e, t, i = 1) {
      this.uniforms.uResolution.value.set(e, t).divideScalar(i),
        (this.uniforms.uDPR.value = i),
        this.blurPass.setSize(e, t),
        this.blurTarget.setSize(e, t),
        this.blurPass.setSize(e, t);
    }
    get uiCanvas() {
      return this._uiCanvas;
    }
    set uiCanvas(e) {
      (this._uiCanvas = e),
        e.texture && (this.uniforms.overlay.value = e.texture);
      let t = e.frame;
      if (t) {
        let i = t.data.backgroundBlur,
          r = i.radius;
        (this._blurEnabled = i.enabled),
          (this.uniforms.blurIntensity.value = this._blurEnabled ? 1 : 0),
          (this.blurPass.scale = r / 3);
      }
    }
    render(e, t, i, r, s) {
      this._blurEnabled &&
        (this.blurPass.setDepthTexture(this.getDepthTexture()),
        this.blurPass.render(e, t, this.blurTarget, r, s)),
        super.render(e, t, i, r, s);
    }
  };
function vM(e, t) {
  return t && t.enabled && e.push(t.effect), e;
}
var NQ = (e) => (Object.values(li).includes(e) ? e : li.NORMAL),
  UQ = class extends ls {
    constructor(e) {
      super(),
        (this.postprocessingState = Qm.defaultData),
        (this._scene = new xo()),
        (this._camera = new vs()),
        (this.effects = new Map()),
        (this.blueNoiseTexture = new Sa()),
        (this._renderToScreen = !0),
        (this._isUIOverlayEnabled = !1),
        (this.clock = new QF()),
        (this.renderer = e),
        (this.debug = !1),
        this.effects.set("bloom", new iQ()),
        this.effects.set("chromaticAberration", new sQ()),
        this.effects.set("vignette", new lQ()),
        this.effects.set("noise", new oQ()),
        this.effects.set("colorAverage", new aQ()),
        this.effects.set("hueSaturation", new nQ()),
        this.effects.set("brightnessContrast", new rQ()),
        this.effects.set("depthOfField", new hQ()),
        this.effects.set("pixelation", new cQ()),
        (this.effectComposer = new yQ(this.renderer)),
        (this.effectComposer.autoRenderToScreen = !1),
        (this.opaquePass = new G1(!0, this.scene, this.camera)),
        (this.opaquePass.clear = !0),
        (this.transmissionPass = new gQ(
          this.scene,
          this.camera,
          this.renderer
        )),
        (this.aoPass = new TQ(this.scene, this.camera)),
        (this.taaPass = new mQ()),
        (this.taaPass.renderToScreen = !1),
        (this.helperPass = new bQ(this.camera)),
        (this.helperPass.renderToScreen = !1),
        (this.stylesOverlayPass = new OQ()),
        (this.stylesOverlayPass.enabled = !1),
        (this.uiOverlayPass = new kQ()),
        (this.uiOverlayPass.enabled = !1),
        (this.sceneTransitionPass = new BQ()),
        (this.sceneTransitionPass.enabled = !1),
        this._initCopyPass(),
        this._initPasses();
    }
    set overlayTexture(e) {
      e !== void 0
        ? ((this.stylesOverlayPass.texture = e),
          (this.stylesOverlayPass.enabled = !0))
        : (this.stylesOverlayPass.enabled = !1);
    }
    get overlayTexture() {
      return this.stylesOverlayPass.texture;
    }
    set sceneHelpers(e) {
      this.helperPass.sceneHelpers = e;
    }
    get sceneHelpers() {
      return this.helperPass.sceneHelpers;
    }
    set sceneHelpersOnTop(e) {
      this.helperPass.sceneHelpersOnTop = e;
    }
    get sceneHelpersOnTop() {
      return this.helperPass.sceneHelpersOnTop;
    }
    get scene() {
      return this._scene;
    }
    set scene(e) {
      (this._scene = e),
        this.opaquePass.setScene(e),
        this.transmissionPass.setScene(e),
        this.aoPass.setScene(e);
    }
    get camera() {
      return this._camera;
    }
    set camera(e) {
      (this._camera = e),
        this.opaquePass.setCamera(e),
        this.transmissionPass.setCamera(e),
        this.aoPass.setCamera(e),
        this.helperPass.setCamera(e);
    }
    updateRenderToScreen() {
      let e = !1;
      for (let t = this.effectComposer.passes.length - 1; t >= 0; t--) {
        let i = this.effectComposer.passes[t];
        if (i.enabled === !0 && !e && this._renderToScreen) {
          (i.renderToScreen = !0), (e = !0);
          continue;
        }
        i.renderToScreen = !1;
      }
    }
    get isUIOverlayEnabled() {
      return this._isUIOverlayEnabled;
    }
    disableUIOverlay() {
      this._isUIOverlayEnabled = !1;
    }
    enableUIOverlay() {
      this._isUIOverlayEnabled = !0;
    }
    disableHelpers() {
      (this.helperPass.enabled = !1), this.updateRenderToScreen();
    }
    enableHelpers() {
      (this.helperPass.enabled = !0), this.updateRenderToScreen();
    }
    updateBlueNoiseTexture(e) {
      (this.blueNoiseTexture = new Sa(e, 128, 128)),
        (this.blueNoiseTexture.wrapS = mo),
        (this.blueNoiseTexture.wrapT = mo),
        (this.blueNoiseTexture.minFilter = mi),
        (this.blueNoiseTexture.magFilter = mi),
        (this.blueNoiseTexture.needsUpdate = !0);
    }
    setAmbientOcclusionParams(e, t, i, r, s, a, n, o) {
      (this.aoPass.enabled = e),
        (this.aoPass.radius = t),
        (this.aoPass.bias = i),
        (this.aoPass.aoColor = r),
        (this.aoPass.fogEnabled = s),
        (this.aoPass.fogNear = a),
        (this.aoPass.fogFar = n),
        this.aoPass.runHalfRes !== !o && (this.aoPass.runHalfRes = !o);
    }
    setTransmissionPassEnabled(e) {
      (this.transmissionPass.enabled = e),
        (this.opaquePass.hasTransmissionPass = e);
    }
    _initPasses() {
      if (
        (this.uvEffectPass?.dispose(),
        this.effectPass?.dispose(),
        this.effectComposer.removeAllPasses(),
        this.transmissionPass.updatePasses(this.renderer),
        this.effectComposer.addPass(this.aoPass),
        this.effectComposer.addPass(this.opaquePass),
        this.effectComposer.addPass(this.transmissionPass),
        this.effectComposer.addPass(this.taaPass),
        this.postprocessingState.enabled)
      ) {
        let e = [this.effects.get("pixelation")].reduce(vM, []);
        e.length > 0 &&
          ((this.uvEffectPass = new ug(this.camera, ...e)),
          (this.uvEffectPass.renderToScreen = !1),
          this.effectComposer.addPass(this.uvEffectPass));
        let t = [
          this.effects.get("chromaticAberration"),
          this.effects.get("bloom"),
          this.effects.get("colorAverage"),
          this.effects.get("hueSaturation"),
          this.effects.get("brightnessContrast"),
          this.effects.get("vignette"),
          this.effects.get("noise"),
        ].reduce(vM, []);
        t.length > 0 &&
          ((this.effectPass = new ug(this.camera, ...t)),
          (this.effectPass.renderToScreen = !1),
          this.effectComposer.addPass(this.effectPass));
      }
      this.effectComposer.addPass(this.stylesOverlayPass),
        this.effectComposer.addPass(this.uiOverlayPass),
        this.effectComposer.addPass(this.sceneTransitionPass),
        this.effectComposer.addPass(this.helperPass);
    }
    _initCopyPass() {
      if (this._savePass) return;
      let e = new re();
      this.renderer.getDrawingBufferSize(e),
        (this._rt = new gi(e.x, e.y, {
          depthBuffer: !1,
          stencilBuffer: !1,
          wrapS: mo,
          wrapT: mo,
        })),
        (this._rt.samples = 0),
        (this._savePass = new j1(this._rt, !1)),
        (this._savePass.renderToScreen = !1);
    }
    setCopyPass(e) {
      (this._rt = e),
        (this._savePass = new j1(this._rt, !1)),
        (this.renderToScreen = !1);
    }
    get renderToScreen() {
      return this._renderToScreen;
    }
    set renderToScreen(e) {
      if (this._renderToScreen === e) return;
      let t = this.effectComposer;
      !t ||
        (e === !0 ? t.removePass(this._savePass) : t.addPass(this._savePass),
        (this._renderToScreen = e),
        this.updateRenderToScreen());
    }
    set sceneTransitionFromTexture(e) {
      e !== this.sceneTransitionPass.texture &&
        (e !== null
          ? (this.sceneTransitionPass.enabled = !0)
          : ((this.sceneTransitionPass.enabled = !1),
            this.updateRenderToScreen()),
        (this.sceneTransitionPass.texture = e));
    }
    get texture() {
      return this._rt && this._rt.texture;
    }
    get renderTarget() {
      return this._rt;
    }
    updatePostprocessing(e) {
      let { enabled: t, ...i } = e,
        r = !1;
      t !== this.postprocessingState.enabled && (r = !0);
      for (let s of Object.entries(i)) {
        let a = s[1],
          n = this.effects.get(s[0]);
        if (n) {
          n.enabled !== a.enabled && (r = !0), (n.enabled = a.enabled);
          for (let [o, l] of Object.entries(a))
            o === "blendFunction" ? (n.blendFunction = NQ(l)) : (n[o] = l);
        }
      }
      (this.postprocessingState = e), r && this._initPasses();
    }
    render() {
      this.effectComposer.render(this.clock.getDelta());
    }
    setScissor(e, t, i, r) {
      e instanceof Lt
        ? (this.effectComposer.inputBuffer.scissor.set(e.x, e.y, e.z, e.w),
          this.effectComposer.outputBuffer.scissor.set(e.x, e.y, e.z, e.w))
        : (this.effectComposer.inputBuffer.scissor.set(e, t, i, r),
          this.effectComposer.outputBuffer.scissor.set(e, t, i, r));
      let s = this.renderer.getPixelRatio();
      this.effectComposer.inputBuffer.scissor.multiplyScalar(s),
        this.effectComposer.outputBuffer.scissor.multiplyScalar(s),
        this.renderer.setScissor(e, t, i, r);
    }
    setScissorTest(e) {
      (this.effectComposer.inputBuffer.scissorTest = e),
        (this.effectComposer.outputBuffer.scissorTest = e),
        this.renderer.setScissorTest(e);
    }
    setViewport(e, t, i, r) {
      e instanceof Lt
        ? (this.effectComposer.inputBuffer.viewport.copy(e),
          this.effectComposer.outputBuffer.viewport.copy(e))
        : (this.effectComposer.inputBuffer.viewport.set(e, t, i, r),
          this.effectComposer.outputBuffer.viewport.set(e, t, i, r));
    }
    resize(e, t, i) {
      if ((this.effectComposer.setSize(e, t, i), this._rt)) {
        let r = this.renderer.getPixelRatio();
        this._rt.setSize(e * r, t * r);
      }
    }
    dispose() {
      this.uvEffectPass?.dispose(),
        this.effectPass?.dispose(),
        this.effectComposer.dispose();
    }
  },
  VQ = (e) => `

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${e};
const int gShadowSamples = ${e};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, ${5} - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        vec2 halton = haltonSequence[frameIndex];
        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
        float temporalAngle  = temporalOffset * PI2;

        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`,
  jQ = Gt.lights_fragment_begin,
  HQ = Gt.shadowmask_pars_fragment,
  yM = null,
  GQ = (e) => {
    switch (e) {
      case "low":
        return 8;
      case "medium":
        return 16;
      case "high":
        return 32;
      default:
        return 16;
    }
  },
  WQ = (e = "medium") => {
    if (yM === e) return !1;
    yM = e;
    let t = GQ(e);
    Gt.shadowmap_pars_fragment = VQ(t);
    let i = jQ.slice();
    (i = i.replace(
      "getShadow( spotShadowMap[ i ]",
      `getShadow( UNROLLED_LOOP_INDEX + ${3}, spotShadowMap[ i ]`
    )),
      (i = i.replace(
        "getShadow( directionalShadowMap[ i ]",
        "getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"
      )),
      (Gt.lights_fragment_begin = i);
    let r = HQ.slice();
    return (
      (r = r.replaceAll("getShadow(", "getShadow( UNROLLED_LOOP_INDEX, ")),
      (Gt.shadowmask_pars_fragment = r),
      !0
    );
  },
  qQ = `
attribute vec3 randomColor;
varying vec3 vNormal;
flat out vec3 vColor;

void main()
{
vNormal = normal;
vColor = randomColor;
gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
}
`,
  YQ = `
uniform float depthContrast;
varying vec3 vNormal;
flat in vec3 vColor;
void main()
{
vec3 normal = (normalize(vNormal)).rgb;

float contrastDepth = (gl_FragCoord.z - 0.5) * depthContrast + 0.5;

vec3 resultColor = mix(mix(vColor, normal, 0.2), vec3(contrastDepth), 0.4);
gl_FragColor = vec4(resultColor, vColor.r);
gl_FragColor = vec4(resultColor, vColor.r);
}
`,
  z0 = new vi({
    vertexShader: qQ,
    fragmentShader: YQ,
    uniforms: { depthContrast: { value: 1 } },
  }),
  xM = new Yi(),
  XQ = class extends lC {
    constructor(e) {
      super(e),
        (this._pixelRatio = this.getPixelRatio()),
        (this.viewportWidth = 1),
        (this.viewportHeight = 1),
        (this.resolution = new re()),
        (this.pipeline = new UQ(this)),
        (this.dummyCamera = new vs()),
        (this.sceneTransitionDuration = 0),
        (this.sceneTransitionTimeRemaining = -1),
        (this.isXRCopyPassSet = !1),
        (this.clear = (s = !0, a = !0, n = !0) => {
          let o = this.getContext(),
            l = 0;
          s && (l |= o.COLOR_BUFFER_BIT),
            a && (l |= o.DEPTH_BUFFER_BIT),
            n && (l |= o.STENCIL_BUFFER_BIT),
            o.clear(l),
            o.clearBufferfv(o.COLOR, 1, [0, 0, 0, 1]);
        }),
        (this.autoClear = !1);
      let t = this.setPixelRatio.bind(this),
        i = this.setSize.bind(this);
      (this.shadowMap.enabled = !0),
        (this.shadowMap.type = px),
        (this.dummyCamera.matrixAutoUpdate = !1);
      let r = this.getContext();
      if (r && "drawingBufferColorSpace" in r)
        try {
          r.drawingBufferColorSpace = "display-p3";
        } catch (s) {
          console.warn(s);
        }
      (this.setPixelRatio = (s) => {
        this._pixelRatio !== s && ((this._pixelRatio = s), t(s));
      }),
        (this.setSize = (s, a, n = !0) => {
          (this.viewportWidth !== s || this.viewportHeight !== a) &&
            ((this.viewportWidth = s),
            (this.viewportHeight = a),
            i(s, a, n),
            this.normalRenderTarget?.setSize(
              s * this._pixelRatio,
              a * this._pixelRatio
            ),
            this._resizeTransmission(s, a),
            this.transmissionDepthTarget?.setSize(
              (s * this._pixelRatio) / 2,
              (a * this._pixelRatio) / 2
            ),
            this.pipeline.resize(s, a, n));
        }),
        (this._superDispose = this.dispose),
        (this.dispose = this._currentDispose);
    }
    createAORenderTarget() {
      this.aoRenderTarget === void 0 &&
        (this.aoRenderTarget = new gi(
          this.viewportWidth * this._pixelRatio,
          this.viewportHeight * this._pixelRatio,
          {
            generateMipmaps: !1,
            minFilter: Wt,
            magFilter: Wt,
            wrapS: Ui,
            wrapT: Ui,
            depthBuffer: !1,
          }
        ));
    }
    _resizeTransmission(e, t) {
      this.transmissionRenderTarget?.setSize(
        (e * this._pixelRatio) / (this.hdTransmission ? 1 : 2),
        (t * this._pixelRatio) / (this.hdTransmission ? 1 : 2)
      ),
        this.aoRenderTarget?.setSize(
          (e * this._pixelRatio) / 1,
          (t * this._pixelRatio) / 1
        );
    }
    get hdTransmission() {
      return Tt.transmissionLod.value === 1;
    }
    set hdTransmission(e) {
      (Tt.transmissionLod.value = e === !0 ? 1 : 2),
        this._resizeTransmission(this.viewportWidth, this.viewportHeight);
    }
    createTransmissionRenderTarget() {
      this.transmissionRenderTarget === void 0 &&
        ((this.transmissionRenderTarget = new gi(
          (this.viewportWidth * this._pixelRatio) /
            (this.hdTransmission ? 1 : 2),
          (this.viewportHeight * this._pixelRatio) /
            (this.hdTransmission ? 1 : 2),
          {
            generateMipmaps: !0,
            minFilter: jc,
            magFilter: Wt,
            wrapS: Ui,
            wrapT: Ui,
            depthBuffer: !1,
          }
        )),
        (this.transmissionDepthTarget = new gi(
          (this.viewportWidth * this._pixelRatio) / 2,
          (this.viewportHeight * this._pixelRatio) / 2,
          { minFilter: mi, magFilter: mi, depthBuffer: !1 }
        )));
    }
    createNormalRenderTarget() {
      this.normalRenderTarget === void 0 &&
        (this.normalRenderTarget = new gi(
          this.viewportWidth * this._pixelRatio,
          this.viewportHeight * this._pixelRatio,
          {
            generateMipmaps: !1,
            minFilter: mi,
            magFilter: mi,
            type: xr,
            depthTexture: new Gc(
              this.viewportWidth * this._pixelRatio,
              this.viewportHeight * this._pixelRatio
            ),
          }
        ));
    }
    renderNormal(e, t, i) {
      this.normalRenderTarget &&
        (this.setClearColor(0),
        i.layers.enable(8),
        i.layers.disable(0),
        i.layers.disable(3),
        t.traverseEntity((r) => {
          r.layers.isEnabled(8) && (r.copyPreviousMatrix = !1);
        }),
        this.setRenderTarget(this.normalRenderTarget),
        this.clear(),
        i instanceof vs
          ? (z0.uniforms.depthContrast.value = (i.far - i.near) / 1e4)
          : (z0.uniforms.depthContrast.value = 1),
        (t.overrideMaterial = z0),
        this.render(t, i),
        this.setClearColor(t.bgColor, t.bgColor.a),
        this.setRenderTarget(null),
        (t.overrideMaterial = e.wireframeState ? ex : null),
        i.layers.enable(0),
        i.layers.enable(3),
        t.traverseEntity((r) => {
          r.layers.isEnabled(8) && (r.copyPreviousMatrix = !0);
        }));
    }
    renderSplineSceneWithDummyCamera(e, t, i = 1) {
      this.dummyCamera.updateCameraState(t.dataPatched),
        this.dummyCamera.matrix.copy(t.matrixWorld);
      let r = t.height,
        s = t.width,
        a = this.viewportWidth / this.viewportHeight;
      s < r ? (s = r * a) : (r = s / a),
        this.dummyCamera.setViewplaneSize(s, r);
      for (let n = 0; n < i; n++) this.renderSplineScene(e, this.dummyCamera);
    }
    renderSplineScene(
      e,
      t,
      {
        sceneHelpers: i = void 0,
        sceneHelpersOnTop: r = void 0,
        overrideTransmission: s = void 0,
        overrideNormal: a = void 0,
      } = {}
    ) {
      let n = e instanceof Lb ? e.activePage : e,
        o = n.visible;
      n.visible = !0;
      let l = n.scene;
      this.xr.enabled &&
        (this.isXRCopyPassSet === !1 &&
          this.getRenderTarget() !== null &&
          (this.pipeline.setCopyPass(this.getRenderTarget()),
          (this.isXRCopyPassSet = !0)),
        this.xr.updateCamera(t)),
        this.setClearColor(n.bgColor, n.bgColor.a),
        n.penumbraSizeArray.forEach((d, p) => {
          Tt.penumbraSize.value[p] = d;
        }),
        (Tt.pixelRatioNode.value = this.getPixelRatio()),
        this.resolution.x !== 0 && this.resolution.y !== 0
          ? Tt.resolution.value.set(this.resolution.x, this.resolution.y)
          : Tt.resolution.value.set(
              this.viewportWidth * this._pixelRatio,
              this.viewportHeight * this._pixelRatio
            ),
        a !== void 0
          ? ((Tt.normalRenderTarget.value = a),
            (Tt.normalRenderTargetDepth.value = xM))
          : l.needsNormal() &&
            (this.createNormalRenderTarget(),
            (Tt.normalRenderTarget.value = this.normalRenderTarget.texture),
            (Tt.normalRenderTargetDepth.value =
              this.normalRenderTarget.depthTexture),
            this.renderNormal(l, n, t));
      let h = n.data.ao,
        u = h.occlusion;
      u &&
        (this.createAORenderTarget(),
        (Tt.aoRenderTarget.value = this.aoRenderTarget.texture)),
        (Tt.aoEnabled.value = u),
        this.pipeline.setAmbientOcclusionParams(
          h.occlusion,
          h.radius,
          h.bias,
          n.aoColor,
          n.fog !== null,
          n.backupFog.near,
          n.backupFog.far,
          h.aoFullRes
        ),
        this.pipeline.aoPass.setBlueNoiseTexture(
          this.pipeline.blueNoiseTexture
        ),
        this.pipeline.isUIOverlayEnabled &&
        n.uiCanvas?.enabled &&
        n.uiCanvas.texture &&
        n.uiCanvas.texture.image.width > 0
          ? ((n.uiCanvas.width !== this.viewportWidth ||
              n.uiCanvas.height !== this.viewportHeight) &&
              n.uiCanvas.applySize({
                width: this.viewportWidth,
                height: this.viewportHeight,
              }),
            n.uiCanvas.render(),
            (this.pipeline.uiOverlayPass.uiCanvas = n.uiCanvas),
            (this.pipeline.uiOverlayPass.enabled = !0),
            this.pipeline.uiOverlayPass.setResolution(
              this.domElement.width,
              this.domElement.height,
              window.devicePixelRatio
            ),
            this.pipeline.updateRenderToScreen())
          : ((this.pipeline.uiOverlayPass.enabled = !1),
            this.pipeline.updateRenderToScreen());
      let c = !1;
      if (s !== void 0)
        (Tt.transmissionRenderTarget.value = s),
          (Tt.transmissionRenderTargetDepth.value = xM),
          this.pipeline.setTransmissionPassEnabled(!1);
      else {
        let d = l.needsTransmission();
        d &&
          (this.transmissionRenderTarget === void 0 && (c = !0),
          this.createTransmissionRenderTarget(),
          (Tt.transmissionRenderTarget.value =
            this.transmissionRenderTarget.texture),
          (Tt.aspectRatio.value = rq(this.viewportWidth, this.viewportHeight)),
          (Tt.transmissionRenderTargetDepth.value =
            this.transmissionDepthTarget.texture)),
          this.pipeline.setTransmissionPassEnabled(d);
      }
      t.layers.enable(3),
        t.layers.enable(8),
        (this.pipeline.sceneHelpers = i),
        (this.pipeline.sceneHelpersOnTop = r),
        (this.pipeline.scene = n),
        (this.pipeline.camera = t),
        c && this.pipeline.transmissionPass.updatePasses(this),
        this.pipeline.postprocessingState !== n.postprocessing &&
          (this.pipeline.updatePostprocessing(n.postprocessing),
          !i && !r && this.pipeline.disableHelpers()),
        this.clearAlphaOverride !== void 0 &&
          this.setClearAlpha(this.clearAlphaOverride),
        (n.overrideMaterial = l.wireframeState ? ex : null),
        this.pipeline.render(),
        (Tt.frameIndex.value = (Tt.frameIndex.value + 1) % 16),
        t instanceof vs && t.copyHistory(),
        (n.visible = o);
    }
    renderFromSceneForSceneTransitionPass(e, t, i) {
      (this.pipeline.renderToScreen = !1),
        this.pipeline.renderTarget,
        this.renderSplineScene(e, t),
        (this.pipeline.sceneTransitionFromTexture =
          this.pipeline.renderTarget.texture),
        (this.sceneTransitionDuration = i),
        (this.sceneTransitionTimeRemaining = i),
        (this.pipeline.renderToScreen = !0);
      let r = this.pipeline.sceneTransitionPass.uniforms;
      (r.uDPR.value = window.devicePixelRatio),
        r.uResolution.value
          .set(this.domElement.width, this.domElement.height)
          .divideScalar(window.devicePixelRatio);
    }
    _currentDispose() {
      this._superDispose(),
        this.pipeline.dispose(),
        this.aoRenderTarget?.dispose(),
        this.transmissionRenderTarget?.dispose(),
        this.transmissionDepthTarget?.dispose(),
        this.normalRenderTarget?.dispose(),
        this.normalRenderTarget?.depthTexture?.dispose();
    }
  },
  MP = class extends up(uk) {
    constructor(e, t = 15, i = 10066329) {
      super(e, t, i),
        (this.object = e),
        (this.added = !1),
        (this.name = `DirectionalLightHelper: ${e.uuid}`);
    }
    raycast(e, t) {
      dp(this.object, MP.geometryHelper, e, t);
    }
  },
  EP = class extends up(ck) {
    constructor(e, t = 15, i = 6710886) {
      super(e, t, i),
        (this.object = e),
        (this.name = `PointLightHelper: ${e.uuid}`);
    }
    raycast(e, t) {
      dp(this.object, EP.geometryHelper, e, t);
    }
  },
  W1 = class extends up(hk) {
    constructor(e, t = 6710886) {
      super(e, t),
        (this.object = e),
        (this.name = `SpotLightHelper: ${e.uuid}`);
    }
    raycast(e, t) {
      dp(this.object, W1.geometryHelper, e, t);
    }
    update() {
      if (this.object !== void 0) {
        let e = W1._vector,
          t = this.object.distance ? this.object.distance : 1e3,
          i = t * Math.tan(this.object.angle);
        this.cone.scale.set(i, i, t),
          e.setFromMatrixPosition(this.object.target.matrixWorld),
          this.cone.lookAt(e);
        let r = this.color !== void 0 ? this.color : this.light.color;
        if (this.cone.material instanceof Array)
          for (let s = 0, a = this.cone.material.length; s < a; s++)
            this.cone.material[s].color.set(r);
        else this.cone.material.color.set(r);
      }
    }
  },
  CP = W1;
CP._vector = new I();
function QQ(e, t) {
  (e.shadow.camera.right = t / 2),
    (e.shadow.camera.left = -t / 2),
    (e.shadow.camera.top = t / 2),
    (e.shadow.camera.bottom = -t / 2),
    (e.shadow.needsUpdate = !0);
}
var TP = class extends Mb(XF, MP) {
    constructor(e, t, i) {
      super(),
        this.super_Entity(e, t),
        (this.castShadow = !0),
        (this.shadow.mapSize.width = 2048),
        (this.shadow.mapSize.height = 2048),
        (this.shadow.normalBias = 1),
        this.layers.enable(3);
      let r = this.shadow.camera;
      (r.top = 1250),
        (r.bottom = -1250),
        (r.right = 1250),
        (r.left = -1250),
        (r.near = -1e4),
        (r.far = 2500);
      let s = new Tm(this.shadow.camera);
      (s.visible = !1), (this.gizmos.shadowmap = s);
    }
    update() {
      this.shadow.camera.updateProjectionMatrix();
      for (let e in this.gizmos) {
        let t = this.gizmos[e];
        t instanceof Tm && t.update();
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.objectHelper && this.objectHelper.update();
    }
    updateState(e, t) {
      this.updateState_Light(e, t);
      let i =
        (e.depth !== void 0 && e.depth !== this.shadow.camera.far) ||
        (e.size !== void 0 && e.size / 2 !== this.shadow.camera.right);
      e.size !== void 0 && QQ(this, e.size),
        e.shadowRadius !== void 0 && (this.shadow.radius = e.shadowRadius),
        e.shadowResolution !== void 0 &&
          (this.shadow.mapSize.set(e.shadowResolution, e.shadowResolution),
          this.shadow.map &&
            (this.shadow.map.dispose(), (this.shadow.map = null))),
        e.penumbraSize !== void 0 && t.scene.markPenumbraSizeDirty(),
        i && this.update();
    }
  },
  bM = new I(),
  wM = new I(),
  _M = new Rt(),
  PP = class extends Mb(GF, CP) {
    constructor(e, t, i) {
      super(),
        this.super_Entity(e, t),
        (this.castShadow = !0),
        (this.shadow.mapSize.width = 1024),
        (this.shadow.mapSize.height = 1024),
        (this.shadow.normalBias = 1),
        this.layers.enable(3);
      let r = this.shadow.camera;
      (r.fov = dt.RAD2DEG * 2 * this.angle),
        (r.aspect = 1),
        (r.near = 100),
        (r.far = 2500);
      let s = new Tm(this.shadow.camera);
      (s.visible = !1), (this.gizmos.shadowmap = s), this.update();
    }
    update() {
      this.shadow.camera.updateProjectionMatrix();
      for (let e in this.gizmos) {
        let t = this.gizmos[e];
        t instanceof Tm && t.update();
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        wM.setFromMatrixPosition(this.matrixWorld),
        _M.setFromRotationMatrix(this.matrixWorld),
        bM
          .copy(this.up)
          .applyQuaternion(_M)
          .negate()
          .multiplyScalar(this.distance),
        this.target.position.copy(wM).add(bM),
        this.target.updateMatrixWorld(),
        this.objectHelper && this.objectHelper.update();
    }
    updateState(e, t) {
      this.updateState_Light(e, t),
        e.distance !== void 0 && (this.distance = e.distance),
        e.decay !== void 0 && (this.decay = e.decay),
        e.angle !== void 0 && (this.angle = e.angle),
        e.penumbra !== void 0 && (this.penumbra = e.penumbra),
        e.shadowRadius !== void 0 && (this.shadow.radius = e.shadowRadius),
        e.penumbraSize !== void 0 && t.scene.markPenumbraSizeDirty(),
        e.shadowResolution !== void 0 &&
          (this.shadow.mapSize.set(e.shadowResolution, e.shadowResolution),
          this.shadow.map &&
            (this.shadow.map.dispose(), (this.shadow.map = null)));
    }
  },
  Ei;
((e) => {
  function t() {
    return [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  e.identity = t;
  function i(M, C = e.identity()) {
    for (let A = 0, T = M.length; A < T; A++) C[A] = M[A];
    return C;
  }
  e.copy = i;
  function r(M, C, A, T, P, R) {
    return e.setAbcdef(e.identity(), M, C, A, T, P, R);
  }
  e.create = r;
  function s(M, C, A, T, P, R, z) {
    return (
      (M[0] = C), (M[1] = T), (M[2] = R), (M[3] = A), (M[4] = P), (M[5] = z), M
    );
  }
  e.setAbcdef = s;
  function a(M, C) {
    let [A, T, P, R, z, N] = o(M),
      [L, G, Y, Z, q, oe] = o(C),
      ce = L * A + G * P,
      ie = L * T + G * R,
      te = Y * A + Z * P,
      ue = Y * T + Z * R,
      ae = q * A + oe * P + z,
      de = q * T + oe * R + N;
    return e.create(ce, ie, te, ue, ae, de);
  }
  e.append = a;
  function n(M, C) {
    let [A, T, P, R, z, N] = o(M),
      [L, G, Y, Z, q, oe] = o(C),
      ce = A,
      ie = T,
      te = P,
      ue = R;
    (L !== 1 || G !== 0 || Y !== 0 || Z !== 1) &&
      ((ce = A * L + T * Y),
      (ie = A * G + T * Z),
      (te = P * L + R * Y),
      (ue = P * G + R * Z));
    let ae = z * L + N * Y + q,
      de = z * G + N * Z + oe;
    return e.create(ce, ie, te, ue, ae, de);
  }
  e.prepend = n;
  function o(M) {
    return [M[0], M[3], M[1], M[4], M[2], M[5]];
  }
  e.getAbcdef = o;
  function l(M) {
    let [C, A, T, P, R, z] = e.getAbcdef(M),
      N = C * P - A * T,
      L = P / N,
      G = -A / N,
      Y = -T / N,
      Z = C / N,
      q = (T * z - P * R) / N,
      oe = -(C * z - A * R) / N;
    return e.create(L, G, Y, Z, q, oe);
  }
  e.invert = l;
  function h([M, C], A) {
    let [T, P, R, z, N, L] = e.getAbcdef(A);
    return [T * M + R * C + N, P * M + z * C + L];
  }
  e.apply = h;
  function u(M, C) {
    let [A, T, P, R, z, N] = e.getAbcdef(C),
      L = 1 / (A * R + P * -T),
      [G, Y] = M;
    return [
      R * L * G + -P * L * Y + (N * P - z * R) * L,
      A * L * Y + -T * L * G + (-N * A + z * T) * L,
    ];
  }
  e.applyInverse = u;
  function c(M, C, A = C) {
    let [T, P, R, z, N, L] = e.getAbcdef(M);
    return e.setAbcdef(M, T * C, P * A, R * C, z * A, N * C, L * A), M;
  }
  e.scale = c;
  function d(M, C) {
    let A = Math.cos(C),
      T = Math.sin(C),
      [P, R, z, N, L, G] = e.getAbcdef(M);
    return (
      e.setAbcdef(
        M,
        P * A - R * T,
        P * T + R * A,
        z * A - N * T,
        z * T + N * A,
        L * A - G * T,
        L * T + G * A
      ),
      M
    );
  }
  e.rotate = d;
  function p(M, C, A) {
    let [T, P] = A,
      R = e.translate(M, -T, -P);
    return (R = e.rotate(R, C)), (R = e.translate(R, T, P)), R;
  }
  e.rotateAround = p;
  function f(M, C, A) {
    let [T, P, R, z, N, L] = e.getAbcdef(M);
    return e.setAbcdef(M, T, P, R, z, N + C, L + A), M;
  }
  e.translate = f;
  function m(M, C, A) {
    let [T, P, R, z] = e.getAbcdef(M);
    return e.setAbcdef(M, T, P, R, z, C, A), M;
  }
  e.setTranslate = m;
  function g(M, C, A) {
    let [T, P, R, z] = e.getAbcdef(M);
    return e.setAbcdef(M, T, P, R, z, C, A), M;
  }
  e.setPosition = g;
  function y(M) {
    let [C, A, T, P] = e.getAbcdef(M),
      R = Math.sqrt(C * C + A * A),
      z = Math.sqrt(T * T + P * P);
    return [R, z];
  }
  e.getScale = y;
  function x(M) {
    let [, , , , C, A] = e.getAbcdef(M);
    return [C, A];
  }
  e.getPosition = x;
  function b(M, C) {
    return e.decompose(M, C).rotation;
  }
  e.getRotation = b;
  function _(M, C) {
    let [A, T, P, R, z, N] = e.getAbcdef(M),
      L = -Math.atan2(-P, R),
      G = Math.atan2(T, A),
      Y = Math.abs(L + G),
      Z = 0,
      q = [0, 0];
    Y < 1e-5 || Math.abs(Math.PI * 2 - Y) < 1e-5
      ? ((Z = G), (q[0] = q[1] = 0))
      : ((Z = 0), (q[0] = L), (q[1] = G));
    let oe = [Math.sqrt(A * A + T * T), Math.sqrt(P * P + R * R)];
    return {
      position: [
        z + (C[0] * A + C[1] * P) - C[0],
        N + (C[0] * T + C[1] * R) - C[1],
      ],
      scale: oe,
      rotation: Z,
      skew: q,
      pivot: C,
    };
  }
  e.decompose = _;
  function S(M, C, A, T, P = [0, 0]) {
    let [R, z] = M,
      [N, L] = C,
      [G, Y] = T,
      [Z, q] = P,
      oe = Math.cos(A + q) * N,
      ce = Math.sin(A + q) * N,
      ie = -Math.sin(A - Z) * L,
      te = Math.cos(A - Z) * L,
      ue = R - (G * oe + Y * ie) + G,
      ae = z - (G * ce + Y * te) + Y;
    return e.create(oe, ce, ie, te, ue, ae);
  }
  e.compose = S;
})(Ei || (Ei = {}));
var ZQ = Math.PI / 180,
  bte = 180 / Math.PI;
function KQ(e, t, i, r, s, a) {
  let n = e - i,
    o = t - r;
  return (n * n) / (s * s) + (o * o) / (a * a) <= 1;
}
function JQ(e) {
  return e * ZQ;
}
function $Q(e) {
  return {
    all: (e = e || new Map()),
    on: function (t, i) {
      var r = e.get(t);
      r ? r.push(i) : e.set(t, [i]);
    },
    off: function (t, i) {
      var r = e.get(t);
      r && (i ? r.splice(r.indexOf(i) >>> 0, 1) : e.set(t, []));
    },
    emit: function (t, i) {
      var r = e.get(t);
      r &&
        r.slice().map(function (s) {
          s(i);
        }),
        (r = e.get("*")) &&
          r.slice().map(function (s) {
            s(t, i);
          });
    },
  };
}
var Rr = class {
    constructor(e, t, i) {
      (this.uuid = e),
        (this.data = t),
        (this.localMatrix = Ei.identity()),
        (this.worldMatrix = Ei.identity()),
        (this.ignoreCameraZoom = !1),
        (this.visible = !0),
        (this._singleBBox = new q1()),
        (this._recursiveBBox = new q1()),
        (this.singleBBoxNeedsUpdate = !0),
        (this.recursiveBBoxNeedsUpdate = !0),
        (this.stateSelection = null),
        (this.prevState = null),
        (this.currentState = null),
        (this.reversibleToState = null),
        (this.currentTransitionEvent = null),
        (this.previousAction = null),
        (this.name = ""),
        (this.position = [0, 0]),
        (this.scale = [1, 1]),
        (this.rotation = 0),
        (this.emitter = $Q()),
        (this.dpr = i.dpr ?? 1),
        (this.dataPatched = t);
    }
    project(e, t) {
      let i = this.worldMatrix;
      return t && (i = Ei.append(t.worldMatrix, i)), Ei.applyInverse(e, i);
    }
    intersects(e, t, i, r = !1) {
      return (
        this.visible &&
        !this.data.raycastLock &&
        this.intersectsInLocalSpace(...this.project([e, t], i), r)
      );
    }
    intersectsInLocalSpace(e, t, i = !1) {
      let { min: r, max: s } = i ? this.recursiveBBox : this.singleBBox;
      return e >= r[0] && e <= s[0] && t >= r[1] && t <= s[1];
    }
    applyTransforms(e) {
      e.setTransform(this.worldMatrix, this.ignoreCameraZoom);
    }
    get singleBBox() {
      return (
        this.singleBBoxNeedsUpdate &&
          ((this.singleBBoxNeedsUpdate = !1),
          this._singleBBox.setFromObjectSize(this, !1),
          this._singleBBox.computeVertices(),
          this._singleBBox.computeEdges()),
        this._singleBBox
      );
    }
    get recursiveBBox() {
      return (
        this.recursiveBBoxNeedsUpdate &&
          ((this.recursiveBBoxNeedsUpdate = !1),
          this._recursiveBBox.setFromObjectSize(this, !0),
          this._recursiveBBox.computeVertices(),
          this._recursiveBBox.computeEdges()),
        this._recursiveBBox
      );
    }
    updateLocalMatrix() {
      this.localMatrix = Ei.compose(
        this.position,
        this.scale,
        JQ(this.rotation),
        rh.getPivot(this.dataPatched)
      );
    }
    updateWorldMatrix(e, t, i) {
      let r = this.parent;
      t && r !== null && r !== void 0 && r.updateWorldMatrix(e, !0, !1),
        e && this.updateLocalMatrix(),
        this.parent
          ? (this.worldMatrix = Ei.append(
              this.parent.worldMatrix,
              this.localMatrix
            ))
          : (this.worldMatrix = Ei.copy(this.localMatrix)),
        (this.singleBBoxNeedsUpdate = !0),
        (this.recursiveBBoxNeedsUpdate = !0);
    }
    get pivot() {
      return rh.getPivot(this.data);
    }
    getCenter() {
      return [0, 0];
    }
    getHalfSize() {
      return [0, 0];
    }
    get id() {
      return this.uuid;
    }
    resetBBoxNeedsUpdateSelf() {
      (this.singleBBoxNeedsUpdate = !0), (this.recursiveBBoxNeedsUpdate = !0);
    }
    resetBBoxNeedsUpdate() {
      this.resetBBoxNeedsUpdateSelf(),
        this.traverseAncestors((e) => {
          e.resetBBoxNeedsUpdateSelf();
        });
    }
    updateTransformState(e) {
      let t = !1;
      e.position !== void 0 && ((t = !0), (this.position = e.position)),
        e.rotation !== void 0 && ((t = !0), (this.rotation = e.rotation)),
        e.scale !== void 0 && ((t = !0), (this.scale = e.scale)),
        t && (this.updateWorldMatrix(!0, !1, !0), this.resetBBoxNeedsUpdate());
    }
    updateByOp(e, t, i) {
      e.type === 0 &&
        e.props.visible !== void 0 &&
        (this.visible = e.props.visible),
        (this.data = t),
        (this.data = t);
      let r = e,
        s = Ii(e.path, ["states", "*"]);
      if (s !== null) {
        if (e.type === 0) {
          let [a] = s;
          if (this?.stateSelection === a) {
            let n = { ...e.props };
            if (
              (delete n.name, Object.values(e.props).some((o) => o === void 0))
            ) {
              let o = this.data;
              if (o !== void 0) {
                let l = ss.zoom(o, e.path.slice(2));
                if (l)
                  for (let h in e.props)
                    e.props[h] === void 0 && h in l && (n[h] = l[h]);
              }
            }
            r = { ...e, props: n, path: e.path.slice(2) };
          }
        }
      } else if (e.type === 0) {
        let a = this.stateSelection
          ? this.data.states.data(this.stateSelection)
          : void 0;
        if (a !== void 0) {
          if (e.props.name !== void 0 && a.name) {
            let { name: o, ...l } = a;
            a = l;
          }
          let n = ss.removeOverridden(e.path, e.props, a);
          r = { ...e, props: n };
        }
      }
      this.updateByPatchedOpBase(
        r,
        Xl.patch(
          this.data,
          this.stateSelection
            ? this.data.states.data(this.stateSelection)
            : void 0
        ),
        i
      );
    }
    changeSelectedState(e, t, i = !1) {
      if (!(this.data.states.length === 0 && !i)) {
        for (let r of this.data.states)
          Xl.toOps(this.data, r.data).forEach((s) => {
            let a = Nm.replaceProps(s, this.data);
            (this.dataPatched = this.data),
              this.updateByPatchedOp(a, this.data, t);
          });
        if (e !== null) {
          let r = this.data.states.data(e);
          r &&
            ((this.dataPatched = Xl.patch(this.data, r)),
            Xl.toOps(this.data, r).forEach((s) => {
              this.updateByPatchedOp(s, this.dataPatched, t);
            }));
        }
        i && this.updateTransformState(this.dataPatched),
          (this.stateSelection = e);
      }
    }
    updateState(e, t) {
      e.name !== void 0 && (this.name = e.name),
        e.visible !== void 0 && (this.visible = e.visible),
        this.updateTransformState(e);
    }
    updateByPatchedOpBase(e, t, i) {
      (this.dataPatched = t), this.updateByPatchedOp(e, t, i);
    }
    updateByPatchedOp(e, t, i) {
      e.path.length === 0 && e.type === 0 && this.updateState(e.props, i),
        this.requestRender();
    }
    traverseFrameAncestors(e) {
      this.traverseAncestors((t) => {
        t.data.type === "frame2d" && e(t);
      });
    }
    traverseAncestors(e) {
      let t = this.parent;
      for (; t; ) e(t), (t = t.parent);
    }
    requestRender() {
      this.traverseFrameAncestors((e) => {
        e.requestRender();
      });
    }
    clone(e) {
      let t = new Rr(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
    addEventListener(e, t) {
      this.emitter.on(e, t);
    }
    removeEventListener(e, t) {
      this.emitter.off(e, t);
    }
    dispatchEvent(e) {
      this.emitter.emit(e.type, { ...e, target: e.target ?? this });
    }
    traverseSortNextHelper() {
      let e = this.parent;
      if (e) {
        let t = e.children;
        if (t) {
          let i = t.indexOf(this) + 1;
          return t[i] ? t[i] : e.traverseSortNextHelper();
        }
      }
    }
    sortNext() {
      let e = this.children;
      return e && e.length > 0 && e[0] ? e[0] : this.traverseSortNextHelper();
    }
    isDescendantOf(e) {
      e instanceof Rr && (e = e.uuid);
      let t = this;
      for (; t.parent; ) {
        if (t.parent.uuid === e) return !0;
        t = t.parent;
      }
      return !1;
    }
  },
  En = class extends Rr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this.context = i),
        (this.children = []);
    }
    add(e) {
      e.parent && e.parent instanceof En && e.parent.remove(e),
        this.children.push(e),
        (e.parent = this);
    }
    remove(e) {
      let t = this.children.indexOf(e);
      t >= 0 && (this.children.splice(t, 1), (e.parent = void 0));
    }
    traverse(e) {
      let t = e(this);
      if (t !== !0)
        for (let i of this.children)
          i instanceof En ? i.traverse(e) : (t = e(i));
    }
    intersectsChildren(e, t, i, r = !1, s = [], a = !1) {
      for (let n of this.children) {
        let o = n instanceof Mo;
        if (
          (n instanceof En &&
            !o &&
            a &&
            n.intersectsChildren(e, t, i, r, s, !1),
          n.intersects(e, t, i, o) && (s.push(n), r))
        )
          break;
      }
      return s;
    }
    updateWorldMatrix(e, t, i) {
      if ((super.updateWorldMatrix(e, t, i), i && this.children))
        for (let r of this.children) r.updateWorldMatrix(e, !1, !0);
    }
    find(e) {
      let t;
      return (
        this.traverse((i) => {
          i.uuid === e && (t = i);
        }),
        t
      );
    }
    innerDrawChildren(e) {
      for (let t = this.children.length - 1; t >= 0; t--)
        this.children[t].draw(e);
    }
    resetBBoxNeedsUpdate() {
      super.resetBBoxNeedsUpdate(),
        this.traverse((e) => {
          e.resetBBoxNeedsUpdateSelf();
        });
    }
    clone(e) {
      let t = new En(this.uuid, this.data, e);
      t.parent = void 0;
      for (let i of this.children) t.add(i.clone(e));
      return t;
    }
  },
  Mo = class extends En {
    constructor(e, t, i) {
      super(e, t, i), (this.uuid = e), (this.data = t), this.updateState(t, i);
    }
    draw(e) {
      !this.visible ||
        (e.save(),
        this.applyTransforms(e),
        this.innerDrawChildren(e),
        e.restore());
    }
    clone(e) {
      let t = new Mo(this.uuid, this.data, e);
      t.parent = void 0;
      for (let i of this.children) t.add(i.clone(e));
      return t;
    }
  };
function eZ(e, t) {
  let [[i, r], [s, a]] = e,
    [[n, o], [l, h]] = t,
    u = (i - s) * (o - h) - (r - a) * (n - l);
  if (u === 0) return !1;
  let c = ((i - n) * (o - h) - (r - o) * (n - l)) / u,
    d = -((i - s) * (r - o) - (r - a) * (i - n)) / u;
  return c >= 0 && c <= 1 && d >= 0 && d <= 1;
}
var DP = [
    [-1, 1],
    [-1, -1],
    [1, -1],
    [1, 1],
  ],
  SM = (e, t, i) => {
    let r = e.getCenter(),
      s = e.getHalfSize(),
      a = Ei.append(t, e.worldMatrix);
    s[0] === 0 && s[1] === 0
      ? i.push(Ei.apply(r, a))
      : DP.forEach((n) => {
          let o = [n[0] * s[0] + r[0], n[1] * s[1] + r[1]];
          i.push(Ei.apply(o, a));
        });
  },
  q1 = class {
    constructor() {
      (this.matrix = Ei.identity()),
        (this.min = [1 / 0, 1 / 0]),
        (this.max = [-1 / 0, -1 / 0]),
        (this.vertices = []),
        (this.edges = []);
    }
    setFromObjectSize(e, t = !1) {
      e.updateWorldMatrix(),
        this.makeEmpty(),
        Ei.copy(e.worldMatrix, this.matrix);
      let i = Ei.invert(e.worldMatrix);
      this.expandByObjectSize(e, i, t);
    }
    expandByObjectSize(e, t, i = !1) {
      let r = [];
      i === !0 && e instanceof En
        ? e.traverse((s) => {
            s.visible && SM(s, t, r);
          })
        : SM(e, t, r),
        this.setFromPoints(r);
    }
    getCenter() {
      let [e, t] = this.min,
        [i, r] = this.getHalfSize();
      return Ei.apply([e + i, t + r], this.matrix);
    }
    getSize() {
      return [this.max[0] - this.min[0], this.max[1] - this.min[1]];
    }
    getHalfSize() {
      return [
        (this.max[0] - this.min[0]) * 0.5,
        (this.max[1] - this.min[1]) * 0.5,
      ];
    }
    makeEmpty() {
      (this.min = [1 / 0, 1 / 0]), (this.max = [-1 / 0, -1 / 0]);
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t of e) this.expandByPoint(t);
    }
    expandByPoint(e) {
      (this.min = [Math.min(this.min[0], e[0]), Math.min(this.min[1], e[1])]),
        (this.max = [Math.max(this.max[0], e[0]), Math.max(this.max[1], e[1])]);
    }
    computeVertices() {
      let [e, t] = this.getHalfSize(),
        i = this.getCenter(),
        [r, s, a, n] = Ei.getAbcdef(this.matrix),
        o = Ei.create(r, s, a, n, i[0], i[1]);
      this.vertices = DP.map(([l, h]) => Ei.apply([l * e, h * t], o));
    }
    computeEdges() {
      this.edges = [];
      for (let e = 0, t = this.vertices.length; e < t; ++e)
        this.edges.push([this.vertices[e], this.vertices[(e + 1) % t]]);
    }
    project(e, t) {
      let i = this.matrix;
      return t && (i = Ei.append(t.worldMatrix, i)), Ei.applyInverse(e, i);
    }
    intersects(e, t, i) {
      return this.intersectsInLocalSpace(...this.project([e, t], i));
    }
    intersectsInLocalSpace(e, t) {
      let { min: i, max: r } = this;
      return e >= i[0] && e <= r[0] && t >= i[1] && t <= r[1];
    }
    containsPoint(e) {
      let [t, i] = e,
        [r, s] = this.min,
        [a, n] = this.max;
      return t >= r && t <= a && i >= s && i <= n;
    }
    intersectsBBox2D(e) {
      for (let t = 0, i = this.edges.length; t < i; t++) {
        let r = this.edges[t];
        for (let s = 0, a = e.edges.length; s < a; s++) {
          let n = e.edges[s];
          if (eZ(r, n)) return !0;
        }
      }
      for (let t = 0, i = e.vertices.length; t < i; t++) {
        let r = e.vertices[t];
        if (this.containsPoint(r)) return !0;
      }
      return !1;
    }
    ensureMinMax() {
      let e = this.min,
        t = this.max;
      (this.min = [Math.min(e[0], t[0]), Math.min(e[1], t[1])]),
        (this.max = [Math.max(e[0], t[0]), Math.max(e[1], t[1])]);
    }
    copy(e) {
      (this.min = [...e.min]),
        (this.max = [...e.max]),
        Ei.copy(e.matrix, this.matrix),
        this.computeVertices(),
        this.computeEdges();
    }
    clone() {
      let e = new q1();
      return e.copy(this), e;
    }
  },
  OP,
  tZ = new Promise((e) => {
    OP = e;
  }),
  AM = !1,
  Xf;
function iZ() {
  if (AM) return;
  if (Xf) return Xf;
  async function e() {
    let t = await Promise.resolve().then(() => (Fw(), zw));
    OP(t.default ?? t), (AM = !0);
  }
  return (Xf = e()), Xf;
}
function MM(e) {
  let t = !1;
  return (
    e.scene.objects.traverse((i, r) => {
      ((r.type === "Mesh" && r.geometry.type === "UIGeometry") ||
        (r.type === "Page" && r.uiFrame !== void 0)) &&
        (t = !0);
    }),
    t
  );
}
var zt, F0;
async function rZ(e) {
  let t = await tZ;
  zt || (F0 || (F0 = t({ locateFile: () => e })), (zt = await F0));
}
var EM = Ei.identity(),
  CM = class {
    constructor(e, t = 1) {
      (this.canvas = e),
        (this.dpr = t),
        (this._width = 0),
        (this._height = 0),
        (this._strokeMode = "inside"),
        (this._layerBlur = 0),
        (this._backgroundBlur = 0),
        (this._dropShadowBlur = 0),
        (this._dropShadowOffsetX = 0),
        (this._dropShadowOffsetY = 0),
        (this._dropShadowColor = Ti.transparent),
        (this._innerShadowBlur = 0),
        (this._innerShadowOffsetX = 0),
        (this._innerShadowOffsetY = 0),
        (this._innerShadowSpread = 0),
        (this._innerShadowColor = Ti.transparent),
        (this._fonts = new Map());
      try {
        let i = e.getBoundingClientRect();
        (e.width = i.width * t), (e.height = i.height * t);
      } catch {
        console.log(e.width, t);
      }
      (this._currentM3Transform = EM),
        (this._currentTransform = new Float32Array(EM));
    }
    async init() {
      if (!this.wasmURL)
        throw Error(
          "Your must set the wasm binary url with renderer.wasmURL = ... before you can call renderer.init"
        );
      await rZ(this.wasmURL),
        (this._surface = zt.MakeWebGLCanvasSurface(this.canvas)),
        (this.ctx = this._surface?.getCanvas()),
        (this._paint = new zt.Paint()),
        this._paint.setAntiAlias(!0),
        (this._paintFill = this._paint.copy()),
        this._paintFill.setStyle(zt.PaintStyle.Fill),
        (this._paintStroke = this._paint.copy()),
        this._paintStroke.setStyle(zt.PaintStyle.Stroke),
        this.ctx?.scale(this.dpr, this.dpr);
    }
    get currentTransform() {
      return this._currentM3Transform;
    }
    get currentTransformBuffer() {
      return this._currentTransform;
    }
    set currentTransform(e) {
      (this._currentM3Transform = e), this._currentTransform.set(e);
    }
    async loadFont(e, t) {
      let i = await (await fetch(e)).arrayBuffer();
      this.registerFont(i, t);
    }
    registerFont(e, t) {
      if (this._fonts.has(t)) return;
      let i = zt.FontMgr.FromData(e);
      if (i) this._fonts.set(t, i);
      else throw new Error("Invalid font data for " + t);
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    set strokeColor(e) {
      this._paintStroke &&
        this._paintStroke.setColor(Qf(e), zt.ColorSpace.DISPLAY_P3);
    }
    set fillColor(e) {
      this._paintFill &&
        this._paintFill.setColor(Qf(e), zt.ColorSpace.DISPLAY_P3);
    }
    set lineWidth(e) {
      this._paintStroke &&
        this._paintStroke.setStrokeWidth(
          this._strokeMode === "center" ? e : e * 2
        );
    }
    set strokeMode(e) {
      this._strokeMode = e;
    }
    set dropShadowBlur(e) {
      this._dropShadowBlur = e;
    }
    set dropShadowColor(e) {
      this._dropShadowColor = e;
    }
    set dropShadowOffsetX(e) {
      this._dropShadowOffsetX = e;
    }
    set dropShadowOffsetY(e) {
      this._dropShadowOffsetY = e;
    }
    set innerShadowBlur(e) {
      this._innerShadowBlur = e;
    }
    set innerShadowColor(e) {
      this._innerShadowColor = e;
    }
    set innerShadowOffsetX(e) {
      this._innerShadowOffsetX = e;
    }
    set innerShadowOffsetY(e) {
      this._innerShadowOffsetY = e;
    }
    set innerShadowSpread(e) {
      this._innerShadowSpread = e;
    }
    set layerBlur(e) {
      this._layerBlur = e;
    }
    set backgroundBlur(e) {
      this._backgroundBlur = e;
    }
    clear() {
      this.ctx?.clear(zt.TRANSPARENT);
    }
    save() {
      this.ctx?.save();
    }
    restore() {
      this.ctx?.restore();
    }
    beginPath() {
      this._currentPath?.delete(), (this._currentPath = new zt.Path());
    }
    closePath() {
      let e = this._currentPath;
      if (e) {
        if (e.isEmpty()) return;
        let t = e.getBounds();
        (t[3] - t[1] || t[2] - t[0]) && e.close();
      }
    }
    fill() {
      this._paintInner(this._paintFill, !0);
    }
    stroke() {
      this._paintInner(this._paintStroke, !1);
    }
    clipRect(e, t, i, r, s = 0, a = 0, n = 0, o = 0) {
      let l = zt.XYWHRect(e, t, i, r);
      if (s === 0 && a === 0 && o === 0 && n === 0)
        this.ctx?.clipRect(l, zt.ClipOp.Intersect, !0);
      else {
        let h = zt.RRectXY(l, s, s);
        (h[4] = h[5] = s),
          (h[6] = h[7] = a),
          (h[8] = h[9] = n),
          (h[10] = h[11] = o),
          this.ctx?.clipRRect(h, zt.ClipOp.Intersect, !0);
      }
    }
    _applyShadowOffsetMatrix() {
      if (this.ctx) {
        let e = Ei.invert(this.currentTransform);
        this.ctx.concat(e);
        let t = Ei.translate(
          Ei.identity(),
          this._dropShadowOffsetX,
          this._dropShadowOffsetY
        );
        this.ctx.concat(t), this.ctx.concat(this._currentTransform);
      }
    }
    _applyEffectsToPaint(e, t, i = !0) {
      if (this.ctx && this._currentPath) {
        let r,
          s = !1;
        if (i && this._hasDropShadow()) {
          let a = e.copy();
          a.setColor(Qf(this._dropShadowColor));
          let n;
          this._dropShadowBlur > 0 &&
            ((n = zt.MaskFilter.MakeBlur(
              zt.BlurStyle.Normal,
              this._dropShadowBlur * this.dpr * (this.camera?.scale ?? 1),
              !1
            )),
            a.setMaskFilter(n)),
            this.ctx.save(),
            this.ctx.clipPath(this._currentPath, zt.ClipOp.Difference, !0),
            this._applyShadowOffsetMatrix(),
            t(a),
            this.ctx.restore(),
            a.delete(),
            n?.delete();
        }
        if (this._backgroundBlur > 0 && i) {
          this.ctx.save(),
            this.ctx.clipPath(this._currentPath, zt.ClipOp.Intersect, !0);
          let a = zt.ImageFilter.MakeBlur(
              this._backgroundBlur,
              this._backgroundBlur,
              zt.TileMode.Clamp,
              null
            ),
            n = e.copy();
          n.setImageFilter(a), n.setAlphaf(1);
          let o = this._currentPath.computeTightBounds();
          this.ctx.saveLayer(n, o, null, zt.SaveLayerInitWithPrevious),
            this.ctx.drawColor(e.getColor()),
            this.ctx.restore(),
            this.ctx.restore(),
            n.delete(),
            a.delete(),
            (s = !0);
        }
        if (this._layerBlur > 0) {
          let a = e.copy();
          (r = zt.MaskFilter.MakeBlur(
            zt.BlurStyle.Normal,
            this._layerBlur * this.dpr * (this.camera?.scale ?? 1),
            !1
          )),
            a.setMaskFilter(r),
            t(a),
            a.delete(),
            r.delete(),
            (s = !0);
        }
        if ((s || t(e), i && this._hasInnerShadow())) {
          let a = new zt.Paint();
          a.setAntiAlias(!0),
            a.setStyle(zt.PaintStyle.Fill),
            a.setColor(Qf(this._innerShadowColor));
          let n;
          this._innerShadowBlur > 0 &&
            ((n = zt.MaskFilter.MakeBlur(
              zt.BlurStyle.Normal,
              this._innerShadowBlur * this.dpr * (this.camera?.scale ?? 1),
              !1
            )),
            a.setMaskFilter(n));
          let o = this._currentPath.computeTightBounds(),
            [l, h, u, c] = o,
            d = u - l,
            p = c - h;
          this.ctx.save(),
            this.ctx.clipPath(this._currentPath, zt.ClipOp.Intersect, !0),
            this.ctx.saveLayer(a, o, null, zt.SaveLayerInitWithPrevious),
            this.ctx?.translate(
              this._innerShadowOffsetX,
              this._innerShadowOffsetY
            ),
            this.ctx.drawRect(
              zt.XYWHRect(
                -1e3 - this._innerShadowOffsetX,
                -1e3 - this._innerShadowOffsetY,
                2e3 + d + Math.abs(this._innerShadowOffsetX * 2),
                2e3 + p + Math.abs(this._innerShadowOffsetY * 2)
              ),
              a
            ),
            a.setBlendMode(zt.BlendMode.Clear),
            this.ctx.drawPath(this._currentPath, a),
            this.ctx.restore(),
            this.ctx.restore(),
            a.delete(),
            n?.delete();
        }
      }
    }
    _paintInner(e, t = !0) {
      if (this.ctx && this._currentPath && e) {
        let i = this.ctx,
          r = this._currentPath;
        this._applyEffectsToPaint(
          e,
          (s) => {
            let a = !1;
            !t &&
              this._strokeMode !== "center" &&
              (i.save(),
              i.clipPath(
                r,
                this._strokeMode === "outside"
                  ? zt.ClipOp.Difference
                  : zt.ClipOp.Intersect,
                !0
              ),
              (a = !0)),
              i.drawPath(r, s),
              a && i.restore();
          },
          t
        );
      }
    }
    _hasDropShadow() {
      return this._dropShadowColor?.a > 0;
    }
    _hasInnerShadow() {
      return this._innerShadowColor?.a > 0;
    }
    path(e) {
      this._currentPath?.addPath(zt.Path.MakeFromSVGString(e));
    }
    ellipse(e, t, i, r, s, a, n, o) {
      if (!TM([e, t, i, r]) || !this._currentPath) return;
      if (i < 0 || r < 0) throw Error("radii cannot be negative");
      let l = zt.XYWHRect(e - i, t - r, i * 2, r * 2);
      this._currentPath?.addOval(l);
    }
    rect(e, t, i, r, s = 0, a = 0, n = 0, o = 0) {
      let l = zt.XYWHRect(e, t, i, r);
      if (TM(l))
        if (s === 0 && a === 0 && o === 0 && n === 0)
          this._currentPath?.addRect(l);
        else {
          let h = zt.RRectXY(l, s, s);
          (h[4] = h[5] = s),
            (h[6] = h[7] = a),
            (h[8] = h[9] = n),
            (h[10] = h[11] = o),
            this._currentPath?.addRRect(h);
        }
    }
    getHorizontalAlign(e) {
      switch (e) {
        case 2:
          return zt.TextAlign.Right;
        case 3:
          return zt.TextAlign.Center;
        case 4:
          return zt.TextAlign.Justify;
        case 1:
        default:
          return zt.TextAlign.Left;
      }
    }
    drawTextInner(e, t, i, [r, s, a, n], o, l, h = !0) {
      let u = 0,
        { ctx: c } = this;
      if (!c) return u;
      let d = l.copy(),
        p = l.copy();
      return (
        p.setAlphaf(0),
        this._applyEffectsToPaint(
          d,
          (f) => {
            t.pushPaintStyle(i, f, p), t.addText(e);
            let m = t.build();
            m.layout(a);
            let g = s;
            o === 2
              ? (g += (n - m.getHeight()) / 2)
              : o === 3 && (g += n - m.getHeight()),
              c.drawParagraph(m, r, g),
              (u = m.getHeight()),
              t.reset(),
              m.delete();
          },
          h
        ),
        d.delete(),
        p.delete(),
        u
      );
    }
    drawText(e, t) {
      let i = 0,
        r = this._fonts.get(t.font),
        { ctx: s, _paintFill: a, _paintStroke: n } = this;
      if (r && s) {
        let o = new zt.TextStyle({
            fontFamilies: [t.font],
            fontSize: t.fontSize,
            heightMultiplier: t.lineHeight,
            letterSpacing: t.letterSpacing,
          }),
          l = new zt.ParagraphStyle({
            textStyle: o,
            textAlign: this.getHorizontalAlign(t.horizontalAlign),
          }),
          h = zt.XYWHRect(t.x, t.y, t.width, t.height),
          u = zt.ParagraphBuilder.Make(l, r);
        a && (i = this.drawTextInner(e, u, o, h, t.verticalAlign, a, !0)),
          n && (i = this.drawTextInner(e, u, o, h, t.verticalAlign, n, !1)),
          u.delete();
      }
      return { height: i };
    }
    render() {
      this._surface?.flush();
    }
    moveTo(e, t) {
      this._currentPath?.moveTo(e, t);
    }
    lineTo(e, t) {
      this._currentPath?.lineTo(e, t);
    }
    bezierCurveTo(e, t, i, r, s, a) {
      this._currentPath?.cubicTo(e, t, i, r, s, a);
    }
    quadraticCurveTo(e, t, i, r) {
      this._currentPath?.quadTo(e, t, i, r);
    }
    setTransform(e, t = !1) {
      if (!this.ctx) return;
      let i = this.ctx.getTotalMatrix(),
        r = Ei.invert(i);
      if (
        (r && this.ctx.concat(r),
        this.ctx?.scale(this.dpr, this.dpr),
        this.camera?.enabled && (this.ctx?.concat(this.camera.worldMatrix), t))
      ) {
        let s = Ei.getScale(this.camera.worldMatrix);
        this.ctx?.scale(1 / s[0], 1 / s[1]);
      }
      this.ctx?.concat(e), (this.currentTransform = e);
    }
    transform(e) {
      this.ctx?.concat(e);
    }
    setSize(e, t) {
      (e === this._width && t === this._height) ||
        ((this._width = e),
        (this._height = t),
        (this.canvas.style.width = e + "px"),
        (this.canvas.style.height = t + "px"),
        (this.canvas.width = e * this.dpr),
        (this.canvas.height = t * this.dpr),
        this._surface &&
          ((this._surface = zt.MakeWebGLCanvasSurface(this.canvas)),
          (this.ctx = this._surface?.getCanvas())));
    }
  };
function TM(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== void 0 && !Number.isFinite(e[t])) return !1;
  return !0;
}
function Qf({ r: e, g: t, b: i, a: r }) {
  return zt.Color4f(e, t, i, r);
}
var PM = class {
    constructor(e, t, i) {
      (this.uuid = e),
        (this.data = t),
        (this.enabled = !1),
        (this.color = Ti.transparent),
        (this.blurRadius = 0),
        (this.offset = [0, 0]),
        (this.spread = 0),
        this.update(t);
    }
    update(e) {
      e.color !== void 0 && (this.color = e.color),
        e.enabled !== void 0 && (this.enabled = e.enabled),
        e.blurRadius !== void 0 && (this.blurRadius = e.blurRadius),
        e.offset !== void 0 && (this.offset = e.offset),
        e.spread !== void 0 && (this.spread = e.spread);
    }
  },
  DM = class {
    constructor(e, t, i) {
      (this.uuid = e),
        (this.data = t),
        (this.enabled = !1),
        (this.radius = 0),
        this.update(t);
    }
    update(e) {
      e.enabled !== void 0 && (this.enabled = e.enabled),
        e.radius !== void 0 && (this.radius = e.radius);
    }
  },
  sZ = class {
    constructor(e, t, i) {
      (this.uuid = e),
        (this.data = t),
        (this.enabled = !1),
        (this.color = Ti.transparent),
        this.update(t);
    }
    update(e) {
      e.enabled !== void 0 && (this.enabled = e.enabled),
        e.color !== void 0 && (this.color = e.color);
    }
  },
  aZ = class {
    constructor(e, t, i) {
      (this.uuid = e),
        (this.data = t),
        (this.enabled = !1),
        (this.color = Ti.transparent),
        (this.thickness = 0),
        (this.mode = "inside"),
        this.update(t);
    }
    update(e) {
      e.enabled !== void 0 && (this.enabled = e.enabled),
        e.color !== void 0 && (this.color = e.color),
        e.thickness !== void 0 && (this.thickness = e.thickness),
        e.mode !== void 0 && (this.mode = e.mode);
    }
  },
  Gr = class extends Rr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this.autoClose = !0),
        (this.fill = new sZ(e + "-fill", t.fill, i)),
        (this.stroke = new aZ(e + "-stroke", t.stroke, i)),
        (this.dropShadow = new PM(e + "-dropShadow", t.dropShadow, i)),
        (this.innerShadow = new PM(e + "-innerShadow", t.innerShadow, i)),
        (this.backgroundBlur = new DM(
          e + "-backgroundBlur",
          t.backgroundBlur,
          i
        )),
        (this.layerBlur = new DM(e + "-layerBlur", t.layerBlur, i));
    }
    applyFillStroke(e) {
      (e.fillColor = this.fill.enabled ? this.fill.color : Ti.transparent),
        (e.strokeColor =
          this.stroke.enabled && this.stroke.thickness > 0
            ? this.stroke.color
            : Ti.transparent),
        (e.strokeMode = this.stroke.mode),
        (e.lineWidth = this.stroke.thickness);
    }
    applyFilters(e) {
      this.layerBlur.enabled
        ? (e.layerBlur = this.layerBlur.radius * 5)
        : (e.layerBlur = 0),
        this.backgroundBlur.enabled
          ? (e.backgroundBlur = this.backgroundBlur.radius * 5)
          : (e.backgroundBlur = 0),
        this.dropShadow.enabled
          ? ((e.dropShadowBlur = this.dropShadow.blurRadius * 5),
            (e.dropShadowColor = this.dropShadow.color),
            (e.dropShadowOffsetX = this.dropShadow.offset[0]),
            (e.dropShadowOffsetY = this.dropShadow.offset[1]))
          : (e.dropShadowColor = Ti.transparent),
        this.innerShadow.enabled
          ? ((e.innerShadowSpread = this.innerShadow.spread),
            (e.innerShadowBlur = this.innerShadow.blurRadius * 5),
            (e.innerShadowColor = this.innerShadow.color),
            (e.innerShadowOffsetX = this.innerShadow.offset[0]),
            (e.innerShadowOffsetY = this.innerShadow.offset[1]))
          : (e.innerShadowColor = Ti.transparent);
    }
    innerDraw(e) {}
    draw(e) {
      !this.visible ||
        (e.save(),
        this.applyTransforms(e),
        this.applyFilters(e),
        this.applyFillStroke(e),
        e.beginPath(),
        this.innerDraw(e),
        this.autoClose && e.closePath(),
        this.fill.enabled && e.fill(),
        this.stroke.enabled && e.stroke(),
        e.restore());
    }
    updateByPatchedOp(e, t, i) {
      super.updateByPatchedOp(e, t, i),
        e.type === 0 &&
          (Ii(e.path, ["fill"])
            ? this.fill.update(e.props)
            : Ii(e.path, ["stroke"])
            ? this.stroke.update(e.props)
            : Ii(e.path, ["dropShadow"])
            ? this.dropShadow.update(e.props)
            : Ii(e.path, ["innerShadow"])
            ? this.innerShadow.update(e.props)
            : Ii(e.path, ["layerBlur"])
            ? this.layerBlur.update(e.props)
            : Ii(e.path, ["backgroundBlur"])
            ? this.backgroundBlur.update(e.props)
            : this.resetBBoxNeedsUpdate());
    }
    updateState(e, t) {
      super.updateState(e, t),
        e.fill !== void 0 && this.fill.update(e.fill),
        e.stroke !== void 0 && this.stroke.update(e.stroke),
        e.dropShadow !== void 0 && this.dropShadow.update(e.dropShadow),
        e.innerShadow !== void 0 && this.innerShadow.update(e.innerShadow),
        e.layerBlur !== void 0 && this.layerBlur.update(e.layerBlur),
        e.backgroundBlur !== void 0 &&
          this.backgroundBlur.update(e.backgroundBlur);
    }
    clone(e) {
      let t = new Gr(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
  },
  Tb = class extends Gr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this.width = 0),
        (this.height = 0),
        this.updateState(t, i);
    }
    innerDraw(e) {
      e.ellipse(
        this.width * 0.5,
        this.height * 0.5,
        this.width * 0.5,
        this.height * 0.5,
        0,
        0,
        Math.PI * 2
      );
    }
    intersectsInLocalSpace(e, t) {
      return KQ(
        e,
        t,
        this.width * 0.5,
        this.height * 0.5,
        this.width * 0.5,
        this.height * 0.5
      );
    }
    getCenter() {
      return [this.width * 0.5, this.height * 0.5];
    }
    getHalfSize() {
      return [this.width * 0.5, this.height * 0.5];
    }
    updateSizeState(e) {
      let t = !1;
      e.width !== void 0 &&
        ((this.width = typeof e.width == "number" ? e.width : this.width),
        (t = !0)),
        e.height !== void 0 &&
          ((this.height = typeof e.height == "number" ? e.height : this.height),
          (t = !0)),
        t && this.updateWorldMatrix(!0, !1, !0);
    }
    updateState(e, t) {
      super.updateState(e, t), this.updateSizeState(e);
    }
    clone(e) {
      let t = new Tb(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
  },
  mp = class extends Gr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this.width = 0),
        (this.height = 0),
        (this.cornerRadius = [0, 0, 0, 0]),
        this.updateState(t, i);
    }
    innerDraw(e) {
      e.rect(0, 0, this.width, this.height, ...this.cornerRadius);
    }
    getCenter() {
      return [this.width * 0.5, this.height * 0.5];
    }
    getHalfSize() {
      return [this.width * 0.5, this.height * 0.5];
    }
    updateCornerState(e) {
      e.cornerRadius !== void 0 && (this.cornerRadius = e.cornerRadius);
    }
    updateSizeState(e) {
      let t = !1;
      e.width !== void 0 &&
        ((this.width = typeof e.width == "number" ? e.width : this.width),
        (t = !0)),
        e.height !== void 0 &&
          ((this.height = typeof e.height == "number" ? e.height : this.height),
          (t = !0)),
        t && this.updateWorldMatrix(!0, !1, !0);
    }
    updateState(e, t) {
      super.updateState(e, t),
        this.updateSizeState(e),
        this.updateCornerState(e);
    }
    clone(e) {
      let t = new mp(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
  },
  Pb = class extends Gr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this._textHeight = 0),
        (this._textHeightDirty = !0),
        (this.width = 0),
        (this.height = 0),
        this.updateState(t, i);
    }
    get textHeight() {
      return this._textHeight;
    }
    applyFillStroke(e) {
      (e.fillColor = this.fill.enabled ? this.fill.color : Ti.transparent),
        (e.strokeColor =
          this.stroke.enabled && this.stroke.thickness > 0
            ? this.stroke.color
            : Ti.transparent),
        (e.strokeMode = "center"),
        (e.lineWidth = this.stroke.thickness);
    }
    innerDraw(e) {
      this._fontHolder?.arrayBuffer &&
        this._fontHolder.arrayBuffer.byteLength > 1 &&
        this.data.font &&
        e.registerFont(this._fontHolder.arrayBuffer, this.data.font);
      let t = this.data.textTransform,
        i = this.data.text.textValue.toString(),
        r = t === 2 ? i.toUpperCase() : t === 3 ? i.toLowerCase() : i,
        { height: s } = e.drawText(r, {
          x: 0,
          y: 0,
          width: this.width,
          height: this.height,
          fontSize: this.data.fontSize,
          lineHeight: this.data.lineHeight ?? 1,
          letterSpacing: this.data.letterSpacing ?? 0,
          horizontalAlign: this.data.horizontalAlign,
          verticalAlign: this.data.verticalAlign,
          font: this.data.font,
        });
      this._textHeight = s;
    }
    getCenter() {
      return [this.width * 0.5, this.height * 0.5];
    }
    getHalfSize() {
      return [this.width * 0.5, this.height * 0.5];
    }
    updateSizeState(e) {
      let t = !1;
      e.width !== void 0 &&
        ((this.width = typeof e.width == "number" ? e.width : this.width),
        (t = !0)),
        e.height !== void 0 &&
          ((this.height = typeof e.height == "number" ? e.height : this.height),
          (t = !0)),
        t && this.updateWorldMatrix(!0, !1, !0);
    }
    updateFontState(e, { shared: t }) {
      e.font !== void 0 &&
        ((this._fontHolder = t.getFont(e.font)),
        this._fontHolder &&
          !this._fontHolder.isLoaded &&
          this._fontHolder.loadingPromise.then(() => {
            this.requestRender();
          }));
    }
    updateState(e, t) {
      super.updateState(e, t),
        this.updateSizeState(e),
        this.updateFontState(e, t);
    }
    clone(e) {
      let t = new Pb(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
  },
  IP = class extends Gr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this.curves = []),
        (this.extremasBBox = { min: [0, 0], max: [0, 0] }),
        this.updateState(t, i);
    }
    computeExtremas() {
      this.curves.length === 0 && this.computeCurves();
      let e = this.curves.map((r) => dg.extremas(r)),
        t = [1 / 0, 1 / 0],
        i = [-1 / 0, -1 / 0];
      for (let r = 0, s = e.length; r < s; r++) {
        let a = e[r];
        a[0][0] < t[0] && (t[0] = a[0][0]),
          a[0][1] < t[1] && (t[1] = a[0][1]),
          a[1][0] > i[0] && (i[0] = a[1][0]),
          a[1][1] > i[1] && (i[1] = a[1][1]);
      }
      return (
        (this.extremasBBox.min = [t[0], t[1]]),
        (this.extremasBBox.max = [i[0], i[1]]),
        this.extremasBBox
      );
    }
    computeCurves() {
      this.curves = [];
      for (let i = 1, r = this.data.points.length; i < r; i++) {
        let s = this.data.points[i].data,
          a = this.data.points[i - 1].data,
          n = {
            start: a.position,
            cp1: a.controlNext.position,
            cp2: s.controlPrevious.position,
            end: s.position,
          };
        this.curves.push(n);
      }
      let e = this.data.points[0].data,
        t = this.data.points[this.data.points.length - 1].data;
      if (this.data.isClosed) {
        let i = {
          start: t.position,
          cp1: t.controlNext.position,
          cp2: e.controlPrevious.position,
          end: e.position,
        };
        this.curves.push(i);
      }
    }
    getCenter() {
      let [e, t] = this.extremasBBox.min,
        [i, r] = this.getHalfSize();
      return [e + i, t + r];
    }
    getHalfSize() {
      let { min: e, max: t } = this.extremasBBox;
      return [(t[0] - e[0]) * 0.5, (t[1] - e[1]) * 0.5];
    }
    innerDraw(e) {
      for (let r = 0, s = this.data.points.length; r < s; r++) {
        let a = this.data.points[r].data;
        if (r === 0) {
          let [n, o] = a.position;
          e.moveTo(n, o);
        } else {
          let n = this.data.points[r - 1].data,
            [o, l] = n.controlNext.position,
            [h, u] = a.controlPrevious.position,
            [c, d] = a.position,
            p = {
              start: n.position,
              cp1: n.controlNext.position,
              cp2: a.controlPrevious.position,
              end: a.position,
            };
          dg.derive(p), e.bezierCurveTo(o, l, h, u, c, d);
        }
      }
      let t = this.data.points[0].data,
        i = this.data.points[this.data.points.length - 1].data;
      if (this.data.isClosed) {
        let [r, s] = i.controlNext.position,
          [a, n] = t.controlPrevious.position,
          [o, l] = t.position;
        e.bezierCurveTo(r, s, a, n, o, l);
      }
    }
    updateState(e, t) {
      super.updateState(e, t), this.computeExtremas();
    }
    clone(e) {
      let t = new IP(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
  },
  dg;
((e) => {
  function t(n) {
    let o = n.start,
      l = n.cp1,
      h = n.cp2,
      u = n.end,
      c = [3 * (l[0] - o[0]), 3 * (l[1] - o[1])],
      d = [3 * (h[0] - l[0]), 3 * (h[1] - l[1])],
      p = [3 * (u[0] - h[0]), 3 * (u[1] - h[1])],
      f = { start: c, cp: d, end: p };
    return (n.derivative = f), (f.derivative = Y1.derive(f)), f;
  }
  e.derive = t;
  function i(n, o, l, h = !1) {
    let u = n - 2 * o + l;
    if (u !== 0) {
      let c = -Math.sqrt(Math.abs(o * o - n * l)),
        d = -n + o,
        p = -(c + d) / u,
        f = -(-c + d) / u;
      return [p, f];
    } else if (o !== l && u === 0) return [(2 * o - l) / (2 * (o - l))];
    return [];
  }
  function r(n) {
    let o = n.derivative ?? e.derive(n),
      l = o.start,
      h = o.cp,
      u = o.end;
    return [i(l[0], h[0], u[0]), i(l[1], h[1], u[1])];
  }
  e.droot = r;
  function s(n) {
    let [o, l] = e.droot(n),
      h = [n.start[0], n.end[0]],
      u = [n.start[1], n.end[1]];
    for (let c of o) h.push(e.compute(n, Math.min(1, Math.max(0, c)))[0]);
    for (let c of l) u.push(e.compute(n, Math.min(1, Math.max(0, c)))[1]);
    return (
      h.sort((c, d) => c - d),
      u.sort((c, d) => c - d),
      [
        [h[0], u[0]],
        [h[h.length - 1], u[u.length - 1]],
      ]
    );
  }
  e.extremas = s;
  function a(n, o) {
    if (o === 0) return [...n.start];
    if (o === 1) return [...n.end];
    let l = 1 - o,
      h = l * l,
      u = o * o,
      c = h * l,
      d = h * o * 3,
      p = l * u * 3,
      f = o * u;
    return [
      c * n.start[0] + d * n.cp1[0] + p * n.cp2[0] + f * n.end[0],
      c * n.start[1] + d * n.cp1[1] + p * n.cp2[1] + f * n.end[1],
    ];
  }
  e.compute = a;
})(dg || (dg = {}));
var Y1;
((e) => {
  function t(s) {
    let a = s.start,
      n = s.cp,
      o = s.end,
      l = [2 * (n[0] - a[0]), 2 * (n[1] - a[1])],
      h = [2 * (o[0] - n[0]), 2 * (o[1] - n[1])],
      u = { start: l, end: h };
    return (u.derivative = X1.derive(u)), (s.derivative = u), u;
  }
  e.derive = t;
  function i(s) {
    let a = s.derivative ?? e.derive(s),
      n = a.start,
      o = a.end;
    return [
      n[0] !== o[0] ? n[0] / (n[0] - o[0]) : 0,
      n[1] !== o[1] ? n[1] / (n[1] - o[1]) : 0,
    ];
  }
  e.droot = i;
  function r(s, a) {
    if (a === 0) return [...s.start];
    if (a === 1) return [...s.end];
    let n = 1 - a,
      o = n * n,
      l = a * a,
      h = o,
      u = n * a * 2,
      c = l;
    return [
      h * s.start[0] + u * s.cp[0] + c * s.end[0],
      h * s.start[1] + u * s.cp[1] + c * s.end[1],
    ];
  }
  e.compute = r;
})(Y1 || (Y1 = {}));
var X1;
((e) => {
  function t(r) {
    let s = r.start,
      a = r.end,
      n = [a[0] - s[0], a[1] - s[1]];
    return (r.derivative = n), r.derivative;
  }
  e.derive = t;
  function i(r, s) {
    if (s === 0) return [...r.start];
    if (s === 1) return [...r.end];
    let a = r.start,
      n = r.end;
    return [a[0] + (n[0] - a[0]) * s, a[1] + (n[1] - a[1]) * s];
  }
  e.compute = i;
})(X1 || (X1 = {}));
var Dn = class extends En {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.width = 0),
        (this.height = 0),
        (this.clipped = !0),
        (this.background = new mp(e + "-background", Yd.defaultData, i)),
        (this.background.parent = this),
        this.updateState(t, i);
    }
    get fill() {
      return this.background.fill;
    }
    get stroke() {
      return this.background.stroke;
    }
    get backgroundBlur() {
      return this.background.backgroundBlur;
    }
    get layerBlur() {
      return this.background.layerBlur;
    }
    get dropShadow() {
      return this.background.dropShadow;
    }
    get innerShadow() {
      return this.background.innerShadow;
    }
    get cornerRadius() {
      return this.background.cornerRadius;
    }
    set cornerRadius(e) {
      this.background.cornerRadius = e;
    }
    updateLocalMatrix() {
      super.updateLocalMatrix(), this.background?.updateLocalMatrix();
    }
    updateWorldMatrix(e, t, i) {
      super.updateWorldMatrix(e, t, i),
        this.background?.updateWorldMatrix(e, t, i);
    }
    draw(e) {
      if (!this.visible) return;
      e.save();
      let t = this.width,
        i = this.height;
      this.applyTransforms(e),
        (this.background.width = t),
        (this.background.height = i),
        this.background.draw(e),
        this.clipped && e.clipRect(0, 0, t, i, ...this.cornerRadius),
        this.innerDrawChildren(e),
        e.restore();
    }
    getCenter() {
      return [this.width * 0.5, this.height * 0.5];
    }
    getHalfSize() {
      return [this.width * 0.5, this.height * 0.5];
    }
    updateCornerState(e) {
      e.cornerRadius !== void 0 && (this.cornerRadius = e.cornerRadius);
    }
    updateSizeState(e) {
      let t = !1;
      e.width !== void 0 &&
        ((this.width = typeof e.width == "number" ? e.width : this.width),
        (t = !0)),
        e.height !== void 0 &&
          ((this.height = typeof e.height == "number" ? e.height : this.height),
          (t = !0)),
        t && this.updateWorldMatrix(!0, !1, !0);
    }
    updateState(e, t) {
      super.updateState(e, t),
        this.updateSizeState(e),
        this.updateCornerState(e),
        e.fill !== void 0 && this.fill.update(e.fill),
        e.stroke !== void 0 && this.stroke.update(e.stroke),
        e.dropShadow !== void 0 && this.dropShadow.update(e.dropShadow),
        e.innerShadow !== void 0 && this.innerShadow.update(e.innerShadow),
        e.layerBlur !== void 0 && this.layerBlur.update(e.layerBlur),
        e.backgroundBlur !== void 0 &&
          this.backgroundBlur.update(e.backgroundBlur),
        e.clipped !== void 0 && (this.clipped = e.clipped);
    }
    requestRender() {
      super.requestRender(), this.dispatchEvent({ type: "render" });
    }
    dispose() {
      this.removeEventListener("render");
    }
    updateByPatchedOp(e, t, i) {
      super.updateByPatchedOp(e, t, i),
        e.type === 0 &&
          (Ii(e.path, ["fill"])
            ? this.fill.update(e.props)
            : Ii(e.path, ["stroke"])
            ? this.stroke.update(e.props)
            : Ii(e.path, ["dropShadow"])
            ? this.dropShadow.update(e.props)
            : Ii(e.path, ["innerShadow"])
            ? this.innerShadow.update(e.props)
            : Ii(e.path, ["layerBlur"])
            ? this.layerBlur.update(e.props)
            : Ii(e.path, ["backgroundBlur"])
            ? this.backgroundBlur.update(e.props)
            : this.resetBBoxNeedsUpdate());
    }
    clone(e) {
      let t = new Dn(this.uuid, this.data, e);
      t.parent = void 0;
      for (let i of this.children) t.add(i.clone(e));
      return t;
    }
  },
  nZ = Sr(kE(), 1),
  Vg = class extends Gr {
    constructor(e, t, i) {
      super(e, t, i),
        (this.uuid = e),
        (this.data = t),
        (this._pathBBox = new DOMRect()),
        (this.path = ""),
        this.updateState(t, i),
        (this.autoClose = !1),
        this.computeSVGBBox();
    }
    computeSVGBBox() {
      let e = document.createElementNS("http://www.w3.org/2000/svg", "svg"),
        t = document.createElementNS("http://www.w3.org/2000/svg", "path");
      document.body.appendChild(e),
        t.setAttribute("d", this.path),
        e.appendChild(t),
        (this._pathBBox = t.getBBox()),
        e.remove();
    }
    innerDraw(e) {
      e.path(this.path);
    }
    intersectsInLocalSpace(e, t) {
      return (
        e >= this._pathBBox.x &&
        e <= this._pathBBox.x + this._pathBBox.width &&
        t >= this._pathBBox.y &&
        t <= this._pathBBox.y + this._pathBBox.height
      );
    }
    getCenter() {
      return [
        (this._pathBBox.x + this._pathBBox.width) / 2,
        (this._pathBBox.y + this._pathBBox.height) / 2,
      ];
    }
    getHalfSize() {
      return [
        (this._pathBBox.x + this._pathBBox.width) / 2,
        (this._pathBBox.y + this._pathBBox.height) / 2,
      ];
    }
    updateState(e, t) {
      super.updateState(e, t),
        e.path !== void 0 && ((this.path = e.path), this.computeSVGBBox());
    }
    clone(e) {
      let t = new Vg(this.uuid, this.data, e);
      return (t.parent = void 0), t;
    }
  };
function oZ(e, t = 1, i = 1) {
  if (t <= 0 || i <= 0) return e;
  let r = (0, nZ.parseSVG)(e).map((s) => {
    let a = { ...s };
    return (
      "x" in a && (a.x = a.x * t),
      "y" in a && (a.y = a.y * i),
      "x1" in a && (a.x1 = a.x1 * t),
      "x2" in a && (a.x2 = a.x2 * t),
      "y1" in a && (a.y1 = a.y1 * i),
      "y2" in a && (a.y2 = a.y2 * i),
      "rx" in a && (a.rx = a.rx * t),
      "ry" in a && (a.ry = a.ry * i),
      a
    );
  });
  return lZ(r);
}
function lZ(e) {
  let t = [
      "rx",
      "ry",
      "xAxisRotation",
      "largeArc",
      "sweep",
      "x1",
      "y1",
      "x2",
      "y2",
      "x",
      "y",
    ],
    i;
  return e
    .map((r) => {
      let s = [];
      t.forEach((n) => {
        if (n in r) {
          let o = r[n] * 1;
          s.length && o >= 0 && s.push(","), s.push(o);
        }
      });
      let a = (i === r.code ? (s[0] < 0 ? "" : ",") : r.code) + s.join("");
      return (i = r.code), a;
    })
    .join("");
}
function hZ(e, t, i) {
  switch (t.type) {
    case "ellipse2d":
      return new Tb(e, t, i);
    case "rectangle2d":
      return new mp(e, t, i);
    case "text2d":
      return new Pb(e, t, i);
    case "vector2d":
      return new IP(e, t, i);
    case "path2d":
      return new Vg(e, t, i);
    case "frame2d":
      return new Dn(e, t, i);
    case "group2d":
    default:
      return new Mo(e, t, i);
  }
}
var RP = class {
    constructor(e, t, i) {
      (this.uuid = e),
        (this.data = t),
        (this.group = new Mo(RP.GROUP_ID, { ...ag.defaultData }, i)),
        this.createChildrenObjects(t.objects, this.group, i);
    }
    createObject(e, t, i, r, s, a) {
      let n = hZ(e, t, a);
      n &&
        (r.add(n),
        r.children.splice(s, 0, r.children.pop()),
        n.updateWorldMatrix(),
        i.length > 0 &&
          (n instanceof Mo || n instanceof Dn) &&
          this.createChildrenObjects(i, n, a));
    }
    createChildrenObjects(e, t, i) {
      let r = 0;
      for (let s of e)
        this.createObject(s.id, s.data, s.children, t, r, i), (r += 1);
    }
    draw(e) {
      this.group.draw(e);
    }
    updateEntityByOp(e, t, i, r) {
      let s = this.find(e);
      if (s)
        try {
          s.updateByOp(t, i, { shared: r });
        } catch (a) {
          console.error(a);
        }
    }
    updateTreeByOp(e, t) {
      if (e.path.length === 0 && e.type === 7) {
        let i = e.parent === null ? this.group : this.find(e.parent);
        i !== void 0 &&
          i instanceof En &&
          (this.createObject(e.id, e.data, e.children, i, e.localIndex, t),
          i.requestRender());
      } else if (e.path.length === 0 && e.type === 8) {
        let i = this.find(e.id);
        if (i !== void 0 && i.parent !== void 0 && i.parent instanceof En) {
          let r = i.parent;
          i.resetBBoxNeedsUpdate(), r?.remove(i), r?.requestRender();
        }
      } else if (e.path.length === 0 && e.type === 9) {
        let i = this.find(e.id);
        if (i !== void 0) {
          let r = i.parent,
            s = e.parent === null ? this : this.find(e.parent);
          if (s instanceof En || s === this) {
            s.add(i);
            let a = e.localIndex;
            s.children.splice(a, 0, s.children.pop()),
              i.updateWorldMatrix(!0, !1, !0),
              r?.requestRender(),
              i.requestRender();
          }
          i.resetBBoxNeedsUpdate();
        }
      }
    }
    add(e) {
      this.group.add(e);
    }
    remove(e) {
      this.group.remove(e);
    }
    traverse(e) {
      this.group.traverse((t) => {
        t !== this.group && e(t);
      });
    }
    intersectsChildren(e, t, i, r = !1, s = []) {
      return this.group.intersectsChildren(e, t, i, r, s, !0);
    }
    find(e) {
      return this.group.find(e);
    }
    get children() {
      return this.group.children;
    }
    project(e, t) {
      return this.group.project(e, t);
    }
    getWithSortKey(e) {
      let t = this.find(e);
      if (t === void 0) return;
      let i = [],
        r = t;
      for (; r !== this.group; ) {
        let s = r;
        r = r.parent;
        let a = r.children.indexOf(s);
        i.splice(0, 0, a);
      }
      return { entity: t, sortKey: i };
    }
    getAllSorted(e) {
      let t = [];
      for (let i of e) {
        let r = this.getWithSortKey(i.id);
        r !== void 0 && t.push(r);
      }
      return t.sort((i, r) => mT(i.sortKey, r.sortKey)), t.map((i) => i.entity);
    }
  },
  Db = RP;
Db.GROUP_ID = "scene2d";
function LP({
  constraints: e,
  newParentWidth: t,
  newParentHeight: i,
  initialParentWidth: r,
  initialParentHeight: s,
  objectInitialWidth: a,
  objectInitialHeight: n,
  objectInitialPosition: o,
}) {
  let { horizontalConstraint: l, verticalConstraint: h } = e,
    u = t - r,
    c = i - s,
    d = a,
    p = n,
    f = o[0],
    m = o[1];
  if (l !== 0) {
    if (l === 1) f += u;
    else if (l === 3) f += u / 2;
    else if (l === 2) d = Math.max(1, d + u);
    else if (l === 4) {
      let g = t / r;
      (d *= g), (f *= g);
    }
  }
  if (h !== 0) {
    if (h === 1) m += c;
    else if (h === 3) m += c / 2;
    else if (h === 2) p = Math.max(1, p + c);
    else if (h === 4) {
      let g = i / s;
      (p *= g), (m *= g);
    }
  }
  return { width: d, height: p, position: [f, m] };
}
var wte = Sr(kE(), 1),
  _te = {
    mm: { mm: 1, cm: 0.1, in: 1 / 25.4, pt: 72 / 25.4, pc: 6 / 25.4, px: -1 },
    cm: { mm: 10, cm: 1, in: 1 / 2.54, pt: 72 / 2.54, pc: 6 / 2.54, px: -1 },
    in: { mm: 25.4, cm: 2.54, in: 1, pt: 72, pc: 6, px: -1 },
    pt: { mm: 25.4 / 72, cm: 2.54 / 72, in: 1 / 72, pt: 1, pc: 6 / 72, px: -1 },
    pc: { mm: 25.4 / 6, cm: 2.54 / 6, in: 1 / 6, pt: 72 / 6, pc: 1, px: -1 },
    px: { mm: 1, px: 1, cm: 1, in: 1, pt: 1, pc: 1 },
  },
  cZ = Ei.identity(),
  BP = class {
    constructor(e, t, i, r) {
      (this.uuid = e),
        (this.width = t),
        (this.height = i),
        (this.context = r),
        (this.enabled = !0),
        (this.isScreenSpace = !1),
        (this.isFrameDirty = !1),
        (this.onRenderRequestedDownstream = () => {
          (this.isFrameDirty = !0), this.context.shared.requestRender();
        }),
        (this.onFrameOverrideObjectEvent = (s) => {
          if (s.target?.uuid !== void 0) {
            let a = this.frameRoot?.find(s.target.uuid);
            a && a.dispatchEvent({ ...s, target: a });
          }
        }),
        (this.scene2d = new Db(dt.generateUUID(), y1.defaultData, {
          dpr: window.devicePixelRatio,
          shared: r.shared,
        })),
        (this.canvas = document.createElement("canvas")),
        (this.renderer = new CM(this.canvas)),
        r.shared.addCanvas(this.uuid, this.canvas),
        (this.textureHolder = r.shared.canvas(this.uuid)),
        (this.promise = this.init());
    }
    async init() {
      this.renderer instanceof CM && (this.renderer.wasmURL = nP.skiaWasmUrl),
        await this.renderer.init();
    }
    render() {
      this.isFrameDirty &&
        (this.renderer.clear(),
        this.frameOverride?.draw(this.renderer),
        this.renderer.render(),
        this.textureHolder?.setNeedsUpdate(!0),
        (this.isFrameDirty = !1));
    }
    updateEntity2DByOp(e, t, i, r) {
      this.scene2d.updateEntityByOp(e, t, i, r), this.applySize();
    }
    updateTreeByOp(e, t) {
      this.scene2d.updateTreeByOp(e, t), this.applySize();
    }
    applyOverrides(e) {
      if (this.frameOverride && this.frameRoot) {
        (this.frameOverride.position = [0, 0]),
          (this.frameOverride.rotation = 0);
        let t = e?.width ?? this.width,
          i = e?.height ?? this.height;
        (this.frameOverride.width = t),
          (this.frameOverride.height = i),
          (this.frameOverride.localMatrix = cZ),
          this.isScreenSpace &&
            (this.frameOverride.fill.color = Ti.from0to1([0, 0, 0, 0])),
          (this.frameOverride.data = {
            ...this.frameOverride.data,
            width: t,
            height: i,
          }),
          zP({
            objectOverride: this.frameOverride,
            objectRoot: this.frameRoot,
            newParentWidth: this.frameOverride.width,
            newParentHeight: this.frameOverride.height,
            initialParentWidth: this.frameRoot.width,
            initialParentHeight: this.frameRoot.height,
          }),
          this.frameOverride.updateWorldMatrix(!0, !1, !0);
      }
    }
    applySize(e) {
      let t = e?.width ?? this.width,
        i = e?.height ?? this.height;
      (this.width = t),
        (this.height = i),
        (this.renderer.dpr = this.isScreenSpace
          ? window.devicePixelRatio
          : Math.floor(2048 / Math.max(t, i))),
        this.renderer.setSize(t, i),
        this.textureHolder?.dispose(),
        this.applyOverrides(e),
        this.frameOverride?.requestRender();
    }
    applyFrame(e) {
      let t = this.context.scene.find2D(e);
      if (!(!t || !(t instanceof Dn)))
        return (
          this.disposeFrameOverride(),
          (this.frameRoot = t),
          (this.frameOverride = t.clone({
            dpr: this.renderer.dpr,
            shared: this.context.shared,
          })),
          this.scene2d.add(this.frameOverride),
          this.applySize(),
          this.textureHolder?.dispose(),
          this.frame?.addEventListener(
            "render",
            this.onRenderRequestedDownstream
          ),
          this.frameOverride.traverse((i) => {
            i.addEventListener("beginState", this.onFrameOverrideObjectEvent);
          }),
          this.frameOverride.traverse((i) => {
            i.addEventListener(
              "completeState",
              this.onFrameOverrideObjectEvent
            );
          }),
          this.frame?.requestRender(),
          t
        );
    }
    get frame() {
      return this.frameOverride;
    }
    get frameId() {
      return this.frame?.uuid;
    }
    find(e) {
      return this.scene2d.find(e);
    }
    get texture() {
      return this.textureHolder?.getTexture(1001);
    }
    disposeFrameOverride() {
      this.frameOverride?.removeEventListener(
        "render",
        this.onRenderRequestedDownstream
      ),
        this.frameOverride?.traverse((e) => {
          e.removeEventListener(
            "beginStateChange",
            this.onFrameOverrideObjectEvent
          );
        }),
        this.frameOverride?.traverse((e) => {
          e.removeEventListener(
            "completeState",
            this.onFrameOverrideObjectEvent
          );
        }),
        this.frameOverride && this.scene2d.remove(this.frameOverride);
    }
  };
function zP({
  objectOverride: e,
  objectRoot: t,
  newParentWidth: i,
  newParentHeight: r,
  initialParentWidth: s,
  initialParentHeight: a,
}) {
  if (
    (e instanceof Dn && t instanceof Dn) ||
    (e instanceof Mo && t instanceof Mo)
  )
    for (let n = 0, o = e.children.length; n < o; n++) {
      let l = e.children[n],
        h = t.children[n];
      l &&
        h &&
        l.uuid === h.uuid &&
        dZ({
          objectOverride: l,
          objectRoot: h,
          newParentWidth: i,
          newParentHeight: r,
          initialParentWidth: s,
          initialParentHeight: a,
        });
    }
}
function uZ(e) {
  if (Q1(e)) return [e.width, e.height];
  if (e instanceof Vg) {
    let [t, i] = e.getHalfSize();
    return [t * 2, i * 2];
  } else if (e instanceof Mo) {
    let [t, i] = e.recursiveBBox.getHalfSize();
    return [t * 2, i * 2];
  }
  return [0, 0];
}
function dZ({
  objectOverride: e,
  objectRoot: t,
  newParentWidth: i,
  newParentHeight: r,
  initialParentWidth: s,
  initialParentHeight: a,
}) {
  let [n, o] = uZ(t),
    {
      width: l,
      height: h,
      position: u,
    } = LP({
      constraints: e.data,
      newParentWidth: i,
      newParentHeight: r,
      initialParentWidth: s,
      initialParentHeight: a,
      objectInitialWidth: n,
      objectInitialHeight: o,
      objectInitialPosition: t.position,
    });
  if (((e.position = u), (e.data = { ...e.data, position: u }), e.states))
    for (let c in e.states)
      pZ({
        stateId: c,
        objectOverride: e,
        objectRoot: t,
        newParentWidth: i,
        newParentHeight: r,
        initialParentWidth: s,
        initialParentHeight: a,
      });
  if (Q1(e) || e instanceof Mo)
    Q1(e) &&
      ((e.width = l),
      (e.height = h),
      (e.data = { ...e.data, width: l, height: h })),
      zP({
        objectOverride: e,
        objectRoot: t,
        newParentWidth: l,
        newParentHeight: h,
        initialParentWidth: n,
        initialParentHeight: o,
      });
  else if (e instanceof Vg) {
    let c = t,
      d = n !== 0 ? l / n : 1,
      p = o !== 0 ? h / o : 1;
    (e.path = oZ(c.path, d, p)), (e.data = { ...e.data, path: e.path });
  }
}
function pZ({
  stateId: e,
  objectOverride: t,
  objectRoot: i,
  newParentWidth: r,
  newParentHeight: s,
  initialParentWidth: a,
  initialParentHeight: n,
}) {
  let o = t.states?.[e],
    l = i.states?.[e];
  if (o && l) {
    let {
      width: h,
      height: u,
      position: c,
    } = LP({
      constraints: t.data,
      newParentWidth: r,
      newParentHeight: s,
      initialParentWidth: a,
      initialParentHeight: n,
      objectInitialWidth: rh.isResizeable(l) ? l.width : 0,
      objectInitialHeight: rh.isResizeable(l) ? l.height : 0,
      objectInitialPosition: l.position,
    });
    Object.assign(t.states[e], { position: c }),
      rh.isResizeable(o) && Object.assign(t.states[e], { width: h, height: u });
  }
}
function Q1(e) {
  return (
    e instanceof mp || e instanceof Dn || e instanceof Tb || e instanceof Pb
  );
}
var Hr = class extends ob(xo) {
    constructor(e, t, i) {
      super(),
        (this.data = t),
        (this.bgColor = new os(1, 1, 1, 1)),
        (this.fog = null),
        (this.backupFog = new hC(16777215, 0.1, 2e3)),
        (this.fogUseBGColor = !1),
        (this.isActive = !1),
        (this.aoColor = new Et()),
        (this.penumbraSizeArrayCache = null),
        this.super_Entity(e, t),
        (this.personalCamera = new vs(mu, {
          ...Gd.defaultData,
          ...t.camera,
          name: "Personal Camera",
        })),
        (this.personalCamera.objectHelper.visible = !1),
        this.add(this.personalCamera),
        (this.activeCamera = this.personalCamera),
        (this.ambientLight = new jF(13882323, 8553090, 0.75)),
        (this.ambientLight.name = "Default Ambient Light"),
        this.ambientLight.layers.enable(3),
        this.ambientLight.removeFromParent(),
        this.add(this.ambientLight),
        t.uiScene
          ? (this.uiScene = new Db(
              (Array.isArray(e) ? e[0] : e) + "-ui",
              t.uiScene,
              { dpr: window.devicePixelRatio, shared: i.shared }
            ))
          : t.uiFrame && this.createUICanvas(t.uiFrame, i);
    }
    get scene() {
      return this.parent;
    }
    get postprocessing() {
      return this.data.postprocessing;
    }
    get frameId() {
      return this.data.uiFrame;
    }
    get frame() {
      return this.uiCanvas?.frame;
    }
    createUICanvas(e, t) {
      (this.uiCanvas = new BP(
        this.uuid + "-uiscreen",
        window.innerWidth,
        window.innerHeight,
        t
      )),
        (this.uiCanvas.isScreenSpace = !0),
        this.uiCanvas.promise.then(() => {
          this.uiCanvas?.applyFrame(e), this.uiCanvas?.applySize();
        });
    }
    updateVisible() {}
    setBackgroundColor(e) {
      (this.bgColor = e),
        this.fogUseBGColor === !0 && (this.backupFog.color = e);
    }
    entityChildrenCount() {
      return this.uiScene
        ? this.uiScene.children.length
        : super.entityChildrenCount();
    }
    updateAmbientLight(e, t) {
      e.color !== void 0 && (this.ambientLight.color = Ds(e.color, t)),
        e.intensity !== void 0 && (this.ambientLight.intensity = e.intensity),
        e.enabled !== void 0 &&
          (e.enabled
            ? this.add(this.ambientLight)
            : this.remove(this.ambientLight));
    }
    onDeactive() {
      this.isActive = !1;
    }
    onActive(e) {
      (this.isActive = !0),
        (e.fog = this.fog),
        this.traverseEntity((t) => {
          t instanceof fh && t.recomputeBoolean();
        }),
        this.updateShadow(this.data.shadow);
    }
    forceMaterialsUpdate() {
      this.traverseEntity((e) => {
        if (e instanceof yu)
          if (Array.isArray(e.material))
            for (let t of e.material) t.needsUpdate = !0;
          else (e.material.needsUpdate = !0), e.material.dispose();
      });
    }
    updateShadow(e) {
      e.softShadowQuality !== void 0 &&
        this.isActive &&
        WQ(e.softShadowQuality) &&
        this.forceMaterialsUpdate();
    }
    updateFog(e, t) {
      if (
        (e.enabled ? (this.fog = this.backupFog) : (this.fog = null),
        this.isActive)
      ) {
        let i = this.scene;
        i.fog = this.fog;
      }
      (this.fogUseBGColor = e.useBackgroundColor),
        e.useBackgroundColor
          ? this.backupFog.color.set(this.bgColor)
          : (this.backupFog.color = Ds(e.color, t)),
        (this.backupFog.near = e.near),
        (this.backupFog.far = e.far);
    }
    updateAo(e, t) {
      e.aoColor !== void 0 && (this.aoColor = Ds(e.aoColor, t));
    }
    updateByOp(e, t, i, r) {
      let s = this.data.uiFrame;
      super.updateByOp(e, t, i, r);
      let a = t;
      Ii(e.path, ["fog"])
        ? this.updateFog(a.fog, i.shared)
        : Ii(e.path, ["ao"])
        ? this.updateAo(a.ao, i.shared)
        : Ii(e.path, ["ambient"])
        ? this.updateAmbientLight(a.ambient, i.shared)
        : Ii(e.path, ["shadow"])
        ? this.updateShadow(a.shadow)
        : e.type === 0 &&
          e.path.length === 0 &&
          (e.props.uiFrame !== void 0 || s !== a.uiFrame) &&
          this.updateUIFrame(e.props.uiFrame, i);
    }
    updateUIFrame(e, t) {
      e
        ? (this.uiCanvas || this.createUICanvas(e, t),
          (this.uiCanvas.enabled = !0),
          this.uiCanvas.applyFrame(e))
        : this.uiCanvas && (this.uiCanvas.enabled = !1);
    }
    updateState(e, t) {
      this.updateState_Entity(e, t),
        e.backgroundColor !== void 0 &&
          this.setBackgroundColor(Ds(e.backgroundColor, t.shared)),
        e.fog !== void 0 && this.updateFog(e.fog, t.shared),
        e.ambient !== void 0 && this.updateAmbientLight(e.ambient, t.shared),
        e.ao !== void 0 && this.updateAo(e.ao, t.shared),
        e.shadow !== void 0 && this.updateShadow(e.shadow);
    }
    createFrame(e, t) {}
    raycast(e, t) {
      super.raycast(e, t);
    }
    switchActiveCamera(e) {
      e &&
        e.isDescendantOf(this) &&
        (this.activeCamera !== this.personalCamera &&
          (this.activeCamera.objectHelper.visible = !0),
        (this.activeCamera = e),
        (e.objectHelper.visible = !1));
    }
    get playCamera() {
      return (
        this.scene?.find(this.data.publish.playCamera) ?? this.personalCamera
      );
    }
    switchToPlayCamera() {
      this.switchActiveCamera(this.playCamera);
    }
    get penumbraSizeArray() {
      return (
        this.penumbraSizeArrayCache === null && this.updatePenumbraSizeArray(),
        this.penumbraSizeArrayCache
      );
    }
    updatePenumbraSizeArray() {
      this.penumbraSizeArrayCache = new Array(5).fill(0.5);
      let e = 0,
        t = 0;
      this.traverseEntity((i) => {
        if (!i.visible) return !0;
        i instanceof TP &&
          i.visible &&
          e < 3 &&
          ((this.penumbraSizeArrayCache[e] = i.data.penumbraSize), (e += 1)),
          i instanceof PP &&
            i.visible &&
            e < 5 - 3 &&
            ((this.penumbraSizeArrayCache[3 + t] = i.data.penumbraSize),
            (t += 1));
      });
    }
    raycastWithClones(e) {
      let t = [],
        i = (r) => {
          for (let s of r.children) {
            let a = s.cloner;
            si.is(s) &&
              (s.visible || a?.object.data.visible) &&
              ((ja(s) ||
                (k1(s) &&
                  this.scene.enableHelpers &&
                  s.objectHelper.visible)) &&
                (e.intersectObject(s, !1, t), K1(s, e, t, !0)),
              i(s));
          }
        };
      return i(this), t;
    }
    updateEntity2DByOp(e, t, i, r) {
      this.uiCanvas?.updateEntity2DByOp(e, t, i, r);
    }
  },
  fZ = class extends Mb(qF, EP) {
    constructor(e, t, i) {
      super(),
        this.super_Entity(e, t),
        (this.castShadow = !0),
        (this.shadow.mapSize.width = 1024),
        (this.shadow.mapSize.height = 1024),
        (this.shadow.normalBias = 1),
        this.layers.enable(3);
      let r = this.shadow.camera;
      (r.fov = 90), (r.aspect = 1), (r.near = 100), (r.far = 2500);
      let s = new I(
          -r.far + this.position.x,
          -r.far + this.position.y,
          -r.far + this.position.z
        ),
        a = new I(
          r.far + this.position.x,
          r.far + this.position.y,
          r.far + this.position.z
        ),
        n = new ur(s, a),
        o = new Pm(n, new Et(16755200));
      (o.visible = !1), (this.gizmos.shadowmap = o), this.update();
    }
    update() {
      if (
        this.shadow &&
        (this.shadow.camera.updateProjectionMatrix(), this.gizmos)
      )
        for (let e in this.gizmos) {
          let t = this.gizmos[e];
          if (t instanceof Pm) {
            let i = this.shadow.camera,
              r = new I(
                -i.far + this.position.x,
                -i.far + this.position.y,
                -i.far + this.position.z
              ),
              s = new I(
                i.far + this.position.x,
                i.far + this.position.y,
                i.far + this.position.z
              );
            t.box.set(r, s), t.updateMatrixWorld(!0);
          }
        }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.objectHelper && this.objectHelper.update();
    }
    updateState(e, t) {
      this.updateState_Light(e, t),
        e.distance !== void 0 && (this.distance = e.distance),
        e.decay !== void 0 && (this.decay = e.decay),
        e.shadowRadius !== void 0 && (this.shadow.radius = e.shadowRadius),
        e.shadowResolution !== void 0 &&
          (this.shadow.mapSize.set(e.shadowResolution, e.shadowResolution),
          this.shadow.map &&
            (this.shadow.map.dispose(), (this.shadow.map = null)));
    }
  },
  mZ = class extends ms {
    get forceComputeSize() {
      return !0;
    }
    get shape() {
      return this.geometry.userData.shape;
    }
    updateEntityBoxSize(e, t) {
      let i = this.geometry.getAttribute("position");
      i !== void 0
        ? mb(
            i,
            this.geometry.drawRange.start,
            this.geometry.drawRange.count < 1 / 0
              ? this.geometry.drawRange.count
              : i.count,
            e,
            t
          )
        : super.updateEntityBoxSize(e, t);
    }
  },
  Ob = class extends ms {
    constructor(e, t, i) {
      super(e, t, i), (this._shapeId = null), (this._context = i);
    }
    updateState(e, t) {
      super.updateState(e, t), this.updateShape();
    }
    updateShape() {
      let e = { ...this.data.geometry.extrusion.shape };
      for (let r in e)
        typeof e[r] == "string" &&
          (e[r] = this._context.shared.getVariable(e[r], [
            this.uuid,
            "geometry",
            "extrusion",
            "shape",
            r,
          ]));
      let t;
      if (e.type === "Custom") {
        let r = e.shapeId;
        if ((r !== this._shapeId && this.detachShape(), r)) {
          this._shapeId = r;
          let s = this._context.scene.find(r);
          s?.data &&
            (s.attachedPaths.add(this), (t = s.geometry.userData?.shape)),
            t ||
              this._context.scene.addPendingCommand(() => this.updateShape());
        }
      } else {
        let r;
        switch (e.type) {
          case "Rectangle":
            r = fb;
            break;
          case "Ellipse":
            r = pb;
            break;
          case "Polygon":
            r = S3;
            break;
          case "Star":
            r = A3;
            break;
          default:
            throw new Error(`Unknown shape type: ${e.type}`);
        }
        t = r.create({ parameters: e }).userData.shape;
      }
      let i = this.geometry;
      t &&
        i.inputs &&
        ((i.inputs.shapeData = t),
        i.build(),
        this.attachedSurfaceCloners.forEach((r) => r.update()));
    }
    detachShape() {
      this._shapeId !== null &&
        this._context.scene.find(this._shapeId)?.attachedPaths.delete(this);
    }
    createGeometryDelayed(e) {
      (this.geometryCreateDeleyed = e.shared),
        this.updateShape(),
        this.refreshAttachedPaths(e);
    }
    updateTransformState(e, t) {
      return super.updateTransformState(e, t);
    }
    updateGeometryInteractions(e, t) {
      super.updateGeometryInteractions(e, t), this.updateShape();
    }
    updateEntityBoxSize(e, t) {
      let i = this.geometry.getAttribute("position");
      i !== void 0
        ? mb(
            i,
            this.geometry.drawRange.start,
            this.geometry.drawRange.count < 1 / 0
              ? this.geometry.drawRange.count
              : i.count,
            e,
            t
          )
        : super.updateEntityBoxSize(e, t);
    }
  },
  Nc = class extends xu(Hl, pp) {
    constructor(e, t, i) {
      super(),
        t.type === "Instance" &&
          typeof e == "string" &&
          (t = this.transformAssignData(t, i)),
        this.super_Entity(e, t),
        this.objectHelper.update();
    }
    get isComponentRoot() {
      return this.data.type === "Component" && typeof this.identity == "string";
    }
    get isInstanceRoot() {
      return this.data.type === "Instance" && typeof this.identity == "string";
    }
    transformAssignData(e, t) {
      let i = tg.getComponentData(
        { scene: t.scene.data, shared: t.shared.data },
        e.component
      );
      if (i) {
        let r, s;
        for (let a of rl.rootOverrideProps)
          e[a] === void 0
            ? (r === void 0 && (r = { ...e }), (r[a] = i.data[a]))
            : (s === void 0 && (s = {}),
              (s[a] = e[a]),
              r === void 0 && (r = { ...e }),
              (r[a] = hl.apply(i.data[a], e[a])));
        return (this.overrideData = s), r;
      } else
        return {
          ...ns.defaultData,
          ...e,
          ...bo(ns.defaultData, rl.rootOverrideProps),
        };
    }
    updateByOp(e, t, i, r) {
      let s;
      if (this.isInstanceRoot && !r) {
        if (
          ((t = this.transformAssignData(t, i)),
          e.type === 0 && e.path.length === 0 && this.component)
        )
          for (let a of rl.rootOverrideProps)
            a in e.props &&
              e.props[a] === void 0 &&
              (s === void 0 && (s = { ...e, props: { ...e.props } }),
              (s.props[a] = this.component.data[a]));
        else if (
          e.type === 0 &&
          e.path.length > 0 &&
          rl.rootOverrideProps.includes(e.path[0])
        ) {
          let a = e.path[0];
          s === void 0 && (s = { ...e, path: [], props: { [a]: t[a] } });
        }
      }
      super.updateByOp(s ?? e, t, i, r);
    }
    updateState(e, t) {
      this.updateState_Entity(e, t);
    }
    expandInstanceChildren(e) {
      let t = this.data;
      if (this.component === void 0) {
        let i = e.scene.find(t.component) ?? null,
          r = !1;
        if (i !== this.oldComponent) {
          if (this.oldComponent) {
            let s = 0;
            for (let a of this.children)
              if (si.is(a))
                e.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(
                  a
                ),
                  Ib(a),
                  (s += 1);
              else break;
            this.children.splice(0, s);
          }
          r = !0;
        }
        if (i) {
          let s = {};
          FP(e, [this.uuid], t.overrides, this, i, i, 0, r, s);
          for (let a of this.children)
            if (si.is(a)) {
              let n = a.data;
              n.type === "Empty" &&
                n.animations &&
                a.traverseEntity((o) => {
                  if (o instanceof ms && o.isSkinnedMesh) {
                    let l = o.dataPatched;
                    if (l.bones && l.boneInverses) {
                      let h = l.bones.map((d) => e.scene.find(s[d])),
                        u = l.boneInverses.map((d) => new je().fromArray(d)),
                        c = new _x(h, u);
                      o.bind(c, o.bindMatrix);
                    }
                  } else o.matrixAutoUpdate = !0;
                });
            }
        }
        this.oldComponent = this.component;
      }
    }
  };
function Ib(e) {
  if (e.component) {
    let t = e.component.instances.indexOf(e);
    t >= 0 && e.component.instances.splice(t, 1);
    for (let i of e.children) si.is(i) && Ib(i);
  }
}
function OM(e, t, i, r) {
  return e.component === t && dT(e.identity, r)
    ? e.overrideData === i
      ? 2
      : 1
    : 0;
}
function FP(e, t, i, r, s, a, n, o, l) {
  if (n > 50) return !1;
  if (r.component !== s) {
    if (r.component) {
      let u = r.component.instances.indexOf(r);
      u >= 0 && r.component.instances.splice(u, 1);
    }
    s.instances.push(r), (r.component = s);
  }
  s instanceof Nc && s.isInstanceRoot && s.expandInstanceChildren(e);
  let h = 0;
  for (let u of s.children)
    if (si.is(u)) {
      let c = [
          ...t,
          ...(typeof u.identity == "string" ? [u.identity] : u.identity),
        ],
        d = Zm.resolve(i, c, 1);
      d != null &&
        !(d instanceof _r) &&
        (Object.setPrototypeOf(d, _r.prototype),
        console.error("wrong prototype"));
      let p = null,
        f;
      if (!o) {
        let m = r.children[h];
        if (((p = si.is(m) ? m : null), p !== null)) {
          let g = OM(p, u, d, c);
          (f = g >= 1 ? p.stateSelection : void 0), g !== 2 && (p = null);
        }
        if (p === null && ((p = e.scene.findInstance(c) ?? null), p !== null)) {
          let g = OM(p, u, d, c);
          if (((f = g >= 1 ? p.stateSelection : void 0), g !== 2)) p = null;
          else {
            let y = p.parent.children.indexOf(p);
            p.parent.children.splice(y, 1),
              r.children.splice(h, 0, p),
              p.parent === r
                ? y <= h && console.error("not possible")
                : ((p.parent = r),
                  (p.matrixWorldNeedsUpdate = !0),
                  p.resetBBoxNeedsUpdate(),
                  p.updateVisible(),
                  e.pendingDeletes.delete(p));
          }
        }
      }
      if (p === null) {
        let m = d ? hl.apply(u.data, d) : u.data;
        uh.is(m.type) && (m = { ...m, type: "Empty" }),
          (p = al.createEntity(c, m, e)),
          (p.overrideData = d),
          r.add(p),
          r.children.splice(r.children.length - 1, 1),
          r.children.splice(h, 0, p),
          p.updateState(p.data, e),
          f && p.changeSelectedState(f, e),
          e.scene.registerInstanceAndSetUuid(p);
      }
      if (p.isBone) {
        let m = p.identity[p.identity.length - 1];
        l[m] = p.uuid;
      }
      (h += 1), FP(e, t, i, p, u, a, n + 1, o, l);
    }
  if (!o) {
    let u = h;
    for (;;) {
      let c = r.children[h];
      if (si.is(c)) e.pendingDeletes.add(c);
      else break;
      h += 1;
    }
    r.children.splice(u, h - u);
  }
  return !0;
}
var gZ = class extends xu(cC, pp) {
    constructor(e, t) {
      super(),
        this.super_Entity(e, t),
        this.objectHelper.update(),
        (this.matrixAutoUpdate = !0);
    }
    updateState(e, t) {
      this.updateState_Entity(e, t);
    }
  },
  ps = class extends ms {
    constructor(e, t, i) {
      super(e, t, i),
        (this.onBeforeRender = () => {
          this.uiCanvas.render();
        }),
        (this.uiCanvas = new BP(
          e + "-canvas",
          t.geometry.width,
          t.geometry.height,
          i
        )),
        this.uiCanvas.promise.then(() => {
          this.applyFrame(this.dataPatched.geometry.frame, i.shared);
        });
    }
    updateByPatchedOpGeometry(e, t, i) {
      super.updateByPatchedOpGeometry(e, t, i),
        e.type === 0 &&
          (e.props.frame !== void 0 && this.applyFrame(e.props.frame, i.shared),
          (e.props.width !== void 0 || e.props.height !== void 0) &&
            this.applySize(e.props, i.shared));
    }
    applySize(e, t) {
      let i = e?.width ?? this.dataPatched.geometry.width,
        r = e?.height ?? this.dataPatched.geometry.height;
      this.uiCanvas.applySize({ width: i, height: r }),
        this.applyGeometryParametersFromFrame(t);
    }
    applyFrame(e, t) {
      this.uiCanvas.applyFrame(e),
        this.applyGeometryParametersFromFrame(t),
        this.applyMaterialParametersFromFrame({ shared: t });
    }
    applyGeometryParametersFromFrame(e) {
      let t = this.frame;
      t &&
        (Object.assign(this.data, {
          geometry: Object.assign(this.data.geometry, {
            cornerRadius: t.cornerRadius,
            cornerType: 0,
          }),
        }),
        Object.assign(this.dataPatched, {
          geometry: Object.assign(this.dataPatched.geometry, {
            cornerRadius: t.cornerRadius,
            cornerType: 0,
          }),
        }),
        this.localGeometry?.dispose(),
        (this.localGeometry = Jd(
          this.dataPatched.geometry,
          e,
          this.data.flatShading,
          this
        )));
    }
    applyMaterialParametersFromFrame(e) {
      let t = this.frame;
      if (t) {
        let i = t.data.backgroundBlur;
        Object.assign(this.data.material.layers[0].data.texture, {
          image: this.uiCanvas.uuid,
        }),
          Object.assign(this.data.material.layers[1].data, {
            roughness: i.radius,
            alpha: i.enabled ? 1 : 0,
          }),
          Object.assign(this.dataPatched.material.layers[0].data.texture, {
            image: this.uiCanvas.uuid,
          }),
          Object.assign(this.dataPatched.material.layers[1].data, {
            roughness: i.radius,
            alpha: i.enabled ? 1 : 0,
          }),
          this.material.reset(this.dataPatched.material, e, !0);
      }
    }
    updateEntity2DByOp(e, t, i, r) {
      this.uiCanvas.updateEntity2DByOp(e, t, i, r),
        e === this.frameId &&
          t.type === 0 &&
          (t.props.cornerRadius !== void 0
            ? this.applyGeometryParametersFromFrame(r)
            : Ii(t.path, ["backgroundBlur"]) &&
              this.applyMaterialParametersFromFrame({ shared: r }));
    }
    get frame() {
      return this.uiCanvas.frame;
    }
    get frameId() {
      return this.frame?.uuid;
    }
    removeInteractionGeometry(e) {
      super.removeInteractionGeometry(e), this.applySize({}, e);
    }
    updateGeometryInteractions(e, t) {
      super.updateGeometryInteractions(e, t),
        this.applySize({ width: e.width, height: e.height }, t);
    }
  },
  vZ = class {
    constructor(e, t, i) {
      (this.variables = []), (this.currentTextureIndex = 0);
      let r = xr,
        s = new xo(),
        a = new gh();
      a.position.z = 1;
      let n = { passThruTexture: { value: null } },
        o = u(d(), n),
        l = new br(new vh(2, 2), o);
      s.add(l),
        (this.setDataType = function (p) {
          return (r = p), this;
        }),
        (this.addVariable = function (p, f, m) {
          let g = this.createShaderMaterial(f),
            y = {
              name: p,
              initialValueTexture: m,
              material: g,
              dependencies: null,
              renderTargets: [],
              wrapS: null,
              wrapT: null,
              minFilter: mi,
              magFilter: mi,
            };
          return this.variables.push(y), y;
        }),
        (this.setVariableDependencies = function (p, f) {
          p.dependencies = f;
        }),
        (this.init = function () {
          if (
            i.capabilities.isWebGL2 === !1 &&
            i.extensions.has("OES_texture_float") === !1
          )
            return "No OES_texture_float support for float textures.";
          if (i.capabilities.maxVertexTextures === 0)
            return "No support for vertex shader textures.";
          for (let p = 0; p < this.variables.length; p++) {
            let f = this.variables[p];
            (f.renderTargets[0] = this.createRenderTarget(
              e,
              t,
              f.wrapS,
              f.wrapT,
              f.minFilter,
              f.magFilter
            )),
              (f.renderTargets[1] = this.createRenderTarget(
                e,
                t,
                f.wrapS,
                f.wrapT,
                f.minFilter,
                f.magFilter
              )),
              this.renderTexture(f.initialValueTexture, f.renderTargets[0]),
              this.renderTexture(f.initialValueTexture, f.renderTargets[1]);
            let m = f.material,
              g = m.uniforms;
            if (f.dependencies !== null)
              for (let y = 0; y < f.dependencies.length; y++) {
                let x = f.dependencies[y];
                if (x.name !== f.name) {
                  let b = !1;
                  for (let _ = 0; _ < this.variables.length; _++)
                    if (x.name === this.variables[_].name) {
                      b = !0;
                      break;
                    }
                  if (!b)
                    return (
                      "Variable dependency not found. Variable=" +
                      f.name +
                      ", dependency=" +
                      x.name
                    );
                }
                (g[x.name] = { value: null }),
                  (m.fragmentShader =
                    `
uniform sampler2D ` +
                    x.name +
                    `;
` +
                    m.fragmentShader);
              }
          }
          return (this.currentTextureIndex = 0), null;
        }),
        (this.compute = function () {
          let p = this.currentTextureIndex,
            f = this.currentTextureIndex === 0 ? 1 : 0;
          for (let m = 0, g = this.variables.length; m < g; m++) {
            let y = this.variables[m];
            if (y.dependencies !== null) {
              let x = y.material.uniforms;
              for (let b = 0, _ = y.dependencies.length; b < _; b++) {
                let S = y.dependencies[b];
                x[S.name].value = S.renderTargets[p].texture;
              }
            }
            this.doRenderTarget(y.material, y.renderTargets[f]);
          }
          this.currentTextureIndex = f;
        }),
        (this.getCurrentRenderTarget = function (p) {
          return p.renderTargets[this.currentTextureIndex];
        }),
        (this.getAlternateRenderTarget = function (p) {
          return p.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
        }),
        (this.dispose = function () {
          l.geometry.dispose(), l.material.dispose();
          let p = this.variables;
          for (let f = 0; f < p.length; f++) {
            let m = p[f];
            m.initialValueTexture && m.initialValueTexture.dispose();
            let g = m.renderTargets;
            for (let y = 0; y < g.length; y++) g[y].dispose();
          }
        });
      function h(p) {
        p.defines.resolution =
          "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
      }
      this.addResolutionDefine = h;
      function u(p, f) {
        f = f || {};
        let m = new vi({ uniforms: f, vertexShader: c(), fragmentShader: p });
        return h(m), m;
      }
      (this.createShaderMaterial = u),
        (this.createRenderTarget = function (p, f, m, g, y, x) {
          return (
            (p = p || e),
            (f = f || t),
            (m = m || Ui),
            (g = g || Ui),
            (y = y || mi),
            (x = x || mi),
            new gi(p, f, {
              wrapS: m,
              wrapT: g,
              minFilter: y,
              magFilter: x,
              format: Wr,
              type: r,
              depthBuffer: !1,
            })
          );
        }),
        (this.createTexture = function () {
          let p = new Float32Array(e * t * 4),
            f = new Sa(p, e, t, Wr, xr);
          return (f.needsUpdate = !0), f;
        }),
        (this.renderTexture = function (p, f) {
          (n.passThruTexture.value = p),
            this.doRenderTarget(o, f),
            (n.passThruTexture.value = null);
        }),
        (this.doRenderTarget = function (p, f) {
          let m = i.getRenderTarget(),
            g = i.xr.enabled,
            y = i.shadowMap.autoUpdate,
            x = i.outputEncoding,
            b = i.toneMapping;
          (i.xr.enabled = !1),
            (i.shadowMap.autoUpdate = !1),
            (i.outputEncoding = Qa),
            (i.toneMapping = Tn),
            (l.material = p),
            i.setRenderTarget(f),
            i.render(s, a),
            (l.material = o),
            (i.xr.enabled = g),
            (i.shadowMap.autoUpdate = y),
            (i.outputEncoding = x),
            (i.toneMapping = b),
            i.setRenderTarget(m);
        });
      function c() {
        return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
      }
      function d() {
        return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
      }
    }
  },
  $r = new rs(),
  Zf = new I(),
  yZ = class {
    constructor(e) {
      let t = e.geometry;
      if (!t.isBufferGeometry || t.attributes.position.itemSize !== 3)
        throw new Error(
          "THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."
        );
      t.index &&
        (console.warn(
          "THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."
        ),
        (t = t.toNonIndexed())),
        (this.geometry = t),
        (this.randomFunction = Math.random),
        (this.positionAttribute = this.geometry.getAttribute("position")),
        (this.colorAttribute = this.geometry.getAttribute("color")),
        (this.weightAttribute = null),
        (this.distribution = null);
    }
    setWeightAttribute(e) {
      return (
        (this.weightAttribute = e ? this.geometry.getAttribute(e) : null), this
      );
    }
    build() {
      let e = this.positionAttribute,
        t = this.weightAttribute,
        i = new Float32Array(e.count / 3);
      for (let s = 0; s < e.count; s += 3) {
        let a = 1;
        t && (a = t.getX(s) + t.getX(s + 1) + t.getX(s + 2)),
          $r.a.fromBufferAttribute(e, s),
          $r.b.fromBufferAttribute(e, s + 1),
          $r.c.fromBufferAttribute(e, s + 2),
          (a *= $r.getArea()),
          (i[s / 3] = a);
      }
      this.distribution = new Float32Array(e.count / 3);
      let r = 0;
      for (let s = 0; s < i.length; s++)
        (r += i[s]), (this.distribution[s] = r);
      return this;
    }
    setRandomGenerator(e) {
      return (this.randomFunction = e), this;
    }
    sample(e, t, i) {
      let r = this.distribution[this.distribution.length - 1],
        s = this.binarySearch(this.randomFunction() * r);
      return this.sampleFace(s, e, t, i);
    }
    binarySearch(e) {
      let t = this.distribution,
        i = 0,
        r = t.length - 1,
        s = -1;
      for (; i <= r; ) {
        let a = Math.ceil((i + r) / 2);
        if (a === 0 || (t[a - 1] <= e && t[a] > e)) {
          s = a;
          break;
        } else e < t[a] ? (r = a - 1) : (i = a + 1);
      }
      return s;
    }
    sampleFace(e, t, i, r) {
      let s = this.randomFunction(),
        a = this.randomFunction();
      return (
        s + a > 1 && ((s = 1 - s), (a = 1 - a)),
        $r.a.fromBufferAttribute(this.positionAttribute, e * 3),
        $r.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1),
        $r.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2),
        t
          .set(0, 0, 0)
          .addScaledVector($r.a, s)
          .addScaledVector($r.b, a)
          .addScaledVector($r.c, 1 - (s + a)),
        i !== void 0 && $r.getNormal(i),
        r !== void 0 &&
          this.colorAttribute !== void 0 &&
          ($r.a.fromBufferAttribute(this.colorAttribute, e * 3),
          $r.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1),
          $r.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2),
          Zf.set(0, 0, 0)
            .addScaledVector($r.a, s)
            .addScaledVector($r.b, a)
            .addScaledVector($r.c, 1 - (s + a)),
          (r.r = Zf.x),
          (r.g = Zf.y),
          (r.b = Zf.z)),
        this
      );
    }
  };
function xZ(e) {
  let t = new Float32Array(e * e * 2);
  for (let i = 0; i < e; i++)
    for (let r = 0; r < e; r++) {
      let s = i * e + r;
      (t[s * 2 + 0] = i / (e - 1)), (t[s * 2 + 1] = r / (e - 1));
    }
  return t;
}
function bZ(e) {
  let t = Math.ceil(Math.sqrt(e));
  return Math.max(t, 1);
}
function wZ(e, t) {
  let i = new br(e.geometry, e.material),
    r = [],
    s = [],
    a = new I(),
    n = new I();
  i.geometry.index !== null && (i.geometry = i.geometry.toNonIndexed());
  let o = new yZ(i).build();
  for (let u = 0; u < t; u++)
    o.sample(a, n), r.push(a.x, a.y, a.z), s.push(n.x, n.y, n.z);
  let l = new Float32Array(r),
    h = new Float32Array(s);
  return { positions: l, normals: h };
}
function IM(e, t) {
  let i = e,
    r = new Float32Array(4 * t * t);
  for (let a = 0; a < t * t; a++)
    (r[4 * a] = i[3 * a]),
      (r[4 * a + 1] = i[3 * a + 1]),
      (r[4 * a + 2] = i[3 * a + 2]),
      (r[4 * a + 3] = 0);
  let s = new Sa(r, t, t, Wr, xr);
  return (s.needsUpdate = !0), s;
}
function _Z({ size: e }) {
  let t = new Float32Array(4 * e * e);
  for (let r = 0; r < e * e; r++)
    (t[4 * r] = r), (t[4 * r + 1] = 0), (t[4 * r + 2] = 0), (t[4 * r + 3] = 0);
  let i = new Sa(t, e, e, Wr, xr);
  return (i.needsUpdate = !0), i;
}
function SZ(e) {
  let t = new Float32Array(4 * e * e);
  for (let r = 0; r < e * e; r++)
    (t[4 * r] = 0), (t[4 * r + 1] = 0), (t[4 * r + 2] = 0), (t[4 * r + 3] = 0);
  let i = new Sa(t, e, e, Wr, xr);
  return (i.needsUpdate = !0), i;
}
var AZ = `
// uniform sampler2D uCurrentPosition; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentVelocity; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentEmissionRate; // Pass in the variable from GPGPU
uniform sampler2D uOriginalPosition;
uniform float uTime;
uniform float uSpeed;     // update speed of the particles
uniform vec3 uWorldOffset;    
uniform vec4 uWorldQuaternion;
uniform float uMaxLifeTime;
uniform vec3 uEmitterSize;
uniform float uFPSRatio;     // 1  for 60 FPS

float random (vec2 st) {
    return fract(sin(dot(st.xy,
        vec2(12.9898,78.233)))*
        43758.5453123);
}
vec3 applyQuaternionToVector( vec4 q, vec3 v ){
    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
}

vec3 applyForce(vec3 force, float mass) {
    vec3 acceleration = force / mass;
    
    return acceleration;
  }
  

void main() {
    vec2 vUv = gl_FragCoord.xy / resolution.xy;
    vec3 position = texture2D( uCurrentPosition, vUv ).xyz;
    float currentLife = texture2D( uCurrentPosition, vUv ).w;   // from 1 to 0
    float isSpawning = texture2D( uCurrentEmissionRate, vUv ).r;        // 1. = spawning, 0. = not spawning
    float isActive = texture2D( uCurrentEmissionRate, vUv ).g;          // 1. = active, 0. = not active
    float timeStart = texture2D( uCurrentEmissionRate, vUv ).b;         // timeStart in seconds when the particle was emitted
    vec3 originalPosition = ((texture2D( uOriginalPosition, vUv ).xyz) * uEmitterSize);
    vec3 velocity = texture2D( uCurrentVelocity, vUv ).xyz;
    float collisionFlag = texture2D( uCurrentVelocity, vUv ).w;             // 1. = collided, 0. = not collided
    float lifeTime = uMaxLifeTime;

    // Calculate the position adjustment based on collision
    //     if (collisionFlag > .5) {  
    float isColliding = step(0.5, collisionFlag); // 1.0 if collisionFlag > 0.5, otherwise 0.0
    float bounceOffset = 3.0 * isColliding; // Becomes 3.0 if colliding, 0.0 otherwise
    vec3 collisionAdjustedVelocity = velocity * (1.0 + bounceOffset);

    // Update position based on collision or normal movement
    vec3 fpsVelocity = velocity * min(uFPSRatio, 5.0);
    position += mix(fpsVelocity, collisionAdjustedVelocity, isColliding);

    // EMISSION RATE - BIRTH
    // if (isSpawning == 1.0) {
    // Better Approach to avoid If statement
    vec3 newPosition = applyQuaternionToVector(uWorldQuaternion, originalPosition) + uWorldOffset;
    originalPosition = mix(originalPosition, newPosition, isSpawning);
    position = mix(position, originalPosition, isSpawning);;
    timeStart = mix(timeStart, uTime, isSpawning);

    // Calculate timeLeft for life normalization
    float timeLeft = max(lifeTime - (uTime - timeStart), 0.0);
    float life_Normalize = timeLeft / lifeTime;

    // Use isActive to blend between the calculated color and black
    vec4 activeColor = vec4(position, life_Normalize);
    // if (isActive == 1.0) {
    gl_FragColor = mix(vec4(0.0), activeColor, isActive);

}
`,
  MZ = `

    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    vec4 permute(vec4 x) {
        return mod289(((x*34.0)+1.0)*x);
    }
    
    vec4 taylorInvSqrt(vec4 r)
    {
    return 1.79284291400159 - 0.85373472095314 * r;
    }
    
    vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

    float snoise(vec3 v)
    {
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
    
    // Permutations
    i = mod289(i);
    vec4 p = permute( permute( permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
    
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
    
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
    
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
    
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
    
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
    
    //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
    }
    
    vec3 snoiseVec3( vec3 x ){
    
      float s  = snoise(vec3( x ));
      float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
      float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
      vec3 c = vec3( s , s1 , s2 );
      return c;
    
    }
    
      
    vec3 curlNoise( vec3 p, float seed){
      p += seed;
      const float e = .1;
      vec3 dx = vec3( e   , 0.0 , 0.0 );
      vec3 dy = vec3( 0.0 , e   , 0.0 );
      vec3 dz = vec3( 0.0 , 0.0 , e   );
    
      vec3 p_x0 = snoiseVec3( p - dx );
      vec3 p_x1 = snoiseVec3( p + dx );
      vec3 p_y0 = snoiseVec3( p - dy );
      vec3 p_y1 = snoiseVec3( p + dy );
      vec3 p_z0 = snoiseVec3( p - dz );
      vec3 p_z1 = snoiseVec3( p + dz );
    
      float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
      float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
      float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
    
      const float divisor = 1.0 / ( 2.0 * e );
      return normalize( vec3( x , y , z ) * divisor );
    
    }


// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
  return 2.2 * n_xyz;
}


vec3 fbm_vec3(vec3 p, float frequency, float offset)
{
  return vec3(
    cnoise((p+vec3(offset))*frequency),
    cnoise((p+vec3(offset+20.0))*frequency),
    cnoise((p+vec3(offset-30.0))*frequency)
  );
}

`,
  EZ = `
  #ifdef USE_COLLIDER
    float restitution = max(uBounce * 2., .01); // Energy Loss
    // SPHERE COLLIDER
    // **************************************************************
    #ifdef USE_SPHERE_COLLIDER       
      // Convert collider size to radii (assuming uColliderSize is the diameter in each axis)
      vec3 radii = uColliderSize;
      // Adjust position relative to collider
      vec3 relPos = position - uColliderPos;
      // Apply rotation of the collider to the relative position
      relPos = applyQuaternionToVector(uColliderQuaternionInvert, relPos);            
      // Scale relative position by radii (for ellipsoid collision detection)
      vec3 scaledPos = relPos / radii;
      // Calculate ellipsoidal distance
      float dist = length(scaledPos); // Distance in terms of ellipsoid
      
      // Check for collision
      if (dist <= 1. + particleSize / length(radii) && collisionFlag == 0.0) {
          // Compute the normal at the collision point, accounting for particle size
        vec3 adjustedPos = scaledPos * (1.0 + particleSize / length(radii));          
        // Compute the normal at the collision point
        vec3 normal = ellipsoidNormal(adjustedPos, radii);
        // Rotate the normal back to world space
        normal = applyQuaternionToVector(uColliderQuaternion, normal);
        // Reflect the velocity vector off the normal
        velocity = reflect(velocity, normal) * restitution;

        collisionFlag = 1.0;
      } else {
        collisionFlag = 0.0;
      }
    #endif

    // BOX COLLIDER or PLANE COLLIDER 
    // **************************************************************
    #ifdef USE_BOX_COLLIDER
      // Box dimensions and repulsion variables
      vec3 boxHalfSize = uColliderSize / 2.0;
      // Convert world position to box's local space
      vec3 localPos = applyQuaternionToVector(uColliderQuaternionInvert, position - uColliderPos);      
      // Collision detection
      vec3 localDistance = abs(localPos) - boxHalfSize;
      float distToSurface = max(localDistance.x, max(localDistance.y, localDistance.z));    

      // Collision Detected
      if (distToSurface <= particleSize * 0.5 && collisionFlag == 0.0) {      
        // Find the nearest face normal for bounce direction
        vec3 normal;
        if (localDistance.x > localDistance.y && localDistance.x > localDistance.z) {
            normal = vec3(sign(localPos.x), 0.0, 0.0);
        } else if (localDistance.y > localDistance.z) {
            normal = vec3(0.0, sign(localPos.y), 0.0);
        } else {
            normal = vec3(0.0, 0.0, sign(localPos.z));
        }            
        // Rotate normal back to world space
        normal = applyQuaternionToVector(uColliderQuaternion, normal);      
        // Reflect velocity and apply repulsion force
        velocity = reflect(velocity, normal) * restitution;
        
        collisionFlag = 1.0;
      } else {
        collisionFlag = 0.0;
      }
    #endif      
  #endif      
  // END COLLIDER    
`,
  CZ = `
  #ifdef USE_ATTRACTOR

      #ifdef USE_SPHERE_COLLIDER      
        // Convert collider size to radii (assuming uColliderSize is the diameter in each axis)
        vec3 radii = uColliderSize;
        // Adjust position relative to collider
        vec3 relPos = position - uColliderPos;
        // Apply rotation of the collider to the relative position
        relPos = applyQuaternionToVector(uColliderQuaternionInvert, relPos);            
        // Scale relative position by radii (for ellipsoid collision detection)
        vec3 scaledPos = relPos / radii;
        // Calculate ellipsoidal distance
        float distToSurface = length(scaledPos); // Distance in terms of ellipsoid
        float insideCheck = 1.0;

      #endif


      #ifdef USE_BOX_COLLIDER
        // Box dimensions
        vec3 boxHalfSize = uColliderSize / 2.0;
        // Convert world position to box's local space
        vec3 localPos = applyQuaternionToVector(uColliderQuaternionInvert, position - uColliderPos);      
        vec3 localDistance = abs(localPos) - boxHalfSize;
        float distToSurface = max(localDistance.x, max(localDistance.y, localDistance.z));
        float insideCheck = particleSize;
      #endif      
  
      // Apply vortex force inside the Helper
      #ifdef USE_FORCE_LOCAL_SPACE
        if (distToSurface <= insideCheck ) {    
            // Define parameters for the attractor field
            #ifdef USE_SPHERE_COLLIDER      
              float attractorStrength = (1.0 - distToSurface ) * uForceIntensity; // Adjust as needed
            #endif

            #ifdef USE_BOX_COLLIDER
              float attractorStrength = max((1.0 - insideCheck / distToSurface), 0.) * uForceIntensity; // Adjust as needed
              #endif

            float attractorDamping = uForceDamping;  // Adjust as needed (higher values will attenuate velocity more)
          
            // Use the same radii calculation code as for the collider
            vec3 attractorRadii = uColliderSize;
            // Adjust position relative to attractor center
            vec3 relPos = position - uColliderPos;
            // Apply rotation of the collider to the relative position
            relPos = applyQuaternionToVector(uColliderQuaternionInvert, relPos);            
            // Scale relative position by radii (for ellipsoid attraction)
            vec3 scaledPos = relPos / attractorRadii;

            // Calculate ellipsoidal distance as attractor radius
            float attractorRadius = length(scaledPos);
            // Calculate the distance from the attractor center
            vec3 relativePosition = position - uColliderPos;
            // Calculate the force vector towards the attractor center
            vec3 attractorForce = normalize(relativePosition) * attractorStrength;
            // Apply the attractor force to the particle
            velocity -= attractorForce;
            // Attenuate the particle's velocity
            velocity *= attractorDamping;
        }
      #else 
            // Calculate the distance from the attractor center
            vec3 relativePosition = position - uColliderPos;
            // Calculate the force vector towards the attractor center
            vec3 attractorForce = normalize(relativePosition) * uForceIntensity;
            // Apply the attractor force to the particle
            velocity -= attractorForce;
            // Attenuate the particle's velocity
            velocity *= uForceDamping;
      #endif    
  #endif      
`,
  TZ = `
  #ifdef USE_VORTEX
    // Box dimensions
    vec3 boxHalfSize = uColliderSize / 2.0;
    // Convert world position to box's local space
    vec3 localPos = applyQuaternionToVector(uColliderQuaternionInvert, position - uColliderPos);      
    vec3 localDistance = abs(localPos) - boxHalfSize;
    float distToSurface = max(localDistance.x, max(localDistance.y, localDistance.z));

    // Apply vortex force inside the box
    if (distToSurface <= particleSize) {
      float vortexStrength = uForceIntensity;
      vec3 localTopCenter = vec3(0.0, 0., 0.0);

      // Transform the local top center to the world space
      vec3 vortexCenter = uColliderPos + applyQuaternionToVector(uColliderQuaternion, localTopCenter);
      // Calculate the vector from particle to vortex center
      vec3 vortexVector = vortexCenter - position;

      // Calculate the rotation axis from the inverse of the collider's quaternion and the fixed up vector
      // Note: important to add a tiny z component to the up vector to avoid instability
      vec3 upVector = vec3(0.0, 1.0, 0.01);
      vec3 rotationAxis = cross(upVector, applyQuaternionToVector(uColliderQuaternion, vortexVector));
      rotationAxis = normalize(rotationAxis);

      // Add rotational component to velocity
      float rotationSpeed = length(vortexVector * vortexStrength * 3.0) ; 

      vec3 rotationVelocity = rotationAxis * rotationSpeed;
      // velocity += rotationVelocity * 0.005 ;
      velocity = rotationVelocity * 0.005 ;

      // Calculate vortex force
      // vec3 vortexForce = normalize(vortexVector) * uSpeed * .1 ;
      // Apply the vortex force to the particle
      vec3 originDirection = applyQuaternionToVector(uWorldQuaternion, directions);
      velocity += applyForce( originDirection * uSpeed * (1. - uForceDamping) , mass * .5);
    }
  #endif      
`,
  PZ =
    `
// uniform sampler2D uCurrentPosition; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentVelocity; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentEmissionRate; // Pass in the variable from GPGPU
uniform sampler2D uOriginalPosition;
uniform sampler2D uDirections;     
uniform vec3 uDirectionsAxis;
uniform vec4 uWorldQuaternion;
uniform vec3 uGravity;        
uniform float uNoiseStrength;     // Variation of the noise
uniform float uNoiseScale;        // Scale of the noise
uniform float uNoiseSeed;         // Seed of the noise
uniform float particleSize;
uniform float uSpeed;     // update speed of the particles
uniform float uRandomMassFactor;

// COLLIDER
uniform vec3 uColliderPos;                // Collider Position
uniform vec3 uColliderSize;               // Collider Dimension
uniform vec4 uColliderQuaternion;         // Collider Rotation
uniform vec4 uColliderQuaternionInvert;   // Collider Rotation
uniform float uBounce;                    // Bounce factor
uniform float uForceDamping;
uniform float uForceIntensity;


` +
    MZ +
    `
float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}
vec3 applyQuaternionToVector( vec4 q, vec3 v ){
    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
 } 
vec3 applyForce(vec3 force, float mass) {
  vec3 acceleration = force / mass;
  
  return acceleration;
}

vec4 conjugate(vec4 q) {
  return vec4(q.w, -q.x, -q.y, -q.z);
}

// Function to compute the normal of the ellipsoid at a given point
vec3 ellipsoidNormal(vec3 p, vec3 radii) {
  return normalize(p / (radii * radii));
}

float friction = .3;

void main() {
    vec2 vUv = gl_FragCoord.xy / resolution.xy;
    vec3 position = texture2D( uCurrentPosition, vUv ).xyz;
    vec3 originalPosition = texture2D( uOriginalPosition, vUv ).xyz;
    float timeLeft = texture2D( uCurrentPosition, vUv ).w;
    vec3 directions = texture2D( uDirections, vUv ).xyz;    
    vec3 velocity = texture2D( uCurrentVelocity, vUv ).xyz;
    float mass = rand(originalPosition.xy) * 0.5 + 0.5;
    float isSpawning = texture2D( uCurrentEmissionRate, vUv ).x;        // 1. = spawning, 0. = not spawning
    float isActive = texture2D( uCurrentEmissionRate, vUv ).y;          // 1. = active, 0. = not active
    float collisionFlag =texture2D( uCurrentVelocity, vUv ).w;          // Indicate collision

    // Randomness Mass
    mass = (1.0 - (uRandomMassFactor * mass));
    
    if (isActive == 1.0) {
      // **************************************************************
      // FORCES NOISES
      // **************************************************************
      #ifdef USE_CURL_NOISE
        if (uNoiseScale > 0.0 ) {
          velocity = curlNoise(position * uNoiseScale * .002, uNoiseSeed) * ( uNoiseStrength + 1.0) * .05 * uSpeed;
        }
        // Variation of the noise Over Time
        if (uNoiseStrength > 0.0 && uNoiseScale == 0.0 ) {
          velocity += curlNoise( position, uNoiseSeed)  * uNoiseStrength * 0.05 * uSpeed;
        }
      #endif
      // **************************************************************
      #ifdef USE_SIMPLEX_NOISE
        if (uNoiseScale > 0.0 ) {
          velocity = vec3(snoise(position * uNoiseScale * .001) * ( uNoiseStrength + 1.0) * .1);
          velocity *= uSpeed;
        }
        // Variation of the noise Over Time
        if (uNoiseStrength > 0.0 && uNoiseScale == 0.0) {
          velocity += vec3(snoise(position * uNoiseStrength * .001) * .05 * uSpeed);
        }
      #endif
      // ************************************************************** 
      #ifdef USE_FBM_NOISE
        if (uNoiseScale > 0.0 ) {
          float offset = 0.0;
          velocity = fbm_vec3(position * uNoiseScale * .001, ( uNoiseStrength + 1.0), offset);
          velocity *= uSpeed;
        }
        // Variation of the noise Over Time
        if (uNoiseStrength > 0.0 && uNoiseScale == 0.0 ) {      
          float offset = 0.0;
          velocity += fbm_vec3(position * uNoiseStrength * .001, ( uNoiseStrength + 1.0), uNoiseSeed) * .1 * uSpeed;
        }
      #endif

      // COLLIDER
      ${EZ}
      // ATTRACTION
      ${CZ}  
      // VORTEX
      ${TZ}
    } 
    // End isActive

    // SPAWN BIRTH 
    // **************************************************************
    // if (isSpawning == 1.)
    #ifdef USE_NORMALS
      velocity = mix(velocity, applyQuaternionToVector(uWorldQuaternion, directions) * uSpeed, isSpawning);
    #else
      velocity = mix(velocity, applyQuaternionToVector(uWorldQuaternion, uDirectionsAxis) * uSpeed, isSpawning);    
    #endif
    
    // if (collisionFlag == 0.0)
    velocity += applyForce(uGravity, mass * .5) * (1.0 - collisionFlag);

    gl_FragColor = vec4(velocity, collisionFlag);
}
`,
  kP = `

  // Linear Fade In
  float linearFadeIn(float t) {
    return t;
  }


  // linear fade out
  float linearFadeOut(float t) {
    return 1.0 - t;
  }
  
  float linearInOut(float t) {
    return t < 0.5 ? t :  (1.0 - t);  
  }

    // lerp
    float lerp(float a, float b, float t) {
      return a + (b - a) * t;
    }

  // Ease In Out Quart
  float exponentialInOut(float t) {
    return t < 0.4 ? lerp(0.0, 1.0, t / 0.4) :
    t > 0.6 ? lerp(1.0, 0.0, (t - 0.6) / 0.4) :
    1.0;
   }

  // constant
  float constant(float t) {
    return 1.0;
  } 
`,
  DZ = `

float rand(vec3 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 applyQuaternionToVector( vec4 q, vec3 v ){
  return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
}

vec3 applyForce(vec3 force, float mass) {
  vec3 acceleration = force / mass;
    
  return acceleration;
}
`,
  OZ = `
vec3 rgb2xyz (in vec3 rgb) {
    float r = rgb.r;
	float g = rgb.g;
	float b = rgb.b;

	r = r > 0.04045 ? pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	float x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	float y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	float z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
    
    vec3 xyz = vec3(
        (r * 0.4124) + (g * 0.3576) + (b * 0.1805) * 100.0,
        (r * 0.2126) + (g * 0.7152) + (b * 0.0722) * 100.0,
        (r * 0.0193) + (g * 0.1192) + (b * 0.9505) * 100.0
    );
    return(xyz);
}

vec3 xyz2lab (in vec3 xyz) {
	float x = xyz.x / 95.047;
	float y = xyz.y / 100.0;
	float z = xyz.z / 108.883;

	x = x > 0.008856 ? pow(x, 1.0 / 3.0) : (7.787 * x) + (16.0 / 116.0);
	y = y > 0.008856 ? pow(y, 1.0 / 3.0) : (7.787 * y) + (16.0 / 116.0);
	z = z > 0.008856 ? pow(z, 1.0 / 3.0) : (7.787 * z) + (16.0 / 116.0);

    vec3 lab = vec3((116.0 * y) - 16.0, 500.0 * (x - y), 200.0 * (y - z));
    return(lab);
}

vec3 rgb2lab(in vec3 rgb) {
    vec3 xyz = rgb2xyz(rgb);
    vec3 lab = xyz2lab(xyz);
    return(lab);
}

vec3 xyz2rgb (in vec3 xyz) {
	float x = xyz.x / 100.0;
	float y = xyz.y / 100.0;
	float z = xyz.z / 100.0;
	
    
	float r = (x *  3.2406) + (y * -1.5372) + (z * -0.4986);
	float g = (x * -0.9689) + (y *  1.8758) + (z *  0.0415);
	float b = (x *  0.0557) + (y * -0.2040) + (z *  1.0570);

	r = r > 0.0031308 ? ((1.055 * pow(r, 1.0 / 2.4)) - 0.055) : r * 12.92;
	g = g > 0.0031308 ? ((1.055 * pow(g, 1.0 / 2.4)) - 0.055) : g * 12.92;
	b = b > 0.0031308 ? ((1.055 * pow(b, 1.0 / 2.4)) - 0.055) : b * 12.92;

	r = min(max(0.0, r), 1.0);
	g = min(max(0.0, g), 1.0);
	b = min(max(0.0, b), 1.0);

	return(vec3(r, g, b));
}

vec3 lab2xyz (in vec3 lab) {
    float l = lab.x;
	float a = lab.y;
	float b = lab.z;

  	float y = (l + 16.0) / 116.0;
	float x = a / 500.0 + y;
	float z = y - b / 200.0;

	float y2 = pow(y, 3.0);
	float x2 = pow(x, 3.0);
	float z2 = pow(z, 3.0);

  	y = y2 > 0.008856 ? y2 : (y - 16.0 / 116.0) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16.0 / 116.0) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16.0 / 116.0) / 7.787;

	x *= 95.047;
	y *= 100.0;
	z *= 108.883;

	return(vec3(x, y, z));
}
vec3 lab2rgb (in vec3 lab) {
    vec3 xyz = lab2xyz(lab);
    vec3 rgb = xyz2rgb(xyz);
    return(rgb);
}

`,
  IZ = `
  uniform sampler2D uPosition;
  uniform float uSize;
  uniform float uSizeEnd;
  uniform vec3 uWorldOffset;
  uniform vec4 uWorldQuaternion;
  // Billboard Behavior - Currently at Zero, but we can change that
  uniform float uRotation;
  uniform float uRotationEnd;
  uniform vec2 center;

  // Randomness
  uniform float uRandScaleFactor;
  uniform float uRandRotationFactor;

  attribute vec2 ref;

  varying float v_LifeLeft;    // normalized lifetime 1 to 0
  varying vec2 vUv;
  varying vec2 vRef;

  ${DZ}
  ${kP}
`,
  RZ = ({ easeSize: e = "linearFadeOut" }) => `
  vUv = uv;  
  vRef = ref;
  // Normalized LifeTime 1 to 0
  float lifeLeft = texture2D(uPosition, ref).w;
  v_LifeLeft = lifeLeft;
  // Position From DataTexture Simulation
  vec3 pos = texture2D(uPosition, ref).rgb - uWorldOffset;
  // Apply World Quaternion
  pos = applyQuaternionToVector(uWorldQuaternion, pos);  
            
  #ifdef  USE_SIZE_END
    // Scaled Over Time
    float t = 1. - lifeLeft;
    float currentSize = mix(uSize, uSizeEnd, t); // Linearly interpolate between uSize and uSizeEnd
    vec3 scaledPosition = position * vec3(currentSize);
  #else
    // Change Size Behavior over LifeTime
    float easeSize = ${e}(1. - lifeLeft);
    // Scaled Over Time
    vec3 scaledPosition = position * vec3(uSize * easeSize);
  #endif

  // Billboard Behavior
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );    
  // Randomness 
  float randRef = rand(ref);
  scale *= (1.0 - (uRandScaleFactor * randRef));
  // Rotation
  float randRotation =  2.0 * PI * ( uRandRotationFactor * randRef);
  float originalRotation = (1.0 - uRotation) * 2.0 * PI;
  float originalRotationEnd = (1.0 - uRotationEnd) * 2.0 * PI;
  // OverTime
  float finalRotation = mix(originalRotation + randRotation, originalRotationEnd + randRotation, lifeLeft);

  vec2 alignedPosition = ( scaledPosition.xy - ( center - vec2( 0.5 ) ) ) * scale;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( finalRotation ) * alignedPosition.x - sin( finalRotation ) * alignedPosition.y;
  rotatedPosition.y = sin( finalRotation ) * alignedPosition.x + cos( finalRotation ) * alignedPosition.y;
  
  mat4 instanceMatrix = mat4(
    vec4(1.0, 0.0, 0.0, 0.0),
    vec4(0.0, 1.0, 0.0, 0.0),
    vec4(0.0, 0.0, 1.0, 0.0),
    vec4(pos.x, pos.y, pos.z, 1.0)
  );  

  mvPosition = modelViewMatrix * instanceMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  mvPosition.xy += rotatedPosition;
  gl_Position = projectionMatrix  * mvPosition;   
`,
  LZ =
    `
  uniform vec4 uColor;                // start color
  uniform vec4 uColor2;               // end color
  uniform sampler2D uTexture;         // texture
  varying float v_LifeLeft;   // normalized lifetime 1 to 0
  varying vec2 vUv;
  varying vec2 vRef;

  float random(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
  }
  ` +
    kP +
    `  
  ${OZ}

`,
  BZ = ({ easeOpacity: e = "linearFadeOut" }) => `  
  // if Particle is dead, hide it
  if (v_LifeLeft <= 0.005 ) {
    discard;
  }

  #ifdef USE_RANDOM_COLORING
    float randVal = random(vRef); // Generate a random value based on the reference
    vec4 color = mix(uColor, uColor2, randVal); // Interpolate between the two colors
  #else
    vec4 color = mix(uColor, uColor2, 1. - v_LifeLeft);
  #endif

  // Opacity over Life Time
  float finalAlpha = ${e}(1. - v_LifeLeft);  
  vec4 textureColor = texture2D(uTexture, vUv).rgba; 
  finalColor = textureColor.rgb * color.rgb;
  finalAlpha = color.a * textureColor.a * finalAlpha;
  
  gl_FragColor = vec4(finalColor, finalAlpha);     

`,
  zZ = class extends vi {
    constructor(e, t) {
      super(),
        (this.needsJitter = !0),
        (this.type = "ParticleMaterial"),
        (this.easeOpacity = "linearFadeIn"),
        (this.easeSize = "linearFadeIn"),
        (this.useSizeEnd = !1),
        (this.isColoringRandom = !1),
        this.init(e, t),
        (this.context = t);
    }
    reset() {}
    init(e, t) {
      (this.transparent = !0),
        (this.depthTest = !0),
        (this.depthWrite = !1),
        (this.easeOpacity = e.ease),
        (this.easeSize = e.easeSize),
        (this.layers = []),
        (this.lightLayer = new xn(
          0,
          "",
          { ...jr.defaultData("light", "phong"), visible: !1 },
          new bb(),
          {},
          t.shared
        )),
        this.build();
    }
    updateState(e) {
      e.coloring !== void 0 &&
        (this.isColoringRandom = e.coloring === "random"),
        e.color !== void 0 &&
          (e.color instanceof Array
            ? (this.uniforms.uColor.value = e.color)
            : (this.uniforms.uColor.value = this.context.shared.color(
                e.color
              ))),
        e.color2 !== void 0 &&
          (e.color2 instanceof Array
            ? (this.uniforms.uColor2.value = e.color2)
            : (this.uniforms.uColor2.value = this.context.shared.color(
                e.color2
              ))),
        e.size !== void 0 &&
          ((this.uniforms.uSize.value = e.size[0]),
          (this.uniforms.uSizeEnd.value = e.size[1]),
          e.size[0] !== e.size[1]
            ? (this.useSizeEnd = !0)
            : (this.useSizeEnd = !1)),
        e.ease !== void 0 && ((this.easeOpacity = e.ease), this.build()),
        e.easeSize !== void 0 && ((this.easeSize = e.easeSize), this.build()),
        (this.needsUpdate = !0);
    }
    onBeforeCompile(e) {
      this.build(),
        (e.defines = this.defines),
        (e.uniforms = this.uniforms),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader);
    }
    build() {
      let e = new k3();
      return (
        (e.needsJitter = this.needsJitter),
        e.addFragmentParsCode(X7),
        e.buildShader("vertex", this.fragment),
        e.buildShader("fragment", this.fragment),
        e.addFragmentFinalCode(Q7),
        this.isColoringRandom && e.define("USE_RANDOM_COLORING"),
        this.useSizeEnd && e.define("USE_SIZE_END"),
        e.addVertexParsCode(IZ),
        e.addFragmentParsCode(LZ),
        e.addVertexFinalCode(RZ({ easeSize: this.easeSize })),
        e.addFragmentFinalCode(BZ({ easeOpacity: this.easeOpacity })),
        (this.vertexShader = e.getCode("vertex")),
        (this.fragmentShader = e.getCode("fragment")),
        (this.defines = e.defines),
        (this.uniforms = { ...e.uniforms, ...this.uniforms }),
        (this.extensions = e.extensions),
        this
      );
    }
    get nodeMaterial() {
      return this;
    }
    get fragment() {
      return this.lightLayer.node;
    }
    getDefines() {
      return this.defines;
    }
    nodeMaterialDispose() {
      this.layers.forEach((e) => e.dispose()), super.dispose();
    }
  },
  k0 = class {
    constructor(e, t, i, r) {
      (this.type = "SphereEmitterShape"),
        (this.targetMesh = void 0),
        (this.size = e),
        (this.type = i),
        (this.textureSize = bZ(t));
      let s = 1;
      this.targetMesh = r?.type === "Mesh" && r ? r : this.getMesh(i, s);
      let {
        positions: a,
        dataTexture: n,
        dataTextureNormals: o,
      } = this.createPositions(
        this.textureSize,
        this.targetMesh ?? this.getMesh(i, s)
      );
      (this.positionsTexture = n),
        (this.positionsAttribute = a),
        (this.directionsTexture = o);
    }
    createPositions(e, t) {
      let { positions: i, normals: r } = wZ(t, e * e),
        s = IM(i, e),
        a = IM(r, e);
      return { dataTexture: s, positions: i, dataTextureNormals: a };
    }
    getMesh(e, t) {
      let i = null;
      switch (e) {
        case "SphereEmitterShape": {
          i = new Cc(t * 0.5, 32, 32);
          break;
        }
        case "TorusEmitterShape": {
          i = new bC(t * 0.5, 0.3, 15, 40);
          break;
        }
        case "ConeEmitterShape": {
          i = new Ex(t, t, 15);
          break;
        }
        case "BoxEmitterShape": {
          i = new Za(t, t, t);
          break;
        }
        case "PlaneEmitterShape": {
          (i = new vh(t, t)), i.rotateX(-Math.PI / 2);
          break;
        }
        case "MeshEmitterShape": {
          i = new Cc(t, 32, 32);
          break;
        }
        default: {
          i = new Cc(t, 32, 32);
          break;
        }
      }
      return new br(i, new mh({ color: 16711680 }));
    }
    applyToShader(e, t) {
      (this.size = new I().fromArray(t.size)),
        (e.uEmitterSize.value = this.size);
    }
    dispose() {
      this.positionsTexture.dispose(),
        this.directionsTexture.dispose(),
        (this.positionsAttribute = new Float32Array());
    }
  };
function yd(e) {
  let t = { ...e },
    i = Gm.defaultData;
  t.forceFieldObjectId && (t.colliderEntityId = t.forceFieldObjectId);
  let r = { ...i.shape, ...t.shape },
    s = { ...i.renderMaterial, ...t.renderMaterial };
  return { ...i, ...t, shape: r, renderMaterial: s };
}
var FZ = `
// uniform sampler2D uCurrentPosition; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentVelocity; // Pass in the variable from GPGPU
// uniform sampler2D uCurrentEmissionRate; // Pass in the variable from GPGPU

uniform sampler2D uIndex; // Texture with corresponding index
uniform float uLastIndexEmitted; // Last emitted index
uniform float uParticlesToEmit; // Number of particles to emit on that frame
uniform float uTime;

void main() {
    vec2 vUv = gl_FragCoord.xy / resolution.xy;
    float particleIndex = texture(uIndex, vUv).x;
    float timeLeft = texture2D( uCurrentPosition, vUv ).w;
    float isActive = texture2D( uCurrentEmissionRate, vUv ).g;    // 1. = active, 0. = not active
    float timeStart = texture2D( uCurrentEmissionRate, vUv ).b;


    // ********** Detect Colision to Create a flag and use it in position **********
    // We are doing this here, so

    // ********** Emit Particles **********
    // X = isSpawning 0.0 or 1.0
    // Y = isActive 0.0 or 1.0
    // Check if the vertex index is between the first value and the last value
    // if (particleIndex >= uLastIndexEmitted && particleIndex < uLastIndexEmitted + uParticlesToEmit) {
    //     // Emit a particle by writing 1 to the red channel of the color output
    //     // r: 1. == emit the particle
    //     // g: 1. == particle is now active
    //     timeStart = uTime;
    //     gl_FragColor = vec4(1.0, 1.0, timeStart, 1.0);
    // } else {
    //     // The Particle is either already emitted or not in the range of the particles to emit
    //     // Do not emit a particle by writing 0 to the red channel of the color output        
    //     gl_FragColor = vec4(0.0, isActive, timeStart, 1.0);
    // }
    // Determine if the particle is within the emission range
    float emitLowerBound = step(uLastIndexEmitted, particleIndex);
    float emitUpperBound = step(particleIndex, uLastIndexEmitted + uParticlesToEmit - 1.0);
    float emitParticle = emitLowerBound * emitUpperBound; // 1.0 if in range, 0.0 otherwise

    // Set timeStart and color
    timeStart = mix(timeStart, uTime, emitParticle);
    gl_FragColor = vec4(emitParticle, mix(isActive, 1.0, emitParticle), timeStart, 1.0);


}
`,
  N0 = 10,
  kZ = class extends _i {
    constructor(e, t) {
      super(),
        (this.type = "ParticleEmitter"),
        (this.debugMode = !1),
        (this.worldSpace = !0),
        (this.rootObject = null),
        (this.gpuCompute = null),
        (this.positionSimRT = null),
        (this.velocitySimRT = null),
        (this.emissionRateSimRT = null),
        (this.emitterShape = void 0),
        (this.isEmitting = !1),
        (this.hasBeenReset = !1),
        (this.emittedParticlesAmount = 0),
        (this.lastEmitTime = 0),
        (this.globalTime = 0),
        (this.targetFPS = 60),
        (this.previousRatio = 1),
        (this.lerpFactor = 0.4),
        (this.particlesAmount = 0),
        (this.noiseStrength = 0),
        (this.noiseScale = 0),
        (this.isBillboardBased = !0),
        (this.simFeaturesDefinition = {
          USE_COLLIDER: !1,
          USE_ATTRACTOR: !1,
          USE_VORTEX: !1,
          USE_SPHERE_COLLIDER: !1,
          USE_BOX_COLLIDER: !1,
          USE_FORCE_LOCAL_SPACE: !1,
          USE_NORMALS: !1,
          USE_CURL_NOISE: !0,
          USE_SIMPLEX_NOISE: !1,
          USE_FBM_NOISE: !1,
        }),
        (this.textureLoader = new VF()),
        (this.currentWorldPosition = new I()),
        (this.systemQuaternion = new Rt()),
        (this.worldGravity = new I(0, 0, 0)),
        (this.directionAxis = new I(0, 0, 0)),
        (this.colliderV3 = new I(0, 0, 0)),
        (this.colliderQuaternion = new Rt(0, 0, 0, 1)),
        (this.matrixAutoUpdate = !0),
        (this.renderer = e),
        (this.system = t),
        (this.shared = t.context.shared);
      let i = t.data;
      (this.material = new zZ(i.renderMaterial, t.context)),
        (this.material.uniforms = {
          uSize: { value: 0 },
          uSizeEnd: { value: 0 },
          uColor: { value: i.renderMaterial.color },
          uColor2: { value: i.renderMaterial.color2 },
          uPosition: { value: new I(0, 0, 0) },
          uEmissionData: { value: new I(0, 0, 0) },
          uTexture: { value: this.defaultTexture },
          uWorldOffset: { value: new I(0, 0, 0) },
          uWorldQuaternion: { value: new Lt(0, 0, 0, 1) },
          uRandScaleFactor: { value: i.randomScale ?? 0 },
          uRandRotationFactor: { value: i.randomRotation ?? 0 },
          uRotation: { value: i.renderMaterial.spriteRotation[0] ?? 0 },
          uRotationEnd: { value: i.renderMaterial.spriteRotation[1] ?? 0 },
        }),
        this.setTexture(this.material.uniforms, i.renderMaterial.texture),
        this.init(i);
    }
    setTexture(e, t) {
      let i = t.data;
      if (typeof t == "string") {
        let r = this.shared.image(t),
          s = new Yi(r.img);
        (s.needsUpdate = !0), (e.uTexture.value = s);
        return;
      }
      if (typeof i != "string") {
        let r = new Image();
        r.onload = () => {
          let n = new Yi(r);
          (n.needsUpdate = !0), (e.uTexture.value = n);
        };
        let s = new Blob([i], { type: "image/*" }),
          a = URL.createObjectURL(s);
        r.src = a;
      }
    }
    updateGeometryAttributes(e, t) {
      let i = xZ(t);
      !this.emitterShape?.positionsAttribute ||
        e.geometry.setAttribute("ref", new Ld(i, 2));
    }
    applyWorldSpace() {
      if (
        !this.system.started ||
        !this.worldSpace ||
        !this.positionSimRT ||
        !this.velocitySimRT
      )
        return;
      let e = this.system;
      e.getWorldQuaternion(this.systemQuaternion),
        this.systemQuaternion.invert(),
        e.getWorldPosition(this.currentWorldPosition),
        (this.material.uniforms.uWorldOffset.value = this.currentWorldPosition),
        this.material.uniforms.uWorldQuaternion.value.copy(
          this.systemQuaternion.normalize()
        ),
        (this.positionSimRT.material.uniforms.uWorldOffset.value =
          this.currentWorldPosition),
        this.systemQuaternion.invert(),
        this.positionSimRT.material.uniforms.uWorldQuaternion.value.copy(
          this.systemQuaternion.normalize()
        ),
        this.velocitySimRT.material.uniforms.uWorldQuaternion.value.copy(
          this.systemQuaternion.normalize()
        );
    }
    update(e, t) {
      if (
        !this.gpuCompute ||
        !this.positionSimRT ||
        !this.velocitySimRT ||
        !this.emissionRateSimRT ||
        this.hasBeenReset
      )
        return;
      if (this.checkIfAllParticlesAreDead() && !this.hasBeenReset) {
        this.reset();
        return;
      }
      this.applyWorldSpace(),
        (this.globalTime = e),
        (this.positionSimRT.material.uniforms.uTime.value = e),
        (this.emissionRateSimRT.material.uniforms.uTime.value = e);
      let i = 1e3 / t,
        r = this.targetFPS / i,
        s = this.previousRatio + (r - this.previousRatio) * this.lerpFactor;
      (this.positionSimRT.material.uniforms.uFPSRatio.value = s),
        (this.previousRatio = s);
      let a = this.isEmitting
        ? this.GoEmitSomeParticles(e, this.system.data.birthRatePerSec)
        : 0;
      (this.emissionRateSimRT.material.uniforms.uLastIndexEmitted.value =
        this.emittedParticlesAmount),
        (this.emissionRateSimRT.material.uniforms.uParticlesToEmit.value = a),
        (this.material.uniforms.uPosition.value =
          this.gpuCompute.getCurrentRenderTarget(this.positionSimRT)?.texture),
        this.system.colliderEntities.length > 0 && this.renderColliders(),
        this.gpuCompute.compute();
    }
    renderColliders() {
      if (!this.velocitySimRT) return;
      let e = this.system.colliderEntities[0];
      if (!e) return;
      e.getWorldPosition(this.colliderV3),
        this.colliderV3.y === 0 && (this.colliderV3.y = 1e-4),
        this.velocitySimRT.material.uniforms.uColliderPos.value.copy(
          this.colliderV3
        );
      let t = e.data.size;
      this.colliderV3.fromArray(t),
        this.velocitySimRT.material.uniforms.uColliderSize.value.copy(
          this.simFeaturesDefinition.USE_SPHERE_COLLIDER
            ? this.colliderV3.multiplyScalar(0.5)
            : this.colliderV3
        ),
        e.getWorldQuaternion(this.colliderQuaternion),
        this.velocitySimRT.material.uniforms.uColliderQuaternion.value.copy(
          this.colliderQuaternion.normalize()
        ),
        this.velocitySimRT.material.uniforms.uColliderQuaternionInvert.value.copy(
          this.colliderQuaternion.normalize().invert()
        );
    }
    updateState(e) {
      !this.velocitySimRT ||
        !this.positionSimRT ||
        (e.renderMaterial && this.updateMaterialState(e.renderMaterial),
        this.updateParticleState(e));
    }
    updateVariableState(e, t) {
      if (!this.velocitySimRT || !this.positionSimRT) return;
      t[2] === "size" &&
        this.material.updateState({
          size: [e, this.material.uniforms.uSizeEnd.value],
        }),
        t[2] === "sizeEnd" &&
          this.material.updateState({
            size: [this.material.uniforms.uSize.value, e],
          });
      let i = (r, s) => {
        let a = [...this.system.data.shape.size];
        (a[r] = s),
          this.updateParticleState({
            shape: { ...this.system.data.shape, size: a },
          });
      };
      t[2] === "shape_size_0" && i(0, e),
        t[2] === "shape_size_1" && i(1, e),
        t[2] === "shape_size_2" && i(2, e),
        t[2] === "speed" &&
          (this.velocitySimRT.material.uniforms.uSpeed.value = e / N0),
        t[2] === "gravity" && this.worldGravity.set(0, e / 100, 0),
        t[2] === "noiseStrength" &&
          ((this.noiseStrength = e),
          (this.velocitySimRT.material.uniforms.uNoiseStrength.value =
            this.noiseStrength)),
        t[2] === "noiseScale" &&
          ((this.noiseScale = e),
          (this.velocitySimRT.material.uniforms.uNoiseScale.value =
            this.noiseScale)),
        t[2] === "direction_x" &&
          (this.directionAxis = this.getDirectionAxis([
            Number(e),
            this.system.data.direction[1],
            this.system.data.direction[2],
          ])),
        t[2] === "direction_y" &&
          (this.directionAxis = this.getDirectionAxis([
            this.system.data.direction[0],
            Number(e),
            this.system.data.direction[2],
          ])),
        t[2] === "direction_z" &&
          (this.directionAxis = this.getDirectionAxis([
            this.system.data.direction[0],
            this.system.data.direction[1],
            Number(e),
          ]));
    }
    updateMaterialState(e) {
      this.material.updateState({
        ...e,
        size: e.size
          ? [
              Number(
                this.shared.getVariable(e.size[0], [
                  this.uuid,
                  "particles",
                  "size",
                ])
              ),
              Number(
                this.shared.getVariable(e.size[1], [
                  this.uuid,
                  "particles",
                  "sizeEnd",
                ])
              ),
            ]
          : [0, 0],
      }),
        e.texture &&
          (this.setTexture(this.material.uniforms, e.texture),
          (this.material.needsUpdate = !0));
    }
    updateParticleState(e) {
      if (!(!this.positionSimRT || !this.velocitySimRT)) {
        if (
          (this.shouldReInitGPUCompute(e) && this.init(yd(this.system.data)),
          e.life !== void 0 &&
            (this.positionSimRT.material.uniforms.uMaxLifeTime.value = e.life),
          e.speed !== void 0 &&
            (this.velocitySimRT.material.uniforms.uSpeed.value =
              Number(
                this.shared.getVariable(e.speed, [
                  this.uuid,
                  "particles",
                  "speed",
                ])
              ) / N0),
          e.collisionBounce !== void 0 &&
            (this.velocitySimRT.material.uniforms.uBounce.value =
              e.collisionBounce),
          e.noiseStrength !== void 0 &&
            ((this.noiseStrength = Number(
              this.shared.getVariable(e.noiseStrength, [
                this.uuid,
                "particles",
                "noiseStrength",
              ])
            )),
            (this.velocitySimRT.material.uniforms.uNoiseStrength.value =
              this.noiseStrength)),
          e.noiseScale !== void 0 &&
            ((this.noiseScale = Number(
              this.shared.getVariable(e.noiseScale, [
                this.uuid,
                "particles",
                "noiseScale",
              ])
            )),
            (this.velocitySimRT.material.uniforms.uNoiseScale.value =
              this.noiseScale)),
          e.noiseSeed !== void 0 &&
            (this.velocitySimRT.material.uniforms.uNoiseSeed.value =
              e.noiseSeed),
          e.randomMass !== void 0 &&
            (this.velocitySimRT.material.uniforms.uRandomMassFactor.value =
              e.randomMass),
          e.renderMaterial?.size !== void 0)
        ) {
          let t = this.shared.getVariable(e.renderMaterial.size[0], [
            this.uuid,
            "particles",
            "size",
          ]);
          this.velocitySimRT.material.uniforms.particleSize.value = Number(t);
        }
        if (
          (e.renderMaterial?.spriteRotation !== void 0 &&
            ((this.material.uniforms.uRotation.value =
              e.renderMaterial.spriteRotation[0]),
            (this.material.uniforms.uRotationEnd.value =
              e.renderMaterial.spriteRotation[1])),
          e.shape !== void 0)
        ) {
          let t = e.shape.size ?? this.system.data.shape.size,
            i = [
              Number(
                this.shared.getVariable(t[0], [
                  this.uuid,
                  "particles",
                  "shape_size_0",
                ])
              ),
              Number(
                this.shared.getVariable(t[1], [
                  this.uuid,
                  "particles",
                  "shape_size_1",
                ])
              ),
              Number(
                this.shared.getVariable(t[2], [
                  this.uuid,
                  "particles",
                  "shape_size_2",
                ])
              ),
            ],
            r = { ...yd(this.system.data).shape, size: i };
          this.emitterShape?.applyToShader(
            this.positionSimRT.material.uniforms,
            r
          );
        }
        if (
          (e.gravity !== void 0 &&
            (this.worldGravity.set(
              0,
              Number(
                this.shared.getVariable(this.system.data.gravity, [
                  this.uuid,
                  "particles",
                  "gravity",
                ])
              ) / 100,
              0
            ),
            (this.velocitySimRT.material.uniforms.uGravity = {
              value: this.worldGravity,
            })),
          e.direction !== void 0)
        ) {
          let t = this.getDirectionFromVariable(e.direction);
          (this.directionAxis = this.getDirectionAxis(t)),
            (this.velocitySimRT.material.uniforms.uDirectionsAxis.value =
              this.directionAxis);
        }
        e.randomRotation !== void 0 &&
          (this.material.uniforms.uRandRotationFactor.value = e.randomRotation),
          e.randomScale !== void 0 &&
            (this.material.uniforms.uRandScaleFactor.value = e.randomScale);
      }
    }
    updateForceFieldParameters(e) {
      !this.velocitySimRT ||
        (e.forceIntensity !== void 0 &&
          (this.velocitySimRT.material.uniforms.uForceIntensity.value =
            e.forceIntensity),
        e.forceDambing !== void 0 &&
          (this.velocitySimRT.material.uniforms.uForceDamping.value =
            e.forceDambing));
    }
    getDirectionAxis(e) {
      let t = [
          Number(e[0]) * dt.DEG2RAD,
          Number(e[1]) * dt.DEG2RAD,
          Number(e[2]) * dt.DEG2RAD,
        ],
        i = new Ir(t[0], t[1], t[2], "XYZ");
      return (
        this.directionAxis.set(0, 1, 0).applyEuler(i).normalize(),
        this.velocitySimRT &&
          (this.velocitySimRT.material.uniforms.uDirectionsAxis.value =
            this.directionAxis),
        this.directionAxis
      );
    }
    shouldReInitGPUCompute(e) {
      let {
        birthRatePerSec: t,
        rootObjectType: i,
        colliderEntityId: r,
        shape: s,
        emitTimeDuration: a,
        emitTimeCycle: n,
        life: o,
        directionMode: l,
        noiseType: h,
      } = e;
      return (
        t !== void 0 ||
        i !== void 0 ||
        r ||
        r === null ||
        n !== void 0 ||
        s !== void 0 ||
        o !== void 0 ||
        a !== void 0 ||
        l !== void 0 ||
        h !== void 0
      );
    }
    init(e) {
      this.dispose(),
        (this.particlesAmount = this.getMaxParticlesAmount({
          birthRatePerSecond: e.birthRatePerSec,
          particleMaxLifeTime: e.life,
          loopDuration: e.emitTimeCycle === "infinity" ? 0 : e.emitTimeDuration,
        })),
        this.particlesAmount > 1e5 &&
          (console.warn(
            `The maximum number of particles is limited to ${1e5}.`
          ),
          (this.particlesAmount = 1e5)),
        (this.emitterShape = this.createShape(e.shape, this.particlesAmount));
      let t = setInterval(() => {
        if (this.emitterShape)
          if (isNaN(this.emitterShape.positionsTexture.source.data.data[0])) {
            this.init(e);
            return;
          } else clearInterval(t);
      }, 100);
      if (!this.emitterShape) return;
      let i = new vZ(
          this.emitterShape.textureSize,
          this.emitterShape.textureSize,
          this.renderer
        ),
        r = this.updateSimulationDefinition(e),
        s = i.addVariable(
          "uCurrentPosition",
          r + AZ,
          this.emitterShape.positionsTexture
        ),
        a = i.addVariable(
          "uCurrentVelocity",
          r + PZ,
          this.emitterShape.directionsTexture
        ),
        n = i.addVariable(
          "uCurrentEmissionRate",
          FZ,
          SZ(this.emitterShape.textureSize)
        );
      i.setVariableDependencies(s, [s, a, n]),
        i.setVariableDependencies(a, [s, a, n]),
        i.setVariableDependencies(n, [s, a, n]);
      let o = _Z({ size: this.emitterShape.textureSize }),
        l = {
          uOriginalPosition: { value: this.emitterShape.positionsTexture },
          uWorldOffset: { value: new I(0, 0, 0) },
          uWorldQuaternion: { value: new Lt(0, 0, 0, 1) },
          uTime: { value: 0 },
          uFPSRatio: { value: 1 },
          uMaxLifeTime: { value: e.life },
          uEmitterSize: {
            value: new I(
              Number(
                this.shared.getVariable(e.shape.size[0], [
                  this.uuid,
                  "particles",
                  "shape_size_0",
                ])
              ),
              Number(
                this.shared.getVariable(e.shape.size[1], [
                  this.uuid,
                  "particles",
                  "shape_size_1",
                ])
              ),
              Number(
                this.shared.getVariable(e.shape.size[2], [
                  this.uuid,
                  "particles",
                  "shape_size_2",
                ])
              )
            ),
          },
          particleSize: { value: 0 },
        };
      s.material.uniforms = l;
      let h = this.getDirectionFromVariable(e.direction);
      (this.directionAxis = this.getDirectionAxis(h)),
        this.worldGravity.set(
          0,
          Number(
            this.shared.getVariable(this.system.data.gravity, [
              this.uuid,
              "particles",
              "gravity",
            ])
          ) / 100,
          0
        ),
        (this.noiseStrength = Number(
          this.shared.getVariable(e.noiseStrength, [
            this.uuid,
            "particles",
            "noiseStrength",
          ])
        )),
        (this.noiseScale = Number(
          this.shared.getVariable(e.noiseScale, [
            this.uuid,
            "particles",
            "noiseScale",
          ])
        ));
      let u =
          e.colliderEntityId && this.system.getColliderData(e.colliderEntityId),
        c = {
          uOriginalPosition: { value: this.emitterShape.positionsTexture },
          uDirections: { value: this.emitterShape.directionsTexture },
          uDirectionsAxis: { value: this.directionAxis },
          uWorldQuaternion: { value: new Lt(0, 0, 0, 1) },
          uColliderPos: { value: new I(0, 0, 0) },
          uColliderSize: { value: new I(0, 0, 0) },
          uForceIntensity: { value: u ? u.forceIntensity : 0 },
          uForceDamping: { value: u ? u.forceDambing : 0 },
          uColliderQuaternion: { value: new Lt(0, 0, 0, 1) },
          uColliderQuaternionInvert: { value: new Lt(0, 0, 0, 1) },
          particleSize: { value: 0 },
          uGravity: { value: this.worldGravity },
          uNoiseStrength: { value: this.noiseStrength },
          uNoiseScale: { value: this.noiseScale },
          uNoiseSeed: { value: e.noiseSeed },
          uRandomMassFactor: { value: e.randomMass },
          uBounce: { value: e.collisionBounce },
          uSpeed: {
            value:
              Number(
                this.shared.getVariable(e.speed, [
                  this.uuid,
                  "particles",
                  "speed",
                ])
              ) / N0,
          },
        };
      a.material.uniforms = c;
      let d = {
        uIndex: { value: o },
        uTime: { value: 0 },
        uLastIndexEmitted: { value: 0 },
        uParticlesToEmit: { value: 0 },
      };
      n.material.uniforms = d;
      let p = [
          Number(
            this.shared.getVariable(e.shape.size[0], [
              this.uuid,
              "particles",
              "shape_size_0",
            ])
          ),
          Number(
            this.shared.getVariable(e.shape.size[1], [
              this.uuid,
              "particles",
              "shape_size_1",
            ])
          ),
          Number(
            this.shared.getVariable(e.shape.size[2], [
              this.uuid,
              "particles",
              "shape_size_2",
            ])
          ),
        ],
        f = { ...yd(this.system.data).shape, size: p };
      this.emitterShape.applyToShader(s.material.uniforms, f),
        i.init(),
        (this.gpuCompute = i),
        (this.positionSimRT = s),
        (this.velocitySimRT = a),
        (this.emissionRateSimRT = n),
        (this.rootObject = this.createPrimaryEmitter(
          this.emitterShape.textureSize
        )),
        this.add(this.rootObject),
        (this.material.needsUpdate = !0);
    }
    getDirectionFromVariable(e) {
      let t = Number(
          this.shared.getVariable(e[0], [this.uuid, "particles", "direction_x"])
        ),
        i = Number(
          this.shared.getVariable(e[1], [this.uuid, "particles", "direction_y"])
        ),
        r = Number(
          this.shared.getVariable(e[2], [this.uuid, "particles", "direction_z"])
        );
      return [t, i, r];
    }
    updateSimulationDefinition(e) {
      if (
        ((this.simFeaturesDefinition.USE_COLLIDER = !1),
        (this.simFeaturesDefinition.USE_ATTRACTOR = !1),
        (this.simFeaturesDefinition.USE_VORTEX = !1),
        (this.simFeaturesDefinition.USE_SPHERE_COLLIDER = !1),
        (this.simFeaturesDefinition.USE_BOX_COLLIDER = !1),
        (this.simFeaturesDefinition.USE_FORCE_LOCAL_SPACE = !1),
        (this.simFeaturesDefinition.USE_NORMALS = !1),
        (this.simFeaturesDefinition.USE_CURL_NOISE = !1),
        (this.simFeaturesDefinition.USE_SIMPLEX_NOISE = !1),
        (this.simFeaturesDefinition.USE_FBM_NOISE = !1),
        e.colliderEntityId && this.system.colliderEntities.length > 0)
      ) {
        let i = this.system.getColliderData(e.colliderEntityId);
        switch (i?.forceType) {
          case "attractor":
            this.simFeaturesDefinition.USE_ATTRACTOR = !0;
            break;
          case "collider":
            this.simFeaturesDefinition.USE_COLLIDER = !0;
            break;
          case "vortex":
            this.simFeaturesDefinition.USE_VORTEX = !0;
            break;
        }
        let r = i?.colliderType;
        r === "sphere" && (this.simFeaturesDefinition.USE_SPHERE_COLLIDER = !0),
          r === "box" && (this.simFeaturesDefinition.USE_BOX_COLLIDER = !0),
          i?.forceRange === "helper" &&
            (this.simFeaturesDefinition.USE_FORCE_LOCAL_SPACE = !0);
      }
      e.directionMode === "normals" &&
        (this.simFeaturesDefinition.USE_NORMALS = !0),
        e.noiseType === "curl" &&
          (this.simFeaturesDefinition.USE_CURL_NOISE = !0),
        e.noiseType === "simplex" &&
          (this.simFeaturesDefinition.USE_SIMPLEX_NOISE = !0),
        e.noiseType === "fbm" &&
          (this.simFeaturesDefinition.USE_FBM_NOISE = !0);
      let t = "";
      for (let [i, r] of Object.entries(this.simFeaturesDefinition))
        r &&
          (t += `#define ${i}
`);
      return t;
    }
    createShape(e, t) {
      this.emitterShape && this.emitterShape.dispose();
      let i = new I(
        Number(
          this.shared.getVariable(e.size[0], [
            this.uuid,
            "particles",
            "shape_size_0",
          ])
        ),
        Number(
          this.shared.getVariable(e.size[1], [
            this.uuid,
            "particles",
            "shape_size_1",
          ])
        ),
        Number(
          this.shared.getVariable(e.size[2], [
            this.uuid,
            "particles",
            "shape_size_2",
          ])
        )
      );
      if (e.type === "MeshEmitterShape") {
        let r = null;
        return (
          this.system.context.scene.traverseEntity((s) => {
            s.uuid === e.fromMeshId && (r = s);
          }),
          r ? new k0(i, t, e.type, r) : new k0(i, t, "SphereEmitterShape")
        );
      } else return new k0(i, t, e.type);
    }
    createPrimaryEmitter(e) {
      let t,
        i = e * e;
      return (
        (t = new tF(new vh(1, 1, 1), this.material, i)),
        this.updateGeometryAttributes(t, e),
        (this.material.needsUpdate = !0),
        (t.onBeforeRender = () => {
          this.applyWorldSpace();
        }),
        t
      );
    }
    getMaxParticlesAmount({
      birthRatePerSecond: e,
      particleMaxLifeTime: t,
      loopDuration: i = 0,
    }) {
      return Math.ceil(e * (t + i));
    }
    dispose() {
      !this.gpuCompute ||
        (this.rootObject?.parent?.remove(this.rootObject),
        this.gpuCompute.dispose(),
        this.material.nodeMaterialDispose(),
        this.emitterShape?.dispose());
    }
    GoEmitSomeParticles(e, t) {
      let i = e - this.lastEmitTime,
        r = 1 / t;
      if (i >= r) {
        let s = Math.max(1, Math.floor(i / r));
        return (
          (this.lastEmitTime = e),
          this.emittedParticlesAmount + s > this.particlesAmount &&
            (this.emittedParticlesAmount = 0),
          (this.emittedParticlesAmount += s),
          s
        );
      }
      return 0;
    }
    checkIfAllParticlesAreDead() {
      return this.lastEmitTime + this.system.data.life + 1 < this.globalTime;
    }
    reset() {
      (this.hasBeenReset = !0),
        (this.lastEmitTime = 0),
        (this.emittedParticlesAmount = 0),
        this.gpuCompute && this.init(yd(this.system.data));
    }
    startEmitting() {
      (this.isEmitting = !0),
        (this.hasBeenReset = !1),
        (this.lastEmitTime = this.globalTime);
    }
    stopEmitting() {
      this.isEmitting = !1;
    }
  },
  Z1 = class extends Is {
    constructor(e, t, i) {
      super(e, t),
        (this.type = "ParticleSystem"),
        (this.geometry = new yt()),
        (this.actualTime = 0),
        (this.currentLoopTime = 0),
        (this.started = !1),
        (this.stopped = !1),
        (this.isFrozen = !1),
        (this.isIdle = !0),
        (this.emitter = null),
        (this.colliderEntities = []),
        (this.renderer = null),
        (this.isPreWarm = !1),
        (this._hasOnAfterRenderBeenCalled = !1),
        (this.onAfterRender = (r) => {
          this._hasOnAfterRenderBeenCalled ||
            ((this._hasOnAfterRenderBeenCalled = !0), this.init(r));
        }),
        (this.context = i),
        (this.data = { ...t, ...yd(t) }),
        this.geometry.setAttribute("position", new ot([], 3)),
        (this.material = new mh({ colorWrite: !1 })),
        (this.frustumCulled = !1);
    }
    init(e) {
      (this.renderer = e),
        (this.emitter = new kZ(e, this)),
        this.add(this.emitter),
        this.updateParticleState(this.data);
    }
    update(e) {
      if (!this.isReady || !this.started || this.isFrozen || this.isIdle)
        return;
      (this.actualTime += e), this.stopped || (this.currentLoopTime += e);
      let t = this.data.emitTimeCycle === "one_time";
      if (
        ((this.data.emitTimeCycle === "loop" || t) &&
          this.currentLoopTime > this.data.emitTimeDuration * 1e3 &&
          (this.stopped ||
            (this.stop(),
            t ||
              this.start(
                this.data.emitTimeLoopDelayStart === "start"
                  ? 0
                  : this.data.emitTimeDelay * 1e3
              ))),
        this.emitter && this.started)
      ) {
        let i = this.actualTime / 1e3;
        this.emitter.update(i, e);
      }
      this.scale.set(1, 1, 1), this.updateMatrix();
    }
    isReady() {
      return !!this.emitter;
    }
    hasCollider(e) {
      return this.colliderEntities.some((t) => t.identity === e);
    }
    getColliderData(e) {
      let t = this.colliderEntities.find((i) => i.identity === e);
      return t ? t.data : null;
    }
    updateByPatchedOp(e, t, i) {
      super.updateByPatchedOp(e, t, i),
        Ii(e.path, ["renderMaterial"]) &&
          this.updateParticleState({
            renderMaterial: {
              ...this.data.renderMaterial,
              ...qr.drop(e, 1).props,
            },
          }),
        Ii(e.path, ["shape"]) &&
          this.updateParticleState({
            shape: { ...this.data.shape, ...qr.drop(e, 1).props },
          });
    }
    updateState(e, t) {
      super.updateState(e, t), this.updateParticleState(e);
    }
    updateParticleState(e) {
      if (this.emitter) {
        if (e.colliderEntityId !== void 0 && e.colliderEntityId !== null) {
          let t = this.context.scene.find(e.colliderEntityId);
          this.colliderEntities = t ? [t] : [];
        }
        e.colliderEntityId === null && (this.colliderEntities = []),
          this.emitter.updateState(e),
          e.emitTimeCycle && this.started && this.start();
      }
    }
    updateFromColliderEntity(e) {
      !this.emitter ||
        (this.emitter.updateForceFieldParameters(e), this.stop(), this.start());
    }
    start(e = 0) {
      if (((this.currentLoopTime = 0), e)) {
        setTimeout(() => {
          this.start(0);
        }, e);
        return;
      }
      (this.started = !0),
        (this.stopped = !1),
        (this.isFrozen = !1),
        this.emitter?.startEmitting();
    }
    froze() {
      this.isFrozen = !0;
    }
    unFroze() {
      this.isFrozen = !1;
    }
    stop() {
      (this.stopped = !0),
        (this.currentLoopTime = 0),
        this.emitter?.stopEmitting();
    }
    reset() {
      (this.started = !1), (this.stopped = !1), this.emitter?.reset();
    }
    wakeUp() {
      this.isIdle = !1;
    }
    sleep() {
      (this.isIdle = !0), this.reset();
    }
  };
function NZ(e, t, i) {
  let r;
  return t.geometry.type === "TextGeometry"
    ? new yP(e, t, i)
    : (t.geometry.type === "SubdivGeometry"
        ? (r = new $d(e, t, i))
        : t.geometry.type === "PathGeometry"
        ? (r = new Ob(e, t, i))
        : t.geometry.type === "VectorGeometry"
        ? (r = new mZ(e, t, i))
        : t.geometry.type === "BooleanGeometry"
        ? (r = new fh(e, t, i))
        : t.geometry.type === "UIGeometry"
        ? (r = new ps(e, t, i))
        : (r = new ms(e, t, i)),
      r);
}
function Rb(e, t, i) {
  return (
    console.assert(t.type !== void 0),
    t.type === "Mesh"
      ? NZ(e, t, i)
      : t.type === "Empty"
      ? new kc(e, t)
      : t.type === "Particle"
      ? new Z1(e, t, i)
      : t.type === "ParticleCollider"
      ? new N1(e, t, i)
      : t.type === "Splat"
      ? new kc(e, t)
      : t.type === "Bone"
      ? new gZ(e, t)
      : t.type === "Page"
      ? new Hr(e, t, i)
      : t.type === "PointLight"
      ? new fZ(e, t, i)
      : t.type === "SpotLight"
      ? new PP(e, t, i)
      : t.type === "DirectionalLight"
      ? new TP(e, t, i)
      : t.type === "Component" || t.type === "Instance"
      ? new Nc(e, t, i)
      : uh.is(t.type)
      ? new vs(e, t)
      : (console.error(t), new kc(e, t))
  );
}
al.createEntity = Rb;
function UZ(e, t, i) {
  let r = Rb(e.identity, t, i),
    s = e.children,
    a = e.attachedPaths,
    n = e.parent,
    o = e.component,
    l = e.instances,
    h = e.overrideData,
    u = e.uuid,
    c = e.stateSelection;
  e.dispose();
  for (let d of Object.keys(e)) delete e[d];
  Object.setPrototypeOf(e, Object.getPrototypeOf(r));
  for (let d of Object.keys(r)) e[d] = r[d];
  (e.children = [...e.children, ...s]),
    (e.attachedPaths = a),
    (e.parent = n),
    (e.component = o),
    (e.instances = l),
    (e.uuid = u),
    (e.overrideData = h),
    e.updateState(e.data, i),
    c && e.changeSelectedState(c, i),
    e.resetBBoxNeedsUpdate();
}
al.changeEntityProptotype = UZ;
al.Cloner = Wa;
function VZ(e, t, i, r) {
  e.updateByOp(t, i, r, !1);
}
function RM(e, t) {
  let i = !1,
    r = t.getLayersOfType("transmission"),
    s = t.getLayersOfType("outline");
  return (
    s.length > 0 &&
      (e.layers.set(8),
      r.length > 0 && e.layers.enable(3),
      (i = !0),
      Ab(e),
      Sb(e)),
    r.length === 0 && s.length === 0 && e.layers.set(0),
    e instanceof yu && e.needsAO && e.layers.enable(5),
    i
  );
}
function LM(e, t) {
  if (!t.layers) return !1;
  let i = !1,
    r = t.getLayersOfType("transmission").filter((a) => a.data.visible),
    s = t.getLayersOfType("outline").filter((a) => a.data.visible);
  return (
    r.length > 0 &&
      (e.layers.set(3), s.length > 0 && e.layers.enable(8), (i = !0)),
    r.length === 0 && s.length === 0 && e.layers.set(0),
    e.needsAO && e.layers.enable(5),
    i
  );
}
function jZ(e) {
  let t = !1;
  return (
    e.traverseEntity((i) => {
      if (i instanceof yu)
        if (Array.isArray(i.material))
          for (let r = 0; r < i.material.length; r++)
            RM(i, i.material[r]) && (t = !0);
        else RM(i, i.material) && (t = !0);
    }),
    t
  );
}
function HZ(e) {
  let t = !1;
  return (
    e.traverseEntity((i) => {
      if (i instanceof yu)
        if (Array.isArray(i.material))
          for (let r = 0; r < i.material.length; r++)
            LM(i, i.material[r]) && (t = !0);
        else LM(i, i.material) && (t = !0);
    }),
    t
  );
}
var GZ = new PC(),
  WZ = new je(),
  qZ = new su();
function K1(e, t, i, r = !1) {
  let s = e.cloner;
  if (s)
    for (let a of s.children) {
      let n = WZ.copy(a.matrixWorld).invert(),
        o = qZ.copy(t.ray).applyMatrix4(n),
        l = e.matrixWorld;
      o.applyMatrix4(l);
      let h = GZ;
      h.set(o.origin, o.direction), (h.near = t.near), (h.far = t.far);
      let u = h.intersectObject(e, !1);
      u.length > 0 && i.push({ ...u[0], object: r ? a : e });
    }
}
var YZ = class {
    constructor() {
      this._constraints = new Map();
    }
    setConstraint(e, t) {
      t === null ? this._constraints.delete(e) : this._constraints.set(e, t);
    }
    removeDependencies(e) {
      this._constraints.delete(e);
    }
    applyConstraints(e) {
      let t = new Set();
      this._constraints.forEach((i, r) => {
        let s = [r, i],
          a = i;
        for (; this._constraints.has(a); )
          (a = this._constraints.get(a)), t.has(a) || s.push(a);
        for (let n = s.length - 2; n >= 0; n--)
          if (!t.has(s[n])) {
            let o = e.find(s[n]);
            o ? o.applyPathSnapping(e) : console.warn(`missing entity ${s[n]}`),
              t.add(s[n]);
          }
      });
    }
    findDependency(e, t) {
      let i = e;
      for (; this._constraints.has(i); )
        if (((i = this._constraints.get(i)), i === t)) return !0;
      return !1;
    }
  },
  dn = Sr(tp()),
  Jn = Sr(ip()),
  or = Sr(tp()),
  Qt = Sr(ip()),
  pg = class {
    constructor(e, t, i) {
      (this._dataNormalized = e), (this._minD = t), (this._maxD = i);
    }
    static createFromUnnormalized(e) {
      let t = Qt.sup(e),
        i = Qt.inf(e),
        r = (0, or.default)(new Float32Array(e.size), e.shape),
        s = t - i;
      return (
        s < 1e-4 ? Qt.assigns(r, 0) : (Qt.subs(r, e, i), Qt.divs(r, r, s)),
        new pg(r, i, t)
      );
    }
    get data() {
      return this._dataNormalized;
    }
    get minD() {
      return this._minD;
    }
    get maxD() {
      return this._maxD;
    }
    denormalize() {
      let e = (0, or.default)(
        new Float32Array(this._dataNormalized.size),
        this._dataNormalized.shape
      );
      return (
        Qt.muls(e, this._dataNormalized, this._maxD - this._minD),
        Qt.adds(e, e, this._minD),
        e
      );
    }
  },
  Wi = class {
    constructor(e, t) {
      (this._quantized = e), (this._method = t);
    }
    get quantized() {
      return this._quantized;
    }
    static maxIntBits(e) {
      return 2 ** e - 1;
    }
    static fromNormalized(e, t) {
      let i = e.data,
        r;
      if (t === "norm8x") {
        let s = Wi.maxIntBits(8),
          a = (0, or.default)(new Float32Array(i.size), i.shape);
        Qt.muls(a, i, s),
          Qt.roundeq(a),
          (r = (0, or.default)(new Uint8Array(a.data), i.shape));
      } else if (t === "norm565") {
        let s = (0, or.default)(new Float32Array(i.size), i.shape);
        Qt.assign(s, i),
          Qt.mulseq(s.pick(null, 0), Wi.maxIntBits(5)),
          Qt.mulseq(s.pick(null, 1), Wi.maxIntBits(6)),
          Qt.mulseq(s.pick(null, 2), Wi.maxIntBits(5)),
          Qt.roundeq(s);
        let a = (0, or.default)(new Uint16Array(s.data), i.shape),
          n = (0, or.default)(new Uint16Array(i.shape[0]), [i.shape[0]]),
          o = (0, or.default)(new Uint16Array(i.shape[0]), [i.shape[0]]);
        Qt.lshifts(n, a.pick(null, 0), 11),
          Qt.lshifts(o, a.pick(null, 1), 5),
          Qt.boreq(n, o),
          Qt.boreq(n, a.pick(null, 2)),
          (r = n);
      } else {
        let s = (0, or.default)(new Float32Array(i.size), i.shape);
        Qt.assign(s, i),
          Qt.mulseq(s.pick(null, 0), Wi.maxIntBits(11)),
          Qt.mulseq(s.pick(null, 1), Wi.maxIntBits(10)),
          Qt.mulseq(s.pick(null, 2), Wi.maxIntBits(11)),
          Qt.roundeq(s);
        let a = (0, or.default)(new Uint32Array(s.data), i.shape),
          n = (0, or.default)(new Uint32Array(i.shape[0]), [i.shape[0]]),
          o = (0, or.default)(new Uint32Array(i.shape[0]), [i.shape[0]]);
        Qt.lshifts(n, a.pick(null, 0), 21),
          Qt.lshifts(o, a.pick(null, 1), 11),
          Qt.boreq(n, o),
          Qt.boreq(n, a.pick(null, 2)),
          (r = n);
      }
      return new Wi(r, t);
    }
    dequantize(e, t) {
      let i = this._method,
        r,
        s = this._quantized;
      if (i === "norm8x") {
        let a = Wi.maxIntBits(8);
        (r = (0, or.default)(new Float32Array(s.size), s.shape)),
          Qt.muls(r, s, 1 / a);
      } else if (i === "norm565") {
        let a = (0, or.default)(new Uint8Array(s.shape[0]), [s.shape[0]]),
          n = (0, or.default)(new Uint8Array(s.shape[0]), [s.shape[0]]),
          o = (0, or.default)(new Uint8Array(s.shape[0]), [s.shape[0]]);
        Qt.rrshifts(a, s, 11),
          Qt.rrshifts(n, s, 5),
          Qt.bandseq(n, Wi.maxIntBits(6)),
          Qt.bands(o, s, Wi.maxIntBits(5)),
          (r = (0, or.default)(new Float32Array(s.shape[0] * 3), [
            s.shape[0],
            3,
          ])),
          Qt.muls(r.pick(null, 0), a, 1 / Wi.maxIntBits(5)),
          Qt.muls(r.pick(null, 1), n, 1 / Wi.maxIntBits(6)),
          Qt.muls(r.pick(null, 2), o, 1 / Wi.maxIntBits(5));
      } else {
        let a = (0, or.default)(new Uint16Array(s.shape[0]), [s.shape[0]]),
          n = (0, or.default)(new Uint16Array(s.shape[0]), [s.shape[0]]),
          o = (0, or.default)(new Uint16Array(s.shape[0]), [s.shape[0]]);
        Qt.rrshifts(a, s, 21),
          Qt.rrshifts(n, s, 11),
          Qt.bandseq(n, Wi.maxIntBits(10)),
          Qt.bands(o, s, Wi.maxIntBits(11)),
          (r = (0, or.default)(new Float32Array(s.shape[0] * 3), [
            s.shape[0],
            3,
          ])),
          Qt.muls(r.pick(null, 0), a, 1 / Wi.maxIntBits(11)),
          Qt.muls(r.pick(null, 1), n, 1 / Wi.maxIntBits(10)),
          Qt.muls(r.pick(null, 2), o, 1 / Wi.maxIntBits(11));
      }
      return new pg(r, e, t);
    }
  },
  Ki = class {
    constructor(e, t, i, r, s, a = !1) {
      (this._quantized = e),
        (this._minMaxMatrix = t),
        (this._chunkSize = i),
        (this._quantizationMethod = r),
        (this._variableChunkSize = s),
        (this._isDynamicChunks = a);
    }
    get length() {
      return this._quantized.shape[0];
    }
    get nchunks() {
      return this._minMaxMatrix.shape[0];
    }
    get quantized() {
      return this._quantized;
    }
    get method() {
      return this._quantizationMethod;
    }
    get minmaxMatrix() {
      return this._minMaxMatrix;
    }
    _createPrunedMinMax(e) {
      let t = e.length,
        i = this.minmaxMatrix.shape[0] - t,
        r = (0, dn.default)(new Float32Array(i * 2), [i, 2]),
        s = 0,
        a = i,
        n = 0,
        o = this.minmaxMatrix.shape[0];
      for (let l = 0; l < e.length; l++)
        (o = e[l]),
          (a = o - n + s),
          a > s &&
            Jn.assign(r.hi(a, 2).lo(s, 0), this.minmaxMatrix.hi(o, 2).lo(n, 0)),
          (s = a),
          (n = o + 1);
      return s < i && Jn.assign(r.lo(s, 0), this.minmaxMatrix.lo(n, 0)), r;
    }
    _createPrunedQuantized(e) {
      let t = e.length,
        i = this.quantized.shape[0] - t,
        r = this._quantizationMethod,
        s,
        a;
      if (r === "norm8x") {
        a = this._quantized.shape[1];
        let u = a ? i * a : i;
        s = (0, dn.default)(new Uint8Array(u), a ? [i, a] : [i, 1]);
      } else
        r === "norm565"
          ? (s = (0, dn.default)(new Uint16Array(i), [i]))
          : (s = (0, dn.default)(new Uint32Array(i), [i]));
      let n = 0,
        o = i,
        l = 0,
        h = s.shape[0];
      for (let u = 0; u < e.length; u++)
        (h = e[u]),
          (o = h - l + n),
          o > n &&
            (a
              ? Jn.assign(
                  s.hi(o, a).lo(n, 0),
                  this._quantized.hi(h, a).lo(l, 0)
                )
              : Jn.assign(s.hi(o).lo(n), this._quantized.hi(h).lo(l))),
          (n = o),
          (l = h + 1);
      return (
        n < i &&
          (a
            ? Jn.assign(s.lo(n, 0), this._quantized.lo(l, 0))
            : Jn.assign(s.lo(n), this._quantized.lo(l))),
        s
      );
    }
    pruneFeature(e, t, i) {
      let r = this._createPrunedQuantized(e),
        s = this._createPrunedMinMax(t);
      return new Ki(r, s, this._chunkSize, this._quantizationMethod, i, !0);
    }
    static getRequiredNChunks(e, t) {
      return Math.floor(e / t);
    }
    static fromArray(e, t, i) {
      let r = e.shape[0],
        s = Math.floor(r / i),
        a = (0, dn.default)(new Float32Array(s * 2), [s, 2], [2, 1]),
        n;
      t === "norm8x"
        ? (n = (0, dn.default)(new Uint8Array(e.size), e.shape))
        : t === "norm565"
        ? (n = (0, dn.default)(new Uint16Array(e.shape[0]), [e.shape[0]]))
        : (n = (0, dn.default)(new Uint32Array(e.shape[0]), [e.shape[0]]));
      for (let o = 0; o < s; o++) {
        let l = o * i,
          h = o + 1 < s ? (o + 1) * i : r,
          u;
        e.shape.length > 1
          ? (u = pg.createFromUnnormalized(e.hi(h, e.shape[1]).lo(l, 0)))
          : (u = pg.createFromUnnormalized(e.hi(h).lo(l))),
          a.set(o, 0, u.minD),
          a.set(o, 1, u.maxD),
          n.shape.length > 1
            ? Jn.assign(
                n.hi(h, n.shape[1]).lo(l, 0),
                Wi.fromNormalized(u, t).quantized
              )
            : Jn.assign(n.hi(h).lo(l), Wi.fromNormalized(u, t).quantized);
      }
      return new Ki(n, a, i, t);
    }
    denormDequant() {
      let e = this._minMaxMatrix.shape[0],
        t = this._quantized,
        i = t.shape[0],
        r = this._quantizationMethod,
        s = this._chunkSize,
        a;
      if (this._isDynamicChunks) {
        if (!this._variableChunkSize)
          throw new Error("variable chunk must exists if chunkSize isDynamic");
        a = this._variableChunkSize;
      }
      let n;
      r === "norm8x"
        ? (n = (0, dn.default)(new Float32Array(t.size), t.shape))
        : (n = (0, dn.default)(new Float32Array(i * 3), [i, 3]));
      let o = 0,
        l = s;
      for (let h = 0; h < e; h++) {
        let [u, c] = [
          this._minMaxMatrix.get(h, 0),
          this._minMaxMatrix.get(h, 1),
        ];
        this._isDynamicChunks && (l = a[h]);
        let d = h + 1 < e ? o + l : i,
          p;
        t.shape.length > 1
          ? (p = new Wi(t.hi(d, t.shape[1]).lo(o, 0), r))
          : (p = new Wi(t.hi(d).lo(o), r)),
          Jn.assign(
            n.hi(d, n.shape[1]).lo(o, 0),
            p.dequantize(u, c).denormalize()
          ),
          (o = d);
      }
      return n;
    }
    static async fetchArrayBuffer(e) {
      return await (await fetch(e, { mode: "cors" })).arrayBuffer();
    }
  },
  Ho = Sr(tp()),
  ni = Sr(ip()),
  XZ = "http://127.0.0.1:8000",
  Uc = Sr(tp()),
  gr = Sr(ip()),
  BM = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
function zM(e) {
  return e < 1e5
    ? e < 100
      ? e < 10
        ? 0
        : 1
      : e < 1e4
      ? e < 1e3
        ? 2
        : 3
      : 4
    : e < 1e7
    ? e < 1e6
      ? 5
      : 6
    : e < 1e9
    ? e < 1e8
      ? 7
      : 8
    : 9;
}
function FM(e, t) {
  if (e === t) return 0;
  if (~~e === e && ~~t === t) {
    if (e === 0 || t === 0) return e < t ? -1 : 1;
    if (e < 0 || t < 0) {
      if (t >= 0) return -1;
      if (e >= 0) return 1;
      (e = -e), (t = -t);
    }
    let s = zM(e),
      a = zM(t),
      n = 0;
    return (
      s < a
        ? ((e *= BM[a - s - 1]), (t /= 10), (n = -1))
        : s > a && ((t *= BM[s - a - 1]), (e /= 10), (n = 1)),
      e === t ? n : e < t ? -1 : 1
    );
  }
  let i = String(e),
    r = String(t);
  return i === r ? 0 : i < r ? -1 : 1;
}
function QZ(e) {
  let t = 0;
  for (; e >= 32; ) (t |= e & 1), (e >>= 1);
  return e + t;
}
function kM(e, t, i, r) {
  let s = t + 1;
  if (s === i) return 1;
  if (r(e[s++], e[t]) < 0) {
    for (; s < i && r(e[s], e[s - 1]) < 0; ) s++;
    ZZ(e, t, s);
  } else for (; s < i && r(e[s], e[s - 1]) >= 0; ) s++;
  return s - t;
}
function ZZ(e, t, i) {
  for (i--; t < i; ) {
    let r = e[t];
    (e[t++] = e[i]), (e[i--] = r);
  }
}
function NM(e, t, i, r, s) {
  for (r === t && r++; r < i; r++) {
    let a = e[r],
      n = t,
      o = r;
    for (; n < o; ) {
      let h = (n + o) >>> 1;
      s(a, e[h]) < 0 ? (o = h) : (n = h + 1);
    }
    let l = r - n;
    switch (l) {
      case 3:
        e[n + 3] = e[n + 2];
      case 2:
        e[n + 2] = e[n + 1];
      case 1:
        e[n + 1] = e[n];
        break;
      default:
        for (; l > 0; ) (e[n + l] = e[n + l - 1]), l--;
    }
    e[n] = a;
  }
}
function U0(e, t, i, r, s, a) {
  let n = 0,
    o = 0,
    l = 1;
  if (a(e, t[i + s]) > 0) {
    for (o = r - s; l < o && a(e, t[i + s + l]) > 0; )
      (n = l), (l = (l << 1) + 1), l <= 0 && (l = o);
    l > o && (l = o), (n += s), (l += s);
  } else {
    for (o = s + 1; l < o && a(e, t[i + s - l]) <= 0; )
      (n = l), (l = (l << 1) + 1), l <= 0 && (l = o);
    l > o && (l = o);
    let h = n;
    (n = s - l), (l = s - h);
  }
  for (n++; n < l; ) {
    let h = n + ((l - n) >>> 1);
    a(e, t[i + h]) > 0 ? (n = h + 1) : (l = h);
  }
  return l;
}
function V0(e, t, i, r, s, a) {
  let n = 0,
    o = 0,
    l = 1;
  if (a(e, t[i + s]) < 0) {
    for (o = s + 1; l < o && a(e, t[i + s - l]) < 0; )
      (n = l), (l = (l << 1) + 1), l <= 0 && (l = o);
    l > o && (l = o);
    let h = n;
    (n = s - l), (l = s - h);
  } else {
    for (o = r - s; l < o && a(e, t[i + s + l]) >= 0; )
      (n = l), (l = (l << 1) + 1), l <= 0 && (l = o);
    l > o && (l = o), (n += s), (l += s);
  }
  for (n++; n < l; ) {
    let h = n + ((l - n) >>> 1);
    a(e, t[i + h]) < 0 ? (l = h) : (n = h + 1);
  }
  return l;
}
var KZ = class {
  constructor(e, t) {
    Es(this, "array", null),
      Es(this, "compare", null),
      Es(this, "minGallop", 7),
      Es(this, "length", 0),
      Es(this, "tmpStorageLength", 256),
      Es(this, "stackLength", 0),
      Es(this, "runStart", null),
      Es(this, "runLength", null),
      Es(this, "stackSize", 0),
      (this.array = e),
      (this.compare = t),
      (this.length = e.length),
      this.length < 2 * 256 && (this.tmpStorageLength = this.length >>> 1),
      (this.tmp = new Array(this.tmpStorageLength)),
      (this.stackLength =
        this.length < 120
          ? 5
          : this.length < 1542
          ? 10
          : this.length < 119151
          ? 19
          : 40),
      (this.runStart = new Array(this.stackLength)),
      (this.runLength = new Array(this.stackLength));
  }
  pushRun(e, t) {
    (this.runStart[this.stackSize] = e),
      (this.runLength[this.stackSize] = t),
      (this.stackSize += 1);
  }
  mergeRuns() {
    for (; this.stackSize > 1; ) {
      let e = this.stackSize - 2;
      if (
        (e >= 1 &&
          this.runLength[e - 1] <= this.runLength[e] + this.runLength[e + 1]) ||
        (e >= 2 &&
          this.runLength[e - 2] <= this.runLength[e] + this.runLength[e - 1])
      )
        this.runLength[e - 1] < this.runLength[e + 1] && e--;
      else if (this.runLength[e] > this.runLength[e + 1]) break;
      this.mergeAt(e);
    }
  }
  forceMergeRuns() {
    for (; this.stackSize > 1; ) {
      let e = this.stackSize - 2;
      e > 0 && this.runLength[e - 1] < this.runLength[e + 1] && e--,
        this.mergeAt(e);
    }
  }
  mergeAt(e) {
    let t = this.compare,
      i = this.array,
      r = this.runStart[e],
      s = this.runLength[e],
      a = this.runStart[e + 1],
      n = this.runLength[e + 1];
    (this.runLength[e] = s + n),
      e === this.stackSize - 3 &&
        ((this.runStart[e + 1] = this.runStart[e + 2]),
        (this.runLength[e + 1] = this.runLength[e + 2])),
      this.stackSize--;
    let o = V0(i[a], i, r, s, 0, t);
    (r += o),
      (s -= o),
      s !== 0 &&
        ((n = U0(i[r + s - 1], i, a, n, n - 1, t)),
        n !== 0 &&
          (s <= n ? this.mergeLow(r, s, a, n) : this.mergeHigh(r, s, a, n)));
  }
  mergeLow(e, t, i, r) {
    let s = this.compare,
      a = this.array,
      n = this.tmp,
      o = 0;
    for (o = 0; o < t; o++) n[o] = a[e + o];
    let l = 0,
      h = i,
      u = e;
    if (((a[u++] = a[h++]), --r === 0)) {
      for (o = 0; o < t; o++) a[u + o] = n[l + o];
      return;
    }
    if (t === 1) {
      for (o = 0; o < r; o++) a[u + o] = a[h + o];
      a[u + r] = n[l];
      return;
    }
    let c = this.minGallop;
    for (;;) {
      let d = 0,
        p = 0,
        f = !1;
      do
        if (s(a[h], n[l]) < 0) {
          if (((a[u++] = a[h++]), p++, (d = 0), --r === 0)) {
            f = !0;
            break;
          }
        } else if (((a[u++] = n[l++]), d++, (p = 0), --t === 1)) {
          f = !0;
          break;
        }
      while ((d | p) < c);
      if (f) break;
      do {
        if (((d = V0(a[h], n, l, t, 0, s)), d !== 0)) {
          for (o = 0; o < d; o++) a[u + o] = n[l + o];
          if (((u += d), (l += d), (t -= d), t <= 1)) {
            f = !0;
            break;
          }
        }
        if (((a[u++] = a[h++]), --r === 0)) {
          f = !0;
          break;
        }
        if (((p = U0(n[l], a, h, r, 0, s)), p !== 0)) {
          for (o = 0; o < p; o++) a[u + o] = a[h + o];
          if (((u += p), (h += p), (r -= p), r === 0)) {
            f = !0;
            break;
          }
        }
        if (((a[u++] = n[l++]), --t === 1)) {
          f = !0;
          break;
        }
        c--;
      } while (d >= 7 || p >= 7);
      if (f) break;
      c < 0 && (c = 0), (c += 2);
    }
    if (((this.minGallop = c), c < 1 && (this.minGallop = 1), t === 1)) {
      for (o = 0; o < r; o++) a[u + o] = a[h + o];
      a[u + r] = n[l];
    } else {
      if (t === 0) throw new Error("mergeLow preconditions were not respected");
      for (o = 0; o < t; o++) a[u + o] = n[l + o];
    }
  }
  mergeHigh(e, t, i, r) {
    let s = this.compare,
      a = this.array,
      n = this.tmp,
      o = 0;
    for (o = 0; o < r; o++) n[o] = a[i + o];
    let l = e + t - 1,
      h = r - 1,
      u = i + r - 1,
      c = 0,
      d = 0;
    if (((a[u--] = a[l--]), --t === 0)) {
      for (c = u - (r - 1), o = 0; o < r; o++) a[c + o] = n[o];
      return;
    }
    if (r === 1) {
      for (u -= t, l -= t, d = u + 1, c = l + 1, o = t - 1; o >= 0; o--)
        a[d + o] = a[c + o];
      a[u] = n[h];
      return;
    }
    let p = this.minGallop;
    for (;;) {
      let f = 0,
        m = 0,
        g = !1;
      do
        if (s(n[h], a[l]) < 0) {
          if (((a[u--] = a[l--]), f++, (m = 0), --t === 0)) {
            g = !0;
            break;
          }
        } else if (((a[u--] = n[h--]), m++, (f = 0), --r === 1)) {
          g = !0;
          break;
        }
      while ((f | m) < p);
      if (g) break;
      do {
        if (((f = t - V0(n[h], a, e, t, t - 1, s)), f !== 0)) {
          for (
            u -= f, l -= f, t -= f, d = u + 1, c = l + 1, o = f - 1;
            o >= 0;
            o--
          )
            a[d + o] = a[c + o];
          if (t === 0) {
            g = !0;
            break;
          }
        }
        if (((a[u--] = n[h--]), --r === 1)) {
          g = !0;
          break;
        }
        if (((m = r - U0(a[l], n, 0, r, r - 1, s)), m !== 0)) {
          for (u -= m, h -= m, r -= m, d = u + 1, c = h + 1, o = 0; o < m; o++)
            a[d + o] = n[c + o];
          if (r <= 1) {
            g = !0;
            break;
          }
        }
        if (((a[u--] = a[l--]), --t === 0)) {
          g = !0;
          break;
        }
        p--;
      } while (f >= 7 || m >= 7);
      if (g) break;
      p < 0 && (p = 0), (p += 2);
    }
    if (((this.minGallop = p), p < 1 && (this.minGallop = 1), r === 1)) {
      for (u -= t, l -= t, d = u + 1, c = l + 1, o = t - 1; o >= 0; o--)
        a[d + o] = a[c + o];
      a[u] = n[h];
    } else {
      if (r === 0)
        throw new Error("mergeHigh preconditions were not respected");
      for (c = u - (r - 1), o = 0; o < r; o++) a[c + o] = n[o];
    }
  }
};
function JZ(e, t, i, r) {
  if (!Array.isArray(e)) throw new TypeError("Can only sort arrays");
  t ? typeof t != "function" && ((r = i), (i = t), (t = FM)) : (t = FM),
    i || (i = 0),
    r || (r = e.length);
  let s = r - i;
  if (s < 2) return;
  let a = 0;
  if (s < 32) {
    (a = kM(e, i, r, t)), NM(e, i, r, i + a, t);
    return;
  }
  let n = new KZ(e, t),
    o = QZ(s);
  do {
    if (((a = kM(e, i, r, t)), a < o)) {
      let l = s;
      l > o && (l = o), NM(e, i, i + l, i + a, t), (a = l);
    }
    n.pushRun(i, a), n.mergeRuns(), (s -= a), (i += a);
  } while (s !== 0);
  n.forceMergeRuns();
}
function j0(e) {
  let t = (0, Uc.default)(new Int32Array(e.shape[0]), [e.shape[0]]),
    i = (0, Uc.default)(new Int32Array(e.shape[0]), [e.shape[0]]);
  return (
    gr.bands(t, e, 1023),
    gr.lshifts(i, t, 16),
    gr.bxoreq(t, i),
    gr.bandseq(t, 4278190335),
    gr.lshifts(i, t, 8),
    gr.bxoreq(t, i),
    gr.bandseq(t, 50393103),
    gr.lshifts(i, t, 4),
    gr.bxoreq(t, i),
    gr.bandseq(t, 51130563),
    gr.lshifts(i, t, 2),
    gr.bxoreq(t, i),
    gr.bandseq(t, 153391689),
    t
  );
}
function $Z(e) {
  let t = j0(e.pick(null, 0)),
    i = j0(e.pick(null, 1));
  gr.lshiftseq(i, 1);
  let r = j0(e.pick(null, 2));
  return gr.lshiftseq(r, 2), gr.boreq(t, i), gr.boreq(t, r), t;
}
function sc(e, t) {
  if (e.shape[0] !== t.shape[0]) throw new Error("wrong length");
  let i = (0, Uc.default)(
    new Float32Array(e.size),
    e.shape,
    e.stride,
    e.offset
  );
  for (let r = 0; r < t.shape[0]; r++) {
    let s = t.get(r);
    if (e.shape.length > 1)
      for (let a = 0; a < e.shape[1]; a++) i.set(r, a, e.get(s, a));
    else i.set(r, e.get(s));
  }
  return i;
}
function eK(e) {
  let t = gr.sup(e),
    i = gr.inf(e),
    r = 1e3 / Math.min(1e3, t - i),
    s = (0, Uc.default)(new Float32Array(e.data), e.shape);
  gr.mulseq(s, r);
  let a = (0, Uc.default)(new Int32Array(s.data), e.shape),
    n = $Z(a),
    o = Array.from(n.data).map((h, u) => [h, u]);
  JZ(o, (h, u) => h[0] - u[0]);
  let l = o.map(([h, u]) => u);
  return (0, Uc.default)(Uint32Array.from(l));
}
var Fl = class {
    constructor(e, t, i, r, s, a, n, o, l, h) {
      (this.propertyDescs = e),
        (this.format = t),
        (this.nsplats = i),
        (this.xyz = r),
        (this.colors = s),
        (this.harmonics = a),
        (this.opacity = n),
        (this.scaling = o),
        (this.rotation = l),
        (this.maxSHDegree = h);
    }
    getPlyBinary() {
      let e = Fl._generateHeaderString(
          this.propertyDescs,
          this.format,
          this.nsplats
        ),
        t = new TextEncoder().encode(e),
        i = Object.keys(this.propertyDescs).length,
        r = (0, Ho.default)(new Float32Array(this.nsplats * i), [
          this.nsplats,
          i,
        ]);
      if (
        (ni.assign(
          r.pick(null, this.propertyDescs.x.index),
          this.xyz.pick(null, 0)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.y.index),
          this.xyz.pick(null, 1)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.z.index),
          this.xyz.pick(null, 2)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.f_dc_0.index),
          this.colors.pick(null, 0)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.f_dc_1.index),
          this.colors.pick(null, 1)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.f_dc_2.index),
          this.colors.pick(null, 2)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.opacity.index),
          this.opacity.pick(null, 0)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.scale_0.index),
          this.scaling.pick(null, 0)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.scale_1.index),
          this.scaling.pick(null, 1)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.scale_2.index),
          this.scaling.pick(null, 2)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.rot_0.index),
          this.rotation.pick(null, 0)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.rot_1.index),
          this.rotation.pick(null, 1)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.rot_2.index),
          this.rotation.pick(null, 2)
        ),
        ni.assign(
          r.pick(null, this.propertyDescs.rot_3.index),
          this.rotation.pick(null, 3)
        ),
        this.harmonics && this.harmonics.length > 0)
      )
        for (let n = 0; n < this.harmonics.length; n++) {
          let o = n * 3;
          ni.assign(
            r.pick(null, this.propertyDescs[`f_rest_${o}`].index),
            this.harmonics[n].pick(null, 0)
          ),
            ni.assign(
              r.pick(null, this.propertyDescs[`f_rest_${o + 1}`].index),
              this.harmonics[n].pick(null, 1)
            ),
            ni.assign(
              r.pick(null, this.propertyDescs[`f_rest_${o + 2}`].index),
              this.harmonics[n].pick(null, 2)
            );
        }
      let s = new Uint8Array(r.data.buffer),
        a = new Uint8Array(s.length + t.length);
      return a.set(t), a.set(s, t.length), a.buffer;
    }
    save(e, t) {
      let i = this.getPlyBinary(),
        r = new Blob([i], { type: "application/octet-stream" }),
        s = new File([r], e),
        a = new FormData();
      a.append("file", s),
        a.append("filename", e),
        a.append("basedir", t),
        fetch(`${XZ}/push_file`, { method: "POST", body: a });
    }
    static async loadFile(e) {
      return await (await fetch(e)).arrayBuffer();
    }
    mortonPositionSplatsSort() {
      let e = eK(this.xyz),
        t = sc(this.xyz, e),
        i = sc(this.colors, e),
        r = sc(this.opacity, e),
        s = sc(this.scaling, e),
        a = sc(this.rotation, e),
        n = [];
      for (let o = 0; o < this.harmonics.length; o++)
        n.push(sc(this.harmonics[o], e));
      return new Fl(
        this.propertyDescs,
        this.format,
        this.nsplats,
        t,
        i,
        n,
        r,
        s,
        a,
        this.maxSHDegree
      );
    }
    static _generateHeaderString(e, t, i) {
      let r = `ply
format ${t.format} ${t.version}
element vertex ${i}`,
        s = Object.keys(e).length,
        a = Array(s);
      for (let n in e) {
        let o = e[n];
        a[o.index] = { name: n, dtype: o.dtype };
      }
      for (let n = 0; n < a.length; n++)
        r = `${r}
property ${a[n].dtype} ${a[n].name}`;
      return `${r}
end_header
`;
    }
    static fromArrayBuffer(e, t = 3) {
      let {
          splatCount: i,
          vertexData: r,
          propertiesDesc: s,
          format: a,
        } = Fl.decodeHeader(e),
        n = r.buffer.slice(r.byteOffset),
        o = Object.keys(s).length,
        l = (0, Ho.default)(new Float32Array(n), [i, o]),
        h = 0,
        u = {},
        c = {
          double: 8,
          int: 4,
          uint: 4,
          float: 4,
          short: 2,
          ushort: 2,
          uchar: 1,
        };
      for (let b in s)
        if (s.hasOwnProperty(b)) {
          let _ = s[b].dtype;
          (u[b] = h), (h += c[_]);
        }
      let d = (0, Ho.default)(new Float32Array(i * 3), [i, 3]);
      ni.assign(d.pick(null, 0), l.pick(null, u.x / 4)),
        ni.assign(d.pick(null, 1), l.pick(null, u.y / 4)),
        ni.assign(d.pick(null, 2), l.pick(null, u.z / 4));
      let p = (0, Ho.default)(new Float32Array(i * 3), [i, 3]);
      ni.assign(p.pick(null, 0), l.pick(null, u.scale_0 / 4)),
        ni.assign(p.pick(null, 1), l.pick(null, u.scale_1 / 4)),
        ni.assign(p.pick(null, 2), l.pick(null, u.scale_2 / 4));
      let f = (0, Ho.default)(new Float32Array(i * 3), [i, 3]);
      ni.assign(f.pick(null, 0), l.pick(null, u.f_dc_0 / 4)),
        ni.assign(f.pick(null, 1), l.pick(null, u.f_dc_1 / 4)),
        ni.assign(f.pick(null, 2), l.pick(null, u.f_dc_2 / 4));
      let m = (0, Ho.default)(new Float32Array(i * 4), [i, 4]);
      ni.assign(m.pick(null, 0), l.pick(null, u.rot_1 / 4)),
        ni.assign(m.pick(null, 1), l.pick(null, u.rot_2 / 4)),
        ni.assign(m.pick(null, 2), l.pick(null, u.rot_3 / 4)),
        ni.assign(m.pick(null, 3), l.pick(null, u.rot_0 / 4));
      for (let b = 0; b < i; b++) {
        let _ = m.pick(b, null),
          S = Math.sqrt(
            _.get(0) ** 2 + _.get(1) ** 2 + _.get(2) ** 2 + _.get(3) ** 2
          );
        ni.divseq(_, S);
      }
      let g = (0, Ho.default)(new Float32Array(i * 1), [i, 1]);
      ni.assign(g.pick(null, 0), l.pick(null, u.opacity / 4));
      let y = (Math.min(Math.max(t, 0), 3) + 1) ** 2 - 1,
        x = [];
      for (let b = 0; b < y; b++) {
        let _ = (0, Ho.default)(new Float32Array(i * 3), [i, 3]),
          S = b * 3;
        ni.assign(_.pick(null, 0), l.pick(null, u[`f_rest_${S}`] / 4)),
          ni.assign(_.pick(null, 1), l.pick(null, u[`f_rest_${S + 1}`] / 4)),
          ni.assign(_.pick(null, 2), l.pick(null, u[`f_rest_${S + 2}`] / 4)),
          x.push(_);
      }
      return new Fl(s, a, i, d, f, x, g, p, m, t);
    }
    static async fromPLYFile(e, t = 3) {
      let i = await Fl.loadFile(e);
      return Fl.fromArrayBuffer(i, t);
    }
    static decodeHeader(e) {
      let t = new TextDecoder(),
        i = 0,
        r = "",
        s = 100;
      for (;;) {
        if (i + s >= e.byteLength)
          throw new Error(
            "End of file reached while searching for end of header"
          );
        let p = new Uint8Array(e, i, s);
        (r += t.decode(p)), (i += s);
        let f = i - s * 2,
          m = new Uint8Array(e, Math.max(0, f), f > 0 ? s * 2 : s);
        if (t.decode(m).includes("end_header")) break;
      }
      let a = r.split(`
`),
        n = 0,
        o = {},
        l = {},
        h = 0,
        u;
      for (let p = 0; p < a.length; p++) {
        let f = a[p].trim();
        if (f.startsWith("element vertex")) {
          let m = f.match(/\d+/);
          m && (n = parseInt(m[0]));
        } else if (f.startsWith("property")) {
          let m = f.match(/(\w+)\s+(\w+)\s+(\w+)/);
          if (m) {
            let g = m[2],
              y = m[3];
            (o[y] = h), (l[y] = { dtype: g, index: h }), h++;
          }
        } else if (f.startsWith("format")) {
          let m = f.match(/(\w+)\s+(\w+)\s+(\d+\.?\d*)/);
          m && (u = { format: m[2], version: m[3] });
        } else if (f === "end_header") break;
      }
      let c = r.indexOf("end_header") + 10 + 1,
        d = new DataView(e, c);
      return {
        splatCount: n,
        vertexData: d,
        headerOffset: i,
        propertiesDesc: l,
        format: u,
      };
    }
  },
  J1 = class {
    constructor(e, t, i, r, s, a, n, o) {
      (this.config = e),
        (this.xyz = t),
        (this.scaling = i),
        (this.color = r),
        (this.opacity = s),
        (this.harmonics = n),
        (this.quaternion = a),
        (this.variableChunkSize = o);
    }
    get isDynamicChunks() {
      return this.variableChunkSize && this.variableChunkSize.length > 0;
    }
    get nchunks() {
      return this.xyz.nchunks;
    }
    get nsplats() {
      return this.xyz.length;
    }
    get chunkSize() {
      return this.config.chunkSize;
    }
    static compressFromGaussianData(e, t) {
      let i = Ki.fromArray(e.xyz, t.xyz, t.chunkSize),
        r = Ki.fromArray(e.scaling, t.scaling, t.chunkSize),
        s = Ki.fromArray(e.colors, t.color, t.chunkSize),
        a = Ki.fromArray(e.opacity, t.opacity, t.chunkSize),
        n = Ki.fromArray(e.rotation, t.quaternion, t.chunkSize),
        o = e.harmonics,
        l = [];
      if (t.harmonics)
        for (let h = 0; h < o.length; h++) {
          let u = Ki.fromArray(o[h], t.harmonics, t.chunkSize);
          l.push(u);
        }
      return new J1(t, i, r, s, a, n, l);
    }
    _countIndexesInChunks(e) {
      let t = [],
        i = this.nchunks,
        r = this.chunkSize,
        s = this.nsplats,
        a = Ki.getRequiredNChunks(s, r);
      if (i === a)
        for (let n = 0; n < e.length; n++) {
          let o = e[n],
            l = Math.floor(o / this.chunkSize);
          l in t ? t[l].push(o) : (t[l] = [o]);
        }
      else {
        let n = this.variableChunkSize,
          o = {},
          l = 0;
        for (let h = 0; h < i; h++) (o[h] = l), (l += n[h]);
        for (let h = 0; h < e.length; h++) {
          let u = e[h],
            c = Math.min(Math.floor(u / r), i - 1);
          for (; u >= o[c] + n[c]; ) c++;
          c in t ? t[c].push(u) : (t[c] = [u]);
        }
      }
      return t;
    }
    pruneSplats(e) {
      let t = this._countIndexesInChunks(e),
        i,
        r = [];
      return (
        t.length > 0 &&
          ((i = this.variableChunkSize
            ? [...this.variableChunkSize]
            : Array(this.nchunks).fill(this.chunkSize)),
          t.forEach((s, a) => {
            (i[a] -= s.length), i[a] <= 0 && r.push(a);
          }),
          (i = i.filter((s) => s > 0))),
        new J1(
          this.config,
          this.xyz.pruneFeature(e, r, i),
          this.scaling.pruneFeature(e, r, i),
          this.color.pruneFeature(e, r, i),
          this.opacity.pruneFeature(e, r, i),
          this.quaternion.pruneFeature(e, r, i),
          this.harmonics
            ? this.harmonics.map((s) =>
                s.pruneFeature(e, r, this.variableChunkSize)
              )
            : void 0,
          i
        )
      );
    }
    static async loadConfig(e) {
      return await (
        await fetch(e, {
          method: "GET",
          mode: "cors",
          headers: { Accept: "application/json" },
        })
      ).json();
    }
    toGaussians() {
      let e = { format: "binary_little_endian", version: "1.0" },
        t = {},
        i = 0;
      if (
        ((t.x = { dtype: "float", index: i }),
        i++,
        (t.y = { dtype: "float", index: i }),
        i++,
        (t.z = { dtype: "float", index: i }),
        i++,
        (t.f_dc_0 = { dtype: "float", index: i }),
        i++,
        (t.f_dc_1 = { dtype: "float", index: i }),
        i++,
        (t.f_dc_2 = { dtype: "float", index: i }),
        i++,
        this.harmonics && this.harmonics.length > 0)
      )
        for (let s = 0; s < this.harmonics.length; s++)
          (t[`f_rest_${s}`] = { dtype: "float", index: i }),
            i++,
            (t[`f_rest_${s + 1}`] = { dtype: "float", index: i }),
            i++,
            (t[`f_rest_${s + 2}`] = { dtype: "float", index: i }),
            i++;
      (t.opacity = { dtype: "float", index: i }),
        i++,
        (t.scale_0 = { dtype: "float", index: i }),
        i++,
        (t.scale_1 = { dtype: "float", index: i }),
        i++,
        (t.scale_2 = { dtype: "float", index: i }),
        i++,
        (t.rot_0 = { dtype: "float", index: i }),
        i++,
        (t.rot_1 = { dtype: "float", index: i }),
        i++,
        (t.rot_2 = { dtype: "float", index: i }),
        i++,
        (t.rot_3 = { dtype: "float", index: i }),
        i++;
      let r = this.harmonics?.map((s) => s.denormDequant());
      return new Fl(
        t,
        e,
        this.xyz.length,
        this.xyz.denormDequant(),
        this.color.denormDequant(),
        r || [],
        this.opacity.denormDequant(),
        this.scaling.denormDequant(),
        this.quaternion.denormDequant(),
        3
      );
    }
  },
  ac = Sr(tp()),
  pa = Sr(ip()),
  UM = {
    xyz: 3,
    color: 3,
    opacity: 1,
    scaling: 3,
    quaternion: 4,
    harmonics: 3,
  },
  $1 = class {
    constructor(e) {
      this._buffer = e;
    }
    get buffer() {
      return this._buffer;
    }
    get decoded() {
      return (
        this._decoded || (this._decoded = this.decodeBuffer()), this._decoded
      );
    }
    get colorsA() {
      let e = 0.28209479177387814,
        t = this.decoded.color.denormDequant(),
        i = this.decoded.opacity.denormDequant(),
        r = (0, ac.default)(new Float32Array(t.shape[0] * 4), [t.shape[0], 4]);
      return (
        pa.mulseq(t, e),
        pa.addseq(t, 0.5),
        pa.mulseq(t, 255),
        pa.maxseq(t, 0),
        pa.minseq(t, 255),
        pa.negeq(i),
        pa.expeq(i),
        pa.addseq(i, 1),
        pa.recipeq(i),
        pa.mulseq(i, 255),
        pa.assign(r.hi(t.shape[0], 3).lo(0, 0), t),
        pa.assign(r.hi(t.shape[0], 4).lo(0, 3), i),
        (0, ac.default)(new Uint8Array(r.data), [t.shape[0], 4]).data
      );
    }
    get nsplats() {
      return this.decoded.nsplats;
    }
    getSplatCount() {
      return this.decoded.nsplats;
    }
    get precomputedCovarianceBufferData() {
      return this._precomputedCovarianceBufferData;
    }
    decodeBuffer() {
      let {
          splatCount: e,
          chunkCount: t,
          chunkSize: i,
          typeChunks: r,
          vertexData: s,
          propertiesDesc: a,
        } = this.decodeHeader(),
        n = {
          xyz: a.xyz.compressionMethod,
          color: a.color.compressionMethod,
          opacity: a.opacity.compressionMethod,
          scaling: a.scaling.compressionMethod,
          quaternion: a.quaternion.compressionMethod,
          chunkSize: i,
        };
      a.harmonics_0 && (n.harmonics = a.harmonics_0.compressionMethod);
      let o = s.byteOffset,
        l = Array(Object.keys(a).length);
      for (let g in a)
        l[a[g].index] = { name: g, method: a[g].compressionMethod };
      let h = t * 2 * 4,
        u = o,
        c = r === "dynamic" ? t * 2 : 0,
        d,
        p = !1;
      if (c > 0) {
        let g = new Uint16Array(s.buffer.slice(u, u + c));
        (u += c), (d = Array.from(g)), (p = !0);
      }
      let f = {};
      for (let g of l) {
        let y = 0,
          x = !0;
        if (g.method === "norm8x") y = e * 1 * UM[g.name];
        else if (g.method === "norm11") y = e * 4;
        else if (g.method === "norm565") y = e * 2;
        else throw ((x = !1), new Error(`Not Implemented format: ${g.method}`));
        let b;
        if (x) {
          let M = s.buffer.slice(u, u + h);
          (b = (0, ac.default)(new Float32Array(M), [t, 2])), (u += h);
        } else throw new Error("loading chunk byt hasnot minmax!");
        let _ = s.buffer.slice(u, u + y);
        u += y;
        let S;
        if (g.method === "norm8x")
          S = (0, ac.default)(new Uint8Array(_), [e, UM[g.name]]);
        else if (g.method === "norm11") S = (0, ac.default)(new Uint32Array(_));
        else if (g.method === "norm565")
          S = (0, ac.default)(new Uint16Array(_));
        else throw new Error(`Not Implemented format: ${g.method}`);
        f[g.name] = new Ki(S, b, i, g.method, d, p);
      }
      let m = [];
      for (let g = 0; g < 15; g++) {
        let y = f[`harmonics_${g}`];
        y && (m.push(y), delete f[`harmonics_${g}`]);
      }
      return (
        m.length > 0 && (f.harmonics = m),
        new J1(
          n,
          f.xyz,
          f.scaling,
          f.color,
          f.opacity,
          f.quaternion,
          f.harmonics,
          d
        )
      );
    }
    buildPreComputedBuffers() {
      let e = this.decoded,
        t = e.nsplats,
        i = new ArrayBuffer(24 * t),
        r = new Float32Array(i),
        s = e.scaling.denormDequant(),
        a = e.quaternion.denormDequant(),
        n = new Rt(),
        o = new lr(),
        l = new lr(),
        h = new lr(),
        u = new je();
      for (let c = 0; c < t; c++) {
        u.makeScale(
          Math.exp(s.get(c, 0)),
          Math.exp(s.get(c, 1)),
          Math.exp(s.get(c, 2))
        ),
          l.setFromMatrix4(u),
          n.set(a.get(c, 0), a.get(c, 1), a.get(c, 2), a.get(c, 3)),
          u.makeRotationFromQuaternion(n),
          o.setFromMatrix4(u),
          h.copy(o).multiply(l);
        let d = h.elements;
        (r[6 * c] = d[0] * d[0] + d[3] * d[3] + d[6] * d[6]),
          (r[6 * c + 1] = d[0] * d[1] + d[3] * d[4] + d[6] * d[7]),
          (r[6 * c + 2] = d[0] * d[2] + d[3] * d[5] + d[6] * d[8]),
          (r[6 * c + 3] = d[1] * d[1] + d[4] * d[4] + d[7] * d[7]),
          (r[6 * c + 4] = d[1] * d[2] + d[4] * d[5] + d[7] * d[8]),
          (r[6 * c + 5] = d[2] * d[2] + d[5] * d[5] + d[8] * d[8]);
      }
      this._precomputedCovarianceBufferData = i;
    }
    decodeHeader() {
      let e = this._buffer,
        t = new TextDecoder(),
        i = 0,
        r = "",
        s = 100;
      for (;;) {
        if (i + s >= e.byteLength)
          throw new Error(
            "End of file reached while searching for end of header"
          );
        let f = new Uint8Array(e, i, s);
        (r += t.decode(f)), (i += s);
        let m = i - s * 2,
          g = new Uint8Array(e, Math.max(0, m), m >= 0 ? s * 2 : s);
        if (t.decode(g).includes("end_header")) break;
      }
      let a = r.split(`
`),
        n = 0,
        o = 0,
        l = 0,
        h = 0,
        u = "",
        c = {};
      for (let f = 0; f < a.length; f++) {
        let m = a[f].trim();
        if (m.startsWith("element vertex")) {
          let g = m.match(/\d+/);
          g && (n = parseInt(g[0]));
        } else if (m.startsWith("property")) {
          let g = m.match(/(\w+)\s+(\w+)\s+(\w+)/);
          if (g) {
            let y = g[2],
              x = g[3];
            (c[y] = { compressionMethod: x, index: h }), h++;
          }
        } else if (m.startsWith("element chunks")) {
          let g = m.match(/\d+/);
          g && (o = parseInt(g[0]));
        } else if (m.startsWith("element chunkSize")) {
          let g = m.match(/\d+/);
          g && (l = parseInt(g[0]));
        } else if (m.startsWith("element typeChunks")) {
          let g = m.match(/(\w+)\s+(\w+)\s+(\w+)/);
          g && (u = g[3]);
        } else if (m === "end_header") break;
      }
      let d = r.indexOf("end_header") + 10 + 1,
        p = new DataView(e, d);
      return {
        splatCount: n,
        chunkCount: o,
        chunkSize: l,
        typeChunks: u,
        vertexData: p,
        propertiesDesc: c,
      };
    }
    pruneSplats(e) {
      let t = this.decodeBuffer().pruneSplats(e);
      return $1.fromCompressedGaussianSplats(t);
    }
    static fromCompressedGaussianSplats(e) {
      let t = e.xyz.length,
        i = e.xyz.nchunks,
        r = `gspline
element vertex ${t}
element chunks ${i}
element chunkSize ${e.chunkSize}
element typeChunks ${e.isDynamicChunks ? "dynamic" : "static"}
property xyz ${e.xyz.method}
property color ${e.color.method}
property opacity ${e.opacity.method}
property scaling ${e.scaling.method}
property quaternion ${e.quaternion.method}`;
      if (e.harmonics && e.harmonics.length > 0)
        for (let C = 0; C < e.harmonics.length; C++)
          r = `${r}
property harmonics_${C} ${e.harmonics[C].method}`;
      r = `${r}
end_header
`;
      let s = new TextEncoder().encode(r),
        a = i * 2 * 4,
        n = e.xyz.quantized.data.buffer.byteLength,
        o = e.xyz instanceof Ki ? a : 0,
        l = e.color.quantized.data.buffer.byteLength,
        h = e.color instanceof Ki ? a : 0,
        u = e.opacity.quantized.data.buffer.byteLength,
        c = e.opacity instanceof Ki ? a : 0,
        d = e.scaling.quantized.data.buffer.byteLength,
        p = e.scaling instanceof Ki ? a : 0,
        f = e.quaternion.quantized.data.buffer.byteLength,
        m = e.quaternion instanceof Ki ? a : 0,
        g = e.variableChunkSize
          ? Uint16Array.from(e.variableChunkSize)
          : void 0,
        y = g ? g.byteLength : 0,
        x = s.byteLength + y + n + o + l + h + u + c + d + p + f + m,
        b = 0,
        _ = 0;
      if (e.harmonics && e.harmonics.length > 0)
        for (let C = 0; C < e.harmonics.length; C++)
          (b += e.harmonics[C].quantized.data.buffer.byteLength),
            (_ += e.harmonics[C] instanceof Ki ? a : 0);
      (b = 0), (_ = 0), (x += b + _);
      let S = new Uint8Array(x),
        M = 0;
      if (
        (S.set(s, M),
        (M += s.byteLength),
        y > 0 && (S.set(new Uint8Array(g.buffer), M), (M += y)),
        e.xyz instanceof Ki &&
          (S.set(new Uint8Array(e.xyz.minmaxMatrix.data.buffer), M), (M += a)),
        S.set(new Uint8Array(e.xyz.quantized.data.buffer), M),
        (M += n),
        e.color instanceof Ki &&
          (S.set(new Uint8Array(e.color.minmaxMatrix.data.buffer), M),
          (M += a)),
        S.set(new Uint8Array(e.color.quantized.data.buffer), M),
        (M += l),
        e.opacity instanceof Ki &&
          (S.set(new Uint8Array(e.opacity.minmaxMatrix.data.buffer), M),
          (M += a)),
        S.set(new Uint8Array(e.opacity.quantized.data.buffer), M),
        (M += u),
        e.scaling instanceof Ki &&
          (S.set(new Uint8Array(e.scaling.minmaxMatrix.data.buffer), M),
          (M += a)),
        S.set(new Uint8Array(e.scaling.quantized.data.buffer), M),
        (M += d),
        e.quaternion instanceof Ki &&
          (S.set(new Uint8Array(e.quaternion.minmaxMatrix.data.buffer), M),
          (M += a)),
        S.set(new Uint8Array(e.quaternion.quantized.data.buffer), M),
        (M += f),
        b > 0 && e.harmonics && e.harmonics.length > 0)
      )
        for (let C = 0; C < e.harmonics.length; C++) {
          let A = e.harmonics[C];
          A instanceof Ki &&
            (S.set(new Uint8Array(A.minmaxMatrix.data.buffer), M), (M += a)),
            S.set(new Uint8Array(A.quantized.data.buffer), M),
            (M += A.quantized.data.byteLength);
        }
      return new $1(S.buffer);
    }
  },
  tK =
    "AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAETA2AAAGAIf39/f39/f38AYAABfwISAQNlbnYGbWVtb3J5AgMAgIAEAwQDAAECBzkDEV9fd2FzbV9jYWxsX2N0b3JzAAALc29ydEluZGV4ZXMAARNlbXNjcmlwdGVuX3Rsc19pbml0AAIK3gMDAwABC9IDAwF/BnwBfgJAIAdFDQAgAysDUCEMIAMrAzAhDSADKwMQIQ5BACEDRP///////+9/IQtEAAAAAAAAEAAhCgNAIAIgA0ECdGoCfyAOIAEgA0EMbGoiCCoCALuiIA0gCCoCBLuioCAMIAgqAgi7oqBEAAAAAAAAsECiIgmZRAAAAAAAAOBBYwRAIAmqDAELQYCAgIB4CzYCACAJIAsgCSALYxshCyAJIAogCSAKZBshCiADQQFqIgMgB0cNAAsgB0UNACAGuCAKIAuhoyEJQQAhAwNAAn8gCSACIANBAnRqIgEoAgC3IAuhoiIKmUQAAAAAAADgQWMEQCAKqgwBC0GAgICAeAshCCABIAg2AgAgBCAIQQJ0aiIBIAEoAgBBAWo2AgAgA0EBaiIDIAdHDQALCyAGQQJPBEAgBCgCACEIQQEhAwNAIAQgA0ECdGoiASABKAIAIAhqIgg2AgAgA0EBaiIDIAZHDQALCyAHQQFrIgGtIQ8DQCAEIAIgD6dBAnQiA2ooAgBBAnRqIgcgBygCAEEBayIHNgIAIAUgASAHa0ECdGogACADaigCADYCACAPUCEDIA9CAX0hDyADRQ0ACyAGBEAgBEEAIAZBAnT8CwALCwQAQQAL",
  ol = class {};
Es(ol, "DepthMapRange", 1 << 16),
  Es(ol, "MemoryPageSize", 65536),
  Es(ol, "BytesPerFloat", 4),
  Es(ol, "BytesPerInt", 4);
function iK(e) {
  let t, i, r, s, a, n, o, l, h, u, c, d, p, f, m, g;
  function y(R) {
    let z = new Float64Array(u, n, 16);
    for (let L = 0; L < 16; L++) z[L] = R[L];
    let N;
    if (r > 1) {
      t.exports.sortIndexes(s, a, h, n, o, l, d.DepthMapRange, r);
      let L = new Uint32Array(r);
      (N = L.buffer), L.set(new Uint32Array(u, l, r));
    } else if (r === 1) {
      let L = new Uint32Array(r);
      (L[0] = new Uint32Array(u, s, i)[0]), (N = L.buffer);
    } else N = new ArrayBuffer(0);
    e.postMessage({ sortDone: !0, indexesBuffer: N }, [N]);
  }
  function x(R, z, N) {
    let L = new Float32Array(u, a, i * 3);
    r = 0;
    let G = new Uint32Array(u, s, i);
    for (let Y = 0; Y < N.length - 1; Y++) {
      let Z = z[Y],
        q = R[Y].elements,
        oe = Z.filter((ie) => ie.enabled && ie.mode === "Include").map((ie) =>
          ie.type === "Box" ? M(ie) : T(ie)
        ),
        ce = Z.filter((ie) => ie.enabled && ie.mode === "Exclude").map((ie) =>
          ie.type === "Box" ? M(ie) : T(ie)
        );
      for (let ie = N[Y]; ie < N[Y + 1]; ie++) {
        let te = p[ie * 3],
          ue = p[ie * 3 + 1],
          ae = p[ie * 3 + 2];
        if (
          (oe.length === 0 || _(te, ue, ae, oe)) &&
          (ce.length === 0 || !_(te, ue, ae, ce))
        ) {
          let de = 1 / (q[3] * te + q[7] * ue + q[11] * ae + q[15]);
          (L[r * 3] = (q[0] * te + q[4] * ue + q[8] * ae + q[12]) * de),
            (L[r * 3 + 1] = (q[1] * te + q[5] * ue + q[9] * ae + q[13]) * de),
            (L[r * 3 + 2] = (q[2] * te + q[6] * ue + q[10] * ae + q[14]) * de),
            (G[r] = ie),
            r++;
        }
      }
    }
  }
  function b(R, z) {
    let N = [],
      L = z
        .filter((Z) => Z.enabled && Z.mode === "Include")
        .map((Z) => (Z.type === "Box" ? M(Z) : T(Z))),
      G = z
        .filter((Z) => Z.enabled && Z.mode === "Exclude")
        .map((Z) => (Z.type === "Box" ? M(Z) : T(Z))),
      Y = R.length;
    for (let Z = 0; Z < Y; Z += 3) {
      let q = R[Z],
        oe = R[Z + 1],
        ce = R[Z + 2];
      ((L.length === 0 || _(q, oe, ce, L)) &&
        (G.length === 0 || !_(q, oe, ce, G))) ||
        N.push(Z / 3);
    }
    return console.log(N), N;
  }
  function _(R, z, N, L, G) {
    return L[G === "Intersect" ? "every" : "some"]((Y) => {
      let Z = S(R, z, N, Y.invRotationMatrix, Y.cropCenter);
      return Array.isArray(Y) ? A(Z.x, Z.y, Z.z, Y) : P(Z.x, Z.y, Z.z, Y);
    });
  }
  function S(R, z, N, L, G) {
    let Y = R - G[0],
      Z = z - G[1],
      q = N - G[2],
      oe = 1 / (L[3] * Y + L[7] * Z + L[11] * q + L[15]);
    return {
      x: (L[0] * Y + L[4] * Z + L[8] * q + L[12]) * oe + G[0],
      y: (L[1] * Y + L[5] * Z + L[9] * q + L[13]) * oe + G[1],
      z: (L[2] * Y + L[6] * Z + L[10] * q + L[14]) * oe + G[2],
    };
  }
  function M(R) {
    let z = R.cropSize[0] / 2,
      N = R.cropSize[1] / 2,
      L = R.cropSize[2] / 2,
      G = [
        R.cropCenter[0] - z,
        R.cropCenter[1] - N,
        R.cropCenter[2] - L,
        R.cropCenter[0] + z,
        R.cropCenter[1] + N,
        R.cropCenter[2] + L,
      ],
      Y = C(R.cropRotation);
    return Object.assign(G, { invRotationMatrix: Y, cropCenter: R.cropCenter });
  }
  function C(R) {
    let z = [],
      N = (R[0] * Math.PI) / 180,
      L = (R[1] * Math.PI) / 180,
      G = (R[2] * Math.PI) / 180,
      Y = Math.cos(N),
      Z = Math.sin(N),
      q = Math.cos(L),
      oe = Math.sin(L),
      ce = Math.cos(G),
      ie = Math.sin(G),
      te = Y * ce,
      ue = Y * ie,
      ae = Z * ce,
      de = Z * ie;
    return (
      (z[0] = q * ce),
      (z[1] = -q * ie),
      (z[2] = oe),
      (z[4] = ue + ae * oe),
      (z[5] = te - de * oe),
      (z[6] = -Z * q),
      (z[8] = de - te * oe),
      (z[9] = ae + ue * oe),
      (z[10] = Y * q),
      (z[12] = 0),
      (z[13] = 0),
      (z[14] = 0),
      (z[3] = 0),
      (z[7] = 0),
      (z[11] = 0),
      (z[15] = 1),
      z
    );
  }
  function A(R, z, N, L) {
    return (
      R >= L[0] && R <= L[3] && z >= L[1] && z <= L[4] && N >= L[2] && N <= L[5]
    );
  }
  function T(R) {
    let z = 2 / R.cropSize[0],
      N = 2 / R.cropSize[1],
      L = 2 / R.cropSize[2],
      G = C(R.cropRotation);
    return {
      invRadiusX: z,
      invRadiusY: N,
      invRadiusZ: L,
      cropCenter: R.cropCenter,
      invRotationMatrix: G,
    };
  }
  function P(R, z, N, L) {
    let G = (R - L.cropCenter[0]) * L.invRadiusX,
      Y = (z - L.cropCenter[1]) * L.invRadiusY,
      Z = (N - L.cropCenter[2]) * L.invRadiusZ;
    return G * G + Y * Y + Z * Z <= 1;
  }
  e.onmessage = (R) => {
    if (R.data.getCroppedIndexes) {
      let z = new Uint32Array(
        b(new Float32Array(R.data.positions), R.data.crops)
      ).buffer;
      e.postMessage({ outOfBoundsIndexes: z }, [z]);
    } else if (R.data.positions)
      (c = R.data.positions),
        (p = new Float32Array(c)),
        (m = R.data.meshMatrixWorlds),
        (g = R.data.cropsArray),
        (f = R.data.meshIndexIntervals),
        x(m, g, f),
        e.postMessage({ sortSetupComplete: !0 });
    else if (R.data.sort || R.data.newMatrixWorlds || R.data.newCropsArray)
      (R.data.newMatrixWorlds || R.data.newCropsArray) &&
        ((g = R.data.newCropsArray || g),
        (m = R.data.newMatrixWorlds || m),
        x(m, g, f)),
        y(R.data.sort.view, R.data.sort.cameraPosition);
    else if (R.data.init) {
      (d = R.data.init.Constants), (i = R.data.init.splatCount);
      let z = d.BytesPerInt,
        N = d.BytesPerFloat * 3,
        L = new Uint8Array(R.data.init.sorterWasmBytes),
        G = z + N,
        Y = i * G,
        Z = i * d.BytesPerInt * 2 + d.DepthMapRange * d.BytesPerInt * 2,
        q = d.MemoryPageSize * 32,
        oe = Y + Z + q,
        ce = Math.floor(oe / d.MemoryPageSize) + 1,
        ie = {
          module: {},
          env: {
            memory: new WebAssembly.Memory({
              initial: ce * 2,
              maximum: ce * 3,
              shared: !0,
            }),
          },
        };
      WebAssembly.compile(L)
        .then((te) => WebAssembly.instantiate(te, ie))
        .then((te) => {
          (t = te),
            (s = 0),
            (a = i * z),
            (n = a + i * N),
            (h = n + 16 * d.BytesPerFloat * 2),
            (o = h + i * d.BytesPerInt),
            (l = o + d.DepthMapRange * d.BytesPerInt),
            (u = ie.env.memory.buffer),
            e.postMessage({ sortSetupPhase1Complete: !0 });
        });
    }
  };
}
function rK(e) {
  let t = new Worker(
      URL.createObjectURL(
        new Blob(["(", iK.toString(), ")(self)"], {
          type: "application/javascript",
        })
      )
    ),
    i = atob(tK),
    r = new Uint8Array(i.length);
  for (let s = 0; s < i.length; s++) r[s] = i.charCodeAt(s);
  return (
    t.postMessage({
      init: {
        sorterWasmBytes: r.buffer,
        splatCount: e,
        Constants: {
          BytesPerFloat: ol.BytesPerFloat,
          BytesPerInt: ol.BytesPerInt,
          DepthMapRange: ol.DepthMapRange,
          MemoryPageSize: ol.MemoryPageSize,
        },
      },
    }),
    t
  );
}
var H0 = (function () {
    let e = new Float32Array(1),
      t = new Int32Array(e.buffer);
    return function (i) {
      return (e[0] = i), t[0];
    };
  })(),
  sK = function (e, t, i, r) {
    return e + (t << 8) + (i << 16) + (r << 24);
  },
  Kf = new re(),
  um = class extends br {
    constructor(e, t, i, r, s = !1, a = 1, n, o) {
      super(i, r),
        (this.splatCount = t),
        (this.meshIndexIntervals = n),
        (this.meshMatrixWorlds = o),
        (this.splatBuffers = e),
        (this.geometry = i),
        (this.material = r),
        (this.splatDataTextures = null),
        (this.halfPrecisionCovariancesOnGPU = s),
        (this.devicePixelRatio = a),
        this.resetLocalSplatDataAndTexturesFromSplatBuffer();
    }
    static buildMesh(e, t, i = !1, r = 1, s, a) {
      let n = um.buildGeomtery(t),
        o = um.buildMaterial(s);
      return new um(e, t, n, o, i, r, s, a);
    }
    static buildMaterial(e) {
      let t = `
            precision highp float;
            #include <common>

            attribute uint splatIndex;

            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D centersColorsTexture;
            uniform vec2 focal;
            uniform vec2 viewport;
            uniform vec2 basisViewport;
            uniform vec2 covariancesTextureSize;
            uniform vec2 centersColorsTextureSize;
						uniform highp sampler2D meshMatrixWorldsTexture;
						uniform uint meshIndexIntervals[257];
						uniform float orthoZoom;

            varying vec4 vColor;
            varying vec2 vUv;

            varying vec2 vPosition;

            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
            const uvec4 shift4 = uvec4(0, 8, 16, 24);
            vec4 uintToRGBAVec (uint u) {
               uvec4 urgba = mask4 & u;
               urgba = urgba >> shift4;
               vec4 rgba = vec4(urgba) * encodeNorm4;
               return rgba;
            }

            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
                vec2 samplerUV = vec2(0.0, 0.0);
                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
                samplerUV.y = float(floor(d)) / dimensions.y;
                samplerUV.x = fract(d);
                return samplerUV;
            }

            void main () {
                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));
                vColor = uintToRGBAVec(sampledCenterColor.r);

                vPosition = position.xy * 2.0;

								uint meshIndex;
								for (int i = 1; i < 257; i++) {
									if (splatIndex < meshIndexIntervals[i]) {
										meshIndex = uint(i - 1);
										break;
									}
								}

								float strideMulmeshIndex = float(4u*meshIndex);
								float meshMatrixWorldsTextureLength = float(256*4);

								mat4 modelMat = mat4(
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+0.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+1.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+2.0)/meshMatrixWorldsTextureLength, 0)),
									texture(meshMatrixWorldsTexture, vec2((strideMulmeshIndex+3.0)/meshMatrixWorldsTextureLength, 0))
								);
								mat4 modelViewMat = viewMatrix * modelMat;
								vec4 viewCenter = modelViewMat * vec4(splatCenter, 1.0); 
                vec4 clipCenter = projectionMatrix * viewCenter;

                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;
                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;
                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;

                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);
                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);

                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix
                mat3 Vrk = mat3(
                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
                );
                float s = 1.0 / (viewCenter.z * viewCenter.z);

                mat3 W = transpose(mat3(modelViewMat));
                mat3 T = orthoZoom > 0.0 ? W : W * mat3(
									focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
									0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
									0., 0., 0.
								);
                mat3 cov2Dm = transpose(T) * Vrk * T;
                cov2Dm[0][0] += 0.3;
                cov2Dm[1][1] += 0.3;

                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
                // need cov2Dm[1][0] because it is a symetric matrix.
                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
                // so that we can determine the 2D basis for the splat. This is done using the method described
                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
                //
                // This is a different approach than in the original work at INRIA. In that work they compute the
                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle
                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance
                // matrix (called 'conic') to determine fragment opacity.
                float a = cov2Dv.x;
                float d = cov2Dv.z;
                float b = cov2Dv.y;
                float D = a * d - b * b;
                float trace = a + d;
                float traceOver2 = 0.5 * trace;
                float term2 = sqrt(trace * trace / 4.0 - D);
                float eigenValue1 = traceOver2 + term2;
								float eigenValue2 = max(traceOver2 - term2, 0.00); // prevent negative eigen value

                const float maxSplatSize = 1024.0;
                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
                // since the eigen vectors are orthogonal, we derive the second one from the first
                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);
                vec2 basisVector1 = eigenVector1 * min(sqrt(2.0 * eigenValue1), maxSplatSize);
                vec2 basisVector2 = eigenVector2 * min(sqrt(2.0 * eigenValue2), maxSplatSize);

                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport;

								if (orthoZoom > 0.0) {
									ndcOffset *= orthoZoom;
								}

                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            }`,
        i = `
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;

            varying vec2 vPosition;
						layout(location = 1) out vec4 gVelocity; 

            void main () {
                // compute the negative squared distance from the center of the splat to the
                // current fragment in the splat's local space.
                float A = -dot(vPosition, vPosition);
                if (A < -4.0) discard;
                vec3 color = vColor.rgb;
                A = exp(A) * vColor.a;
                gl_FragColor = vec4(color.rgb, A);
								gVelocity = vec4(0.0); // so it is ignored by TAA
            }`,
        r = {
          covariancesTexture: { type: "t", value: null },
          centersColorsTexture: { type: "t", value: null },
          meshIndexIntervals: { value: e },
          meshMatrixWorldsTexture: { type: "t", value: null },
          focal: { type: "v2", value: new re() },
          viewport: { type: "v2", value: new re() },
          basisViewport: { type: "v2", value: new re() },
          debugColor: { type: "v3", value: new Et() },
          covariancesTextureSize: { type: "v2", value: new re(1024, 1024) },
          centersColorsTextureSize: { type: "v2", value: new re(1024, 1024) },
          orthoZoom: { type: "f", value: -1 },
        };
      return new vi({
        uniforms: r,
        vertexShader: t,
        fragmentShader: i,
        transparent: !0,
        alphaTest: 1,
        blending: Jl,
        depthTest: !0,
        depthWrite: !1,
        side: js,
      });
    }
    static buildGeomtery(e) {
      let t = new yt();
      t.setIndex([0, 1, 2, 0, 2, 3]);
      let i = new Float32Array(4 * 3),
        r = new It(i, 3);
      t.setAttribute("position", r),
        r.setXYZ(0, -1, -1, 0),
        r.setXYZ(1, -1, 1, 0),
        r.setXYZ(2, 1, 1, 0),
        r.setXYZ(3, 1, -1, 0),
        (r.needsUpdate = !0);
      let s = new CC().copy(t),
        a = new Uint32Array(e),
        n = new Ld(a, 1, !1);
      return (
        n.setUsage(UI),
        s.setAttribute("splatIndex", n),
        (s.instanceCount = e),
        s
      );
    }
    resetLocalSplatDataAndTexturesFromSplatBuffer() {
      this.updateLocalSplatDataFromSplatBuffer(),
        this.allocateAndStoreLocalSplatDataInTextures();
    }
    updateLocalSplatDataFromSplatBuffer() {
      this.splatBuffers.forEach((r) => r.buildPreComputedBuffers()),
        (this.covariances = new Float32Array(this.splatCount * 6)),
        (this.colors = new Uint8Array(this.splatCount * 4)),
        (this.centers = new Float32Array(this.splatCount * 3));
      let e = 0,
        t = 0,
        i = 0;
      for (let r of this.splatBuffers) {
        let s = r.nsplats;
        this.colors.subarray(e, e + s * 4).set(r.colorsA),
          (e += s * 4),
          this.centers
            .subarray(t, t + s * 3)
            .set(r.decoded.xyz.denormDequant().data),
          (t += s * 3),
          this.covariances
            .subarray(i, i + s * 6)
            .set(new Float32Array(r.precomputedCovarianceBufferData)),
          (i += s * 6);
      }
    }
    allocateAndStoreLocalSplatDataInTextures() {
      let e = this.splatCount,
        t = new re(4096, 1024);
      for (; t.x * t.y * 2 < e * 6; ) t.y *= 2;
      let i = new re(4096, 1024);
      for (; i.x * i.y * 4 < e * 4; ) i.y *= 2;
      let r, s;
      if (this.halfPrecisionCovariancesOnGPU) {
        s = new Uint16Array(t.x * t.y * 2);
        for (let u = 0; u < this.covariances.length; u++)
          s[u] = gk.toHalfFloat(this.covariances[u]);
        r = new Sa(s, t.x, t.y, gm, lh);
      } else
        (s = new Float32Array(t.x * t.y * 2)),
          s.set(this.covariances),
          (r = new Sa(s, t.x, t.y, gm, xr));
      (r.needsUpdate = !0),
        (this.material.uniforms.covariancesTexture.value = r),
        this.material.uniforms.covariancesTextureSize.value.copy(t);
      let a = new Uint32Array(i.x * i.y * 4);
      for (let u = 0; u < e; u++) {
        let c = u * 4,
          d = u * 3,
          p = u * 4;
        (a[p] = sK(
          this.colors[c],
          this.colors[c + 1],
          this.colors[c + 2],
          this.colors[c + 3]
        )),
          (a[p + 1] = H0(this.centers[d])),
          (a[p + 2] = H0(this.centers[d + 1])),
          (a[p + 3] = H0(this.centers[d + 2]));
      }
      let n = new Sa(a, i.x, i.y, GE, go);
      (n.internalFormat = "RGBA32UI"),
        (n.needsUpdate = !0),
        (this.material.uniforms.centersColorsTexture.value = n),
        this.material.uniforms.centersColorsTextureSize.value.copy(i);
      let o = 256 * 4,
        l = new Float32Array(256 * 16);
      for (let u = 0; u < this.meshMatrixWorlds.length; u++)
        l.set(this.meshMatrixWorlds[u].elements, u * 16);
      let h = new Sa(l, o, 1, Wr, xr);
      (h.needsUpdate = !0),
        (this.material.uniforms.meshMatrixWorldsTexture.value = h),
        (this.material.uniformsNeedUpdate = !0),
        (this.splatDataTextures = {
          covariances: { data: s, texture: r, size: t },
          centerColors: { data: a, texture: n, size: i },
          meshMatrixWorlds: { data: l, texture: h },
        });
    }
    updateIndexes(e) {
      let t = this.geometry;
      t.attributes.splatIndex.set(e),
        (t.attributes.splatIndex.needsUpdate = !0),
        (t.instanceCount = e.length);
    }
    updateUniforms(e, t, i, r) {
      this.splatCount > 0 &&
        (Kf.set(e.x * this.devicePixelRatio, e.y * this.devicePixelRatio),
        this.material.uniforms.viewport.value.copy(Kf),
        this.material.uniforms.basisViewport.value.set(2 / Kf.x, 2 / Kf.y),
        this.material.uniforms.focal.value.set(t, i),
        (this.material.uniforms.orthoZoom.value = r),
        (this.material.uniformsNeedUpdate = !0));
    }
    getSplatDataTextures() {
      return this.splatDataTextures;
    }
    getSplatCount() {
      return this.splatCount;
    }
    getCenters() {
      return this.centers;
    }
    getColors() {
      return this.colors;
    }
    getCovariances() {
      return this.covariances;
    }
    dispose() {
      this.geometry.dispose(),
        this.material.dispose(),
        this.splatDataTextures &&
          (this.splatDataTextures.covariances.texture.dispose(),
          this.splatDataTextures.centerColors.texture.dispose(),
          this.splatDataTextures.meshMatrixWorlds.texture.dispose());
    }
  },
  aK = class {
    constructor(e = {}) {
      Es(
        this,
        "updateSplatMeshUniforms",
        (function () {
          let t = new re();
          return function () {
            this.splatMesh !== null &&
              this.splatMesh.getSplatCount() > 0 &&
              (this.renderer.getSize(t),
              (this.cameraFocalLengthX =
                this.camera.projectionMatrix.elements[0] *
                this.devicePixelRatio *
                t.x *
                0.45),
              (this.cameraFocalLengthY =
                this.camera.projectionMatrix.elements[5] *
                this.devicePixelRatio *
                t.y *
                0.45),
              this.splatMesh.updateUniforms(
                t,
                this.cameraFocalLengthX,
                this.cameraFocalLengthY,
                this.camera.isPerspectiveCamera
                  ? -1
                  : this.camera.zoom * this.devicePixelRatio
              ));
          };
        })()
      ),
        Es(
          this,
          "updateView",
          (function () {
            let t = new je(),
              i = [],
              r = new I(0, 0, -1),
              s = new I(0, 0, -1),
              a = new I(),
              n = new I();
            return function (o = !1) {
              let l = this.updateMatrixWorldsInWorkerIfNeeded(),
                h = this.cropsChanged();
              if (!o) {
                s.set(0, 0, -1).applyQuaternion(this.camera.quaternion);
                let c = !1,
                  d = !1;
                if (
                  (s.dot(r) <= 0.95 && (c = !0),
                  n.copy(this.camera.position).sub(a).length() >= 1 && (d = !0),
                  !c && !d && !l && !h)
                )
                  return;
              }
              a.copy(this.camera.position),
                r.copy(s),
                t.copy(this.camera.matrixWorld).invert(),
                t.premultiply(this.camera.perspCamera.projectionMatrix),
                (i[0] = this.camera.position.x),
                (i[1] = this.camera.position.y),
                (i[2] = this.camera.position.z);
              let u = {
                sort: {
                  view: t.elements,
                  cameraPosition: i,
                  splatRenderCount: this.splatRenderCount,
                  splatSortCount: this.splatRenderCount,
                },
                ...(l ? { newMatrixWorlds: this.meshMatrixWorlds } : {}),
                ...(h ? { newCropsArray: this.cropsArray } : {}),
              };
              this.sortRunning
                ? (this.queuedMessage = u)
                : ((this.queuedMessage = null),
                  (this.sortRunning = !0),
                  this.sortWorker.postMessage(u));
            };
          })()
        ),
        (this.scene = e.scene),
        (this.currentPage = null),
        (this.renderer = e.renderer),
        (this.devicePixelRatio = window.devicePixelRatio),
        (this.sortWorker = null),
        (this.splatRenderCount = 0),
        (this.splatSortCount = 0),
        (this.splatMesh = null),
        (this.sortRunning = !1),
        (this.splatRenderingInitialized = !1),
        (this.meshMatrixWorlds = null),
        (this.meshMatrixWorldsOld = null),
        (this.cropsArray = null),
        (this.splatEntries = null),
        (this.queuedMessage = null);
    }
    get camera() {
      return this.scene.activeCamera;
    }
    reloadSplats() {
      this.splatRenderingInitialized = !1;
      let e = this.loadSplat();
      this.renderer.pipeline.opaquePass.splatViewer = e ? this : null;
    }
    loadSplat(e = {}) {
      (this.activePage = this.scene.activePage),
        e.position && (e.position = new I().fromArray(e.position)),
        e.orientation && (e.orientation = new Rt().fromArray(e.orientation)),
        (e.halfPrecisionCovariances = !!e.halfPrecisionCovariances);
      let t = [];
      if (
        ((this.splatEntries = t),
        this.activePage.traverseEntity((a) => {
          if (a.data.type === "Splat") {
            let n = a.visible;
            a.traverseAncestors((o) => {
              n && (n = o.visible);
            }),
              n && t.push(a);
          }
        }),
        this.splatMesh && this.splatMesh.dispose(),
        t.length === 0)
      )
        return (this.splatMesh = null), !1;
      (this.meshMatrixWorlds = t.map((a) => a.matrixWorld)),
        (this.meshMatrixWorldsOld = t.map((a) => a.matrixWorld.clone())),
        (this.cropsArray = t.map((a) => a.data.crops.map((n) => n.data)));
      let i = t.map((a) => new $1(new Uint8Array(a.data.buffer).buffer)),
        r = 0,
        s = [0];
      for (let a of i) (r += a.getSplatCount()), s.push(r);
      return (
        this.setupSplatMesh(
          i,
          r,
          e.position,
          e.orientation,
          e.halfPrecisionCovariances,
          this.devicePixelRatio,
          s,
          this.meshMatrixWorlds
        ),
        this.setupSortWorker(r),
        !0
      );
    }
    updateMatrixWorldsInWorkerIfNeeded() {
      let e = this.splatDataTextures.meshMatrixWorlds.data;
      for (let t = 0; t < this.meshMatrixWorlds.length; t++)
        e.set(this.meshMatrixWorlds[t].elements, t * 16);
      return (
        (this.splatDataTextures.meshMatrixWorlds.texture.needsUpdate = !0),
        this.meshMatrixWorlds.every((t, i) =>
          t.equals(this.meshMatrixWorldsOld[i])
        )
          ? !1
          : ((this.meshMatrixWorldsOld = this.meshMatrixWorlds.map((t) =>
              t.clone()
            )),
            !0)
      );
    }
    cropsChanged() {
      let e = !1;
      return (
        this.splatEntries.forEach((t, i) => {
          t.data.crops.forEach((r, s) => {
            this.cropsArray[i][s] === void 0
              ? ((e = !0), (this.cropsArray[i][s] = r.data))
              : Object.entries(r.data).forEach(([a, n]) => {
                  Array.isArray(n) &&
                  n.some((o, l) => o !== this.cropsArray[i][s][a][l])
                    ? ((e = !0), (this.cropsArray[i][s][a] = n))
                    : n !== this.cropsArray[i][s]?.[a] &&
                      ((e = !0), (this.cropsArray[i][s][a] = n));
                });
          }),
            t.data.crops.length !== this.cropsArray[i]?.length &&
              ((this.cropsArray[i].length = t.data.crops.length), (e = !0));
        }),
        e
      );
    }
    setupSplatMesh(e, t, i = new I(), r = new Rt(), s = !1, a = 1, n, o) {
      (this.splatMesh = um.buildMesh(e, t, s, a, n, o)),
        this.splatMesh.position.copy(i),
        this.splatMesh.quaternion.copy(r),
        (this.splatMesh.frustumCulled = !1),
        (this.splatMesh.renderOrder = 10),
        this.updateSplatMeshUniforms(),
        (this.splatRenderCount = t);
    }
    setupSortWorker(e) {
      (this.sortWorker = rK(e)),
        (this.sortWorker.onmessage = (t) => {
          t.data.sortDone
            ? ((this.sortRunning = !1),
              this.splatMesh?.updateIndexes(
                new Uint32Array(t.data.indexesBuffer)
              ),
              (this.lastSortTime = t.data.sortTime),
              this.queuedMessage &&
                (this.sortWorker.postMessage(this.queuedMessage),
                (this.queuedMessage = null)))
            : t.data.sortCanceled
            ? (this.sortRunning = !1)
            : t.data.sortSetupPhase1Complete
            ? this.sortWorker.postMessage({
                positions: this.splatMesh.getCenters().buffer,
                meshMatrixWorlds: this.splatMesh.meshMatrixWorlds,
                meshIndexIntervals: this.splatMesh.meshIndexIntervals,
                cropsArray: this.cropsArray,
              })
            : t.data.sortSetupComplete &&
              ((this.splatDataTextures = this.splatMesh.getSplatDataTextures()),
              this.updateView(!0, !0),
              (this.splatRenderingInitialized = !0));
        });
    }
    update() {
      this.splatRenderingInitialized !== !1 &&
        (this.updateSplatMeshUniforms(), this.updateView());
    }
    getSplatMesh() {
      return this.splatMesh;
    }
  },
  ex = new mh();
ex.wireframe = !0;
var VM = new I(),
  Lb = class extends xo {
    constructor(e, t) {
      super(),
        (this.data = e),
        (this.sharedAssets = t),
        (this.enableHelpers = !1),
        (this.wireframeState = !1),
        (this.needsTransmissionDirty = !0),
        (this.needsNormalDirty = !0),
        (this._needsTransmission = !1),
        (this._needsNormal = !1),
        (this.geometryCacheChanged = !1),
        (this.splatViewer = null),
        (this.entityByUuid = {}),
        (this.entityIdentityToEntity = {}),
        (this.toExpandCloner = new Set()),
        (this.toUpdateCloner = new Set()),
        (this.pendingCommands = []),
        (this.pathConstraints = new YZ()),
        (this.invisibleObjects = new kc("jflkdsafjasdifjaslk", {
          ...o1.defaultData,
          visible: !1,
          name: "buildin invisible",
        })),
        (this.needsRecomputeInstances = !1),
        this.init(e, t),
        (this.matrixAutoUpdate = !1),
        (this.errorPage = new Hr(
          "fdasfa",
          { ...$c.defaultData, name: "" },
          { shared: t, scene: this }
        ));
    }
    markGeometryCacheDirty() {
      this.geometryCacheChanged = !0;
    }
    markNeedsUpdateRendererDirty() {
      (this.needsTransmissionDirty = !0), (this.needsNormalDirty = !0);
    }
    needsTransmission() {
      return (
        this.needsTransmissionDirty &&
          ((this._needsTransmission = HZ(this)),
          (this.needsTransmissionDirty = !1)),
        this._needsTransmission
      );
    }
    needsNormal() {
      return (
        this.needsNormalDirty &&
          ((this._needsNormal = jZ(this)), (this.needsNormalDirty = !1)),
        this._needsNormal
      );
    }
    registerInstanceAndSetUuid(e) {
      let t = e.identity.join("-"),
        i = this.entityIdentityToEntity[t];
      i && (e.uuid = i.uuid),
        (this.entityIdentityToEntity[t] = e),
        (this.entityByUuid[e.uuid] = e);
    }
    markPenumbraSizeDirty() {
      for (let e of this.children)
        e instanceof Hr && (e.penumbraSizeArrayCache = null);
    }
    findInstance(e) {
      return this.entityIdentityToEntity[e.join("-")];
    }
    get bgColor() {
      return this.activePage.bgColor;
    }
    get postprocessing() {
      return this.activePage.data.postprocessing;
    }
    getWithSortKey(e) {
      let t = this.find(e);
      if (t === void 0) return;
      let i = [],
        r = t;
      for (; r !== this; ) {
        let s = r;
        r = r.parent;
        let a = r.children.indexOf(s);
        i.splice(0, 0, a);
      }
      return { entity: t, sortKey: i };
    }
    getAllSorted(e) {
      let t = [];
      for (let i of e) {
        let r = this.getWithSortKey(i.id);
        r !== void 0 && t.push(r);
      }
      return t.sort((i, r) => mT(i.sortKey, r.sortKey)), t.map((i) => i.entity);
    }
    nonExistOrDescendantOf(e, t) {
      let i = this.find(e);
      if (i === void 0) return !0;
      for (; i; ) {
        if (i.uuid === t) return !0;
        i = i.parent;
      }
      return !1;
    }
    find(e) {
      if (this.activePage && this.activePage.personalCamera.parent) {
        if (e === "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera")
          return this.activePage.personalCamera;
        if (e === mu) return this.activePage.personalCamera;
      }
      if (e === "" || e === void 0) return;
      let t = this.entityByUuid[e];
      return t === void 0 ? this.getObjectByProperty("uuid", e) : t;
    }
    find2D(e) {
      for (let t of this.children)
        if (t instanceof Hr && t.uiScene) {
          let i = t.uiScene.find(e);
          if (i) return i;
        }
    }
    findScene2DfromObject2D(e) {
      for (let t of this.children)
        if (t instanceof Hr && t.uiScene && t.uiScene.find(e)) return t.uiScene;
    }
    find2DInUIObjects(e) {
      let t;
      return (
        this.traverseEntity((i) => {
          t === void 0 && i instanceof ps && (t = i.uiCanvas.find(e));
        }),
        t
      );
    }
    traverse2D(e) {
      for (let t of this.children)
        t instanceof Hr && t.uiScene && t.uiScene.traverse(e);
    }
    debugEnsureEntity(e) {
      let t = this.find(e);
      if (t) {
        if (
          Array.isArray(t.identity) &&
          this.findInstance(t.identity) === void 0
        ) {
          console.error("not found instance");
          debugger;
        }
      } else {
        console.error("not found");
        debugger;
      }
    }
    addPendingExpandCloner(e) {
      this.toExpandCloner.add(e);
    }
    addPendingUpdateCloner(e) {
      this.toUpdateCloner.add(e);
    }
    markToExpandCloner(e) {
      this.toExpandCloner.add(e),
        e.traverseEntityAncestors((t) => {
          this.toExpandCloner.add(t);
        });
    }
    doPendingExpandCloner() {
      this.toExpandCloner.forEach((e) => {
        e.expandCloner(this);
      }),
        this.toExpandCloner.clear();
    }
    doPendingUpdateCloner() {
      this.toUpdateCloner.forEach((e) => {
        e.cloner?.update();
      }),
        this.toUpdateCloner.clear();
    }
    doPendingUpdates() {
      this.doPendingExpandCloner(),
        this.doPendingUpdateCloner(),
        this.applyPendingCommands();
    }
    addPendingCommand(e) {
      this.pendingCommands.push(e);
    }
    applyPendingCommands() {
      this.pendingCommands.forEach((e) => e()),
        (this.pendingCommands.length = 0);
    }
    updateByLibOp(e, t) {
      e.path.length === 1 &&
        e.path[0] === "components" &&
        e.type === 1 &&
        this.createChildrenObjects(
          [{ ...e.data.asset, id: e.id }],
          this.invisibleObjects,
          t
        );
    }
    updateTreeByOp(e, t) {
      if (e.path.length === 0 && e.type === 7) {
        let i = e.parent === null ? this : this.find(e.parent);
        if (i === void 0) throw new Error("unexpected");
        let r = this.createObject(e.id, e.data, e.children, i, e.localIndex, t);
        r.updateVisible(this),
          r.resetBBoxNeedsUpdate(),
          ja(r) &&
            yo(r.parent) &&
            (r.invalidateUpstreamBooleanData(),
            r.parent.invalidateDownstreamBooleanData().recomputeBoolean()),
          this.markNeedsRecomputeInstancesForAncessors(i),
          this.markNeedsRecomputeInstancesForChildren(r),
          this.markToExpandCloner(r),
          this.markPenumbraSizeDirty(),
          r.updatePathSnapping();
      } else if (e.path.length === 0 && e.type === 8) {
        let i = this.find(e.id);
        if (i === void 0) throw new Error("unexpected");
        this.markToExpandCloner(i),
          i.resetBBoxNeedsUpdate(),
          this.unregisterObject(i);
        let r = i.parent;
        this.markNeedsRecomputeInstancesForAncessors(r),
          this.markNeedsRecomputeInstancesForChildren(i),
          this.markPenumbraSizeDirty(),
          i.parent.remove(i),
          yo(i.parent) &&
            (i.parent.invalidateUpstreamBooleanData(),
            i.parent.invalidateDownstreamBooleanData().recomputeBoolean()),
          ja(i) &&
            (i.freeBooleanPointer(),
            r instanceof fh &&
              r.invalidateDownstreamBooleanData().recomputeBoolean()),
          i instanceof Ob && i.detachShape(),
          this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(i),
          this.pathConstraints.removeDependencies(i.uuid),
          i.updatePathSnapping();
      } else if (e.path.length === 0 && e.type === 9) {
        let i = this.find(e.id);
        if (i === void 0) throw new Error("unexpected");
        this.markNeedsRecomputeInstancesForChildren(i);
        let r = i.parent;
        this.markNeedsRecomputeInstancesForAncessors(r),
          i.cloner?.resetOnMove(),
          this.markToExpandCloner(i);
        let s = e.parent === null ? this : this.find(e.parent);
        if (s === void 0) throw new Error("unexpected");
        s.add(i),
          this.markNeedsRecomputeInstancesForAncessors(s),
          this.markToExpandCloner(i),
          i.invalidateClonerTransform(i),
          i.updateVisible(this),
          i.resetBBoxNeedsUpdate(),
          this.markPenumbraSizeDirty();
        let a = e.localIndex;
        s.children.splice(a, 0, s.children.pop()),
          ja(i) &&
            (i.invalidateUpstreamBooleanData(),
            yo(i.parent)
              ? i.parent.invalidateDownstreamBooleanData().recomputeBoolean()
              : r instanceof fh &&
                r.invalidateDownstreamBooleanData().recomputeBoolean()),
          i.updatePathSnapping();
      }
      this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty();
    }
    get playPage() {
      return this.find(this.data.publish.playPage) ?? this.errorPage;
    }
    updatePage(e) {
      this.activePage && this.activePage.onDeactive(),
        (this.activePage = this.errorPage);
      for (let t of this.children)
        t instanceof Hr &&
          ((t.visible = t.uuid === e),
          t.visible && ((this.activePage = t), this.activePage.onActive(this)));
      this.activePage !== this.splatViewer?.activePage && this.reloadSplats();
    }
    updateEntityByOp(e, t, i, r) {
      if (t.type === 0) {
        if (
          (("overrides" in t.props || "component" in t.props) &&
            this.markNeedsRecomputeInstances(),
          "visible" in t.props && this.markPenumbraSizeDirty(),
          t.path.includes("overrides") && "states" in t.props)
        ) {
          let { rest: a } = t.props;
          (t = { ...t, props: a }), this.markNeedsRecomputeInstances();
        }
        t.path[0] === "pathSnapping" &&
          t.props.pathId !== void 0 &&
          this.pathConstraints.setConstraint(e, t.props.pathId);
      }
      let s = this.find(e);
      if (s)
        try {
          VZ(s, t, i, { scene: this, shared: r }),
            s instanceof ms && s.updateGeometryGroupsIfNeeded();
        } catch (a) {
          console.error(a);
        }
    }
    updateEntity2DByOp(e, t, i, r, s, a = []) {
      e.updateEntityByOp(t, i, r, s),
        this.traverseEntity((n) => {
          (n instanceof ps || n instanceof Hr) &&
            (a.includes(n.frameId ?? "") || n.frameId === t) &&
            n.updateEntity2DByOp(t, i, r, s);
        });
    }
    get activeCamera() {
      return this.activePage.activeCamera;
    }
    switchActiveCamera(e) {
      this.activePage.switchActiveCamera(e);
    }
    isInvisibleObjects(e) {
      return (
        e === this.invisibleObjects || e.hasAnccestor(this.invisibleObjects)
      );
    }
    init(e, t) {
      let i = Object.entries(t.data.lib.components).map((r, s) => ({
        data: r[1].asset.data,
        children: r[1].asset.children,
        id: r[0],
        fi: s,
      }));
      this.invisibleObjects.updateState(this.invisibleObjects.data, {
        scene: this,
        shared: t,
      }),
        this.add(this.invisibleObjects),
        this.createChildrenObjects(i, this.invisibleObjects, t),
        this.createChildrenObjects(e.objects, this, t),
        this.updatePage(e.publish.playPage),
        this.activePage.switchToPlayCamera(),
        this.expandInstances(t, !0),
        this.traverseEntity((r) => {
          r instanceof vs && r.updateUp();
        }),
        this.doPendingExpandCloner(),
        this.applyPendingCommands();
    }
    markNeedsRecomputeInstances() {
      this.needsRecomputeInstances = !0;
    }
    markNeedsRecomputeInstancesForChildren(e) {
      e.traverseEntity((t) => {
        (t.data.type === "Component" || t.data.type === "Instance") &&
          this.markNeedsRecomputeInstances();
      });
    }
    markNeedsRecomputeInstancesForAncessors(e) {
      si.is(e) &&
        (e.data.type === "Component" && this.markNeedsRecomputeInstances(),
        e.traverseAncestors((t) => {
          si.is(t) &&
            t.data.type === "Component" &&
            this.markNeedsRecomputeInstances();
        }));
    }
    relativeizeInner(e, t, i, r, s, a, n) {
      if (e) {
        let o = r.find(e);
        o &&
          o !== r &&
          s.forInstancesRec((l) => {
            l.data = Hd(l.data, (h) => {
              let u = h.events.data(n.id),
                c = l.goUp(a);
              if (c) {
                let d = [...fT(c.identity), e].join("-"),
                  p = this.entityIdentityToEntity[d];
                if (p) {
                  let f = p.uuid,
                    m = ss.zoom(u, t);
                  m[i] = f;
                } else console.warn("cannot find instance");
              }
            }).data;
          });
      }
    }
    rewriteActions(e, t, i, r, s, a) {
      e.forEach((n) => {
        n.data.type === "Transition"
          ? this.relativeizeInner(
              n.data.object,
              [...t, n.id],
              "object",
              i,
              r,
              s,
              a
            )
          : n.data.type === "Animation" &&
            this.relativeizeInner(
              n.data.object,
              [...t, n.id],
              "object",
              i,
              r,
              s,
              a
            );
      });
    }
    rewriteEventsBeforeGoToPlayMode() {
      this.traverseEntity((e) => {
        if (
          e instanceof Nc &&
          typeof e.identity == "string" &&
          e.data.type === "Component"
        )
          return (
            e.traverseEntity((t, i) => {
              t.data.events.forEach((r) => {
                if (r.data.type === "GameControl") {
                  let s = !1;
                  if (
                    (t.forInstancesRec((a) => {
                      a.data = Hd(a.data, (n) => {
                        a.isInstanceRoot || (n.events.delete(r.id), (s = !0));
                      }).data;
                    }),
                    s === !1)
                  )
                    for (let a of $m.list)
                      this.rewriteActions(
                        r.data.gameActions[a],
                        ["gameActions", a],
                        e,
                        t,
                        i,
                        r
                      );
                } else
                  r.data.type === "Conditional"
                    ? (r.data.condition.type === "Distance"
                        ? (this.relativeizeInner(
                            r.data.condition.fromObject,
                            ["condition"],
                            "fromObject",
                            e,
                            t,
                            i,
                            r
                          ),
                          this.relativeizeInner(
                            r.data.condition.toObject,
                            ["condition"],
                            "toObject",
                            e,
                            t,
                            i,
                            r
                          ))
                        : r.data.condition.type === "State"
                        ? this.relativeizeInner(
                            r.data.condition.object,
                            ["condition"],
                            "object",
                            e,
                            t,
                            i,
                            r
                          )
                        : r.data.condition.type === "Comparison" &&
                          (r.data.condition.lOperand.type === "Property" &&
                            this.relativeizeInner(
                              r.data.condition.lOperand.value[0],
                              ["condition", "lOperand", "value"],
                              0,
                              e,
                              t,
                              i,
                              r
                            ),
                          r.data.condition.rOperand.type === "Property" &&
                            this.relativeizeInner(
                              r.data.condition.rOperand.value[0],
                              ["condition", "rOperand", "value"],
                              0,
                              e,
                              t,
                              i,
                              r
                            )),
                      this.rewriteActions(
                        r.data.inActions,
                        ["inActions"],
                        e,
                        t,
                        i,
                        r
                      ),
                      this.rewriteActions(
                        r.data.outActions,
                        ["outActions"],
                        e,
                        t,
                        i,
                        r
                      ))
                    : "actions" in r.data &&
                      this.rewriteActions(
                        r.data.actions,
                        ["actions"],
                        e,
                        t,
                        i,
                        r
                      );
              });
            }),
            !0
          );
      });
    }
    expandInstances(e, t, i) {
      let r = new Set();
      this.traverseEntity((s) => {
        if (s instanceof Nc && s.isInstanceRoot)
          return (
            s.expandInstanceChildren({
              scene: this,
              shared: e,
              pendingDeletes: r,
            }),
            t || s.resetBBoxNeedsUpdate(),
            i &&
              s.traverseEntity((a) => {
                i.addClip(a);
              }),
            !0
          );
      });
      for (let s of r)
        this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(s), Ib(s);
    }
    recomputeInstances(e, t) {
      this.needsRecomputeInstances &&
        ((this.needsRecomputeInstances = !1),
        this.traverseEntity((i) => {
          i instanceof Nc && i.isInstanceRoot && (i.component = void 0);
        }),
        this.expandInstances(e, !1, t));
    }
    disposeAndUnregisterEntityRecursivelyIfNotReregistered(e) {
      e.traverseEntity((t) => {
        let i =
          typeof t.identity == "string" ? t.identity : t.identity.join("-");
        this.entityIdentityToEntity[i] === t &&
          (delete this.entityByUuid[t.uuid],
          delete this.entityIdentityToEntity[i]),
          t.dispose();
      });
    }
    clearScene() {
      for (let e of this.children) si.is(e) && e.disposeRecursively();
      this.children.length = 0;
    }
    resetAfterClear(e, t) {
      this.init(e, t);
    }
    raycast(e) {
      return this.raycast1(e, !1);
    }
    raycast1(e, t) {
      let i = [],
        r = (s) => {
          for (let a of s.children) {
            let n = a.cloner;
            if (
              si.is(a) &&
              !a.raycastLock &&
              (a.visible || n?.object.data.visible)
            )
              if (t === !0 && a.isInstanceRoot) {
                let o = [];
                if ((e.intersectObject(a, !0, o), o.length)) {
                  let l = o[0];
                  (l.object = a), l.point.applyMatrix4(l.object.matrixWorld);
                  let h = a.matrixWorld.clone().invert();
                  l.point.applyMatrix4(h), i.push(l);
                }
              } else
                (ja(a) ||
                  (k1(a) && this.enableHelpers && a.objectHelper.visible)) &&
                  (e.intersectObject(a, !1, i), K1(a, e, i)),
                  r(a);
          }
        };
      return r(this.activePage), i;
    }
    raycastWithClones(e) {
      let t = [],
        i = (r) => {
          for (let s of r.children) {
            let a = s.cloner;
            si.is(s) &&
              (s.visible || a?.object.data.visible) &&
              ((ja(s) ||
                (k1(s) && this.enableHelpers && s.objectHelper.visible)) &&
                (e.intersectObject(s, !1, t), K1(s, e, t, !0)),
              i(s));
          }
        };
      return i(this), t;
    }
    forEachEntity(e) {
      for (let t of this.children) si.is(t) && e(t);
    }
    traverseConcreteEntity(e) {
      for (let t of this.children)
        si.is(t) && t.isConcreteEntity && t.traverseEntity(e);
    }
    traverseEntity(e) {
      for (let t of this.children) si.is(t) && t.traverseEntity(e);
    }
    updateFont(e, t) {
      this.traverseEntity((i) => {
        if (
          i instanceof ms &&
          i.data.type === "Mesh" &&
          i.data.geometry.type === "TextGeometry" &&
          i.data.geometry.font === e
        ) {
          let r = i.geometry,
            s = i.data.geometry;
          r.updateFont(e, t).then(() => {
            r.update(s);
            let a = i.invalidateDownstreamBooleanData();
            yo(a) && a.recomputeBoolean();
          });
        }
      });
    }
    traverseObject(e) {
      for (let t of this.children) Kd.is(t) && t.traverseObject(e);
    }
    traverseVisibleEntity(e) {
      for (let t of this.children)
        si.is(t) && t.visible && t.traverseVisibleEntity(e);
    }
    dispose() {
      this.clearScene();
    }
    createChildrenObjects(e, t, i) {
      let r = 0;
      for (let s of e)
        this.createObject(s.id, s.data, s.children, t, r, i), (r += 1);
    }
    registerObjectCreatedInLegacy(e) {
      this.entityByUuid[e.uuid] = e;
    }
    unregisterObject(e) {
      delete this.entityByUuid[e.uuid];
      for (let t of e.children) this.unregisterObject(t);
    }
    createObject(e, t, i, r, s, a) {
      let n = { scene: this, shared: a },
        o = Rb(e, t, n);
      return (
        o &&
          ((this.entityByUuid[e] = o),
          r.add(o),
          r.children.splice(s, 0, r.children.pop()),
          i.length > 0 &&
            (o.isInstanceRoot
              ? console.error("instance should not have children!")
              : this.createChildrenObjects(i, o, a)),
          o.updateState(t, n),
          o instanceof ms && o.updateGeometryGroupsIfNeeded(),
          o.updateVisible(this),
          o.cloner && this.toExpandCloner.add(o),
          t.pathSnapping?.pathId &&
            this.pathConstraints.setConstraint(e, t.pathSnapping.pathId)),
        t.type === "Empty" &&
          t.animations &&
          o.traverseEntity((l) => {
            let h = l.dataPatched;
            if (l instanceof ms && h.bones && h.boneInverses) {
              let u = h.bones.map((p) => this.find(p)),
                c = h.boneInverses.map((p) => new je().fromArray(p)),
                d = new _x(u, c);
              l.bind(d, l.bindMatrix);
            } else l.matrixAutoUpdate = !0;
          }),
        o
      );
    }
    getCenter(e) {
      let t = [];
      for (let r = 0, s = e.length; r < s; ++r) {
        let { id: a, recursive: n } = e[r],
          o = this.find(a),
          l = n ? o.recursiveBBox : o.singleBBox;
        t.push(...l.vertices);
      }
      let i = new ur();
      return i.setFromPoints(t), i.getCenter(VM), VM;
    }
    copyMatrixWorld(e, t) {
      if (e === null) {
        t.identity();
        return;
      }
      let i = this.find(e);
      i ? t.copy(i.matrixWorld) : t.identity();
    }
    copyParentMatrixWorld(e, t) {
      if (e === null) {
        t.identity();
        return;
      }
      let i = this.find(e)?.parent;
      i ? t.copy(i.matrixWorld) : t.identity();
    }
    traverseMaterial(e) {
      this.traverseEntity((t) => {
        if (t instanceof Is)
          if (Array.isArray(t.material))
            for (let i = 0; i < t.material.length; i++)
              t.material[i] instanceof ml && e(t.material[i]);
          else t.material instanceof ml && e(t.material);
      });
    }
    updateViewPlaneSize(e, t, i = !1) {
      this.traverseConcreteEntity((r) => {
        r instanceof vs && r.setViewplaneSize(e, t, i);
      });
    }
    initializeSplatViewer(e) {
      (this.splatViewer = new aK({ scene: this, renderer: e })),
        this.reloadSplats();
    }
    reloadSplats() {
      this.splatViewer?.reloadSplats();
    }
  },
  dm = (e, t) => {
    let i = t.x - e.x,
      r = t.y - e.y;
    return Math.sqrt(i * i + r * r);
  },
  nK = (e, t) => {
    let i = t.x - e.x,
      r = t.y - e.y;
    return lK(Math.atan2(r, i));
  },
  oK = (e, t, i) => {
    let r = { x: 0, y: 0 };
    return (
      (i = tx(i)),
      (r.x = e.x - t * Math.cos(i)),
      (r.y = e.y - t * Math.sin(i)),
      r
    );
  },
  tx = (e) => e * (Math.PI / 180),
  lK = (e) => e * (180 / Math.PI),
  hK = (e) => (isNaN(e.buttons) ? e.pressure !== 0 : e.buttons !== 0),
  G0 = new Map(),
  jM = (e) => {
    G0.has(e) && clearTimeout(G0.get(e)), G0.set(e, setTimeout(e, 100));
  },
  fg = (e, t, i) => {
    let r = t.split(/[ ,]+/g),
      s;
    for (let a = 0; a < r.length; a += 1)
      (s = r[a]),
        e.addEventListener
          ? e.addEventListener(s, i, !1)
          : e.attachEvent && e.attachEvent(s, i);
  },
  HM = (e, t, i) => {
    let r = t.split(/[ ,]+/g),
      s;
    for (let a = 0; a < r.length; a += 1)
      (s = r[a]),
        e.removeEventListener
          ? e.removeEventListener(s, i)
          : e.detachEvent && e.detachEvent(s, i);
  },
  NP = (e) => (
    e.preventDefault(), e.type.match(/^touch/) ? e.changedTouches : e
  ),
  GM = () => {
    if (typeof window > "u") return;
    let e =
        window.pageXOffset !== void 0
          ? window.pageXOffset
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollLeft,
      t =
        window.pageYOffset !== void 0
          ? window.pageYOffset
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollTop;
    return { x: e, y: t };
  },
  ix = (e, t) => {
    t.top || t.right || t.bottom || t.left
      ? ((e.style.top = t.top),
        (e.style.right = t.right),
        (e.style.bottom = t.bottom),
        (e.style.left = t.left))
      : ((e.style.left = t.x + "px"), (e.style.top = t.y + "px"));
  },
  Bb = (e, t, i) => {
    let r = UP(e);
    for (let s in r)
      if (r.hasOwnProperty(s))
        if (typeof t == "string") r[s] = t + " " + i;
        else {
          let a = "";
          for (let n = 0, o = t.length; n < o; n += 1)
            a += t[n] + " " + i + ", ";
          r[s] = a.slice(0, -2);
        }
    return r;
  },
  cK = (e, t) => {
    let i = UP(e);
    for (let r in i) i.hasOwnProperty(r) && (i[r] = t);
    return i;
  },
  UP = (e) => {
    let t = {};
    return (
      (t[e] = ""),
      ["webkit", "Moz", "o"].forEach(function (i) {
        t[i + e.charAt(0).toUpperCase() + e.slice(1)] = "";
      }),
      t
    );
  },
  W0 = (e, t) => {
    for (let i in t) t.hasOwnProperty(i) && (e[i] = t[i]);
    return e;
  },
  uK = (e, t) => {
    let i = {};
    for (let r in e)
      e.hasOwnProperty(r) && t.hasOwnProperty(r)
        ? (i[r] = t[r])
        : e.hasOwnProperty(r) && (i[r] = e[r]);
    return i;
  },
  rx = (e, t) => {
    if (e.length) for (let i = 0, r = e.length; i < r; i += 1) t(e[i]);
    else t(e);
  },
  dK = (e, t, i) => ({
    x: Math.min(Math.max(e.x, t.x - i), t.x + i),
    y: Math.min(Math.max(e.y, t.y - i), t.y + i),
  });
typeof window < "u" &&
  ((VP = "ontouchstart" in window),
  (jP = !!window.PointerEvent),
  (HP = !!window.MSPointerEvent));
var VP,
  jP,
  HP,
  rd = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      end: "touchend, touchcancel",
    },
    mouse: { start: "mousedown", move: "mousemove", end: "mouseup" },
    pointer: {
      start: "pointerdown",
      move: "pointermove",
      end: "pointerup, pointercancel",
    },
    MSPointer: {
      start: "MSPointerDown",
      move: "MSPointerMove",
      end: "MSPointerUp",
    },
  },
  Mc,
  ep = {};
jP
  ? (Mc = rd.pointer)
  : HP
  ? (Mc = rd.MSPointer)
  : VP
  ? ((Mc = rd.touch), (ep = rd.mouse))
  : (Mc = rd.mouse);
function _h() {}
_h.prototype.on = function (e, t) {
  var i = this,
    r = e.split(/[ ,]+/g),
    s;
  i._handlers_ = i._handlers_ || {};
  for (var a = 0; a < r.length; a += 1)
    (s = r[a]),
      (i._handlers_[s] = i._handlers_[s] || []),
      i._handlers_[s].push(t);
  return i;
};
_h.prototype.off = function (e, t) {
  var i = this;
  return (
    (i._handlers_ = i._handlers_ || {}),
    e === void 0
      ? (i._handlers_ = {})
      : t === void 0
      ? (i._handlers_[e] = null)
      : i._handlers_[e] &&
        i._handlers_[e].indexOf(t) >= 0 &&
        i._handlers_[e].splice(i._handlers_[e].indexOf(t), 1),
    i
  );
};
_h.prototype.trigger = function (e, t) {
  var i = this,
    r = e.split(/[ ,]+/g),
    s;
  i._handlers_ = i._handlers_ || {};
  for (var a = 0; a < r.length; a += 1)
    (s = r[a]),
      i._handlers_[s] &&
        i._handlers_[s].length &&
        i._handlers_[s].forEach(function (n) {
          n.call(i, { type: s, target: i }, t);
        });
};
_h.prototype.config = function (e) {
  var t = this;
  (t.options = t.defaults || {}), e && (t.options = uK(t.options, e));
};
_h.prototype.bindEvt = function (e, t) {
  var i = this;
  return (
    (i._domHandlers_ = i._domHandlers_ || {}),
    (i._domHandlers_[t] = function () {
      typeof i["on" + t] == "function"
        ? i["on" + t].apply(i, arguments)
        : console.warn('[WARNING] : Missing "on' + t + '" handler.');
    }),
    fg(e, Mc[t], i._domHandlers_[t]),
    ep[t] && fg(e, ep[t], i._domHandlers_[t]),
    i
  );
};
_h.prototype.unbindEvt = function (e, t) {
  var i = this;
  return (
    (i._domHandlers_ = i._domHandlers_ || {}),
    HM(e, Mc[t], i._domHandlers_[t]),
    ep[t] && HM(e, ep[t], i._domHandlers_[t]),
    delete i._domHandlers_[t],
    this
  );
};
var zb = _h;
function zr(e, t) {
  return (
    (this.identifier = t.identifier),
    (this.position = t.position),
    (this.frontPosition = t.frontPosition),
    (this.collection = e),
    (this.defaults = {
      size: 100,
      threshold: 0.1,
      color: "white",
      fadeTime: 250,
      dataOnly: !1,
      restJoystick: !0,
      restOpacity: 1,
      mode: "dynamic",
      zone: document.body,
      lockX: !1,
      lockY: !1,
      shape: "circle",
    }),
    this.config(t),
    this.options.mode === "dynamic" && (this.options.restOpacity = 0),
    (this.id = zr.id),
    (zr.id += 1),
    this.buildEl().stylize(),
    (this.instance = {
      el: this.ui.el,
      on: this.on.bind(this),
      off: this.off.bind(this),
      show: this.show.bind(this),
      hide: this.hide.bind(this),
      add: this.addToDom.bind(this),
      remove: this.removeFromDom.bind(this),
      destroy: this.destroy.bind(this),
      setPosition: this.setPosition.bind(this),
      resetDirection: this.resetDirection.bind(this),
      computeDirection: this.computeDirection.bind(this),
      trigger: this.trigger.bind(this),
      position: this.position,
      frontPosition: this.frontPosition,
      ui: this.ui,
      identifier: this.identifier,
      id: this.id,
      options: this.options,
    }),
    this.instance
  );
}
zr.prototype = new zb();
zr.constructor = zr;
zr.id = 0;
zr.prototype.buildEl = function (e) {
  return (
    (this.ui = {}),
    this.options.dataOnly
      ? this
      : ((this.ui.el = document.createElement("div")),
        (this.ui.back = document.createElement("div")),
        (this.ui.front = document.createElement("div")),
        (this.ui.el.className = "nipple collection_" + this.collection.id),
        (this.ui.back.className = "back"),
        (this.ui.front.className = "front"),
        this.ui.el.setAttribute(
          "id",
          "nipple_" + this.collection.id + "_" + this.id
        ),
        this.ui.el.appendChild(this.ui.back),
        this.ui.el.appendChild(this.ui.front),
        this)
  );
};
zr.prototype.stylize = function () {
  if (this.options.dataOnly) return this;
  var e = this.options.fadeTime + "ms",
    t = cK("borderRadius", "50%"),
    i = Bb("transition", "opacity", e),
    r = {};
  return (
    (r.el = {
      position: "absolute",
      opacity: this.options.restOpacity,
      display: "block",
      zIndex: 999,
    }),
    (r.back = {
      position: "absolute",
      display: "block",
      width: this.options.size + "px",
      height: this.options.size + "px",
      marginLeft: -this.options.size / 2 + "px",
      marginTop: -this.options.size / 2 + "px",
      background: "rgba(255, 255, 255, .4)",
      border: "solid 2px rgba(0, 0, 0, .1)",
    }),
    (r.front = {
      width: this.options.size / 2 + "px",
      height: this.options.size / 2 + "px",
      position: "absolute",
      display: "block",
      marginLeft: -this.options.size / 4 + "px",
      marginTop: -this.options.size / 4 + "px",
      background: "rgba(255, 255, 255, .8)",
      border: "solid 2px rgba(0, 0, 0, .1)",
    }),
    W0(r.el, i),
    this.options.shape === "circle" && W0(r.back, t),
    W0(r.front, t),
    this.applyStyles(r),
    this
  );
};
zr.prototype.applyStyles = function (e) {
  for (var t in this.ui)
    if (this.ui.hasOwnProperty(t))
      for (var i in e[t]) this.ui[t].style[i] = e[t][i];
  return this;
};
zr.prototype.addToDom = function () {
  return this.options.dataOnly || document.body.contains(this.ui.el)
    ? this
    : (this.options.zone.appendChild(this.ui.el), this);
};
zr.prototype.removeFromDom = function () {
  return this.options.dataOnly || !document.body.contains(this.ui.el)
    ? this
    : (this.options.zone.removeChild(this.ui.el), this);
};
zr.prototype.destroy = function () {
  clearTimeout(this.removeTimeout),
    clearTimeout(this.showTimeout),
    clearTimeout(this.restTimeout),
    this.trigger("destroyed", this.instance),
    this.removeFromDom(),
    this.off();
};
zr.prototype.show = function (e) {
  var t = this;
  return (
    t.options.dataOnly ||
      (clearTimeout(t.removeTimeout),
      clearTimeout(t.showTimeout),
      clearTimeout(t.restTimeout),
      t.addToDom(),
      t.restCallback(),
      setTimeout(function () {
        t.ui.el.style.opacity = 1;
      }, 0),
      (t.showTimeout = setTimeout(function () {
        t.trigger("shown", t.instance), typeof e == "function" && e.call(this);
      }, t.options.fadeTime))),
    t
  );
};
zr.prototype.hide = function (e) {
  var t = this;
  if (t.options.dataOnly) return t;
  if (
    ((t.ui.el.style.opacity = t.options.restOpacity),
    clearTimeout(t.removeTimeout),
    clearTimeout(t.showTimeout),
    clearTimeout(t.restTimeout),
    (t.removeTimeout = setTimeout(function () {
      var i = t.options.mode === "dynamic" ? "none" : "block";
      (t.ui.el.style.display = i),
        typeof e == "function" && e.call(t),
        t.trigger("hidden", t.instance);
    }, t.options.fadeTime)),
    t.options.restJoystick)
  ) {
    let i = t.options.restJoystick,
      r = {};
    (r.x = i === !0 || i.x !== !1 ? 0 : t.instance.frontPosition.x),
      (r.y = i === !0 || i.y !== !1 ? 0 : t.instance.frontPosition.y),
      t.setPosition(e, r);
  }
  return t;
};
zr.prototype.setPosition = function (e, t) {
  var i = this;
  i.frontPosition = { x: t.x, y: t.y };
  var r = i.options.fadeTime + "ms",
    s = {};
  s.front = Bb("transition", ["top", "left"], r);
  var a = { front: {} };
  (a.front = { left: i.frontPosition.x + "px", top: i.frontPosition.y + "px" }),
    i.applyStyles(s),
    i.applyStyles(a),
    (i.restTimeout = setTimeout(function () {
      typeof e == "function" && e.call(i), i.restCallback();
    }, i.options.fadeTime));
};
zr.prototype.restCallback = function () {
  var e = this,
    t = {};
  (t.front = Bb("transition", "none", "")),
    e.applyStyles(t),
    e.trigger("rested", e.instance);
};
zr.prototype.resetDirection = function () {
  this.direction = { x: !1, y: !1, angle: !1 };
};
zr.prototype.computeDirection = function (e) {
  var t = e.angle.radian,
    i = Math.PI / 4,
    r = Math.PI / 2,
    s,
    a,
    n;
  if (
    (t > i && t < i * 3 && !e.lockX
      ? (s = "up")
      : t > -i && t <= i && !e.lockY
      ? (s = "left")
      : t > -i * 3 && t <= -i && !e.lockX
      ? (s = "down")
      : e.lockY || (s = "right"),
    e.lockY || (t > -r && t < r ? (a = "left") : (a = "right")),
    e.lockX || (t > 0 ? (n = "up") : (n = "down")),
    e.force > this.options.threshold)
  ) {
    var o = {},
      l;
    for (l in this.direction)
      this.direction.hasOwnProperty(l) && (o[l] = this.direction[l]);
    var h = {};
    (this.direction = { x: a, y: n, angle: s }), (e.direction = this.direction);
    for (l in o) o[l] === this.direction[l] && (h[l] = !0);
    if (h.x && h.y && h.angle) return e;
    (!h.x || !h.y) && this.trigger("plain", e),
      h.x || this.trigger("plain:" + a, e),
      h.y || this.trigger("plain:" + n, e),
      h.angle || this.trigger("dir dir:" + s, e);
  } else this.resetDirection();
  return e;
};
var pK = zr;
function dr(e, t) {
  var i = this;
  (i.nipples = []),
    (i.idles = []),
    (i.actives = []),
    (i.ids = []),
    (i.pressureIntervals = {}),
    (i.manager = e),
    (i.id = dr.id),
    (dr.id += 1),
    (i.defaults = {
      zone: document.body,
      multitouch: !1,
      maxNumberOfNipples: 10,
      mode: "dynamic",
      position: { top: 0, left: 0 },
      catchDistance: 200,
      size: 100,
      threshold: 0.1,
      color: "white",
      fadeTime: 250,
      dataOnly: !1,
      restJoystick: !0,
      restOpacity: 1,
      lockX: !1,
      lockY: !1,
      shape: "circle",
      dynamicPage: !1,
      follow: !1,
    }),
    i.config(t),
    (i.options.mode === "static" || i.options.mode === "semi") &&
      (i.options.multitouch = !1),
    i.options.multitouch || (i.options.maxNumberOfNipples = 1);
  let r = getComputedStyle(i.options.zone.parentElement);
  return (
    r && r.display === "flex" && (i.parentIsFlex = !0),
    i.updateBox(),
    i.prepareNipples(),
    i.bindings(),
    i.begin(),
    i.nipples
  );
}
dr.prototype = new zb();
dr.constructor = dr;
dr.id = 0;
dr.prototype.prepareNipples = function () {
  var e = this,
    t = e.nipples;
  (t.on = e.on.bind(e)),
    (t.off = e.off.bind(e)),
    (t.options = e.options),
    (t.destroy = e.destroy.bind(e)),
    (t.ids = e.ids),
    (t.id = e.id),
    (t.processOnMove = e.processOnMove.bind(e)),
    (t.processOnEnd = e.processOnEnd.bind(e)),
    (t.get = function (i) {
      if (i === void 0) return t[0];
      for (var r = 0, s = t.length; r < s; r += 1)
        if (t[r].identifier === i) return t[r];
      return !1;
    });
};
dr.prototype.bindings = function () {
  var e = this;
  e.bindEvt(e.options.zone, "start"),
    (e.options.zone.style.touchAction = "none"),
    (e.options.zone.style.msTouchAction = "none");
};
dr.prototype.begin = function () {
  var e = this,
    t = e.options;
  if (t.mode === "static") {
    var i = e.createNipple(t.position, e.manager.getIdentifier());
    i.add(), e.idles.push(i);
  }
};
dr.prototype.createNipple = function (e, t) {
  var i = this,
    r = i.manager.scroll,
    s = {},
    a = i.options,
    n = {
      x: i.parentIsFlex ? r.x : r.x + i.box.left,
      y: i.parentIsFlex ? r.y : r.y + i.box.top,
    };
  if (e.x && e.y) s = { x: e.x - n.x, y: e.y - n.y };
  else if (e.top || e.right || e.bottom || e.left) {
    var o = document.createElement("DIV");
    (o.style.display = "hidden"),
      (o.style.top = e.top),
      (o.style.right = e.right),
      (o.style.bottom = e.bottom),
      (o.style.left = e.left),
      (o.style.position = "absolute"),
      a.zone.appendChild(o);
    var l = o.getBoundingClientRect();
    a.zone.removeChild(o), (s = e), (e = { x: l.left + r.x, y: l.top + r.y });
  }
  var h = new pK(i, {
    color: a.color,
    size: a.size,
    threshold: a.threshold,
    fadeTime: a.fadeTime,
    dataOnly: a.dataOnly,
    restJoystick: a.restJoystick,
    restOpacity: a.restOpacity,
    mode: a.mode,
    identifier: t,
    position: e,
    zone: a.zone,
    frontPosition: { x: 0, y: 0 },
    shape: a.shape,
  });
  return (
    a.dataOnly || (ix(h.ui.el, s), ix(h.ui.front, h.frontPosition)),
    i.nipples.push(h),
    i.trigger("added " + h.identifier + ":added", h),
    i.manager.trigger("added " + h.identifier + ":added", h),
    i.bindNipple(h),
    h
  );
};
dr.prototype.updateBox = function () {
  var e = this;
  e.box = e.options.zone.getBoundingClientRect();
};
dr.prototype.bindNipple = function (e) {
  var t = this,
    i,
    r = function (s, a) {
      (i = s.type + " " + a.id + ":" + s.type), t.trigger(i, a);
    };
  e.on("destroyed", t.onDestroyed.bind(t)),
    e.on("shown hidden rested dir plain", r),
    e.on("dir:up dir:right dir:down dir:left", r),
    e.on("plain:up plain:right plain:down plain:left", r);
};
dr.prototype.pressureFn = function (e, t, i) {
  var r = this,
    s = 0;
  clearInterval(r.pressureIntervals[i]),
    (r.pressureIntervals[i] = setInterval(
      function () {
        var a = e.force || e.pressure || e.webkitForce || 0;
        a !== s &&
          (t.trigger("pressure", a),
          r.trigger("pressure " + t.identifier + ":pressure", a),
          (s = a));
      }.bind(r),
      100
    ));
};
dr.prototype.onstart = function (e) {
  var t = this,
    i = t.options,
    r = e;
  (e = NP(e)), t.updateBox();
  var s = function (a) {
    t.actives.length < i.maxNumberOfNipples
      ? t.processOnStart(a)
      : r.type.match(/^touch/) &&
        (Object.keys(t.manager.ids).forEach(function (n) {
          if (
            Object.values(r.touches).findIndex(function (l) {
              return l.identifier === n;
            }) < 0
          ) {
            var o = [e[0]];
            (o.identifier = n), t.processOnEnd(o);
          }
        }),
        t.actives.length < i.maxNumberOfNipples && t.processOnStart(a));
  };
  return rx(e, s), t.manager.bindDocument(), !1;
};
dr.prototype.processOnStart = function (e) {
  var t = this,
    i = t.options,
    r,
    s = t.manager.getIdentifier(e),
    a = e.force || e.pressure || e.webkitForce || 0,
    n = { x: e.pageX, y: e.pageY },
    o = t.getOrCreate(s, n);
  o.identifier !== s && t.manager.removeIdentifier(o.identifier),
    (o.identifier = s);
  var l = function (u) {
    u.trigger("start", u),
      t.trigger("start " + u.id + ":start", u),
      u.show(),
      a > 0 && t.pressureFn(e, u, u.identifier),
      t.processOnMove(e);
  };
  if (
    ((r = t.idles.indexOf(o)) >= 0 && t.idles.splice(r, 1),
    t.actives.push(o),
    t.ids.push(o.identifier),
    i.mode !== "semi")
  )
    l(o);
  else {
    var h = dm(n, o.position);
    if (h <= i.catchDistance) l(o);
    else {
      o.destroy(), t.processOnStart(e);
      return;
    }
  }
  return o;
};
dr.prototype.getOrCreate = function (e, t) {
  var i = this,
    r = i.options,
    s;
  return /(semi|static)/.test(r.mode)
    ? ((s = i.idles[0]),
      s
        ? (i.idles.splice(0, 1), s)
        : r.mode === "semi"
        ? i.createNipple(t, e)
        : (console.warn("Coudln't find the needed nipple."), !1))
    : ((s = i.createNipple(t, e)), s);
};
dr.prototype.processOnMove = function (e) {
  var t = this,
    i = t.options,
    r = t.manager.getIdentifier(e),
    s = t.nipples.get(r),
    a = t.manager.scroll;
  if (!hK(e)) {
    this.processOnEnd(e);
    return;
  }
  if (!s) {
    console.error("Found zombie joystick with ID " + r),
      t.manager.removeIdentifier(r);
    return;
  }
  if (i.dynamicPage) {
    var n = s.el.getBoundingClientRect();
    s.position = { x: a.x + n.left, y: a.y + n.top };
  }
  s.identifier = r;
  var o = s.options.size / 2,
    l = { x: e.pageX, y: e.pageY };
  i.lockX && (l.y = s.position.y), i.lockY && (l.x = s.position.x);
  var h = dm(l, s.position),
    u = nK(l, s.position),
    c = tx(u),
    d = h / o,
    p = { distance: h, position: l },
    f,
    m;
  if (
    (s.options.shape === "circle"
      ? ((f = Math.min(h, o)), (m = oK(s.position, f, u)))
      : ((m = dK(l, s.position, o)), (f = dm(m, s.position))),
    i.follow)
  ) {
    if (h > o) {
      let b = l.x - m.x,
        _ = l.y - m.y;
      (s.position.x += b),
        (s.position.y += _),
        (s.el.style.top = s.position.y - (t.box.top + a.y) + "px"),
        (s.el.style.left = s.position.x - (t.box.left + a.x) + "px"),
        (h = dm(l, s.position));
    }
  } else (l = m), (h = f);
  var g = l.x - s.position.x,
    y = l.y - s.position.y;
  (s.frontPosition = { x: g, y }),
    i.dataOnly || ix(s.ui.front, s.frontPosition);
  var x = {
    identifier: s.identifier,
    position: l,
    force: d,
    pressure: e.force || e.pressure || e.webkitForce || 0,
    distance: h,
    angle: { radian: c, degree: u },
    vector: { x: g / o, y: -y / o },
    raw: p,
    instance: s,
    lockX: i.lockX,
    lockY: i.lockY,
  };
  (x = s.computeDirection(x)),
    (x.angle = { radian: tx(180 - u), degree: 180 - u }),
    s.trigger("move", x),
    t.trigger("move " + s.id + ":move", x);
};
dr.prototype.processOnEnd = function (e) {
  var t = this,
    i = t.options,
    r = t.manager.getIdentifier(e),
    s = t.nipples.get(r),
    a = t.manager.removeIdentifier(s.identifier);
  !s ||
    (i.dataOnly ||
      s.hide(function () {
        i.mode === "dynamic" &&
          (s.trigger("removed", s),
          t.trigger("removed " + s.id + ":removed", s),
          t.manager.trigger("removed " + s.id + ":removed", s),
          s.destroy());
      }),
    clearInterval(t.pressureIntervals[s.identifier]),
    s.resetDirection(),
    s.trigger("end", s),
    t.trigger("end " + s.id + ":end", s),
    t.ids.indexOf(s.identifier) >= 0 &&
      t.ids.splice(t.ids.indexOf(s.identifier), 1),
    t.actives.indexOf(s) >= 0 && t.actives.splice(t.actives.indexOf(s), 1),
    /(semi|static)/.test(i.mode)
      ? t.idles.push(s)
      : t.nipples.indexOf(s) >= 0 && t.nipples.splice(t.nipples.indexOf(s), 1),
    t.manager.unbindDocument(),
    /(semi|static)/.test(i.mode) && (t.manager.ids[a.id] = a.identifier));
};
dr.prototype.onDestroyed = function (e, t) {
  var i = this;
  i.nipples.indexOf(t) >= 0 && i.nipples.splice(i.nipples.indexOf(t), 1),
    i.actives.indexOf(t) >= 0 && i.actives.splice(i.actives.indexOf(t), 1),
    i.idles.indexOf(t) >= 0 && i.idles.splice(i.idles.indexOf(t), 1),
    i.ids.indexOf(t.identifier) >= 0 &&
      i.ids.splice(i.ids.indexOf(t.identifier), 1),
    i.manager.removeIdentifier(t.identifier),
    i.manager.unbindDocument();
};
dr.prototype.destroy = function () {
  var e = this;
  e.unbindEvt(e.options.zone, "start"),
    e.nipples.forEach(function (i) {
      i.destroy();
    });
  for (var t in e.pressureIntervals)
    e.pressureIntervals.hasOwnProperty(t) &&
      clearInterval(e.pressureIntervals[t]);
  e.trigger("destroyed", e.nipples), e.manager.unbindDocument(), e.off();
};
var fK = dr;
function Qr(e) {
  var t = this;
  (t.ids = {}),
    (t.index = 0),
    (t.collections = []),
    (t.scroll = GM()),
    t.config(e),
    t.prepareCollections();
  var i = function () {
    var s;
    t.collections.forEach(function (a) {
      a.forEach(function (n) {
        (s = n.el.getBoundingClientRect()),
          (n.position = { x: t.scroll.x + s.left, y: t.scroll.y + s.top });
      });
    });
  };
  if (typeof window > "u") return t.collections;
  fg(window, "resize", function () {
    jM(i);
  });
  var r = function () {
    t.scroll = GM();
  };
  return (
    fg(window, "scroll", function () {
      jM(r);
    }),
    t.collections
  );
}
Qr.prototype = new zb();
Qr.constructor = Qr;
Qr.prototype.prepareCollections = function () {
  var e = this;
  (e.collections.create = e.create.bind(e)),
    (e.collections.on = e.on.bind(e)),
    (e.collections.off = e.off.bind(e)),
    (e.collections.destroy = e.destroy.bind(e)),
    (e.collections.get = function (t) {
      var i;
      return (
        e.collections.every(function (r) {
          return (i = r.get(t)), !i;
        }),
        i
      );
    });
};
Qr.prototype.create = function (e) {
  return this.createCollection(e);
};
Qr.prototype.createCollection = function (e) {
  var t = this,
    i = new fK(t, e);
  return t.bindCollection(i), t.collections.push(i), i;
};
Qr.prototype.bindCollection = function (e) {
  var t = this,
    i,
    r = function (s, a) {
      (i = s.type + " " + a.id + ":" + s.type), t.trigger(i, a);
    };
  e.on("destroyed", t.onDestroyed.bind(t)),
    e.on("shown hidden rested dir plain", r),
    e.on("dir:up dir:right dir:down dir:left", r),
    e.on("plain:up plain:right plain:down plain:left", r);
};
Qr.prototype.bindDocument = function () {
  var e = this;
  e.binded ||
    (e.bindEvt(document, "move").bindEvt(document, "end"), (e.binded = !0));
};
Qr.prototype.unbindDocument = function (e) {
  var t = this;
  (!Object.keys(t.ids).length || e === !0) &&
    (t.unbindEvt(document, "move").unbindEvt(document, "end"), (t.binded = !1));
};
Qr.prototype.getIdentifier = function (e) {
  var t;
  return (
    e
      ? ((t = e.identifier === void 0 ? e.pointerId : e.identifier),
        t === void 0 && (t = this.latest || 0))
      : (t = this.index),
    this.ids[t] === void 0 && ((this.ids[t] = this.index), (this.index += 1)),
    (this.latest = t),
    this.ids[t]
  );
};
Qr.prototype.removeIdentifier = function (e) {
  var t = {};
  for (var i in this.ids)
    if (this.ids[i] === e) {
      (t.id = i), (t.identifier = this.ids[i]), delete this.ids[i];
      break;
    }
  return t;
};
Qr.prototype.onmove = function (e) {
  var t = this;
  return t.onAny("move", e), !1;
};
Qr.prototype.onend = function (e) {
  var t = this;
  return t.onAny("end", e), !1;
};
Qr.prototype.oncancel = function (e) {
  var t = this;
  return t.onAny("end", e), !1;
};
Qr.prototype.onAny = function (e, t) {
  var i = this,
    r,
    s = "processOn" + e.charAt(0).toUpperCase() + e.slice(1);
  t = NP(t);
  var a = function (o, l, h) {
      h.ids.indexOf(l) >= 0 && (h[s](o), (o._found_ = !0));
    },
    n = function (o) {
      (r = i.getIdentifier(o)),
        rx(i.collections, a.bind(null, o, r)),
        o._found_ || i.removeIdentifier(r);
    };
  return rx(t, n), !1;
};
Qr.prototype.destroy = function () {
  var e = this;
  e.unbindDocument(!0),
    (e.ids = {}),
    (e.index = 0),
    e.collections.forEach(function (t) {
      t.destroy();
    }),
    e.off();
};
Qr.prototype.onDestroyed = function (e, t) {
  var i = this;
  if (i.collections.indexOf(t) < 0) return !1;
  i.collections.splice(i.collections.indexOf(t), 1);
};
var mK = Qr,
  WM = new mK(),
  gK = {
    create: function (e) {
      return WM.create(e);
    },
    factory: WM,
  },
  GP = new Map(),
  Td = new Map(),
  Zl = class {
    constructor(e, t, i, r) {
      this.data = t;
      let { audio: s, volume: a, delay: n, loop: o } = t;
      if (!s) throw new Error("Missing property");
      let l = typeof s == "string" ? r.getAudio(s).src : s.data;
      (this.audioPlayer = new vd({ src: l, volume: a, delay: n, loop: o })),
        Td.has(i.uuid) ? Td.get(i.uuid).push(this) : Td.set(i.uuid, [this]),
        GP.set(e, this);
    }
    playByToggle() {
      this.data.toggle === "stop"
        ? this.audioPlayer.status === "playing"
          ? this.audioPlayer.stop()
          : (this.audioPlayer.stop(), this.audioPlayer.play())
        : this.data.toggle === "pause"
        ? this.audioPlayer.status === "playing"
          ? this.audioPlayer.pause()
          : this.audioPlayer.play()
        : (this.audioPlayer.stop(), this.audioPlayer.play());
    }
    dispose() {
      this.audioPlayer.stop();
    }
  },
  sx = class {
    constructor(e) {
      this.data = e;
    }
    dispatch() {
      this.data.playAudio
        ? this.pauseAudio(this.data.playAudio)
        : this.data.object
        ? this.pauseAllAudiosFromObject(this.data.object)
        : this.pauseAllAudios();
    }
    pauseAudio(e) {
      let t = GP.get(e);
      !t ||
        (this.data.delay > 0
          ? (this.disposeDelay(),
            (this.timeoutId = window.setTimeout(() => {
              t.audioPlayer[this.data.interaction](), this.disposeDelay();
            }, this.data.delay)))
          : t.audioPlayer[this.data.interaction]());
    }
    pauseAllAudiosFromObject(e) {
      let t = Td.get(e);
      !t?.length ||
        (this.data.delay > 0
          ? (this.disposeDelay(),
            (this.timeoutId = window.setTimeout(() => {
              t.forEach((i) => i.audioPlayer[this.data.interaction]()),
                this.disposeDelay();
            }, this.data.delay)))
          : t.forEach((i) => i.audioPlayer[this.data.interaction]()));
    }
    pauseAllAudios() {
      let e = [...Td.values()];
      !e.length ||
        (this.data.delay > 0
          ? (this.disposeDelay(),
            (this.timeoutId = window.setTimeout(() => {
              e.forEach((t) => {
                t.forEach((i) => {
                  i.audioPlayer[this.data.interaction]();
                });
              }),
                this.disposeDelay();
            }, this.data.delay)))
          : e.forEach((t) => {
              t.forEach((i) => {
                i.audioPlayer[this.data.interaction]();
              });
            }));
    }
    disposeDelay() {
      clearTimeout(this.timeoutId), delete this.timeoutId;
    }
    dispose() {
      clearTimeout(this.timeoutId), delete this.timeoutId;
    }
  },
  WP = class {
    constructor(e, t, i, r, s) {
      if (
        ((this.data = t),
        (this.shared = r),
        (this.condition = s),
        t.interaction === "play")
      )
        this.interaction = new Zl(e, t, i, r);
      else if (t.interaction === "pause" || t.interaction === "stop")
        this.interaction = new sx(t);
      else throw new Error("Missing property");
    }
    dispatchBasic() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.interaction instanceof Zl
        ? this.interaction.playByToggle()
        : this.interaction.dispatch();
    }
    dispatchConditional() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.interaction instanceof Zl
        ? this.interaction.audioPlayer.play()
        : this.interaction.dispatch();
    }
    dispatchGameControl(e) {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.interaction instanceof Zl &&
        (e === "start"
          ? this.interaction.audioPlayer.play()
          : this.interaction.audioPlayer.stop());
    }
    dispose() {
      this.interaction.dispose();
    }
  },
  qP = class {
    constructor(e, t, i, r) {
      (this.data = e),
        (this.page = t),
        (this.shared = i),
        (this.condition = r),
        (this.delay = 0),
        (this.emission = e.emission),
        e.delay !== void 0 && (this.delay = e.delay),
        (this.particleSystem = this.page.scene.find(this.data.emitterObjectId));
    }
    toggleEmitting() {
      this.particleSystem.started && !this.particleSystem.stopped
        ? this.stop()
        : this.start(this.delay);
    }
    toggleFroze() {
      this.particleSystem.started && !this.particleSystem.isFrozen
        ? this.freeze()
        : this.unFreeze();
    }
    start(e = 0) {
      if (e) {
        this.delayTimerId = window.setTimeout(() => {
          this.start(0), this.clearDelay();
        }, this.delay);
        return;
      }
      this.particleSystem.start();
    }
    stop() {
      this.particleSystem.stop(), this.clearDelay();
    }
    freeze() {
      this.particleSystem.froze(), this.clearDelay();
    }
    unFreeze() {
      this.particleSystem.unFroze(), this.clearDelay();
    }
    reset() {
      this.particleSystem.reset(), this.clearDelay();
    }
    reverseFromCurrent() {
      switch (this.emission) {
        case "emitToggle":
          this.toggleEmitting();
          break;
        case "pauseToggle":
          this.toggleFroze();
          break;
      }
    }
    dispatchBasic() {
      if (Xi(this.shared, this.condition) === !1 || !this.particleSystem)
        return !1;
      switch (this.emission) {
        case "start":
          this.start(this.delay);
          break;
        case "emitToggle":
          this.toggleEmitting();
          break;
        case "pause":
          this.freeze();
          break;
        case "pauseToggle":
          this.toggleFroze();
          break;
        case "stop":
          this.stop();
          break;
        case "reset":
          this.reset();
          break;
        default:
          break;
      }
    }
    dispatchConditional() {
      if (Xi(this.shared, this.condition) === !1 || !this.particleSystem)
        return !1;
      switch (this.emission) {
        case "start":
          this.particleSystem.start();
          break;
        case "stop":
          this.particleSystem.stop();
          break;
        case "reset":
          this.particleSystem.reset();
          break;
        default:
          break;
      }
    }
    dispatchGameControl(e) {
      if (Xi(this.shared, this.condition) === !1 || !this.particleSystem)
        return !1;
      e === "start" ? this.particleSystem.start() : this.particleSystem.stop();
    }
    dispose() {
      !this.particleSystem || (this.particleSystem.reset(), this.clearDelay());
    }
    clearDelay() {
      this.delayTimerId &&
        (clearTimeout(this.delayTimerId), delete this.delayTimerId);
    }
  },
  vK = "text/plain",
  yK = "us-ascii",
  qM = (e, t) => t.some((i) => (i instanceof RegExp ? i.test(e) : i === e)),
  xK = (e, { stripHash: t }) => {
    let i = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);
    if (!i) throw new Error(`Invalid URL: ${e}`);
    let { type: r, data: s, hash: a } = i.groups,
      n = r.split(";");
    a = t ? "" : a;
    let o = !1;
    n[n.length - 1] === "base64" && (n.pop(), (o = !0));
    let l = (n.shift() || "").toLowerCase(),
      h = [
        ...n
          .map((u) => {
            let [c, d = ""] = u.split("=").map((p) => p.trim());
            return c === "charset" && ((d = d.toLowerCase()), d === yK)
              ? ""
              : `${c}${d ? `=${d}` : ""}`;
          })
          .filter(Boolean),
      ];
    return (
      o && h.push("base64"),
      (h.length > 0 || (l && l !== vK)) && h.unshift(l),
      `data:${h.join(";")},${o ? s.trim() : s}${a ? `#${a}` : ""}`
    );
  };
function bK(e, t) {
  if (
    ((t = {
      defaultProtocol: "http:",
      normalizeProtocol: !0,
      forceHttp: !1,
      forceHttps: !1,
      stripAuthentication: !0,
      stripHash: !1,
      stripTextFragment: !0,
      stripWWW: !0,
      removeQueryParameters: [/^utm_\w+/i],
      removeTrailingSlash: !0,
      removeSingleSlash: !0,
      removeDirectoryIndex: !1,
      sortQueryParameters: !0,
      ...t,
    }),
    (e = e.trim()),
    /^data:/i.test(e))
  )
    return xK(e, t);
  if (/^view-source:/i.test(e))
    throw new Error(
      "`view-source:` is not supported as it is a non-standard protocol"
    );
  let i = e.startsWith("//");
  (!i && /^\.*\//.test(e)) ||
    (e = e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol));
  let r = new URL(e);
  if (t.forceHttp && t.forceHttps)
    throw new Error(
      "The `forceHttp` and `forceHttps` options cannot be used together"
    );
  if (
    (t.forceHttp && r.protocol === "https:" && (r.protocol = "http:"),
    t.forceHttps && r.protocol === "http:" && (r.protocol = "https:"),
    t.stripAuthentication && ((r.username = ""), (r.password = "")),
    t.stripHash
      ? (r.hash = "")
      : t.stripTextFragment && (r.hash = r.hash.replace(/#?:~:text.*?$/i, "")),
    r.pathname)
  ) {
    let a = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g,
      n = 0,
      o = "";
    for (;;) {
      let h = a.exec(r.pathname);
      if (!h) break;
      let u = h[0],
        c = h.index,
        d = r.pathname.slice(n, c);
      (o += d.replace(/\/{2,}/g, "/")), (o += u), (n = c + u.length);
    }
    let l = r.pathname.slice(n, r.pathname.length);
    (o += l.replace(/\/{2,}/g, "/")), (r.pathname = o);
  }
  if (r.pathname)
    try {
      r.pathname = decodeURI(r.pathname);
    } catch {}
  if (
    (t.removeDirectoryIndex === !0 &&
      (t.removeDirectoryIndex = [/^index\.[a-z]+$/]),
    Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.length > 0)
  ) {
    let a = r.pathname.split("/"),
      n = a[a.length - 1];
    qM(n, t.removeDirectoryIndex) &&
      ((a = a.slice(0, -1)), (r.pathname = a.slice(1).join("/") + "/"));
  }
  if (
    (r.hostname &&
      ((r.hostname = r.hostname.replace(/\.$/, "")),
      t.stripWWW &&
        /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(r.hostname) &&
        (r.hostname = r.hostname.replace(/^www\./, ""))),
    Array.isArray(t.removeQueryParameters))
  )
    for (let a of [...r.searchParams.keys()])
      qM(a, t.removeQueryParameters) && r.searchParams.delete(a);
  if (
    (t.removeQueryParameters === !0 && (r.search = ""), t.sortQueryParameters)
  ) {
    r.searchParams.sort();
    try {
      r.search = decodeURIComponent(r.search);
    } catch {}
  }
  t.removeTrailingSlash && (r.pathname = r.pathname.replace(/\/$/, ""));
  let s = e;
  return (
    (e = r.toString()),
    !t.removeSingleSlash &&
      r.pathname === "/" &&
      !s.endsWith("/") &&
      r.hash === "" &&
      (e = e.replace(/\/$/, "")),
    (t.removeTrailingSlash || r.pathname === "/") &&
      r.hash === "" &&
      t.removeSingleSlash &&
      (e = e.replace(/\/$/, "")),
    i && !t.normalizeProtocol && (e = e.replace(/^http:\/\//, "//")),
    t.stripProtocol && (e = e.replace(/^(?:https?:)?\/\//, "")),
    e
  );
}
var wK = class {
    constructor({ url: e, context: t }, i, r, s) {
      if (
        ((this.controlsManager = i),
        (this.shared = r),
        (this.condition = s),
        !e)
      )
        throw new Error("Missing property");
      (this.url = e.startsWith("mailto:")
        ? e
        : bK(e, { removeTrailingSlash: !1, removeSingleSlash: !1 })),
        (this.context = t ?? "tab");
    }
    dispatch() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      Xx
        ? window.location.assign(this.url)
        : (this.context === "tab"
            ? window.open(this.url, "_blank")
            : this.context === "window"
            ? window.open(
                this.url,
                "_blank",
                `width=${window.innerWidth}, height=${window.innerHeight}`
              )
            : window.open(this.url, "_parent"),
          this.controlsManager.orbitControls?.onPointerUp(Pt[0]),
          VH());
    }
  },
  YP = class {
    constructor(e, t, i, r, s) {
      (this.data = e),
        (this.page = t),
        (this.controlsManager = i),
        (this.shared = r),
        (this.condition = s),
        (this.timeoutIdQueue = []),
        (this.dispatchInner = () => {
          this.objects.forEach(this.destroyCallback);
        }),
        (this.destroyCallback = (a) => {
          this.timeoutIdQueue.shift();
          let n = this.page.scene.find(a);
          if (n === void 0) return;
          let o = this.controlsManager.sharedGameControlGlobals.rapierWorld,
            l = o ? n.dataPatched.physics?.fusedBody : !0;
          if (n.cloner) {
            for (let h of n.cloner.children)
              l
                ? ((h.playModeVisible = !1),
                  h.rigidBody &&
                    n.dataPatched.physics?.rigidBody === "positioned" &&
                    (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                      h.rigidBody.collider(0).handle
                    ),
                    o.removeRigidBody(h.rigidBody),
                    (h.rigidBody = void 0)),
                  h.bvhGeometry && (h.bvhGeometry = void 0))
                : this.clone === void 0 || this.clone === h
                ? ((h.playModeVisible = !1),
                  h.rigidBody &&
                    (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                      h.rigidBody.collider(0).handle
                    ),
                    o.removeRigidBody(h.rigidBody),
                    (h.rigidBody = void 0)))
                : h.playModeVisible === void 0 && (h.playModeVisible = !0);
            (l || this.clone === void 0 || this.clone === !1) &&
              ((n.visible = !1),
              n.rigidBody &&
                (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                  n.rigidBody.collider(0).handle
                ),
                o.removeRigidBody(n.rigidBody),
                (n.rigidBody = void 0)),
              n.bvhGeometry && (n.bvhGeometry = void 0));
          } else
            n.rigidBody &&
              (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(
                n.rigidBody.collider(0).handle
              ),
              o.removeRigidBody(n.rigidBody),
              (n.rigidBody = void 0)),
              n.bvhGeometry && (n.bvhGeometry = void 0),
              (n.visible = !1);
          o === void 0
            ? (this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim =
                this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(
                  (h) => h.bvhGeometry !== void 0
                ))
            : (this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim =
                this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(
                  (h) => h.rigidBody !== void 0
                )),
            (n.destroyedInAction = !0),
            this.controlsManager.requestRender();
        }),
        (this.objects = [...e.objects]);
    }
    dispatch(e) {
      if (Xi(this.shared, this.condition) === !1) return !1;
      (this.clone = e),
        this.data.delay
          ? this.timeoutIdQueue.push(
              window.setTimeout(this.dispatchInner, this.data.delay * 1e3)
            )
          : this.dispatchInner();
    }
    dispatchFromStart() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.timeoutIdQueue.push(
        window.setTimeout(this.dispatchInner, this.data.delay * 1e3)
      );
    }
    dispose() {
      this.timeoutIdQueue.forEach((e) => window.clearTimeout(e));
    }
  },
  XP = class {
    constructor(e, t, i, r, s) {
      (this.data = e),
        (this.page = t),
        (this.shared = i),
        (this.eventManager = r),
        (this.condition = s),
        (this.shared = i);
    }
    dispatch() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      clearTimeout(this.timeoutId),
        delete this.timeoutId,
        (this.timeoutId = window.setTimeout(() => {
          this.shared.reset(this.shared.data, !0),
            Yb(this.page, this.shared, !0),
            this.eventManager.reset(),
            this.eventManager.controlsManager.gameControl?.reset(!0),
            this.page.switchToPlayCamera(),
            this.eventManager.controlsManager.requestRender(),
            delete this.timeoutId;
        }, (this.data.delay ?? 0) * 1e3));
    }
    dispose() {
      clearTimeout(this.timeoutId), delete this.timeoutId;
    }
  },
  QP = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    timelineChangeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: "normal",
    autoplay: !0,
    timelineOffset: 0,
    rewind: !0,
  },
  Fb = {
    duration: 1e3,
    delay: 0,
    endDelay: 0,
    startOnceDelay: 0,
    pingPongDelayCorrection: 0,
    pingPongEndDelayCorrection: 0,
    easing: "easeOutElastic(1, .5)",
    round: 0,
  },
  _K = [
    "translateX",
    "translateY",
    "translateZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "matrix3d",
  ],
  mg = { CSS: {}, springs: {} };
function qa(e, t, i) {
  return Math.min(Math.max(e, t), i);
}
function Pd(e, t) {
  return e.indexOf(t) > -1;
}
function q0(e, t) {
  return e.apply(null, t);
}
var Ot = {
  arr: function (e) {
    return Array.isArray(e);
  },
  obj: function (e) {
    return Pd(Object.prototype.toString.call(e), "Object");
  },
  pth: function (e) {
    return Ot.obj(e) && e.hasOwnProperty("totalLength");
  },
  svg: function (e) {
    return e instanceof SVGElement;
  },
  inp: function (e) {
    return e instanceof HTMLInputElement;
  },
  dom: function (e) {
    return !("isNode" in e) && (e.nodeType || Ot.svg(e));
  },
  str: function (e) {
    return typeof e == "string";
  },
  fnc: function (e) {
    return typeof e == "function";
  },
  und: function (e) {
    return typeof e > "u";
  },
  hex: function (e) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e);
  },
  rgb: function (e) {
    return /^rgb/.test(e);
  },
  hsl: function (e) {
    return /^hsl/.test(e);
  },
  col: function (e) {
    return Ot.hex(e) || Ot.rgb(e) || Ot.hsl(e);
  },
  key: function (e) {
    return (
      !QP.hasOwnProperty(e) &&
      !Fb.hasOwnProperty(e) &&
      e !== "targets" &&
      e !== "keyframes"
    );
  },
};
function ZP(e) {
  var t = /\(([^)]+)\)/.exec(e);
  return t
    ? t[1].split(",").map(function (i) {
        return parseFloat(i);
      })
    : [];
}
function KP(e, t) {
  var i = ZP(e),
    r = qa(Ot.und(i[0]) ? 1 : i[0], 0.1, 100),
    s = qa(Ot.und(i[1]) ? 100 : i[1], 0.1, 100),
    a = qa(Ot.und(i[2]) ? 10 : i[2], 0.1, 100),
    n = qa(Ot.und(i[3]) ? 0 : i[3], 0.1, 100),
    o = Math.sqrt(s / r),
    l = a / (2 * Math.sqrt(s * r)),
    h = l < 1 ? o * Math.sqrt(1 - l * l) : 0,
    u = 1,
    c = l < 1 ? (l * o + -n) / h : -n + o;
  function d(f) {
    var m = t ? (t * f) / 1e3 : f;
    return (
      l < 1
        ? (m =
            Math.exp(-m * l * o) * (u * Math.cos(h * m) + c * Math.sin(h * m)))
        : (m = (u + c * m) * Math.exp(-m * o)),
      f === 0 || f === 1 ? f : 1 - m
    );
  }
  function p() {
    var f = mg.springs[e];
    if (f) return f;
    for (var m = 1 / 6, g = 0, y = 0; ; )
      if (((g += m), d(g) === 1)) {
        if ((y++, y >= 16)) break;
      } else y = 0;
    var x = g * m * 1e3;
    return (mg.springs[e] = x), x;
  }
  return t ? d : p;
}
function SK(e) {
  return (
    e === void 0 && (e = 10),
    function (t) {
      return Math.ceil(qa(t, 1e-6, 1) * e) * (1 / e);
    }
  );
}
var AK = (function () {
    var e = 11,
      t = 1 / (e - 1);
    function i(u, c) {
      return 1 - 3 * c + 3 * u;
    }
    function r(u, c) {
      return 3 * c - 6 * u;
    }
    function s(u) {
      return 3 * u;
    }
    function a(u, c, d) {
      return ((i(c, d) * u + r(c, d)) * u + s(c)) * u;
    }
    function n(u, c, d) {
      return 3 * i(c, d) * u * u + 2 * r(c, d) * u + s(c);
    }
    function o(u, c, d, p, f) {
      var m,
        g,
        y = 0;
      do (g = c + (d - c) / 2), (m = a(g, p, f) - u), m > 0 ? (d = g) : (c = g);
      while (Math.abs(m) > 1e-7 && ++y < 10);
      return g;
    }
    function l(u, c, d, p) {
      for (var f = 0; f < 4; ++f) {
        var m = n(c, d, p);
        if (m === 0) return c;
        var g = a(c, d, p) - u;
        c -= g / m;
      }
      return c;
    }
    function h(u, c, d, p) {
      if (!(0 <= u && u <= 1 && 0 <= d && d <= 1)) return;
      var f = new Float32Array(e);
      if (u !== c || d !== p) for (var m = 0; m < e; ++m) f[m] = a(m * t, u, d);
      function g(y) {
        for (var x = 0, b = 1, _ = e - 1; b !== _ && f[b] <= y; ++b) x += t;
        --b;
        var S = (y - f[b]) / (f[b + 1] - f[b]),
          M = x + S * t,
          C = n(M, u, d);
        return C >= 0.001 ? l(y, M, u, d) : C === 0 ? M : o(y, x, x + t, u, d);
      }
      return function (y) {
        return (u === c && d === p) || y === 0 || y === 1 ? y : a(g(y), c, p);
      };
    }
    return h;
  })(),
  JP = (function () {
    var e = {
        linear: function () {
          return function (r) {
            return r;
          };
        },
      },
      t = {
        Sine: function () {
          return function (r) {
            return 1 - Math.cos((r * Math.PI) / 2);
          };
        },
        Circ: function () {
          return function (r) {
            return 1 - Math.sqrt(1 - r * r);
          };
        },
        Back: function () {
          return function (r) {
            return r * r * (3 * r - 2);
          };
        },
        Bounce: function () {
          return function (r) {
            for (var s, a = 4; r < ((s = Math.pow(2, --a)) - 1) / 11; );
            return (
              1 / Math.pow(4, 3 - a) -
              7.5625 * Math.pow((s * 3 - 2) / 22 - r, 2)
            );
          };
        },
        Elastic: function (r, s) {
          r === void 0 && (r = 1), s === void 0 && (s = 0.5);
          var a = qa(r, 1, 10),
            n = qa(s, 0.1, 2);
          return function (o) {
            return o === 0 || o === 1
              ? o
              : -a *
                  Math.pow(2, 10 * (o - 1)) *
                  Math.sin(
                    ((o - 1 - (n / (Math.PI * 2)) * Math.asin(1 / a)) *
                      (Math.PI * 2)) /
                      n
                  );
          };
        },
      },
      i = ["Quad", "Cubic", "Quart", "Quint", "Expo"];
    return (
      i.forEach(function (r, s) {
        t[r] = function () {
          return function (a) {
            return Math.pow(a, s + 2);
          };
        };
      }),
      Object.keys(t).forEach(function (r) {
        var s = t[r];
        (e["easeIn" + r] = s),
          (e["easeOut" + r] = function (a, n) {
            return function (o) {
              return 1 - s(a, n)(1 - o);
            };
          }),
          (e["easeInOut" + r] = function (a, n) {
            return function (o) {
              return o < 0.5 ? s(a, n)(o * 2) / 2 : 1 - s(a, n)(o * -2 + 2) / 2;
            };
          });
      }),
      e
    );
  })();
function kb(e, t) {
  if (Ot.fnc(e)) return e;
  var i = e.split("(")[0],
    r = JP[i],
    s = ZP(e);
  switch (i) {
    case "spring":
      return KP(e, t);
    case "cubicBezier":
      return q0(AK, s);
    case "steps":
      return q0(SK, s);
    default:
      return q0(r, s);
  }
}
function $P(e) {
  try {
    var t = document.querySelectorAll(e);
    return t;
  } catch {
    return;
  }
}
function jg(e, t) {
  for (
    var i = e.length,
      r = arguments.length >= 2 ? arguments[1] : void 0,
      s = [],
      a = 0;
    a < i;
    a++
  )
    if (a in e) {
      var n = e[a];
      t.call(r, n, a, e) && s.push(n);
    }
  return s;
}
function Hg(e) {
  return e.reduce(function (t, i) {
    return t.concat(Ot.arr(i) ? Hg(i) : i);
  }, []);
}
function YM(e) {
  return Ot.arr(e)
    ? e
    : (Ot.str(e) && (e = $P(e) || e),
      e instanceof NodeList || e instanceof HTMLCollection
        ? [].slice.call(e)
        : [e]);
}
function Nb(e, t) {
  return e.some(function (i) {
    return i === t;
  });
}
function Ub(e) {
  var t = {};
  for (var i in e) t[i] = e[i];
  return t;
}
function ax(e, t) {
  var i = Ub(e);
  for (var r in e) i[r] = t.hasOwnProperty(r) ? t[r] : e[r];
  return i;
}
function Gg(e, t) {
  var i = Ub(e);
  for (var r in t) i[r] = Ot.und(e[r]) ? t[r] : e[r];
  return i;
}
function MK(e) {
  var t = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(e);
  return t ? "rgba(" + t[1] + ",1)" : e;
}
function EK(e) {
  var t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
    i = e.replace(t, function (o, l, h, u) {
      return l + l + h + h + u + u;
    }),
    r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i),
    s = parseInt(r[1], 16),
    a = parseInt(r[2], 16),
    n = parseInt(r[3], 16);
  return "rgba(" + s + "," + a + "," + n + ",1)";
}
function CK(e) {
  var t =
      /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e) ||
      /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e),
    i = parseInt(t[1], 10) / 360,
    r = parseInt(t[2], 10) / 100,
    s = parseInt(t[3], 10) / 100,
    a = t[4] || 1;
  function n(d, p, f) {
    return (
      f < 0 && (f += 1),
      f > 1 && (f -= 1),
      f < 1 / 6
        ? d + (p - d) * 6 * f
        : f < 1 / 2
        ? p
        : f < 2 / 3
        ? d + (p - d) * (2 / 3 - f) * 6
        : d
    );
  }
  var o, l, h;
  if (r == 0) o = l = h = s;
  else {
    var u = s < 0.5 ? s * (1 + r) : s + r - s * r,
      c = 2 * s - u;
    (o = n(c, u, i + 1 / 3)), (l = n(c, u, i)), (h = n(c, u, i - 1 / 3));
  }
  return "rgba(" + o * 255 + "," + l * 255 + "," + h * 255 + "," + a + ")";
}
function TK(e) {
  if (Ot.rgb(e)) return MK(e);
  if (Ot.hex(e)) return EK(e);
  if (Ot.hsl(e)) return CK(e);
}
function _o(e) {
  var t =
    /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
      e
    );
  if (t) return t[1];
}
function PK(e) {
  if (Pd(e, "translate") || e === "perspective") return "px";
  if (Pd(e, "rotate") || Pd(e, "skew")) return "deg";
}
function nx(e, t) {
  return Ot.fnc(e) ? e(t.target, t.id, t.total) : e;
}
function Cn(e, t) {
  return e.getAttribute(t);
}
function Vb(e, t, i) {
  var r = _o(t);
  if (Nb([i, "deg", "rad", "turn"], r)) return t;
  var s = mg.CSS[t + i];
  if (!Ot.und(s)) return s;
  var a = 100,
    n = document.createElement(e.tagName),
    o =
      e.parentNode && e.parentNode !== document ? e.parentNode : document.body;
  o.appendChild(n), (n.style.position = "absolute"), (n.style.width = a + i);
  var l = a / n.offsetWidth;
  o.removeChild(n);
  var h = l * parseFloat(t);
  return (mg.CSS[t + i] = h), h;
}
function eD(e, t, i) {
  if (t in e.style) {
    var r = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
      s = e.style[t] || getComputedStyle(e).getPropertyValue(r) || "0";
    return i ? Vb(e, s, i) : s;
  }
}
function jb(e, t) {
  if (Ot.dom(e) && !Ot.inp(e) && (Cn(e, t) || (Ot.svg(e) && e[t])))
    return "attribute";
  if (Ot.dom(e) && Nb(_K, t)) return "transform";
  if (Ot.dom(e) && t !== "transform" && eD(e, t)) return "css";
  if (e[t] != null) return "object";
}
function tD(e) {
  if (Ot.dom(e)) {
    for (
      var t = e.style.transform || "",
        i = /(\w+)\(([^)]*)\)/g,
        r = new Map(),
        s;
      (s = i.exec(t));

    )
      r.set(s[1], s[2]);
    return r;
  }
}
function DK(e, t, i, r) {
  var s = Pd(t, "scale") ? 1 : 0 + PK(t),
    a = tD(e).get(t) || s;
  return (
    i && (i.transforms.list.set(t, a), (i.transforms.last = t)),
    r ? Vb(e, a, r) : a
  );
}
function Hb(e, t, i, r) {
  switch (jb(e, t)) {
    case "transform":
      return DK(e, t, r, i);
    case "css":
      return eD(e, t, i);
    case "attribute":
      return Cn(e, t);
    default:
      return e[t] || 0;
  }
}
function Gb(e, t) {
  var i = /^(\*=|\+=|-=)/.exec(e);
  if (!i) return e;
  var r = _o(e) || 0,
    s = parseFloat(t),
    a = parseFloat(e.replace(i[0], ""));
  switch (i[0][0]) {
    case "+":
      return s + a + r;
    case "-":
      return s - a + r;
    case "*":
      return s * a + r;
  }
}
function iD(e, t) {
  if (Ot.col(e)) return TK(e);
  if (/\s/g.test(e)) return e;
  var i = _o(e),
    r = i ? e.substr(0, e.length - i.length) : e;
  return t ? r + t : r;
}
function Wb(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function OK(e) {
  return Math.PI * 2 * Cn(e, "r");
}
function IK(e) {
  return Cn(e, "width") * 2 + Cn(e, "height") * 2;
}
function RK(e) {
  return Wb(
    { x: Cn(e, "x1"), y: Cn(e, "y1") },
    { x: Cn(e, "x2"), y: Cn(e, "y2") }
  );
}
function rD(e) {
  for (var t = e.points, i = 0, r, s = 0; s < t.numberOfItems; s++) {
    var a = t.getItem(s);
    s > 0 && (i += Wb(r, a)), (r = a);
  }
  return i;
}
function LK(e) {
  var t = e.points;
  return rD(e) + Wb(t.getItem(t.numberOfItems - 1), t.getItem(0));
}
function sD(e) {
  if (e.getTotalLength) return e.getTotalLength();
  switch (e.tagName.toLowerCase()) {
    case "circle":
      return OK(e);
    case "rect":
      return IK(e);
    case "line":
      return RK(e);
    case "polyline":
      return rD(e);
    case "polygon":
      return LK(e);
  }
}
function BK(e) {
  var t = sD(e);
  return e.setAttribute("stroke-dasharray", t), t;
}
function zK(e) {
  for (var t = e.parentNode; Ot.svg(t) && Ot.svg(t.parentNode); )
    t = t.parentNode;
  return t;
}
function aD(e, t) {
  var i = t || {},
    r = i.el || zK(e),
    s = r.getBoundingClientRect(),
    a = Cn(r, "viewBox"),
    n = s.width,
    o = s.height,
    l = i.viewBox || (a ? a.split(" ") : [0, 0, n, o]);
  return {
    el: r,
    viewBox: l,
    x: l[0] / 1,
    y: l[1] / 1,
    w: n / l[2],
    h: o / l[3],
  };
}
function FK(e, t) {
  var i = Ot.str(e) ? $P(e)[0] : e,
    r = t || 100;
  return function (s) {
    return { property: s, el: i, svg: aD(i), totalLength: sD(i) * (r / 100) };
  };
}
function kK(e, t) {
  function i(o) {
    o === void 0 && (o = 0);
    var l = t + o >= 1 ? t + o : 0;
    return e.el.getPointAtLength(l);
  }
  var r = aD(e.el, e.svg),
    s = i(),
    a = i(-1),
    n = i(1);
  switch (e.property) {
    case "x":
      return (s.x - r.x) * r.w;
    case "y":
      return (s.y - r.y) * r.h;
    case "angle":
      return (Math.atan2(n.y - a.y, n.x - a.x) * 180) / Math.PI;
  }
}
function XM(e, t) {
  var i = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
    r = iD(Ot.pth(e) ? e.totalLength : e, t) + "";
  return {
    original: r,
    numbers: r.match(i) ? r.match(i).map(Number) : [0],
    strings: Ot.str(e) || t ? r.split(i) : [],
  };
}
function nD(e) {
  var t = e ? Hg(Ot.arr(e) ? e.map(YM) : YM(e)) : [];
  return jg(t, function (i, r, s) {
    return s.indexOf(i) === r;
  });
}
function oD(e) {
  var t = nD(e);
  return t.map(function (i, r) {
    return { target: i, id: r, total: t.length, transforms: { list: tD(i) } };
  });
}
function NK(e, t) {
  var i = Ub(t);
  if ((/^spring/.test(i.easing) && (i.duration = KP(i.easing)), Ot.arr(e))) {
    var r = e.length,
      s = r === 2 && !Ot.obj(e[0]);
    s
      ? (e = { value: e })
      : Ot.fnc(t.duration) || (i.duration = t.duration / r);
  }
  var a = Ot.arr(e) ? e : [e];
  return a
    .map(function (n, o) {
      var l = Ot.obj(n) && !Ot.pth(n) ? n : { value: n };
      return (
        Ot.und(l.delay) && (l.delay = o ? 0 : t.delay),
        Ot.und(l.endDelay) &&
          (l.endDelay = o === a.length - 1 ? t.endDelay : 0),
        l
      );
    })
    .map(function (n) {
      return Gg(n, i);
    });
}
function UK(e) {
  for (
    var t = jg(
        Hg(
          e.map(function (a) {
            return Object.keys(a);
          })
        ),
        function (a) {
          return Ot.key(a);
        }
      ).reduce(function (a, n) {
        return a.indexOf(n) < 0 && a.push(n), a;
      }, []),
      i = {},
      r = function (a) {
        var n = t[a];
        i[n] = e.map(function (o) {
          var l = {};
          for (var h in o)
            Ot.key(h) ? h == n && (l.value = o[h]) : (l[h] = o[h]);
          return l;
        });
      },
      s = 0;
    s < t.length;
    s++
  )
    r(s);
  return i;
}
function VK(e, t) {
  var i = [],
    r = t.keyframes;
  r && (t = Gg(UK(r), t));
  for (var s in t) Ot.key(s) && i.push({ name: s, tweens: NK(t[s], e) });
  return i;
}
function jK(e, t) {
  var i = {};
  for (var r in e) {
    var s = nx(e[r], t);
    Ot.arr(s) &&
      ((s = s.map(function (a) {
        return nx(a, t);
      })),
      s.length === 1 && (s = s[0])),
      (i[r] = s);
  }
  return (
    (i.duration = parseFloat(i.duration)), (i.delay = parseFloat(i.delay)), i
  );
}
function HK(e, t) {
  var i;
  return e.tweens.map(function (r) {
    var s = jK(r, t),
      a = s.value,
      n = Ot.arr(a) ? a[1] : a,
      o = _o(n),
      l = Hb(t.target, e.name, o, t),
      h = i ? i.to.original : l,
      u = Ot.arr(a) ? a[0] : h,
      c = _o(u) || _o(l),
      d = o || c;
    return (
      Ot.und(n) && (n = h),
      (s.from = XM(u, d)),
      (s.to = XM(Gb(n, u), d)),
      (s.start = i ? i.end : 0),
      (s.end = s.start + s.delay + s.duration + s.endDelay),
      (s.easing = kb(s.easing, s.duration)),
      (s.isPath = Ot.pth(a)),
      (s.isColor = Ot.col(s.from.original)),
      s.isColor && (s.round = 1),
      (i = s),
      s
    );
  });
}
var lD = {
  css: function (e, t, i) {
    return (e.style[t] = i);
  },
  attribute: function (e, t, i) {
    return e.setAttribute(t, i);
  },
  object: function (e, t, i) {
    return (e[t] = i);
  },
  transform: function (e, t, i, r, s) {
    if ((r.list.set(t, i), t === r.last || s)) {
      var a = "";
      r.list.forEach(function (n, o) {
        a += o + "(" + n + ") ";
      }),
        (e.style.transform = a);
    }
  },
};
function hD(e, t) {
  var i = oD(e);
  i.forEach(function (r) {
    for (var s in t) {
      var a = nx(t[s], r),
        n = r.target,
        o = _o(a),
        l = Hb(n, s, o, r),
        h = o || _o(l),
        u = Gb(iD(a, h), l),
        c = jb(n, s);
      lD[c](n, s, u, r.transforms, !0);
    }
  });
}
function GK(e, t) {
  var i = jb(e.target, t.name);
  if (i) {
    var r = HK(t, e),
      s = r[r.length - 1];
    return {
      type: i,
      property: t.name,
      animatable: e,
      tweens: r,
      duration: s.end,
      delay: r[0].delay,
      endDelay: s.endDelay,
    };
  }
}
function WK(e, t) {
  return jg(
    Hg(
      e.map(function (i) {
        return t.map(function (r) {
          return GK(i, r);
        });
      })
    ),
    function (i) {
      return !Ot.und(i);
    }
  );
}
function cD(e, t) {
  var i = e.length,
    r = function (a) {
      return a.timelineOffset ? a.timelineOffset : 0;
    },
    s = {};
  return (
    (s.duration = i
      ? Math.max.apply(
          Math,
          e.map(function (a) {
            let n = a.startOnceDelay ?? 0,
              o = a.pingPongDelayCorrection ?? 0,
              l = a.pingPongEndDelayCorrection ?? 0;
            return r(a) + n + o + l + a.duration * (a.loop ?? 1);
          })
        )
      : t.duration),
    (s.delay = i
      ? Math.min.apply(
          Math,
          e.map(function (a) {
            let n = a.startOnceDelay ?? 0,
              o = a.pingPongDelayCorrection ?? 0;
            return r(a) + n + o + a.delay;
          })
        )
      : t.delay),
    (s.endDelay = i
      ? s.duration -
        Math.max.apply(
          Math,
          e.map(function (a) {
            let n = a.startOnceDelay ?? 0,
              o = a.pingPongDelayCorrection ?? 0,
              l = a.pingPongEndDelayCorrection ?? 0;
            return r(a) + n + o + a.duration * (a.loop ?? 1) - a.endDelay - l;
          })
        )
      : t.endDelay),
    s
  );
}
var QM = 0;
function qK(e) {
  var t = ax(QP, e),
    i = ax(Fb, e),
    r = VK(i, e),
    s = oD(e.targets),
    a = WK(s, r),
    n = cD(a, i),
    o = QM;
  return (
    QM++,
    Gg(t, {
      id: o,
      children: [],
      animatables: s,
      animations: a,
      duration: n.duration,
      delay: n.delay,
      endDelay: n.endDelay,
      startOnceDelay: i.startOnceDelay,
      pingPongDelayCorrection: i.pingPongDelayCorrection,
      pingPongEndDelayCorrection: i.pingPongEndDelayCorrection,
    })
  );
}
var Ea = [],
  ZM = [],
  pm,
  YK = (function () {
    function e() {
      pm = requestAnimationFrame(t);
    }
    function t(i) {
      var r = Ea.length;
      if (r) {
        for (var s = 0; s < r; ) {
          var a = Ea[s];
          a.paused ? (Ea.splice(s, 1), (r -= 1)) : (a.tick(i), s++);
        }
        e();
      } else pm = cancelAnimationFrame(pm);
    }
    return e;
  })();
function XK(e) {
  document.hidden
    ? (Ea.forEach(function (t) {
        return t.pause(e.timeStamp);
      }),
      (ZM = Ea.slice(0)),
      (cr.running = Ea = []))
    : ZM.forEach(function (t) {
        return t.play(e.timeStamp);
      });
}
typeof document < "u" && document.addEventListener("visibilitychange", XK);
function cr(e) {
  e === void 0 && (e = {});
  var t = 0,
    i = 0,
    r = 0,
    s,
    a,
    n = 0,
    o = null;
  function l(C) {
    var A =
      window.Promise &&
      new Promise(function (T) {
        return (o = T);
      });
    return (C.finished = A), A;
  }
  var h = qK(e),
    u = l(h);
  function c() {
    var C = h.direction;
    C !== "alternate" && (h.direction = C !== "normal" ? "normal" : "reverse"),
      (h.reversed = !h.reversed),
      a.forEach(function (A) {
        (A.loop === 1 || A.loop % 2 === 0) && (A.reversed = h.reversed);
      });
  }
  function d() {
    (h.direction = "normal"),
      (h.reversed = !1),
      a.forEach(function (C) {
        return (C.reversed = !1);
      });
  }
  function p(C) {
    return h.reversed ? h.duration - C : C;
  }
  function f() {
    (t = 0), (i = p(h.currentTime) * (1 / cr.speed));
  }
  function m(C, A, T = !1) {
    A &&
      (h.reversed
        ? A.seek(
            A.duration * A.loop -
              (C - A.timelineOffset - A.pingPongDelayCorrection),
            T
          )
        : A.seek(
            C - A.timelineOffset - A.startOnceDelay - A.pingPongDelayCorrection,
            T
          ));
  }
  function g(C, A = !1) {
    if (h.reversed) for (var T = n; T--; ) m(C, a[T], A);
    else for (var P = 0; P < n; P++) m(C, a[P], A);
  }
  function y(C) {
    var A = 0,
      T = h.animations,
      P = T.length;
    for (
      h.direction !== "alternate" && h.parent?.direction === "alternate"
        ? h.parent?.rewind === !1 &&
          h.reversePlayback === !0 &&
          h.rewind === !1 &&
          (h.parent?.reversed && h.direction === "alternate"
            ? (C = h.duration - h.delay + h.endDelay - C)
            : (C = h.duration + h.delay - h.endDelay - C))
        : S(
            !1,
            h.parent?.rewind,
            h.rewind,
            h.parent?.reversePlayback,
            h.reversePlayback
          ) &&
          (h.parent?.reversed && h.direction === "alternate"
            ? (C = h.duration - h.delay + h.endDelay - C)
            : (C = h.duration + h.delay - h.endDelay - C));
      A < P;

    ) {
      var R = T[A],
        z = R.animatable,
        N = R.tweens,
        L = N.length - 1,
        G = N[L];
      L &&
        (G =
          jg(N, function (ye) {
            return C < ye.end;
          })[0] || G);
      let Ae;
      h.parent?.reversed && h.direction === "alternate"
        ? (Ae = qa(C - G.start - G.endDelay, 0, G.duration) / G.duration)
        : (Ae = qa(C - G.start - G.delay, 0, G.duration) / G.duration);
      for (
        var Y = isNaN(Ae) ? 1 : G.easing(Ae),
          Z = G.to.strings,
          q = G.round,
          oe = [],
          ce = G.to.numbers.length,
          ie = void 0,
          te = 0;
        te < ce;
        te++
      ) {
        var ue = void 0;
        let ye, Ue;
        h.direction !== "alternate"
          ? h.parent?.rewind === !1 &&
            h.reversePlayback === !0 &&
            h.rewind === !1
            ? ((ye = G.to.numbers[te]), (Ue = G.from.numbers[te] || 0))
            : ((Ue = G.to.numbers[te]), (ye = G.from.numbers[te] || 0))
          : S(
              !0,
              h.parent?.rewind,
              h.rewind,
              h.parent?.reversePlayback,
              h.reversePlayback
            )
          ? ((ye = G.to.numbers[te]), (Ue = G.from.numbers[te] || 0))
          : ((Ue = G.to.numbers[te]), (ye = G.from.numbers[te] || 0)),
          G.isPath ? (ue = kK(G.value, Y * Ue)) : (ue = ye + Y * (Ue - ye)),
          q && ((G.isColor && te > 2) || (ue = Math.round(ue * q) / q)),
          oe.push(ue);
      }
      var ae = Z.length;
      if (!ae) ie = oe[0];
      else {
        ie = Z[0];
        for (var de = 0; de < ae; de++) {
          var ne = Z[de],
            Ee = Z[de + 1],
            me = oe[de];
          isNaN(me) || (Ee ? (ie += me + Ee) : (ie += me + " "));
        }
      }
      lD[R.type](z.target, R.property, ie, z.transforms),
        (R.currentValue = ie),
        A++;
    }
  }
  function x(C) {
    h[C] && !h.passThrough && h[C](h);
  }
  function b() {
    h.remaining && h.remaining !== !0 && h.remaining--;
  }
  let _ = {
    0: !1,
    1: !0,
    2: !1,
    3: !0,
    4: !1,
    5: !1,
    6: !1,
    7: !1,
    8: !1,
    9: !0,
    10: !0,
    11: !1,
    12: !1,
    13: !1,
    14: !0,
    15: !0,
    16: !1,
    17: !0,
    18: !0,
    19: !1,
    20: !1,
    21: !1,
    22: !0,
    23: !0,
    24: !1,
    25: !0,
    26: !1,
    27: !0,
    28: !1,
    29: !1,
    30: !1,
    31: !1,
  };
  function S(C, A, T, P, R) {
    return _[(C << 4) | (A << 3) | (T << 2) | (P << 1) | R];
  }
  function M(C, A = !1) {
    var T = h.duration;
    let P = h.delay,
      R = T - h.endDelay;
    h.parent?.reversed &&
      h.direction === "alternate" &&
      ((P = h.endDelay), (R = T - h.delay));
    var z = p(C);
    if (
      ((h.progress = qa((z / T) * 100, 0, 100)),
      A || (h.reversePlayback = z < h.currentTime),
      n && g(z, A),
      !h.began && h.currentTime >= 0 && ((h.began = !0), x("begin")),
      !h.loopBegan && h.currentTime > 0 && ((h.loopBegan = !0), x("loopBegin")),
      (h.reversed || z >= 0) &&
        z <= P &&
        h.currentTime !== 0 &&
        (y(0), x("change")),
      ((z >= R && h.currentTime !== T + h.pingPongDelayCorrection) || !T) &&
        (y(T), x("change")),
      z > P && z < R
        ? (h.changeBegan ||
            ((h.changeBegan = !0), (h.changeCompleted = !1), x("changeBegin")),
          y(z),
          x("change"))
        : h.changeBegan
        ? ((h.changeCompleted = !0),
          (h.changeBegan = !1),
          x("change"),
          n && x("timelineChangeComplete"))
        : h.began && z > R && x("changeComplete"),
      (h.currentTime = qa(z, 0, T + h.pingPongDelayCorrection)),
      h.began && x("update"),
      C >= T)
    )
      if ((b(), !h.remaining))
        (h.paused = !0),
          h.completed ||
            ((h.completed = !0),
            x("loopComplete"),
            x("complete"),
            !h.passThrough && "Promise" in window && (o(), (u = l(h))));
      else {
        n ? (t += h.duration / cr.speed) : (t += h.duration);
        for (let N of a) N.setStartTime(0), (N.remaining = N.loop);
        x("loopComplete"),
          (h.loopBegan = !1),
          h.direction === "alternate" ? c() : n && d();
      }
  }
  return (
    (h.reset = function () {
      var C = h.direction;
      (h.passThrough = !1),
        (h.currentTime = 0),
        (h.progress = 0),
        (h.paused = !0),
        (h.began = !1),
        (h.loopBegan = !1),
        (h.changeBegan = !1),
        (h.completed = !1),
        (h.changeCompleted = !1),
        (h.reversePlayback = !1),
        (h.reversed = C === "reverse"),
        (h.remaining = h.loop),
        (a = h.children),
        (n = a.length);
      for (var A = n; A--; ) h.children[A].reset();
      y(h.reversed ? h.duration : 0);
    }),
    (h.setStartTime = function (C) {
      t = C;
    }),
    (h.set = function (C, A) {
      return hD(C, A), h;
    }),
    (h.tick = function (C) {
      (r = C), t || (t = r), M((r + (i - t)) * cr.speed);
    }),
    (h.seek = function (C, A = !1) {
      M(C - t, A);
    }),
    (h.pause = function (C) {
      (h.paused = !0), n && (s = C ?? performance.now());
    }),
    (h.play = function (C) {
      !h.paused ||
        (h.completed && h.reset(),
        (h.paused = !1),
        Ea.push(h),
        n && s !== void 0 && (t += (C ?? performance.now()) - s),
        pm || YK());
    }),
    (h.reverse = function () {
      c(), (h.completed = !h.reversed), f();
    }),
    (h.restart = function () {
      h.reset(), h.play();
    }),
    h.reset(),
    h.autoplay && h.play(),
    h
  );
}
function KM(e, t) {
  for (var i = t.length; i--; ) Nb(e, t[i].animatable.target) && t.splice(i, 1);
}
function QK(e) {
  for (var t = nD(e), i = Ea.length; i--; ) {
    var r = Ea[i],
      s = r.animations,
      a = r.children;
    KM(t, s);
    for (var n = a.length; n--; ) {
      var o = a[n],
        l = o.animations;
      KM(t, l), !l.length && !o.children.length && a.splice(n, 1);
    }
    !s.length && !a.length && r.pause();
  }
}
function ZK(e, t) {
  t === void 0 && (t = {});
  var i = t.direction || "normal",
    r = t.easing ? kb(t.easing) : null,
    s = t.grid,
    a = t.axis,
    n = t.from || 0,
    o = n === "first",
    l = n === "center",
    h = n === "last",
    u = Ot.arr(e),
    c = parseFloat(u ? e[0] : e),
    d = u ? parseFloat(e[1]) : 0,
    p = _o(u ? e[1] : e) || 0,
    f = t.start || 0 + (u ? c : 0),
    m = [],
    g = 0;
  return function (y, x, b) {
    if ((o && (n = 0), l && (n = (b - 1) / 2), h && (n = b - 1), !m.length)) {
      for (var _ = 0; _ < b; _++) {
        if (!s) m.push(Math.abs(n - _));
        else {
          var S = l ? (s[0] - 1) / 2 : n % s[0],
            M = l ? (s[1] - 1) / 2 : Math.floor(n / s[0]),
            C = _ % s[0],
            A = Math.floor(_ / s[0]),
            T = S - C,
            P = M - A,
            R = Math.sqrt(T * T + P * P);
          a === "x" && (R = -T), a === "y" && (R = -P), m.push(R);
        }
        g = Math.max.apply(Math, m);
      }
      r &&
        (m = m.map(function (N) {
          return r(N / g) * g;
        })),
        i === "reverse" &&
          (m = m.map(function (N) {
            return a ? (N < 0 ? N * -1 : -N) : Math.abs(g - N);
          }));
    }
    var z = u ? (d - c) / g : c;
    return f + z * (Math.round(m[x] * 100) / 100) + p;
  };
}
function KK(e) {
  e === void 0 && (e = {});
  var t = cr(e);
  return (
    (t.duration = 0),
    (t.add = function (i, r) {
      var s = Ea.indexOf(t),
        a = t.children;
      s > -1 && Ea.splice(s, 1);
      function n(d) {
        d.passThrough = !0;
      }
      for (var o = 0; o < a.length; o++) n(a[o]);
      var l = Gg(i, ax(Fb, e));
      l.targets = l.targets || e.targets;
      var h = t.duration;
      (l.autoplay = !1), (l.timelineOffset = Ot.und(r) ? h : Gb(r, h)), n(t);
      var u = cr(l);
      n(u), a.push(u), (u.parent = t);
      var c = cD(a, e);
      return (
        (t.delay = c.delay),
        (t.endDelay = c.endDelay),
        (t.duration = c.duration),
        u.loop === !0 && (t.duration = 1 / 0),
        t.seek(0),
        t.reset(),
        t.autoplay && t.play(),
        t
      );
    }),
    t
  );
}
cr.version = "3.2.0";
cr.speed = 1;
cr.running = Ea;
cr.remove = QK;
cr.get = Hb;
cr.set = hD;
cr.convertPx = Vb;
cr.path = FK;
cr.setDashoffset = BK;
cr.stagger = ZK;
cr.timeline = KK;
cr.easing = kb;
cr.penner = JP;
cr.random = function (e, t) {
  return Math.floor(Math.random() * (t - e + 1)) + e;
};
var uD = cr,
  JM = new I(),
  $M = new I(),
  eE = new Rt();
function JK(e, t, i, r) {
  if (r === 0) return i.copy(e);
  if (r === 1) return i.copy(t);
  let s = e.w * t.w + e.x * t.x + e.y * t.y + e.z * t.z;
  if (s >= 1) return i.copy(e);
  let a = 1 - s * s;
  if (a <= Number.EPSILON) {
    let u = 1 - r;
    return (
      (i.w = u * e.w + r * t.w),
      (i.x = u * e.x + r * t.x),
      (i.y = u * e.y + r * t.y),
      (i.z = u * e.z + r * t.z),
      i.normalize(),
      i
    );
  }
  let n = Math.sqrt(a),
    o = Math.atan2(n, s),
    l = Math.sin((1 - r) * o) / n,
    h = Math.sin(r * o) / n;
  return (
    (i.w = e.w * l + t.w * h),
    (i.x = e.x * l + t.x * h),
    (i.y = e.y * l + t.y * h),
    (i.z = e.z * l + t.z * h),
    i
  );
}
function is(e, t, i, r, s, a) {
  let n = i[e] ? i[e] : void 0,
    o = r[e];
  if (o == null) return;
  let l =
      n != null
        ? typeof n == "string"
          ? Number(s.getVariable(n) ?? 0)
          : n
        : t[e],
    h = typeof o == "string" ? Number(s.getVariable(o) ?? 0) : o;
  if (l !== h)
    return {
      update: (u) => {
        let c = dt.lerp(l, h, u);
        a ? (t[e] = Math.trunc(c)) : (t[e] = c);
      },
      start: () => {
        t[e] = l;
      },
      end: () => {
        t[e] = h;
      },
    };
}
function qb(e, t, i, r, s, a) {
  let n = i[e] ? i[e] : void 0,
    o = r[e];
  if (!o) return;
  let l = t[e],
    h = [...(n ?? l)].map((c) =>
      typeof c == "string" ? Number(s.getVariable(c) ?? 0) : c
    ),
    u = [...o].map((c) =>
      typeof c == "string" ? Number(s.getVariable(c) ?? 0) : c
    );
  if (!(h.length !== u.length || dT(h, u)))
    return {
      update: (c) => {
        h.forEach((d, p) => {
          let f = dt.lerp(d, u[p], c);
          t[e][p] = a ? Math.trunc(f) : f;
        });
      },
      start: () => {
        Object.assign(t[e], h);
      },
      end: () => {
        Object.assign(t[e], u);
      },
    };
}
function gg(e, t, i) {
  return (
    t.forEach((r, s) => {
      e.setComponent(
        s,
        typeof r == "string" ? Number(i.getVariable(r) ?? 0) : r
      );
    }),
    e
  );
}
function tE(e, t, i, r, s) {
  let a = i[e] ? i[e] : void 0,
    n = r[e];
  if (!n) return;
  let o = t[e],
    l = a ? gg(new I(), a, s) : o.clone(),
    h = gg(new I(), n, s);
  if (!l.equals(h))
    return {
      update: (u) => {
        o.lerpVectors(l, h, u);
      },
      start: () => {
        o.copy(l);
      },
      end: () => {
        o.copy(h);
      },
    };
}
function iE(e, t, i) {
  return (
    t.forEach((r, s) => {
      e.setComponent(
        s,
        typeof r == "string" ? Number(i.getVariable(r) ?? 0) : r
      );
    }),
    e
  );
}
function ox(e, t, i, r, s) {
  let a = i[e] ? i[e] : void 0,
    n = r[e];
  if (!n) return;
  let o = t[e],
    l = !(o instanceof re),
    h = o instanceof re ? o : new re().fromArray(o),
    u = a ? iE(new re(), a, s) : h.clone(),
    c = iE(new re(), n, s);
  if (!u.equals(c))
    return {
      update: (d) => {
        h.lerpVectors(u, c, d), l && (t[e] = h.toArray());
      },
      start: () => {
        h.copy(u), l && (t[e] = h.toArray());
      },
      end: () => {
        h.copy(c), l && (t[e] = h.toArray());
      },
    };
}
function $K(e, t, i, r) {
  let s = i[e] ? i[e] : void 0,
    a = r[e];
  if (!a) return;
  let n = t[e],
    o = s ? new je().fromArray(s) : n.clone(),
    l = new I(),
    h = new Rt(),
    u = new I();
  o.decompose(l, h, u);
  let c = new je().fromArray(a),
    d = new I(),
    p = new Rt(),
    f = new I();
  if ((c.decompose(d, p, f), !o.equals(c)))
    return {
      update: (m) => {
        eE.slerpQuaternions(h, p, m),
          JM.lerpVectors(l, d, m),
          $M.lerpVectors(u, f, m),
          n.compose(JM, eE, $M);
      },
      start: () => {
        n.compose(l, h, u);
      },
      end: () => {
        n.compose(d, p, f);
      },
    };
}
function eJ(e, t, i, r, s) {
  let a = i[e] ? i[e] : void 0,
    n = r[e];
  if (!n) return;
  let o = t[e],
    l = a
      ? typeof a == "string"
        ? s.getColor(a).clone()
        : new Et().setRGB(a.r, a.g, a.b)
      : o.clone(),
    h =
      typeof n == "string"
        ? s.getColor(n).clone()
        : new Et().setRGB(n.r, n.g, n.b);
  if (l.equals(h)) return;
  let u = o.clone();
  return (
    (t[e] = u),
    {
      update: (c) => {
        u.lerpColors(l, h, c);
      },
      start: () => {
        u.copy(l);
      },
      end: () => {
        u.copy(h);
      },
    }
  );
}
function Jf(e, t, i, r, s) {
  let a = i[e] ? i[e] : void 0,
    n = r[e];
  if (!n) return;
  let o = t[e],
    l = new os(o.r, o.g, o.b, o.a),
    h = a
      ? typeof a == "string"
        ? s.getColor(a).clone()
        : new os(a.r, a.g, a.b, a.a)
      : l.clone(),
    u =
      typeof n == "string" ? s.getColor(n).clone() : new os(n.r, n.g, n.b, n.a);
  if (!h.equals(u))
    return {
      update: (c) => {
        l.lerpColors(h, u, c);
        let d = dt.lerp(h.a, u.a, c);
        (l.a = d), (t[e] = { r: l.r, g: l.g, b: l.b, a: l.a });
      },
      start: () => {
        l.copy(h);
      },
      end: () => {
        l.copy(u);
      },
    };
}
function yl(e, t, i, r, s) {
  if (typeof t[e] == "number") return is(e, t, i ?? {}, r, s);
  if (Array.isArray(t[e])) return qb(e, t, i ?? {}, r, s);
}
function tJ(e, t, i, r) {
  let s = [],
    a =
      e.cameraType === "OrthographicCamera"
        ? t.orthographic?.zoom
        : t.perspective?.zoom,
    n =
      e.cameraType === "OrthographicCamera"
        ? i.orthographic?.zoom
        : i.perspective?.zoom;
  if (n !== void 0) {
    let o = a ?? e.zoom,
      l = n;
    o !== l &&
      s.push({
        update: (h) => {
          (e.zoom = dt.lerp(o, l, h)), e.updateProjectionMatrix();
        },
        start: () => {
          (e.zoom = o), e.updateProjectionMatrix();
        },
        end: () => {
          (e.zoom = l), e.updateProjectionMatrix();
        },
      });
  }
  if (i.targetOffset !== void 0) {
    let o = is("targetOffset", e, t, i, r);
    o && s.push(o);
  }
  return s;
}
function iJ(e, t, i, r) {
  if (i.scaleBaked === void 0) return;
  let s = (t.scaleBaked ?? e.data.geometry.scaleBaked).map((o) =>
      typeof o == "string" ? Number(r.getVariable(o) ?? 0) : o
    ),
    a = i.scaleBaked.map((o) =>
      typeof o == "string" ? Number(r.getVariable(o) ?? 0) : o
    );
  if (ih.isEqual(s, a)) return;
  let n = [];
  return (
    n.push({
      update: (o) => {
        e.updateGeometryInteractions(
          {
            scaleBaked: [
              dt.lerp(s[0], a[0], o),
              dt.lerp(s[1], a[1], o),
              dt.lerp(s[2], a[2], o),
            ],
          },
          r
        ),
          e.invalidateDownstreamBooleanData();
      },
      start: () => {
        e.updateGeometryInteractions({ scaleBaked: s }, r),
          e.invalidateDownstreamBooleanData();
      },
      end: () => {
        e.updateGeometryInteractions({ scaleBaked: a }, r),
          e.invalidateDownstreamBooleanData();
      },
    }),
    n
  );
}
function rJ(e, t, i, r) {
  if (!i.extrusion) return;
  let s = e.extrusion,
    a = t.extrusion ?? {},
    n = i.extrusion,
    o = [];
  return (
    KT.forEach((l) => {
      let h = yl(l, s, a, n, r);
      h && o.push(h);
    }),
    o
  );
}
function sJ(e, t, i, r) {
  let s = [];
  if (!("geometry" in i)) return s;
  let a = e.geometry.userData.parameters,
    n = "geometry" in t ? t.geometry : {},
    o = i.geometry;
  if (e instanceof $d) {
    let l = iJ(e, n, o, r);
    l && s.push(...l);
  } else {
    let l = {};
    if (
      (Object.assign(l, bo(a, D2)),
      D2.forEach((h) => {
        let u = yl(h, l, n, o, r);
        u && s.push(u);
      }),
      e instanceof Ob)
    ) {
      Object.assign(l, { extrusion: { ...a.extrusion } });
      let h = rJ(l, n, o, r);
      h && s.push(...h);
    }
    s.length &&
      s.push({
        update: (h) => {
          e.updateGeometryInteractions(l, r), e.updateGeometryGroupsIfNeeded();
        },
        start: (h) => {
          e.updateGeometryInteractions(l, r), e.updateGeometryGroupsIfNeeded();
        },
        end: (h) => {
          e.updateGeometryInteractions(l, r), e.updateGeometryGroupsIfNeeded();
        },
      });
  }
  return s;
}
function aJ(e, t, i, r) {
  let s = [];
  if (i.intensity !== void 0) {
    let a = is("intensity", e, t, i, r);
    a && s.push(a);
  }
  if (i.color !== void 0) {
    let a = eJ("color", e, t, i, r);
    a && s.push(a);
  }
  return s;
}
function nJ(e, t, i, r) {
  let s = [];
  if (Array.isArray(e.material)) {
    if (!("materials" in i && i.materials)) return s;
    let a = "materials" in t && t.materials ? t.materials : [],
      n = i.materials;
    e.material.forEach((o, l) => {
      if (!n[l]) return;
      let h = a[l] ?? {},
        u = n[l];
      typeof h == "string" || typeof u == "string" || s.push(...rE(o, h, u, r));
    });
  } else {
    if (!("material" in i && i.material)) return s;
    let a = "material" in t && t.material ? t.material : {},
      n = i.material;
    if (typeof a == "string" || typeof n == "string") return s;
    s.push(...rE(e.material, a, n, r));
  }
  return s;
}
function rE(e, t, i, r) {
  let s = [],
    a = Ac(i, r) || (!!t.layers && Ac(t, r));
  s.push(mJ(e, a));
  for (let n of e.layers) {
    let o = t.layers?.data(n.uuid),
      l = i.layers.data(n.uuid);
    if (
      !l ||
      (n.type !== "light" && (!(n.visible ?? !0) || !(l.visible ?? !0)))
    )
      continue;
    let h = n.getNames().filter((u) => !XT.some((c) => u.includes(c)));
    for (let u of h)
      try {
        let c = n.getValue(u),
          d;
        if (u === "colors") d = pJ(n, o, l, u);
        else if (Array.isArray(c)) u === "steps" && (d = dJ(n, o, l, u));
        else if (typeof c == "number") d = oJ(n, o, l, u, r);
        else {
          if (typeof c == "boolean") continue;
          c instanceof re
            ? (d = lJ(n, o, l, u))
            : c instanceof I
            ? (d = hJ(n, o, l, u, r))
            : c instanceof os
            ? (d = uJ(n, o, l, u, r))
            : c instanceof Et
            ? (d = cJ(n, o, l, u, r))
            : "isTexture" in c && (d = fJ(n, o, l, u));
        }
        d && (Array.isArray(d) ? s.push(...d) : s.push(d));
      } catch (c) {
        console.error(`lerpMaterial: unexpected material layer for ${u}`, c);
      }
  }
  return s;
}
function oJ(e, t, i, r, s) {
  if (!e.hasValue(r) || !(r in i)) return;
  let a = t ? t[r] : e.getValue(r),
    n = i[r],
    o = typeof a == "string" ? Number(s.getVariable(a) ?? 0) : a,
    l = typeof n == "string" ? Number(s.getVariable(n) ?? 0) : n;
  if (o !== l)
    return {
      update: (h) => {
        e.setValue(r, dt.lerp(o, l, h));
      },
      start: () => {
        e.setValue(r, o);
      },
      end: () => {
        e.setValue(r, l);
      },
    };
}
function lJ(e, t, i, r) {
  if (!e.hasValue(r) || !(r in i)) return;
  let s = e.getValue(r),
    a = t ? new re().fromArray(t[r]) : s.clone(),
    n = new re().fromArray(i[r]);
  if (!a.equals(n))
    return {
      update: (o) => {
        s.lerpVectors(a, n, o);
      },
      start: () => {
        s.copy(a);
      },
      end: () => {
        s.copy(n);
      },
    };
}
function hJ(e, t, i, r, s) {
  if (!e.hasValue(r) || !(r in i)) return;
  let a = e.getValue(r),
    n = t ? t[r] : void 0,
    o = i[r],
    l = n ? gg(new I(), n, s) : a.clone(),
    h = gg(new I(), o, s);
  if (!l.equals(h))
    return {
      update: (u) => {
        a.lerpVectors(l, h, u);
      },
      start: () => {
        a.copy(l);
      },
      end: () => {
        a.copy(h);
      },
    };
}
function cJ(e, t, i, r, s) {
  if (!e.hasValue(r) || !(r in i)) return;
  let a = t ? t[r] : void 0,
    n = i[r],
    o = e.getValue(r),
    l = a
      ? typeof a == "string"
        ? s.getColor(a).clone()
        : new Et().setRGB(a.r, a.g, a.b)
      : o.clone(),
    h =
      typeof n == "string"
        ? s.getColor(n).clone()
        : new Et().setRGB(n.r, n.g, n.b);
  if (l.equals(h)) return;
  let u = o.clone();
  return {
    update: (c) => {
      e.getValue(r) !== u && e.setValue(r, u), u.lerpColors(l, h, c);
    },
    start: () => {
      u.copy(l);
    },
    end: () => {
      u.copy(h);
    },
  };
}
function uJ(e, t, i, r, s) {
  if (!e.hasValue(r) || !(r in i)) return;
  let a = t ? t[r] : void 0,
    n = i[r],
    o = e.getValue(r),
    l = a
      ? typeof a == "string"
        ? s.getColor(a).clone()
        : new Et().setRGB(a.r, a.g, a.b)
      : o.clone(),
    h =
      typeof n == "string" ? s.getColor(n).clone() : new os(n.r, n.g, n.b, n.a);
  if (l.equals(h)) return;
  let u = o.clone();
  return {
    update: (c) => {
      e.getValue(r) !== u && e.setValue(r, u), u.lerpColors(l, h, c);
    },
    start: () => {
      u.copy(l);
    },
    end: () => {
      u.copy(h);
    },
  };
}
function dJ(e, t, i, r = "steps") {
  if (!e.hasValue(r) || !(r in i)) return;
  let s = [],
    a = e.getValue(r),
    n = t ? t[r] : a,
    o = i[r];
  for (let l = 0; l < a.length; ++l) {
    let h = n[l],
      u = o[l];
    h !== u &&
      s.push({
        update: (c) => {
          a[l] = dt.lerp(h, u, c);
        },
        start: () => {
          a[l] = h;
        },
        end: () => {
          a[l] = u;
        },
      });
  }
  return s.length ? s : void 0;
}
function pJ(e, t, i, r = "colors") {
  if (!e.hasValue(r) || !(r in i)) return;
  let s = [],
    a = e.getValue(r),
    n = t ? t[r] : a.map((l) => l.toArray()),
    o = i[r];
  for (let l = 0; l < a.length; ++l) {
    let h = [...n[l]],
      u = [...o[l]];
    Hm.isEqual(h, u) ||
      s.push({
        update: (c) => {
          a[l].fromArray(Hm.lerp(h, u, c));
        },
        start: () => {
          a[l].fromArray(h);
        },
        end: () => {
          a[l].fromArray(u);
        },
      });
  }
  return s.length ? s : void 0;
}
function fJ(e, t, i, r = "texture") {
  if (!e.hasValue(r) || !(r in i)) return;
  let s = e.getNode("mat");
  if (!s) return;
  let a = t ? t[r] : s,
    n = i[r],
    o = [...a.repeat],
    l = [...a.offset],
    h = [...n.repeat],
    u = [...n.offset];
  if (!tl.isEqual(o, h) || !tl.isEqual(l, u))
    return {
      update: (c) => {
        (s.repeat = tl.lerp(o, h, c)),
          (s.offset = tl.lerp(l, u, c)),
          s.updateMatrix();
      },
      start: () => {
        (s.repeat = [...o]), (s.offset = [...l]), s.updateMatrix();
      },
      end: () => {
        (s.repeat = [...h]), (s.offset = [...u]), s.updateMatrix();
      },
    };
}
function mJ(e, t) {
  return {
    update: () => {
      e.transparent = t;
    },
  };
}
var Y0 = new I(),
  sE = new Ir();
function gJ(e, t, i, r, s) {
  let a = [],
    n,
    o,
    l,
    h,
    u,
    c,
    d;
  if (
    (e instanceof Rr
      ? ((n = ox("position", e, t, i, s)),
        n && a.push(n),
        (l = is("rotation", e, t, i, s)),
        l && a.push(l))
      : ((d = {
          slide:
            t.pathSnapping?.slide ??
            e.updatedPathSnapping?.slide ??
            e.dataPatched.pathSnapping?.slide ??
            0,
          offset:
            t.pathSnapping?.offset ??
            e.updatedPathSnapping?.offset ??
            e.dataPatched.pathSnapping?.offset ??
            0,
        }),
        (u = is(
          "slide",
          d,
          t.pathSnapping ?? e.updatedPathSnapping ?? e.dataPatched.pathSnapping,
          i.pathSnapping ?? e.dataPatched.pathSnapping,
          s
        )),
        u && a.push(u),
        (c = is(
          "offset",
          d,
          t.pathSnapping ?? e.updatedPathSnapping ?? e.dataPatched.pathSnapping,
          i.pathSnapping ?? e.dataPatched.pathSnapping,
          s
        )),
        c && a.push(c),
        !u &&
          !c &&
          ((n = tE("position", e, t, i, s)),
          n && a.push(n),
          (o = tE("scale", e, t, i, s)),
          o && a.push(o),
          (l = vJ(e, t, i, r, s)),
          l && a.push(l),
          (h = $K("hiddenMatrix", e, t, i)),
          h && a.push(h))),
    n || o || l || h || u || c)
  ) {
    let p =
      e instanceof Rr
        ? () => {
            e.updateWorldMatrix(!0);
          }
        : () => {
            e.updateMatrix(),
              e.hasNonUniformScale &&
                (e.updateMatrixWorld(), e.updateMatrixWorldSVD()),
              e.parent?.matrixWorldFusedFalse &&
                (e.matrixWorld.multiplyMatrices(
                  e.parent.matrixWorldFusedFalse,
                  e.matrix
                ),
                (e.matrixWorldNeedsUpdate = !1)),
              ja(e) && yo(e.parent) && e.invalidateDownstreamBooleanData(!0),
              e.updatePathSnapping(Object.assign({}, t.pathSnapping, d));
          };
    a.push({ update: p, start: p, end: p });
  }
  return a;
}
function vJ(e, t, i, r, s) {
  let a = t?.rotation
      ? t.rotation.map(
          (u) =>
            (typeof u == "string" ? Number(s.getVariable(u) ?? 0) : u) *
            dt.DEG2RAD
        )
      : void 0,
    n = i.rotation?.map(
      (u) =>
        (typeof u == "string" ? Number(s.getVariable(u) ?? 0) : u) * dt.DEG2RAD
    );
  if (!n) return;
  let o = a ? new I().fromArray(a) : new I().setFromEuler(e.rotation),
    l = new I().fromArray(n);
  if (o.equals(l)) return;
  let h = Y0.subVectors(l, o);
  if (r && h.toArray().every((u) => Math.abs(u) < 2 * Math.PI)) {
    let u = new Rt().setFromEuler(sE.setFromVector3(o)),
      c = new Rt().setFromEuler(sE.setFromVector3(l));
    return {
      update: (d) => {
        JK(u, c, e.quaternion, d);
      },
      start: () => {
        e.rotation.setFromVector3(o);
      },
      end: () => {
        e.rotation.setFromVector3(l);
      },
    };
  } else
    return {
      update: (u) => {
        Y0.lerpVectors(o, l, u), e.rotation.setFromVector3(Y0);
      },
      start: () => {
        e.rotation.setFromVector3(o);
      },
      end: () => {
        e.rotation.setFromVector3(l);
      },
    };
}
function yJ(e, t, i, r) {
  let s = [];
  if (!("cloner" in i) || !e.cloner) return s;
  let a = e.cloner,
    n = "cloner" in t ? t.cloner : {},
    o = i.cloner;
  jT.forEach((p) => {
    let f;
    p === "count"
      ? (f = is("count", a.parameters, n, o, r, !0))
      : (f = yl(p, a.parameters, n ?? {}, o, r)),
      f && s.push(f);
  });
  let l = xJ(a, n, o, r);
  l?.length && s.push(...l);
  let h = bJ(a, n, o, r);
  h?.length && s.push(...h);
  let u = wJ(a, n, o, r);
  u?.length && s.push(...u);
  let c = _J(a, n, o, r);
  c?.length && s.push(...c);
  let d = SJ(a, n, o, r);
  return (
    d?.length && s.push(...d),
    s.length &&
      s.push({
        update: () => {
          a.update();
        },
      }),
    s
  );
}
function xJ(e, t, i, r) {
  if (e.parameters.type !== "radial") return;
  let s = t.radial,
    a = i.radial;
  if (!a) return;
  let n = e.parameters.radial,
    o = [];
  return (
    HT.forEach((l) => {
      let h = yl(l, n, s ?? {}, a, r);
      h && o.push(h);
    }),
    o
  );
}
function bJ(e, t, i, r) {
  if (e.parameters.type !== "linear") return;
  let s = t.linear,
    a = i.linear;
  if (!a) return;
  let n = [],
    o = e.parameters.linear;
  return (
    GT.forEach((l) => {
      let h = yl(l, o, s ?? {}, a, r);
      h && n.push(h);
    }),
    n
  );
}
function wJ(e, t, i, r) {
  if (e.parameters.type !== "grid") return;
  let s = t.grid,
    a = i.grid;
  if (!a) return;
  let n = [],
    o = e.parameters.grid;
  return (
    WT.forEach((l) => {
      let h;
      l === "count"
        ? (h = qb(l, o, s ?? {}, a, r, !0))
        : (h = yl(l, o, s ?? {}, a, r)),
        h && n.push(h);
    }),
    n
  );
}
function _J(e, t, i, r) {
  if (e.parameters.type !== "toObject") return;
  let s = t.toObject,
    a = i.toObject;
  if (!a) return;
  let n = [],
    o = e.parameters.toObject;
  return (
    qT.forEach((l) => {
      let h;
      l === "count"
        ? (h = is(l, o, s ?? {}, a, r, !0))
        : (h = yl(l, o, s ?? {}, a, r)),
        h && n.push(h);
    }),
    n
  );
}
function SJ(e, t, i, r) {
  if (!e.parameters.randomness) return;
  let s = t.randomnessObject,
    a = i.randomnessObject;
  if (!a) return;
  let n = [],
    o = e.parameters.randomnessObject;
  return (
    YT.forEach((l) => {
      let h = yl(l, o, s ?? {}, a, r);
      h && n.push(h);
    }),
    n
  );
}
function AJ(e, t) {
  return {
    update: () => {
      e instanceof Gr && (e.fill.enabled = t);
    },
  };
}
function MJ(e, t) {
  return {
    update: () => {
      e instanceof Gr && (e.stroke.enabled = t);
    },
  };
}
function EJ(e, t) {
  return {
    update: () => {
      e instanceof Gr && (e.dropShadow.enabled = t);
    },
  };
}
function CJ(e, t) {
  return {
    update: () => {
      e instanceof Gr && (e.innerShadow.enabled = t);
    },
  };
}
function TJ(e, t) {
  return {
    update: () => {
      e instanceof Gr && (e.backgroundBlur.enabled = t);
    },
  };
}
function PJ(e, t) {
  return {
    update: () => {
      e instanceof Gr && (e.layerBlur.enabled = t);
    },
  };
}
function DJ(e, t, i, r, s) {
  let a = [],
    n,
    o,
    l,
    h,
    u,
    c,
    d,
    p,
    f,
    m,
    g,
    y,
    x,
    b,
    _;
  if (
    ("width" in e && ((n = is("width", e, t, i, s)), n && a.push(n)),
    "height" in e && ((o = is("height", e, t, i, s)), o && a.push(o)),
    e instanceof Gr || e instanceof Dn)
  ) {
    let S = { ...t.fill },
      M = { ...i.fill };
    S.enabled !== void 0 &&
      S.enabled !== M.enabled &&
      (a.push(AJ(e, !0)),
      S.enabled ||
        Object.assign(S, { enabled: !0, color: { ...S.color, a: 0 } }),
      M.enabled ||
        Object.assign(M, { enabled: !0, color: { ...M.color, a: 0 } })),
      (l = Jf("color", e.fill, S, M, s)),
      l && a.push(l);
  }
  if (e instanceof Gr) {
    let S = { ...t.stroke },
      M = { ...i.stroke };
    (S.enabled || M.enabled) &&
      (a.push(MJ(e, !0)),
      S.enabled ||
        Object.assign(S, { enabled: !0, color: { ...S.color, a: 0 } }),
      M.enabled ||
        Object.assign(M, { enabled: !0, color: { ...M.color, a: 0 } })),
      (h = Jf("color", e.stroke, S, M, s)),
      h && a.push(h),
      (u = is("thickness", e.stroke, S, M, s)),
      u && a.push(u);
  }
  if (e instanceof Gr) {
    let S = { ...t.dropShadow },
      M = { ...i.dropShadow };
    (S.enabled || M.enabled) &&
      (a.push(EJ(e, !0)),
      S.enabled ||
        Object.assign(S, { enabled: !0, color: { ...S.color, a: 0 } }),
      M.enabled ||
        Object.assign(M, { enabled: !0, color: { ...M.color, a: 0 } })),
      (c = Jf("color", e.dropShadow, S, M, s)),
      c && a.push(c),
      (d = is("blurRadius", e.dropShadow, S, M, s)),
      d && a.push(d),
      (f = is("spread", e.dropShadow, S, M, s)),
      f && a.push(f),
      (p = ox("offset", e.dropShadow, S, M, s)),
      p && a.push(p);
  }
  if (e instanceof Gr) {
    let S = { ...t.innerShadow },
      M = { ...i.innerShadow };
    (S.enabled || M.enabled) &&
      (a.push(CJ(e, !0)),
      S.enabled ||
        Object.assign(S, { enabled: !0, color: { ...S.color, a: 0 } }),
      M.enabled ||
        Object.assign(M, { enabled: !0, color: { ...M.color, a: 0 } })),
      (m = Jf("color", e.innerShadow, S, M, s)),
      m && a.push(m),
      (g = is("blurRadius", e.innerShadow, S, M, s)),
      g && a.push(g),
      (x = is("spread", e.innerShadow, S, M, s)),
      x && a.push(x),
      (y = ox("offset", e.innerShadow, S, M, s)),
      y && a.push(y);
  }
  if (e instanceof Gr || e instanceof Dn) {
    let S = { ...t.backgroundBlur },
      M = { ...i.backgroundBlur };
    (S.enabled || M.enabled) &&
      (a.push(TJ(e, !0)),
      S.enabled || Object.assign(S, { enabled: !0, radius: 0 }),
      M.enabled || Object.assign(M, { enabled: !0, radius: 0 })),
      (b = is("radius", e.backgroundBlur, S, M, s)),
      b && a.push(b);
  }
  if (e instanceof Gr) {
    let S = { ...t.layerBlur },
      M = { ...i.layerBlur };
    (S.enabled || M.enabled) &&
      (a.push(PJ(e, !0)),
      S.enabled || Object.assign(S, { enabled: !0, radius: 0 }),
      M.enabled || Object.assign(M, { enabled: !0, radius: 0 })),
      (_ = is("radius", e.layerBlur, S, M, s)),
      _ && a.push(_);
  }
  if (e instanceof Dn || e instanceof mp) {
    let S = qb("cornerRadius", e, t, i, s);
    S && a.push(S);
  }
  return a;
}
function aE(e, t, i, r, s) {
  let a = [];
  return (
    e.data.visible && a.push(...gJ(e, t, i, s, r)),
    e instanceof Rr
      ? a.push(...DJ(e, t, i, s, r))
      : (e.data.visible && a.push(...yJ(e, t, i, r)),
        ja(e)
          ? (e instanceof ms && e.data.visible && a.push(...sJ(e, t, i, r)),
            e.data.visible && a.push(...nJ(e, t, i, r)))
          : kY(e)
          ? e.data.visible && a.push(...aJ(e, t, i, r))
          : FY(e) && a.push(...tJ(e, t, i, r))),
    a.length
      ? {
          update: (n) => {
            a.forEach((o) => o.update(n));
          },
          start: (n) => {
            a.forEach((o) => o.start?.(n));
          },
          end: (n) => {
            a.forEach((o) => o.end?.(n));
          },
        }
      : void 0
  );
}
var nE = new I();
function Yb(e, t, i = !1) {
  let r = [],
    s = (a) => {
      let n = a.data;
      delete a.states,
        (a.currentState = null),
        (a.reversibleToState = null),
        (a.currentTransitionEvent = null);
      for (let o of n.states) {
        let l = { ...o.data };
        a.states || (a.states = {}), (a.states[o.id] = Xl.patch(n, l));
      }
      lE(
        e.scene,
        a,
        null,
        t,
        n.events.find(
          (o) => o.data.type === "Follow" || o.data.type === "LookAt"
        ) !== void 0
      ),
        oE(e);
    };
  e.scene.traverse2D(s),
    e.traverseChildren((a) => {
      if (
        (i &&
          (a.rigidBody?.setTranslation(a.position0, !0),
          a.rigidBody?.setRotation(a.rotation0, !0),
          a.rigidBody?.setLinvel(nE, !0),
          a.rigidBody?.setAngvel(nE, !0)),
        !si.is(a))
      )
        return;
      let n = a.uuid,
        o = a.data;
      if ((delete a.states, a.uuid === mu)) return;
      let l = !1;
      r.some((h) => e.scene.find(n)?.isDescendantOf(h))
        ? (l = !0)
        : o.physics?.fusedBody === !0 &&
          o.physics.rigidBody === "dynamic" &&
          r.push(n),
        (a.data = o),
        (a.currentState = null),
        (a.reversibleToState = null),
        (a.currentTransitionEvent = null);
      for (let h of o.states) {
        let u = { ...h.data };
        e.data.globalPhysics.usePhysics === !0 &&
          o.physics &&
          (o.physics.rigidBody === "dynamic" || l) &&
          (h.data.position !== void 0 && delete u.position,
          h.data.rotation !== void 0 && delete u.rotation,
          h.data.hiddenMatrix !== void 0 && delete u.hiddenMatrix),
          a.states || (a.states = {}),
          (a.states[h.id] = Wl.patch(o, u));
      }
      lE(
        e.scene,
        a,
        null,
        t,
        o.events.find(
          (h) => h.data.type === "Follow" || h.data.type === "LookAt"
        ) !== void 0
      ),
        oE(e),
        a instanceof ps &&
          a.frame &&
          (a.frame.traverse((h) => s(h)), a.uiCanvas?.applySize());
    }),
    e.frame && (e.frame.traverse((a) => s(a)), e.uiCanvas?.applySize());
}
function oE(e) {
  e.traverseEntity((t) => {
    for (let i of t.data.events) {
      let r = [];
      switch (i.data.type) {
        case "Follow":
        case "MouseHover":
        case "Scroll":
        case "MouseDown":
        case "MouseUp":
        case "MousePress":
        case "KeyUp":
        case "KeyDown":
        case "KeyPress":
        case "Collision":
          r.push(...i.data.actions);
          break;
        case "GameControl":
          for (let s of Object.values(i.data.gameActions)) r.push(...s);
          break;
        case "DragDrop":
          r.push(
            ...i.data.dragDropActions.drag,
            ...i.data.dragDropActions.drop
          );
          break;
        case "Conditional":
          r.push(...i.data.inActions, ...i.data.outActions);
          break;
      }
      for (let s of r)
        if (s.data.type === "Create" && s.data.hideBase === "Yes") {
          let a = e.scene.find(s.data.object);
          a && (a.visible = !1);
        }
    }
  });
}
function lE(e, t, i, r, s = !1) {
  if (
    (t instanceof ms && t.removeInteractionGeometry(r),
    t instanceof Rr
      ? t.changeSelectedState(i, { shared: r }, s)
      : t.changeSelectedState(i, { scene: e, shared: r }, s),
    t instanceof ms && t.updateGeometryGroupsIfNeeded(),
    t instanceof vs &&
      t.updateCameraState(t.dataPatched, { scene: e, shared: r }),
    !(t instanceof Rr))
  ) {
    if (t.cloner) for (let a of t.cloner.children) a.playModeVisible = void 0;
    t.updateVisible(e);
  }
}
function dD(e) {
  let t;
  if (e.easing === 5) {
    let { control1: i, control2: r } = e;
    t = `cubicBezier(
			${i[0]}, ${i[1]}, ${r[0]}, ${r[1]}
		)`;
  } else if (e.easing === 6) {
    let { mass: i, stiffness: r, damping: s, velocity: a } = e;
    t = `spring( ${i}, ${r}, ${s}, ${a} )`;
  } else {
    let i;
    switch (e.easing) {
      case 0:
        i = Xo.linear;
        break;
      case 1:
        i = Xo.ease;
        break;
      case 2:
        i = Xo.easeIn;
        break;
      case 3:
        i = Xo.easeOut;
        break;
      case 4:
        i = Xo.easeInOut;
        break;
      default:
        i = Xo.linear;
    }
    let [r, s, a, n] = i;
    t = `cubicBezier( ${r}, ${s}, ${a}, ${n} )`;
  }
  return { duration: Math.max(e.duration, 1e-4), easing: t };
}
function lx(e) {
  let t = { delay: 0, loop: e.repeat === -1 ? !0 : e.repeat + 1 };
  if (e.repeat === 0) (t.direction = "normal"), (t.rewind = !1);
  else
    switch (e.direction) {
      case "pingpong":
        (t.direction = "alternate"), (t.rewind = !1);
        break;
      case "pingpong-rewind":
        (t.direction = "alternate"), (t.rewind = !0);
        break;
      default:
        (t.direction = "normal"), (t.rewind = !1);
        break;
    }
  switch (
    ((t.delay = 0),
    (t.endDelay = 0),
    (t.startOnceDelay = 0),
    (t.pingPongDelayCorrection = 0),
    (t.pingPongEndDelayCorrection = 0),
    e.delayDirection)
  ) {
    case "start-once":
      t.startOnceDelay = e.delay;
      break;
    case "start":
      t.delay = e.delay;
      break;
    case "end":
      t.endDelay = e.delay;
      break;
    case "start-end":
    case void 0:
      (t.delay = e.delay), (t.endDelay = e.delay);
      break;
  }
  return (
    t.direction === "alternate" &&
      ((t.delay /= 2),
      (t.endDelay /= 2),
      e.delayDirection === "start"
        ? ((t.pingPongDelayCorrection = t.delay),
          typeof t.loop == "number" &&
            t.loop % 2 === 0 &&
            (t.pingPongEndDelayCorrection = t.delay))
        : e.delayDirection === "end"
        ? typeof t.loop == "number" &&
          t.loop % 2 !== 0 &&
          (t.pingPongEndDelayCorrection = t.endDelay)
        : e.delayDirection === "start-end" &&
          ((t.pingPongDelayCorrection = t.delay),
          (t.pingPongEndDelayCorrection = t.endDelay))),
    t
  );
}
var OJ = { type: "beginState" },
  IJ = { type: "completeState", isfromEntity: !1 },
  hE = class {
    constructor(e, t, i, r, s, a) {
      if (
        ((this.object = e),
        (this.data = r),
        (this.sharedAssets = s),
        (this.allowSlerp = a),
        (this.targets = { t: 0 }),
        (this.firstLoop = !0),
        (this._changeBegan = !1),
        (this._changeCompleted = !0),
        (this.onChange = () => {
          this.callback &&
            (this.callback.update(this.targets.t), this.object.requestRender()),
            this.targets.t === 0 || this.targets.t === 1
              ? this._changeCompleted ||
                ((this._changeCompleted = !0),
                (this._changeBegan = !1),
                this.onChangeComplete())
              : (this._changeCompleted && (this._changeCompleted = !1),
                this._changeBegan ||
                  ((this._changeBegan = !0), this.onChangeBegin()));
        }),
        (this.onChangeBegin = () => {
          this.object.reversibleToState = this.to.id;
          let n = this.targets.t > 0.5 ? this.from.id : this.to.id;
          this.object.prevState !== this.object.currentState &&
            (this.object.prevState = this.object.currentState),
            (this.object.currentState = n),
            this.object.dispatchEvent({ type: "beginState", state: n }),
            this.object instanceof Rr ||
              this.object.traverseEntity((o) => {
                o !== this.object && o instanceof vs && o.dispatchEvent(OJ);
              });
        }),
        (this.onChangeComplete = () => {
          this.firstLoop && (this.onFirstLoop(), (this.firstLoop = !1)),
            (this.object.reversibleToState = this.to.id);
          let n = this.targets.t < 0.5 ? this.from.id : this.to.id;
          this.object.prevState !== this.object.currentState &&
            (this.object.prevState = this.object.currentState),
            (this.object.currentState = n),
            this.object.dispatchEvent({ type: "completeState", state: n }),
            this.object instanceof Rr ||
              this.object.traverseEntity((o) => {
                o !== this.object && o instanceof vs && o.dispatchEvent(IJ);
              });
        }),
        (this.onFirstLoop = () => {
          this.useCurrentState &&
            (this.callback = aE(
              this.object,
              this.from.data,
              this.to.data,
              this.sharedAssets,
              this.allowSlerp
            ));
        }),
        t === void 0)
      ) {
        let n = fm(
          this.object,
          this.object.currentState === i
            ? this.object.prevState
            : this.object.currentState
        );
        if (!n) throw new Error("Missing property");
        this.from = n;
      } else {
        let n = fm(this.object, t);
        if (!n) throw new Error("Missing property");
        this.from = n;
      }
      if (i === void 0) throw new Error("Missing property");
      {
        let n = fm(this.object, i);
        if (!n) throw new Error("Missing property");
        this.to = n;
      }
      (this.useCurrentState = t === void 0 || i === void 0),
        (this.params = {
          targets: this.targets,
          t: 1,
          autoplay: !1,
          ...lx(r),
          ...dD(r),
          change: this.onChange,
        }),
        (this.callback = aE(
          this.object,
          t === void 0 ? {} : this.from.data,
          i === void 0 ? {} : this.to.data,
          this.sharedAssets,
          this.allowSlerp
        ));
    }
    get changeBegan() {
      return this._changeBegan;
    }
    get changeCompleted() {
      return this._changeCompleted;
    }
  },
  pD = class extends ls {
    constructor(e, t, i, r) {
      if (
        (super(),
        (this.data = e),
        (this.page = t),
        (this.shared = i),
        (this.condition = r),
        (this.toggleIsForward = !1),
        (this.timelineNeedsRebuild = !1),
        (this.useToggle = !1),
        (this.onTimelineChangeComplete = () => {
          this.data.tweens[0].data.direction !== "normal" &&
            (this.toggleIsForward = !this.toggleIsForward),
            this.timelineNeedsRebuild !== !1 &&
              (this.timeline?.pause(),
              this.buildTimeline({
                isForward: this.toggleIsForward,
                needsRebuild: !1,
                isRebuild: !0,
              }),
              this.timeline.play());
        }),
        !e.object)
      )
        throw new Error("Missing property");
      let s =
        this.page.scene.find(e.object) ??
        this.page.uiCanvas?.find(e.object) ??
        this.page.scene.find2DInUIObjects(e.object);
      if (!s) throw new Error("Missing property");
      if (!s.states) throw new Error("Missing property");
      if (((this.object = s), e.tweens.length < 2))
        throw new Error("Missing property");
      (this.tweens = Array(this.data.tweens.length - 1)),
        (this.startOnceDelay =
          e.tweens[0].data.delayDirection === "start-once"
            ? e.tweens[0].data.delay
            : 0),
        this.init();
    }
    get playing() {
      return this.timeline && this.timeline.paused === !1;
    }
    init() {
      (this.initialCurrentState = fm(this.object, this.object.currentState).id),
        (this.toggleIsForward = !1);
    }
    get currentState() {
      return this.useToggle
        ? this.initialCurrentState
        : this.object.currentState;
    }
    buildTimeline({
      isForward: e = !0,
      needsRebuild: t = !1,
      isRebuild: i = !1,
    } = {}) {
      try {
        let r = lx(this.data.tweens[0].data);
        i && typeof r.loop == "number" && r.loop--,
          this.timeline?.pause(),
          (this.timeline = uD.timeline({
            autoplay: !1,
            ...r,
            ...(r.loop === !0 || r.loop > 1
              ? { timelineChangeComplete: this.onTimelineChangeComplete }
              : {}),
          }));
        let s = this.tweens.findIndex((a) => a?.changeBegan);
        if ((t === !0 && (this.timelineNeedsRebuild = !0), e)) {
          let a = s === -1 ? 0 : s;
          for (let n = a; n < this.data.tweens.length - 1; n++) {
            let o = this.data.tweens[n],
              l = this.data.tweens[n + 1],
              h;
            n === a &&
            (this.object.wasMovedByUser === !0 ||
              this.object.previousAction?.playing === !0)
              ? ((h = void 0),
                this.object instanceof vs && (this.object.wasMovedByUser = !1))
              : (h =
                  o.data.state === void 0 ? this.currentState : o.data.state);
            let u = new hE(
              this.object,
              h,
              l.data.state === void 0 ? this.currentState : l.data.state,
              l.data,
              this.shared,
              this.data.allowSlerp ?? !1
            );
            s !== -1 &&
              n === a &&
              Object.assign(u.params, { startOnceDelay: 0 }),
              (this.tweens[n] = u),
              this.timeline.add(
                u.params,
                this.timeline.duration + (n === a ? r.delay : 0)
              );
          }
          this.timeline.duration += r.endDelay;
        } else {
          let a = s === -1 ? this.data.tweens.length - 1 : s + 1;
          for (let n = a; n > 0; n--) {
            let o = this.data.tweens[n],
              l = this.data.tweens[n - 1],
              h;
            n === a &&
            (this.object.wasMovedByUser === !0 ||
              this.object.previousAction?.playing === !0)
              ? ((h = void 0),
                this.object instanceof vs && (this.object.wasMovedByUser = !1))
              : (h =
                  o.data.state === void 0 ? this.currentState : o.data.state);
            let u = new hE(
              this.object,
              h,
              l.data.state === void 0 ? this.currentState : l.data.state,
              o.data,
              this.shared,
              this.data.allowSlerp ?? !1
            );
            s !== -1 &&
              n === a &&
              Object.assign(u.params, { startOnceDelay: 0 }),
              (this.tweens[n - 1] = u),
              this.timeline.add(
                u.params,
                this.timeline.duration + (n === a ? r.endDelay : 0)
              );
          }
          this.timeline.duration += r.delay;
        }
      } catch (r) {
        r instanceof Error && console.error(r.message);
      }
      this.object.previousAction?.playing === !0 &&
        this.object.previousAction.pause(),
        (this.object.previousAction = this);
    }
    play() {
      if (Xi(this.shared, this.condition) === !1 || this.playing) return !1;
      clearTimeout(this.timeoutId);
      let e = lx(this.data.tweens[0].data).pingPongDelayCorrection;
      this.timeoutId = window.setTimeout(() => {
        try {
          this.buildTimeline(), this.timeline.play();
        } catch (t) {
          t instanceof Error && console.error(t.message);
        }
      }, this.startOnceDelay + e);
    }
    pause() {
      this.timeline?.pause(),
        clearTimeout(this.timeoutId),
        (this.tweens = Array(this.data.tweens.length - 1)),
        delete this.timeoutId;
    }
    stop() {
      this.pause();
      let e =
        this.data.tweens[0].data.state === void 0
          ? this.initialCurrentState
          : this.data.tweens[0].data.state;
      this.object instanceof Rr
        ? this.object.changeSelectedState(e, { shared: this.shared })
        : this.object.changeSelectedState(e, {
            scene: this.page.scene,
            shared: this.shared,
          }),
        (this.object.currentState = e);
    }
    seek(e) {
      this.timeline === void 0 && this.buildTimeline(),
        this.timeline?.seek(e * this.timeline.duration, !0);
    }
    toggle(e) {
      if (Xi(this.shared, this.condition) === !1) return !1;
      (this.useToggle = !0),
        clearTimeout(this.timeoutId),
        (this.toggleIsForward = e ?? !this.toggleIsForward),
        this.playing
          ? (this.timeline?.pause(),
            this.buildTimeline({
              isForward: this.toggleIsForward,
              needsRebuild: !0,
            }),
            this.timeline.play())
          : (this.timeoutId = window.setTimeout(() => {
              this.timeline?.pause(),
                this.buildTimeline({ isForward: this.toggleIsForward }),
                this.timeline.play();
            }, this.startOnceDelay));
    }
    playFromCurrent() {
      this.toggle(!0);
    }
    reverseFromCurrent() {
      this.toggle(!1);
    }
    dispose() {
      this.pause();
    }
  };
function fm(e, t) {
  let i, r;
  if (
    (typeof t == "string"
      ? ((i = t), (r = e.states?.[i]))
      : t === null && ((i = null), (r = e.data)),
    !(i === void 0 || r === void 0))
  )
    return { id: i, data: r };
}
var RJ = { type: "beginState" },
  cE = { type: "completeState", isfromEntity: !1 },
  uE = { type: "requestRender" },
  fD = class extends ls {
    constructor(e, t, i, r) {
      super(),
        (this.data = e),
        (this.page = t),
        (this.shared = i),
        (this.condition = r),
        (this.toggleIsForward = !1),
        (this.useToggle = !1),
        (this.posStart = new I()),
        (this.posEnd = new I()),
        (this.qStart = new Rt()),
        (this.qEnd = new Rt()),
        (this.zoomStart = 1),
        (this.zoomEnd = 1);
    }
    init() {}
    get playing() {
      return (
        this.animation && this.animation.began && !this.animation.completed
      );
    }
    buildAnimation(e = !1) {
      if (!this.data.animate) return;
      let t = this.page.scene.find(this.data.targetCamera);
      if (!t || !t.visible)
        throw new ReferenceError("Target camera not founded or not visible");
      let i = { t: 0 };
      this.posStart.copy(this.page.activeCamera.position),
        this.qStart.copy(this.page.activeCamera.quaternion),
        (this.zoomStart = this.page.activeCamera.zoom),
        (this.animation = uD({
          targets: i,
          t: 1,
          ...dD(this.data),
          update: () => {
            i.t === 0 &&
              (this.useToggle && !this.toggleIsForward
                ? (this.posEnd.copy(this.fromCamera.position),
                  this.qEnd.copy(this.fromCamera.quaternion),
                  (this.zoomEnd = this.fromCamera.zoom),
                  this.switchCamera(this.fromCamera.uuid))
                : (this.posEnd.copy(t.position),
                  this.qEnd.copy(t.quaternion),
                  (this.zoomEnd = t.zoom),
                  (this.fromCamera = this.page.activeCamera),
                  this.switchCamera(t.uuid)),
              this.page.activeCamera.dispatchEvent(RJ));
            let r = this.page.activeCamera;
            r.position.lerpVectors(this.posStart, this.posEnd, i.t),
              r.quaternion.slerpQuaternions(this.qStart, this.qEnd, i.t),
              (r.zoom = this.zoomStart + (this.zoomEnd - this.zoomStart) * i.t),
              (r.wasMovedBySwitchCameraAction = !0),
              r.updateMatrix(),
              r.updateMatrixWorld(),
              r.updateProjectionMatrix(),
              r.dispatchEvent(uE),
              i.t === 1 && r.dispatchEvent(cE);
          },
        }));
    }
    switchCamera(e) {
      let t = this.page.activeCamera,
        i = this.page.scene.find(e);
      if (!i || !i.visible)
        throw new ReferenceError("Target camera not founded or not visible");
      this.page.switchActiveCamera(i),
        t.dispatchEvent({ type: "cameraChange", camera: i });
    }
    play() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      if (
        !this.playing &&
        this.page.activeCamera.uuid !== this.data.targetCamera
      )
        try {
          clearTimeout(this.timeoutId),
            (this.timeoutId = window.setTimeout(() => {
              delete this.timeoutId,
                this.data.animate
                  ? (this.buildAnimation(), this.animation?.play())
                  : this.switchCamera(this.data.targetCamera);
            }, this.data.delay * 1e3));
        } catch {}
    }
    pause() {
      this.animation?.pause(),
        clearTimeout(this.timeoutId),
        delete this.timeoutId;
    }
    toggle(e) {
      if (Xi(this.shared, this.condition) === !1) return !1;
      (this.useToggle = !0),
        clearTimeout(this.timeoutId),
        (this.toggleIsForward = e ?? !this.toggleIsForward);
      try {
        this.playing
          ? (this.animation?.pause(),
            this.buildAnimation(!0),
            this.animation?.play())
          : (this.timeoutId = window.setTimeout(() => {
              delete this.timeoutId,
                this.data.animate
                  ? (this.animation?.pause(),
                    this.buildAnimation(),
                    this.animation?.play())
                  : (this.toggleIsForward
                      ? ((this.fromCamera = this.page.activeCamera),
                        this.switchCamera(this.data.targetCamera))
                      : this.switchCamera(this.fromCamera.uuid),
                    this.page.activeCamera.dispatchEvent(cE),
                    this.page.activeCamera.dispatchEvent(uE));
            }, this.data.delay * 1e3));
      } catch {}
    }
    playFromCurrent() {
      this.toggle(!0);
    }
    reverseFromCurrent() {
      this.toggle(!1);
    }
    dispose() {
      this.pause(), (this.toggleIsForward = !1);
    }
  },
  mD = class extends ls {
    constructor(e, t, i, r, s) {
      super(),
        (this.page = t),
        (this.animationControls = i),
        (this.shared = r),
        (this.condition = s),
        (this.startOnceDelay = 0),
        (this.toggleIsForward = !1);
      let a = e.object,
        n = t.scene.find(e.object);
      n && Array.isArray(n.identity) && (a = n.identity[0]),
        (this.data = { ...e, object: a });
      let o = this.animationControls.clipIdToAction[e.clipId + "/" + a];
      this.duration = o?.getClip()?.duration ?? 1;
      let l = o?.getClip()?.tracks[0]?.times.length ?? 1 / 0;
      (this.leftFrameTime = (this.data.crop[0] / l) * this.duration),
        (this.rightFrameTime = (this.data.crop[1] / l) * this.duration),
        (this.startOnceDelay = e.delay);
    }
    get playing() {
      return this.threeAnimAction?.isRunning() ?? !1;
    }
    play(e = !1) {
      if (Xi(this.shared, this.condition) === !1) return !1;
      window.clearTimeout(this.timeoutId),
        (this.timeoutId = window.setTimeout(() => {
          if (
            ((this.threeAnimAction = this.animationControls.play(this.data)),
            !this.threeAnimAction)
          )
            return;
          this.threeAnimAction.reset(),
            (this.threeAnimAction.time = this.leftFrameTime),
            (this.threeAnimAction._clip.start = this.leftFrameTime),
            (this.threeAnimAction._clip.duration = this.rightFrameTime);
          let t = this.data.object;
          Object.entries(this.animationControls.clipIdToAction).forEach(
            ([i, r]) => {
              let s = i.split("/")[1];
              this.threeAnimAction !== r &&
                s === t &&
                r.isRunning() &&
                (e ? r.fadeOut(0.2) : r.stop());
            }
          ),
            e && this.threeAnimAction?.fadeIn(0.2);
        }, this.startOnceDelay));
    }
    pause() {
      this.threeAnimAction && (this.threeAnimAction.paused = !0),
        window.clearTimeout(this.timeoutId),
        delete this.timeoutId;
    }
    stop() {
      this.threeAnimAction?.fadeOut(0.2);
    }
    seek(e) {
      (this.threeAnimAction = this.animationControls.play(this.data)),
        this.threeAnimAction &&
          ((this.threeAnimAction.paused = !0),
          (this.threeAnimAction.time = dt.clamp(
            this.threeAnimAction.time + (1 / 60) * e,
            this.leftFrameTime,
            this.rightFrameTime - 16e-5
          )),
          (this.animationControls.needsUpdate = !0),
          this.animationControls.requestRender());
    }
    toggle(e, t = !1) {
      if (Xi(this.shared, this.condition) === !1) return !1;
      (this.toggleIsForward = e ?? !this.toggleIsForward),
        this.threeAnimAction && (this.threeAnimAction._loopCount = 0),
        this.playing
          ? this.threeAnimAction &&
            ((this.threeAnimAction.timeScale = this.toggleIsForward ? 1 : -1),
            this.toggleIsForward
              ? ((this.threeAnimAction._clip.start = this.leftFrameTime),
                (this.threeAnimAction._clip.duration = this.rightFrameTime))
              : ((this.threeAnimAction._clip.start = this.rightFrameTime),
                (this.threeAnimAction._clip.duration = this.leftFrameTime)))
          : (this.timeoutId = window.setTimeout(() => {
              if (
                ((this.threeAnimAction = this.animationControls.play(
                  this.data
                )),
                this.threeAnimAction)
              ) {
                this.toggleIsForward
                  ? ((this.threeAnimAction.time = this.leftFrameTime),
                    (this.threeAnimAction._clip.start = this.leftFrameTime),
                    (this.threeAnimAction._clip.duration = this.rightFrameTime))
                  : ((this.threeAnimAction.time = this.rightFrameTime),
                    (this.threeAnimAction._clip.start = this.rightFrameTime),
                    (this.threeAnimAction._clip.duration = this.leftFrameTime)),
                  (this.threeAnimAction.paused = !1),
                  (this.threeAnimAction.timeScale = this.toggleIsForward
                    ? 1
                    : -1);
                let i = this.data.clipId.split("/")[1];
                Object.entries(this.animationControls.clipIdToAction).forEach(
                  ([r, s]) => {
                    let a = r.split("/")[1];
                    this.threeAnimAction !== s &&
                      a === i &&
                      s.isRunning() &&
                      (t ? s.fadeOut(0.2) : s.stop());
                  }
                ),
                  t && this.threeAnimAction?.fadeIn(0.2);
              }
            }, this.startOnceDelay));
    }
    playFromCurrent() {
      this.toggle(!0);
    }
    reverseFromCurrent() {
      this.toggle(!1);
    }
    dispose() {
      let e =
        this.animationControls.clipIdToAction[
          this.data.clipId + "/" + this.data.object
        ]?.getClip();
      e && (e.duration = this.duration), this.pause();
    }
  },
  gD = class {
    constructor(e, t, i, r, s) {
      (this.data = e),
        (this.page = t),
        (this.eventManager = i),
        (this.shared = r),
        (this.condition = s),
        (this.timeOutId = -1),
        (this.scene = t.scene);
    }
    dispatch() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.data.target !== this.page.uuid &&
        (window.clearTimeout(this.timeOutId),
        (this.timeOutId = window.setTimeout(() => {
          this.play();
        }, this.data.delay * 1e3)));
    }
    dispose() {
      window.clearTimeout(this.timeOutId);
    }
    play() {
      if (this.scene.children.every((t) => t.uuid !== this.data.target)) return;
      this.data.transition === "fade" &&
        this.data.duration > 0 &&
        this.eventManager.eventContext.renderer.renderFromSceneForSceneTransitionPass(
          this.scene,
          this.scene.activeCamera,
          this.data.duration * 1e3
        ),
        this.eventManager.deactivate(),
        this.eventManager.controlsManager.deactivate();
      let e = this.scene.activeCamera;
      this.scene.updatePage(this.data.target),
        this.scene.traverseVisibleEntity((t) => {
          t.type === "ParticleSystem" &&
            (t.sleep(), t.wakeUp(), t.data.autoPlay ? t.start() : t.stop());
        }),
        this.scene.activePage.switchToPlayCamera(),
        this.scene.activeCamera.copyViewPlaneSize(e),
        Yb(this.scene.activePage, this.shared),
        this.eventManager.activate(),
        this.eventManager.controlsManager.activate(this.eventManager);
    }
  },
  vD = class {
    constructor(e, t, i, r) {
      (this.data = e),
        (this.page = t),
        (this.shared = i),
        (this.condition = r),
        (this.evaluatedCondition = !1);
    }
    checkConditions() {
      this.evaluatedCondition = Xi(this.shared, this.condition);
    }
    dispatch() {
      if (this.evaluatedCondition === !1) return !1;
      let e = this.shared.getVariable(this.data.variableId),
        t = M3(this.data.expression, this.shared, $s.typeOfVariable(e));
      t !== void 0 &&
        this.shared.updateVariable(
          this.data.variableId,
          typeof t == "string" ? { textValue: t } : t
        );
    }
    dispose() {}
  },
  yD = class {
    constructor(e, t, i, r) {
      (this.data = e),
        (this.page = t),
        (this.shared = i),
        (this.condition = r),
        (this.timeoutId = null);
    }
    dispatchInner() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      let e = this.shared.getDynamicVariablePlayState(this.data.variableId);
      if (this.data.mode === "PlayPause")
        this.shared.getDynamicVariableToggleIsForward(this.data.variableId) ===
          void 0 &&
          this.shared.setDynamicVariableToggleIsForward(
            this.data.variableId,
            !0
          ),
          this.shared.setDynamicVariablePlayState(
            this.data.variableId,
            e === "Playing" ? "Paused" : "Playing"
          );
      else if (this.data.mode === "Play" && e !== "Playing")
        this.shared.getDynamicVariableToggleIsForward(this.data.variableId) ===
          void 0 &&
          this.shared.setDynamicVariableToggleIsForward(
            this.data.variableId,
            !0
          ),
          this.shared.setDynamicVariablePlayState(
            this.data.variableId,
            "Playing"
          );
      else if (this.data.mode === "Stop" && e !== "Stopped")
        this.shared.setDynamicVariablePlayState(
          this.data.variableId,
          "Stopped"
        );
      else if (this.data.mode === "Pause" && e !== "Paused")
        this.shared.setDynamicVariablePlayState(this.data.variableId, "Paused");
      else if (this.data.mode === "Restart")
        this.shared.setDynamicVariablePlayState(
          this.data.variableId,
          "Restarted"
        );
      else if (this.data.mode === "Toggle") {
        let t = this.shared.getDynamicVariableToggleIsForward(
          this.data.variableId
        );
        e === "Playing"
          ? this.shared.setDynamicVariableToggleIsForward(
              this.data.variableId,
              t === void 0 ? !1 : !t
            )
          : (this.shared.setDynamicVariableToggleIsForward(
              this.data.variableId,
              !t
            ),
            this.shared.setDynamicVariablePlayState(
              this.data.variableId,
              "Playing"
            ));
      }
    }
    dispatch() {
      let e = this.data.delay,
        t = this.shared.getDynamicVariablePlayState(this.data.variableId);
      this.data.mode === "PlayPause" &&
        t === "Playing" &&
        (e = this.data.pauseDelay),
        e !== 0
          ? (this.timeoutId && window.clearTimeout(this.timeoutId),
            (this.timeoutId = window.setTimeout(() => {
              (this.timeoutId = null), this.dispatchInner();
            }, e)))
          : this.dispatchInner();
    }
    dispose() {
      this.timeoutId && window.clearTimeout(this.timeoutId);
    }
  };
function Xi(e, t) {
  if (t === void 0) return !0;
  if (t.expression.length === 0) return !1;
  let i = M3(t.expression, e, "boolean");
  return t.negate ? !i : !!i;
}
function Rs(e, t, i, r, s, a) {
  let n = {
      Audio: [],
      Video: [],
      Particles: [],
      Link: [],
      Destroy: [],
      Create: [],
      Reset: [],
      Transition: [],
      SwitchCamera: [],
      Animation: [],
      SceneTransition: [],
      SetVariable: [],
      DynamicVariablePlay: [],
    },
    o =
      (l) =>
      ({ id: h, data: u }) => {
        try {
          u.type === "Audio" && !(a instanceof Rr)
            ? zs[e.type].includes("Audio") &&
              n.Audio.push(new WP(h, u, a, r, l))
            : u.type === "Video" && !(a instanceof Rr)
            ? zs[e.type].includes("Video") &&
              n.Video.push(new bD(h, u, a, r, l))
            : u.type === "Particles"
            ? zs[e.type].includes("Particles") &&
              n.Particles.push(new qP(u, i, r, l))
            : u.type === "Link"
            ? zs[e.type].includes("Link") &&
              n.Link.push(new wK(u, s.controlsManager, r, l))
            : u.type === "Create"
            ? zs[e.type].includes("Create") &&
              n.Create.push(new wD(u, i, s.controlsManager, r, l))
            : u.type === "Destroy"
            ? zs[e.type].includes("Destroy") &&
              n.Destroy.push(new YP(u, i, s.controlsManager, r, l))
            : u.type === "Reset"
            ? zs[e.type].includes("Reset") &&
              n.Reset.push(new XP(u, i, r, s, l))
            : u.type === "Transition"
            ? zs[e.type].includes("Transition") &&
              n.Transition.push(new pD(u, i, r, l))
            : u.type === "SwitchCamera"
            ? zs[e.type].includes("SwitchCamera") &&
              n.SwitchCamera.push(new fD(u, i, r, l))
            : u.type === "SceneTransition"
            ? zs[e.type].includes("SceneTransition") &&
              n.SceneTransition.push(new gD(u, i, s, r, l))
            : u.type === "Animation"
            ? zs[e.type].includes("Animation") &&
              n.Animation.push(new mD(u, i, s.animationControls, r, l))
            : u.type === "SetVariable"
            ? zs[e.type].includes("SetVariable") &&
              n.SetVariable.push(new vD(u, i, r, l))
            : u.type === "DynamicVariablePlay"
            ? zs[e.type].includes("DynamicVariablePlay") &&
              n.DynamicVariablePlay.push(new yD(u, i, r, l))
            : u.type === "Conditional" &&
              zs[e.type].includes("Conditional") &&
              (u.ifActions.forEach(o({ expression: u.condition, negate: !1 })),
              u.elseActions.forEach(
                o({ expression: u.condition, negate: !0 })
              ));
        } catch {}
      };
  return t.forEach(o()), n;
}
function Xr(e) {
  Object.values(e).forEach((t) => {
    t.forEach((i) => {
      (i instanceof WP ||
        i instanceof bD ||
        i instanceof qP ||
        i instanceof mD ||
        i instanceof pD ||
        i instanceof wD ||
        i instanceof YP ||
        i instanceof fD ||
        i instanceof gD ||
        i instanceof XP ||
        i instanceof vD ||
        i instanceof yD) &&
        i.dispose();
    });
  });
}
function LJ(e, t) {
  let i;
  if ("material" in e) {
    let r = e.material;
    Array.isArray(r)
      ? (i = e.material[0].layers.find((s) => s.uuid === t))
      : (i = e.material.layers.find((s) => s.uuid === t));
  }
  if (i)
    return i.color.texture.image.img instanceof HTMLVideoElement
      ? i.color.texture.image.img
      : void 0;
}
var xD = new Map(),
  Dd = new Map(),
  Vc = class {
    constructor(e, t, i) {
      (this.data = t), (this.delay = 0), (this.status = "stopped");
      let { layerId: r, loop: s, volume: a, delay: n } = t;
      if (((this.object = i), r === void 0))
        throw new Error("Missing property");
      let o = LJ(i, r);
      o &&
        ((this.videoElement = o),
        (this.videoElement.loop = s === 1 / 0),
        Xx && (this.videoElement.autoplay = !0),
        a !== void 0 && (this.videoElement.volume = a)),
        n !== void 0 && (this.delay = n),
        Dd.has(i.uuid) ? Dd.get(i.uuid).push(this) : Dd.set(i.uuid, [this]),
        xD.set(e, this),
        this.pause();
    }
    mute() {
      !this.videoElement || (this.videoElement.muted = !0);
    }
    unMute() {
      !this.videoElement || (this.videoElement.muted = !1);
    }
    play(e) {
      if (!this.videoElement) return;
      let t =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      e
        ? (this.mute(), (this.delay += 150))
        : t
        ? (this.mute(),
          window.setTimeout(() => {
            this.unMute();
          }, 100))
        : this.unMute(),
        (this.delayTimerId = window.setTimeout(() => {
          if (!this.videoElement) return;
          let i = this.videoElement.play();
          i !== void 0 &&
            i
              .then((r) => {})
              .catch((r) => {
                this.play();
              }),
            this.clearDelay();
        }, this.delay)),
        (this.status = "playing");
    }
    clearDelay() {
      this.delayTimerId &&
        (clearTimeout(this.delayTimerId), delete this.delayTimerId);
    }
    pause() {
      !this.videoElement ||
        (this.videoElement.pause(), (this.status = "paused"));
    }
    stop() {
      !this.videoElement ||
        (this.videoElement.pause(),
        (this.videoElement.currentTime = 0),
        (this.status = "stopped"),
        this.clearDelay());
    }
    playByToggle() {
      this.data.toggle === "stop"
        ? this.status === "playing"
          ? this.stop()
          : (this.stop(), this.play())
        : this.data.toggle === "pause"
        ? this.status === "playing"
          ? this.pause()
          : this.play()
        : (this.stop(), this.play());
    }
    dispose() {
      !this.videoElement || (this.stop(), (this.videoElement.muted = !0));
    }
  },
  hx = class {
    constructor(e) {
      this.data = e;
    }
    dispatch() {
      this.data.playVideo
        ? this.pauseVideo(this.data.playVideo)
        : this.data.object
        ? this.pauseAllVideosFromObject(this.data.object)
        : this.pauseAllVideos();
    }
    pauseVideo(e) {
      let t = xD.get(e);
      !t ||
        (this.data.delay > 0
          ? (this.disposeDelay(),
            (this.timeoutId = window.setTimeout(() => {
              t[this.data.interaction](), this.disposeDelay();
            }, this.data.delay)))
          : t[this.data.interaction]());
    }
    pauseAllVideosFromObject(e) {
      let t = Dd.get(e);
      !t?.length ||
        (this.data.delay > 0
          ? (this.disposeDelay(),
            (this.timeoutId = window.setTimeout(() => {
              t.forEach((i) => i[this.data.interaction]()), this.disposeDelay();
            }, this.data.delay)))
          : t.forEach((i) => i[this.data.interaction]()));
    }
    pauseAllVideos() {
      let e = [...Dd.values()];
      !e.length ||
        (this.data.delay > 0
          ? (this.disposeDelay(),
            (this.timeoutId = window.setTimeout(() => {
              e.forEach((t) => {
                t.forEach((i) => {
                  i[this.data.interaction]();
                });
              }),
                this.disposeDelay();
            }, this.data.delay)))
          : e.forEach((t) => {
              t.forEach((i) => {
                i[this.data.interaction]();
              });
            }));
    }
    disposeDelay() {
      clearTimeout(this.timeoutId), delete this.timeoutId;
    }
    dispose() {
      clearTimeout(this.timeoutId), delete this.timeoutId;
    }
  },
  bD = class {
    constructor(e, t, i, r, s) {
      if (
        ((this.data = t),
        (this.shared = r),
        (this.condition = s),
        t.interaction === "play")
      )
        this.interaction = new Vc(e, t, i);
      else if (t.interaction === "pause" || t.interaction === "stop")
        this.interaction = new hx(t);
      else throw new Error("Missing property");
    }
    dispatchBasic() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.interaction instanceof Vc
        ? this.interaction.playByToggle()
        : this.interaction.dispatch();
    }
    dispatchConditional() {
      if (Xi(this.shared, this.condition) === !1) return !1;
      this.interaction instanceof Vc
        ? this.interaction.play()
        : this.interaction.dispatch();
    }
    dispose() {
      this.interaction.dispose();
    }
  },
  dE = (() => {
    let e, t, i, r;
    function s(o) {
      !e &&
        !pE() &&
        t?.sharedGameControlGlobals.createdObjects.length > 0 &&
        (e = requestAnimationFrame(a)),
        o && ((t = o), (r = o.requestRender));
    }
    function a(o) {
      let l = i ? o - i : 0,
        h = t.sharedGameControlGlobals.createdObjects,
        u = t.sharedGameControlGlobals.nCreatedPerAction,
        c = h.length,
        d = 0;
      for (; d < c; ) {
        let p = h[d];
        p.userData.createdTime === void 0 && (p.userData.createdTime = o),
          (p.userData.lifetime === void 0 && p.userData.quantity === void 0) ||
          (p.userData.lifetime &&
            o - p.userData.createdTime < p.userData.lifetime) ||
          (p.userData.quantity && u[p.userData.actionId] <= p.userData.quantity)
            ? (p.userData.velocity &&
                (p.position.addScaledVector(p.userData.velocity, l / 1e3),
                p.updateMatrix(),
                r()),
              d++)
            : (u[p.userData.actionId] > p.userData.quantity &&
                u[p.userData.actionId]--,
              h.splice(d, 1),
              p.removeFromParent(),
              t.sharedGameControlGlobals.rapierWorld && p.rigidBody
                ? (t.sharedGameControlGlobals.colliderToEntity.delete(
                    p.rigidBody.collider(0).handle
                  ),
                  t.sharedGameControlGlobals.rapierWorld.removeRigidBody(
                    p.rigidBody
                  ))
                : ((p.bvhGeometry = void 0),
                  (t.sharedGameControlGlobals.entitiesWithTransformAnim =
                    t.sharedGameControlGlobals.entitiesWithTransformAnim.filter(
                      (f) => f.bvhGeometry !== void 0
                    ))),
              c--,
              r());
      }
      (e = d > 0 ? requestAnimationFrame(a) : void 0), (i = d > 0 ? o : void 0);
    }
    function n() {
      pE() ? e && (cancelAnimationFrame(e), (e = void 0), (i = void 0)) : s();
    }
    return (
      typeof document < "u" && document.addEventListener("visibilitychange", n),
      s
    );
  })();
function pE() {
  return !!document && document.hidden;
}
var fE = new Rt(),
  BJ = new I(),
  zJ = new I(),
  wD = class {
    constructor(e, t, i, r, s) {
      (this.data = e),
        (this.page = t),
        (this.controlsManager = i),
        (this.shared = r),
        (this.condition = s),
        (this.intervalId = null),
        (this.timeoutIdQueue = []),
        (this.uniqueId = dt.generateUUID()),
        (this.dispatch = () => {
          if (Xi(this.shared, this.condition) === !1) return !1;
          this.data.delay
            ? this.timeoutIdQueue.push(
                window.setTimeout(this.dispatchInner, this.data.delay * 1e3)
              )
            : this.dispatchInner();
        }),
        (this.dispatchFromStart = () => {
          if (Xi(this.shared, this.condition) === !1) return !1;
          this.timeoutIdQueue.push(
            window.setTimeout(this.dispatchInner, this.data.delay * 1e3)
          );
        }),
        (this.dispatchThrottled = PH(
          this.dispatch,
          1e3 / this.data.creationSpeed
        )),
        (this.dispatchStart = () => {
          this.intervalId === null &&
            (this.intervalId = window.setInterval(
              this.dispatch,
              1e3 / this.data.creationSpeed
            ));
        }),
        (this.dispatchStop = () => {
          this.intervalId !== null &&
            (window.clearInterval(this.intervalId), (this.intervalId = null));
        }),
        (this.dispatchInner = () => {
          this.timeoutIdQueue.shift();
          let n = new fs(this.object);
          if (
            ((n.playModeVisible = !0),
            n.expand(),
            this.data.coordinateSystem !== "world")
          ) {
            let l = this.data.coordinateSystem,
              h = this.page.scene.find(l);
            h &&
              (h.updateMatrixWorldSVD(),
              n.hiddenMatrix.copy(h.matrixWorldRigid));
          }
          n.position.fromArray(this.data.position),
            n.rotation.fromArray(this.data.rotation),
            n.updateMatrix(),
            this.page.add(n);
          let o = this.controlsManager.sharedGameControlGlobals;
          o.createdObjects.push(n),
            o.nCreatedPerAction[this.uniqueId] === void 0
              ? (o.nCreatedPerAction[this.uniqueId] = 1)
              : o.nCreatedPerAction[this.uniqueId]++,
            n.updateWorldMatrix(!0, !0),
            n.traverseObject(this.traverseObjectCB),
            dE(),
            this.controlsManager.requestRender();
        }),
        (this.traverseObjectCB = (n) => {
          n.hasNonUniformScale && n.updateMatrixWorldSVD();
          let o;
          if (this.controlsManager.sharedGameControlGlobals.rapierWorld) {
            if (n instanceof Wa)
              if (n.objectForSample) {
                if (n.objectForSample.dataPatched.physics.fusedBody) return;
                o = n.object;
              } else
                return n.object.dataPatched.physics.fusedBody === !0 &&
                  n.object.dataPatched.physics.rigidBody === "dynamic"
                  ? !0
                  : void 0;
            else if (n instanceof fs) o = n.object;
            else if (((o = n), o.dataPatched.cloner?.hideBase)) return !0;
          } else {
            if (n instanceof Wa) return;
            n instanceof fs ? (o = n.object) : (o = n);
          }
          this.data.destroy === "Time"
            ? (n.userData.lifetime = this.data.lifetime * 1e3)
            : this.data.destroy === "Quantity" &&
              ((n.userData.quantity = this.data.destroyAfterQuantity),
              (n.userData.actionId = this.uniqueId));
          let l = new I().fromArray(this.data.velocity),
            h = o.dataPatched;
          if (
            !(h.physics.enabled === "visibility"
              ? !h.visible
              : !h.physics.enabled) &&
            (this.controlsManager.sharedGameControlGlobals.rapierWorld
              ? (this.controlsManager.addRigidBody(n, o, {
                  fromCreate: !0,
                  dynamic: this.data.dynamic,
                }),
                this.data.destroy === "Collision" &&
                  (n.rigidBody?.collider(0).setActiveEvents(1),
                  (n.userData.hasCollisionDestroy = !0)),
                n.matrixWorld.decompose(BJ, fE, zJ),
                l.applyQuaternion(fE),
                this.data.velocity.some((u) => u !== 0) &&
                  this.data.dynamic &&
                  n.rigidBody?.setLinvel(
                    l.divideScalar(this.controlsManager.pixelsPerMeter),
                    !0
                  ))
              : ("geometry" in n.object &&
                  this.controlsManager.addBoundsTree(n),
                this.data.velocity.some((u) => u !== 0) &&
                  this.data.dynamic &&
                  (n.userData.velocity = l)),
            o.dataPatched.physics?.fusedBody === !0)
          )
            return !0;
        });
      let a = this.page.scene.find(this.data.object);
      if (!a) throw new Error("Missing Property");
      if (
        ((this.object = a),
        this.data.coordinateSystem !== "world" &&
          !this.page.scene.find(this.data.coordinateSystem))
      )
        throw new Error("Missing Property");
      dE(i);
    }
    dispose() {
      this.intervalId !== null &&
        (window.clearInterval(this.intervalId), (this.intervalId = null)),
        this.timeoutIdQueue.forEach((e) => window.clearTimeout(e)),
        this.dispatchThrottled.cancel(),
        this.page.remove(
          ...this.controlsManager.sharedGameControlGlobals.createdObjects
        ),
        (this.controlsManager.sharedGameControlGlobals.createdObjects = []);
    }
  },
  _D = 200,
  X0 = 0.02,
  Q0 = 0.3,
  FJ = 65,
  Ste = new I(),
  mE = new I(),
  gE = new I(),
  kJ = new I(),
  As = new I(),
  Fs = new I(),
  Go = new I(),
  Z0 = new je(),
  vE = new je(),
  NJ = new je(),
  Ate = new je(),
  fa = new Rt(),
  $n = new Rt(),
  pn = new Ir(0, 0, 0, "YXZ"),
  UJ = new I(1, 0, 0),
  ma = new I(0, 1, 0),
  VJ = new I(0, 0, 1),
  yE = new I(1, 1, 1),
  Mte = new Ws(),
  jJ = 1,
  HJ = 0.025,
  GJ = 16e-6,
  xE = 12,
  WJ = 20,
  Ur = new Ma(),
  ga = new ur(),
  qJ = { type: "requestRender" },
  YJ = { type: "updateMatrix" },
  bE = Math.PI / 6,
  cx = class extends ls {
    constructor(e, t, i, r, s, a, n, o, l) {
      super(),
        (this.object = e),
        (this.domElement = t),
        (this.data = i),
        (this.gloabalPhysics = r),
        (this.controlsManager = s),
        (this.cameraFollow = a),
        (this.camera = n),
        (this.page = o),
        (this.sharedAssets = l),
        (this.enableDamping = !0),
        (this.hiddenMatrix0 = new je()),
        (this.target0 = new I()),
        (this.zoom0 = 1),
        (this.rotForce = 1),
        (this.moveForce = 1),
        (this.pixelsPerMeter = _D),
        (this.euler0 = new Ir(0, 0, 0, "YXZ")),
        (this.position0Cam = new I()),
        (this.quat0Cam = new Rt()),
        (this.scale0Cam = new I()),
        (this.hiddenMatrix0Cam = new je()),
        (this.threshEndTranslate = 0.01),
        (this.threshEndRotate = 1e-8),
        (this.threshEndRotVel = 0.005),
        (this.collider = {
          type: "capsule",
          radius: 40,
          segment: new Ma(new I(0, -40, 0), new I(0, 40, 0)),
          matrix: new je(),
          position: new I(),
          rotation: new Rt(),
        }),
        (this.euler = new Ir(0, 0, 0, "YXZ")),
        (this.eulerDelta = new I()),
        (this.lastPosition = new I()),
        (this.lastCameraQuaternion = new Rt()),
        (this.lastCameraPosition = new I()),
        (this.PI_2 = Math.PI / 2),
        (this.prevMouse = new re()),
        (this.velocityTarget = new I()),
        (this.velocity = new I()),
        (this.directionXZ = new I()),
        (this.rotVelocityStick = new I()),
        (this.rotVelocityTarget = new I()),
        (this.rotVelocity = new I()),
        (this.rotDirection = new I()),
        (this.nonColliderRotOffset = new je()),
        (this.nonColliderPosOffset = new je()),
        (this.firstPointerId = -1),
        (this.rot = new I()),
        (this.path = []),
        (this.movementState = {
          moveNegZ: 0,
          movePosZ: 0,
          moveNegX: 0,
          movePosX: 0,
          moveNegY: 0,
          movePosY: 0,
          rotPosX: 0,
          rotNegX: 0,
          rotPosY: 0,
          rotNegY: 0,
          jump: 0,
          run: 0,
        }),
        (this.vrEulerYOffset = 0),
        (this.onObject = !1),
        (this.actionState = {}),
        (this.keyAssignments = [
          ["moveNegZ", "W"],
          ["moveNegX", "A"],
          ["movePosZ", "S"],
          ["movePosX", "D"],
          ["rotPosX", "ArrowUp"],
          ["rotPosY", "ArrowLeft"],
          ["rotNegX", "ArrowDown"],
          ["rotNegY", "ArrowRight"],
          ["jump", " "],
        ]),
        (this.collisionEnabled = !0),
        (this.offsetMatrix = new je()),
        (this.objectToTarget = new I()),
        (this.objectToTarget0 = new I()),
        (this.objectToCamXZ = new I()),
        (this.objectToCamXZ0 = new I()),
        (this.targetToCamera = new I()),
        (this.targetToCamera0 = new I()),
        (this.cameraPolarAxis0 = new I()),
        (this.targetPos = new I()),
        (this.targetQuat = new Rt()),
        (this.lerpFactorPos = new I().setScalar(0.3)),
        (this.lerpFactorPosStart = 0.3),
        (this.lerpFactorPosEnd = 0.3),
        (this.lerpFactorRotStart = 0.3),
        (this.lerpFactorRotEnd = 0.3),
        (this.lerpFactorPosCamera = 0.3),
        (this.lerpFactorRotCamera = 0.3),
        (this.objXZQuat = new Rt()),
        (this.objXZQuatInv = new Rt()),
        (this.objXZRotMat = new je()),
        (this.isFirstPerson = !1),
        (this.didHit = !1),
        (this.groundVelocity = new I()),
        (this.pushedVelocity = new I()),
        (this.groundYRotation = 0),
        (this.objectRealQuat = new Rt()),
        (this.colliderWorldQuat = new Rt()),
        (this.groundNormal = new I()),
        (this.groundTilt = new Rt()),
        (this.groundTiltInv = new Rt()),
        (this.lastHitObj = null),
        (this.isFirstFrame = !0),
        (this.rotationAccumWhenOrientWithCamera = 0),
        (this.navMeshPathDest = null),
        (this.position = new I()),
        (this.quaternion = new Rt()),
        (this.scale = new I()),
        (this.initialAction = !0),
        (this.onPointerDown = (f) => {
          f.target !== this.domElement ||
            this.firstPointerId !== -1 ||
            ((this.firstPointerId = f.pointerId),
            this.domElement.ownerDocument.addEventListener(
              "pointermove",
              this.onPointerMove
            ),
            this.domElement.ownerDocument.addEventListener(
              "pointerup",
              this.onPointerUp
            ),
            this.rotBy !== "keys" &&
              !Js &&
              (!e2 || t2 >= 15.5) &&
              this.domElement.requestPointerLock(),
            this.prevMouse.set(f.clientX, f.clientY));
        }),
        (this.onPointerUp = (f) => {
          (this.firstPointerId = -1),
            this.domElement.ownerDocument.removeEventListener(
              "pointermove",
              this.onPointerMove
            ),
            this.domElement.ownerDocument.removeEventListener(
              "pointerup",
              this.onPointerUp
            ),
            f.pointerType === "mouse" &&
              this.domElement.ownerDocument.exitPointerLock();
        }),
        (this.onPointerMove = (f) => {
          if (f.pointerId !== this.firstPointerId) return;
          let m = f.clientX - this.prevMouse.x,
            g = f.clientY - this.prevMouse.y;
          this.prevMouse.set(f.clientX, f.clientY),
            f.pointerType === "mouse" &&
              this.rotBy !== "keys" &&
              (e2 && t2 < 15.5 && !Js
                ? ((this.eulerDelta.y = -m * this.mouseOrbitSensitivity),
                  (this.eulerDelta.x = -g * this.mouseOrbitSensitivity))
                : ((this.eulerDelta.y =
                    -f.movementX * this.mouseOrbitSensitivity),
                  (this.eulerDelta.x =
                    -f.movementY * this.mouseOrbitSensitivity))),
            f.pointerType !== "mouse" &&
              this.rotByTouch === "drag" &&
              ((this.eulerDelta.y = -m * this.mouseOrbitSensitivity * 5),
              (this.eulerDelta.x = -g * this.mouseOrbitSensitivity * 5)),
            this.controlsManager.requestRender();
        }),
        (this.onPointerlockChange = (f) => {
          this.domElement.ownerDocument.pointerLockElement === this.domElement
            ? (cx.isLocked = !0)
            : (cx.isLocked = !1);
        }),
        (this.onPointerlockError = () => {
          console.error("SPE.GameControls: Unable to use Pointer Lock API");
        }),
        (this.handleVisibilityChange = () => {
          if (document?.hidden)
            for (let f in this.movementState) this.movementState[f] = 0;
        }),
        (this.onKeyDown = (f) => {
          !(f.target instanceof HTMLInputElement) &&
            (f.code === "ArrowLeft" ||
              f.code === "ArrowUp" ||
              f.code === "ArrowRight" ||
              f.code === "ArrowDown" ||
              f.code === "Space") &&
            f.preventDefault();
          for (let m of this.keyAssignments)
            if (f.key.toUpperCase() === m[1] || f.key === m[1]) {
              this.movementState[m[0]] = 1;
              break;
            }
          this.controlsManager.requestRender();
        }),
        (this.onKeyUp = (f) => {
          for (let m of this.keyAssignments)
            if (
              f.key.toUpperCase() === m[1] ||
              f.key === m[1] ||
              f.code.slice(3, f.code.length).toUpperCase() === m[1]
            ) {
              this.movementState[m[0]] = 0;
              break;
            }
        }),
        (this.copyVRGamePadValues = (f, m) => {
          for (let g = 2; g < 4; g++) {
            let y = f.axes[g];
            m === 0
              ? g === 2
                ? (this.movementState.movePosX = y)
                : (this.movementState.movePosZ = y)
              : (f.buttons[3].pressed
                  ? (this.movementState.jump = 1)
                  : (this.movementState.jump = 0),
                g === 2
                  ? (Math.abs(this.movementState.rotPosY) < 0.3 &&
                      Math.abs(y) >= 0.3 &&
                      (this.vrEulerYOffset += y < 0 ? 1 : -1),
                    (this.movementState.rotPosY = y))
                  : this.moveMode === "fly" &&
                    (this.movementState.moveNegY = y));
          }
        }),
        (this.sharedGameControlGlobals = s.sharedGameControlGlobals),
        e === n && (this.isFirstPerson = !0),
        this.hiddenMatrix0.copy(this.object.hiddenMatrix),
        this.object.parent
          ? this.object.hiddenMatrix
              .copy(this.object.parent.matrixWorld)
              .invert()
          : this.object.hiddenMatrix.identity(),
        this.object.matrix.copy(this.object.matrixWorld),
        this.object.matrix.decompose(
          this.position,
          this.quaternion,
          this.scale
        ),
        this.euler0.setFromQuaternion(this.quaternion, "YXZ");
      let h = this.euler0.clone(),
        u = h.y;
      if (
        (this.objectRealQuat.copy(this.quaternion),
        (h.y = 0),
        this.quaternion.setFromEuler(h),
        this.objXZQuat.copy(this.quaternion),
        this.objXZQuatInv.copy(this.objXZQuat).invert(),
        this.objXZRotMat.makeRotationFromQuaternion(this.quaternion),
        h.set(0, u, 0),
        this.quaternion.setFromEuler(h),
        this.rot.setFromEuler(h),
        (this.object.matrixAutoUpdate = !1),
        (this.isFirstPerson || this.cameraFollow === !0) &&
          (this.target0.copy(this.camera.getTarget()),
          (this.zoom0 = this.camera.zoom)),
        this.cameraFollow === !0)
      ) {
        this.position0Cam.copy(this.camera.position),
          this.quat0Cam.copy(this.camera.quaternion),
          this.scale0Cam.copy(this.camera.scale),
          this.hiddenMatrix0Cam.copy(this.camera.hiddenMatrix),
          this.camera.parent
            ? (this.camera.hiddenMatrix.copy(this.camera?.parent.matrixWorld),
              this.camera.matrix.copy(this.camera.matrixWorld))
            : this.camera.hiddenMatrix.identity(),
          this.camera.matrix.copy(this.camera.matrixWorld),
          this.camera.matrix.decompose(
            this.camera.position,
            this.camera.quaternion,
            this.camera.scale
          ),
          (this.camera.matrixAutoUpdate = !1),
          this.offsetMatrix
            .copy(this.object.matrix)
            .invert()
            .multiply(this.camera.matrix);
        let f = new I(0, 0, -1).applyQuaternion(this.camera.quaternion),
          m = new I().subVectors(this.position, this.camera.position);
        this.objectToCamXZ.copy(m),
          (this.objectToCamXZ.y = 0),
          this.objectToCamXZ0.copy(this.objectToCamXZ);
        let g, y;
        Math.abs(f.y) < 1e-6
          ? ((m.y = 0), (f.y = 0), (y = m.projectOnVector(f)))
          : m.y / f.y > 0
          ? (y = f.multiplyScalar(m.y / f.y))
          : (y = f.multiplyScalar(m.length())),
          this.targetToCamera0.copy(y).negate(),
          (g = this.camera.position.clone().add(y)),
          this.objectToTarget0.subVectors(g, this.position);
        let x = new Ir().setFromQuaternion(this.camera.quaternion, "YXZ");
        (this.cameraPolarOffset = -x.x),
          (x.x = 0),
          (x.z = 0),
          (x.y -= Math.PI / 2),
          this.cameraPolarAxis0.set(0, 0, -1).applyEuler(x);
      }
      if (
        (this.object instanceof vs && (this.object.matrixAutoUpdate = !1),
        this.euler.setFromQuaternion(this.quaternion, "YXZ"),
        (this.rotByTouch = i.rotByTouch ?? "joystick"),
        (this.rotBy = i.rotBy ?? "keys"),
        (this.rotationMode = i.rotationMode ?? "normal"),
        (this.moveMode = i.moveMode ?? "walk"),
        (this.collisionEnabled = i.collisionEnabled),
        (this.speedTranslate = (i.speedTranslate ?? 250) * jJ),
        (this.speedOrbit = (i.speedRotate ?? 100) * HJ),
        (this.mouseOrbitSensitivity = (i.speedRotate ?? 100) * GJ),
        (this.keyAssignments = i.keyAssignments.map((f) => {
          let m = [f[0], f[1]];
          return (
            m[1] === "\u25B2"
              ? (m[1] = "ArrowUp")
              : m[1] === "\u25C0"
              ? (m[1] = "ArrowLeft")
              : m[1] === "\u25BC"
              ? (m[1] = "ArrowDown")
              : m[1] === "\u25B6"
              ? (m[1] = "ArrowRight")
              : m[1] === "\u21E7"
              ? (m[1] = "Shift")
              : m[1] === "\u21B5"
              ? (m[1] = "Enter")
              : m[1] === "Space"
              ? (m[1] = " ")
              : m[1] === "\u2318"
              ? (m[1] = "Meta")
              : m[1] === "Ctrl"
              ? (m[1] = "Control")
              : m[1] === "Esc" && (m[1] = "Escape"),
            m
          );
        })),
        i.rotBy === "mouse")
      ) {
        let f;
        (f = this.keyAssignments.findIndex((m) => m[0] === "rotNegX")),
          f !== -1 && (this.keyAssignments[f][1] = ""),
          (f = this.keyAssignments.findIndex((m) => m[0] === "rotPosX")),
          f !== -1 && (this.keyAssignments[f][1] = ""),
          (f = this.keyAssignments.findIndex((m) => m[0] === "rotPosY")),
          f !== -1 && (this.keyAssignments[f][1] = ""),
          (f = this.keyAssignments.findIndex((m) => m[0] === "rotNegY")),
          f !== -1 && (this.keyAssignments[f][1] = "");
      }
      (this.lerpFactorPosStart =
        1 - 0.02 ** (1 / ((i.delayPos[0] ?? 0.3) * 60))),
        (this.lerpFactorPosEnd =
          1 - 0.02 ** (1 / ((i.delayPos[1] ?? 0.3) * 60))),
        this.lerpFactorPos.setScalar(this.lerpFactorPosStart),
        (this.lerpFactorRotStart =
          1 - 0.02 ** (1 / ((i.delayRot[0] ?? 0.3) * 60))),
        (this.lerpFactorRotEnd =
          1 - 0.02 ** (1 / ((i.delayRot[1] ?? 0.3) * 60))),
        (this.lerpFactorPosCamera =
          1 - 0.02 ** (1 / ((i.delayPosCamera ?? 0.3) * 60))),
        (this.lerpFactorRotCamera =
          1 - 0.02 ** (1 / ((i.delayRotCamera ?? 0.3) * 60))),
        (this.gravity =
          (this.gloabalPhysics.gravity ?? Kc.defaultData.gravity) * xE),
        (this.usePhysics =
          this.gloabalPhysics.usePhysics ?? Kc.defaultData.usePhysics),
        (this.jumpPower = i.jumpPower * WJ),
        (this.resetYPosition =
          this.position.y +
          Math.abs(i.resetYPosition) * (this.gravity > 0 ? 1 : -1)),
        (this.alignToGround = i.alignToGround ?? !1),
        (this.orientMode = i.autoOrientMove ? i.orientMode : "none"),
        (this.orientWith =
          i.orientWith ?? eg.defaultDataThirdPerson.orientWith),
        (this.slopeThresh = (FJ * Math.PI) / 180),
        i.collider.type === "capsule"
          ? ((this.collider.radius = i.collider.radius),
            (this.collider.segment.start.y =
              i.collider.height / 2 - i.collider.radius),
            (this.collider.segment.end.y = -this.collider.segment.start.y),
            (this.offset = (i.collider.height * X0) / this.pixelsPerMeter),
            (this.stepThresh = (i.collider.height * Q0) / this.pixelsPerMeter),
            (this.colliderHeight = i.collider.height))
          : i.collider.type === "sphere"
          ? ((this.collider.radius = i.collider.radius),
            (this.collider.segment.start.y = 0),
            (this.collider.segment.end.y = 0),
            (this.offset = (2 * i.collider.radius * X0) / this.pixelsPerMeter),
            (this.stepThresh =
              (2 * i.collider.radius * Q0) / this.pixelsPerMeter),
            (this.colliderHeight = i.collider.radius * 2))
          : ((this.offset = (i.collider.height * X0) / this.pixelsPerMeter),
            (this.stepThresh = (i.collider.height * Q0) / this.pixelsPerMeter),
            (this.colliderHeight = i.collider.height)),
        (this.collider.type = i.collider.type);
      let c = new I().fromArray(i.collider.position),
        d = new Rt().setFromEuler(
          new Ir().fromArray([...i.collider.rotation, "XYZ"])
        );
      this.collider.position.copy(c).multiply(this.scale),
        this.collider.rotation.copy(d),
        this.collider.matrix.compose(c, d, yE),
        i.cameraXAxis !== void 0 &&
          ((this.cameraXAxis = i.cameraXAxis),
          (this.cameraYAxis = i.cameraYAxis),
          (this.minPolarAngle = i.cameraRotXLimits[0]),
          (this.maxPolarAngle = i.cameraRotXLimits[1]),
          (this.minAzimuthAngleRel = i.cameraRotYLimits[0]),
          (this.maxAzimuthAngleRel = i.cameraRotYLimits[1])),
        (this.forwardDir = i.forwardDirection ?? "-z"),
        this.isFirstPerson && (this.forwardDir = "-z"),
        (this.runMultiplier = i.runMultiplier ?? 2);
      let p = i.navmesh.destinationHelperRadius * 2;
      if (p > 0) {
        let f = new At();
        f.push({
          fi: 0,
          data: { ...jr.defaultData("light", "phong"), alpha: 0 },
          id: "layer1",
        }),
          f.push({
            fi: 0,
            data: {
              ...jr.defaultData("color"),
              color: i.navmesh.destinationHelperColor,
              alpha: i.navmesh.destinationHelperColor.a,
            },
            id: "layer2",
          });
        let m = new wb(
          { layers: f },
          { scene: this.page.scene, shared: this.sharedAssets }
        );
        (this.navMeshPathDest = new br(
          n3.create({ parameters: { width: p, height: p / 10, hollow: 0.7 } }),
          m
        )),
          (this.navMeshPathDest.material.userData.opacity0 =
            i.navmesh.destinationHelperColor.a);
      }
      this.activate();
    }
    reset(e = !1) {
      if ((this.object.hiddenMatrix.copy(this.hiddenMatrix0), e)) {
        this.object.updateMatrix(),
          this.object.updateMatrixWorld(),
          this.object.matrix.copy(this.object.matrixWorld),
          this.object.matrix.decompose(
            this.position,
            this.quaternion,
            this.scale
          ),
          this.object.parent
            ? this.object.hiddenMatrix
                .copy(this.object.parent.matrixWorld)
                .invert()
            : this.object.hiddenMatrix.identity();
        let t = new Ir().setFromQuaternion(this.quaternion, "YXZ"),
          i = t.y;
        this.objectRealQuat.copy(this.quaternion),
          (t.y = 0),
          this.quaternion.setFromEuler(t),
          this.objXZQuat.copy(this.quaternion),
          this.objXZQuatInv.copy(this.objXZQuat).invert(),
          this.objXZRotMat.makeRotationFromQuaternion(this.quaternion),
          t.set(0, i, 0),
          this.quaternion.setFromEuler(t),
          this.rot.setFromEuler(t),
          this.euler.setFromQuaternion(this.quaternion, "YXZ"),
          this.velocityTarget.set(0, 0, 0),
          this.velocity.set(0, 0, 0);
      } else
        this.object instanceof vs
          ? (this.object.matrixAutoUpdate = !0)
          : this.object.updateMatrix();
      this.cameraFollow === !0 &&
        (this.camera.quaternion.copy(this.quat0Cam),
        this.camera.position.copy(this.position0Cam),
        this.camera.scale.copy(this.scale0Cam),
        this.camera.hiddenMatrix.copy(this.hiddenMatrix0Cam),
        (this.camera.matrixAutoUpdate = !0)),
        this.controlsManager.requestRender();
    }
    activate() {
      this.instantiateActions(),
        this.domElement.ownerDocument.addEventListener(
          "pointerdown",
          this.onPointerDown
        ),
        this.domElement.ownerDocument.addEventListener(
          "keydown",
          this.onKeyDown
        ),
        this.domElement.ownerDocument.addEventListener("keyup", this.onKeyUp),
        this.domElement.ownerDocument.addEventListener(
          "pointerlockchange",
          this.onPointerlockChange
        ),
        this.domElement.ownerDocument.addEventListener(
          "pointerlockerror",
          this.onPointerlockError
        ),
        this.domElement.ownerDocument.addEventListener(
          "visibilitychange",
          this.handleVisibilityChange
        );
    }
    deactivate() {
      this.disposeActions(),
        this.domElement.ownerDocument.removeEventListener(
          "pointerdown",
          this.onPointerDown
        ),
        this.domElement.ownerDocument.removeEventListener(
          "keydown",
          this.onKeyDown
        ),
        this.domElement.ownerDocument.removeEventListener(
          "keyup",
          this.onKeyUp
        ),
        this.domElement.ownerDocument.removeEventListener(
          "pointerlockchange",
          this.onPointerlockChange
        ),
        this.domElement.ownerDocument.removeEventListener(
          "pointerlockerror",
          this.onPointerlockError
        ),
        this.domElement.ownerDocument.removeEventListener(
          "visibilitychange",
          this.handleVisibilityChange
        );
    }
    dispose() {
      this.deactivate(),
        this.navMeshPathDest?.parent && this.page.remove(this.navMeshPathDest);
    }
    instantiateActions() {
      let e = this.data,
        t = this.sharedAssets;
      e.gameActions !== void 0 &&
        ((this.actions = {}),
        $m.list.forEach((i) => {
          this.actions[i] = Rs(
            { ...e, disabled: !1, type: "GameControl" },
            e.gameActions[i],
            this.page,
            t,
            this.controlsManager.eventManager,
            this.object
          );
        })),
        this.dispatchStopEvent("move"),
        this.dispatchStopEvent("run"),
        this.dispatchStopEvent("jump"),
        this.dispatchStartEvent("idle"),
        this.initialAction && (this.initialAction = !1);
    }
    disposeActions() {
      (this.initialAction = !1),
        this.dispatchStopEvent("idle"),
        this.dispatchStopEvent("move"),
        this.dispatchStopEvent("run"),
        this.dispatchStopEvent("jump"),
        Xr(this.actions.idle),
        Xr(this.actions.move),
        Xr(this.actions.run),
        Xr(this.actions.jump);
    }
    dispatchStartEvent(e) {
      this.actions[e] !== void 0 &&
        (this.actionState[e] ||
          ((this.actionState[e] = !0),
          this.actions[e].Transition.forEach((t) => {
            t.play();
          }),
          this.actions[e].Animation.forEach((t) => {
            t.play(this.initialAction === !1);
          }),
          this.actions[e].Create.forEach((t) => {
            t.dispatchStart();
          }),
          this.actions[e].Audio.forEach((t) => {
            t.dispatchGameControl("start");
          }),
          this.actions[e].Particles.forEach((t) => {
            t.dispatchGameControl("start");
          })));
    }
    dispatchStopEvent(e) {
      this.actions[e] !== void 0 &&
        (!this.actionState[e] ||
          ((this.actionState[e] = !1),
          this.actions[e].Transition.forEach((t) => {
            t.stop(),
              t.object.currentState !== null &&
                t.object.changeSelectedState(null, {
                  scene: this.page.scene,
                  shared: this.sharedAssets,
                });
          }),
          this.actions[e].Create.forEach((t) => {
            t.dispatchStop();
          }),
          this.actions[e].Audio.forEach((t) => {
            t.dispatchGameControl("stop");
          }),
          this.actions[e].Particles.forEach((t) => {
            t.dispatchGameControl("stop");
          })));
    }
    get colliderWorldPosition() {
      return As.copy(this.collider.position)
        .applyQuaternion(this.objectRealQuat)
        .add(this.position);
    }
    update(e, t, i) {
      if (
        this.gravity < 0
          ? this.position.y < this.resetYPosition
          : this.position.y > this.resetYPosition
      )
        return this.reset(!0), !0;
      this.sharedGameControlGlobals.gamePads.forEach(this.copyVRGamePadValues);
      let r = (this.isFirstFrame ? 16.6 : e) / 1e3;
      this.isFirstFrame && (this.isFirstFrame = !1);
      let s = r * 60,
        a = !1;
      if (this.usePhysics && this.collisionEnabled) {
        let o = Fs.set(
            0,
            (this.velocity.y === 0
              ? this.pixelsPerMeter *
                Math.max(Math.abs(this.gravity) / (10 * xE), 1) *
                (this.gravity > 0 ? 1 : -1)
              : this.velocity.y) * r,
            0
          ).divideScalar(this.pixelsPerMeter),
          l = this.sharedGameControlGlobals.rapierWorld.castShape(
            this.colliderWorldPosition.divideScalar(this.pixelsPerMeter),
            this.colliderWorldQuat,
            o,
            this.object.rigidBody?.collider(0).shape,
            1,
            !1,
            16,
            void 0,
            void 0,
            this.object.rigidBody
          );
        if (l) {
          (this.onObject = !0),
            this.groundNormal
              .set(l.normal2.x, l.normal2.y, l.normal2.z)
              .applyQuaternion(this.colliderWorldQuat)
              .negate(),
            this.alignToGround && this.groundTiltAdjustment(this.groundNormal),
            Math.acos(this.groundNormal.y) < this.slopeThresh && (a = !0),
            l.collider.parent()?.bodyType() === 0 &&
              Math.acos(this.groundNormal.y) * (180 / Math.PI) > 45 &&
              (this.onObject = !1);
          let h = l.collider.parent();
          (this.groundYRotation = 0), this.groundVelocity.set(0, 0, 0);
          for (let u of this.sharedGameControlGlobals.entitiesWithTransformAnim)
            if (
              u.rigidBody === h &&
              u.userData.isFollowingObj !== this.object.uuid
            ) {
              (u.hasNonUniformScale
                ? u.matrixWorldRigid
                : u.matrixWorld
              ).decompose(As, $n, Fs),
                this.groundVelocity.subVectors(As, u.prevT),
                this.object
                  .getWorldPosition(Fs)
                  .add(this.collider.position)
                  .sub(As),
                (this.groundYRotation = pn.setFromQuaternion($n).y - u.prevR.y),
                Go.copy(Fs).applyAxisAngle(ma, this.groundYRotation),
                this.groundVelocity.add(Go.sub(Fs)).divideScalar(r);
              break;
            }
        } else this.onObject = !1;
      }
      if (
        (this.moveMode === "walk" &&
          this.collisionEnabled &&
          (this.movementState.jump === 1 &&
            this.onObject &&
            ((this.velocityTarget.y = this.jumpPower),
            (this.movementState.jump = 0),
            this.dispatchStopEvent("idle"),
            this.dispatchStopEvent("move"),
            this.dispatchStopEvent("run"),
            this.dispatchStopEvent("jump"),
            this.dispatchStartEvent("jump"),
            (this.onObject = !1)),
          this.onObject
            ? (this.velocityTarget.y /= 2)
            : (this.velocityTarget.y += this.gravity * s)),
        this.moveMode === "fly" &&
          (this.velocityTarget.y =
            (this.movementState.movePosY - this.movementState.moveNegY) *
            this.speedTranslate),
        (this.directionXZ.z =
          this.movementState.movePosZ - this.movementState.moveNegZ),
        (this.directionXZ.x =
          this.movementState.movePosX - this.movementState.moveNegX),
        this.directionXZ.manhattanLength() > 0 && (this.path = []),
        this.navMeshPathDest)
      ) {
        let o = this.navMeshPathDest.material;
        if (this.moveMode === "walk" && this.path.length > 1) {
          this.navMeshPathDest.position.copy(this.path[this.path.length - 1]),
            this.navMeshPathDest.parent || this.page.add(this.navMeshPathDest);
          let l = As.subVectors(this.path[1], this.position),
            h = Fs.subVectors(this.path[1], this.path[0]);
          l.dot(h) < 0
            ? this.path.shift()
            : ((this.directionXZ.x = h.x), (this.directionXZ.z = h.z)),
            (o.opacity = o.userData.opacity0);
        } else
          (o.opacity -= 0.05 * o.userData.opacity0),
            this.navMeshPathDest.material.opacity <= 0 &&
              this.navMeshPathDest.parent &&
              this.page.remove(this.navMeshPathDest);
      }
      this.directionXZ.normalize(),
        this.movementState.run
          ? (this.moveForce = this.runMultiplier)
          : (this.moveForce = 1),
        (this.velocityTarget.z =
          this.directionXZ.z * this.speedTranslate * this.moveForce),
        (this.velocityTarget.x =
          this.directionXZ.x * this.speedTranslate * this.moveForce),
        (
          this.moveMode === "walk"
            ? this.velocityTarget.x + this.velocityTarget.z === 0
            : this.velocityTarget.manhattanLength() === 0
        )
          ? this.lerpFactorPos.setScalar(this.lerpFactorPosEnd)
          : this.lerpFactorPos.setScalar(this.lerpFactorPosStart),
        this.moveMode === "walk" && (this.lerpFactorPos.y = 1),
        (this.didHit === !1 && this.pushedVelocity.manhattanLength() === 0) ||
        this.usePhysics === !1
          ? ((this.velocity.x +=
              (this.velocityTarget.x - this.velocity.x) *
              (1 - (1 - this.lerpFactorPos.x) ** s)),
            (this.velocity.y +=
              (this.velocityTarget.y - this.velocity.y) *
              (1 - (1 - this.lerpFactorPos.y) ** s)),
            (this.velocity.z +=
              (this.velocityTarget.z - this.velocity.z) *
              (1 - (1 - this.lerpFactorPos.z) ** s)))
          : this.velocity.copy(this.velocityTarget),
        (
          this.moveMode === "walk"
            ? this.velocity.x ** 2 + this.velocity.z ** 2 < this.speedTranslate
            : this.velocity.lengthSq() < this.speedTranslate
        )
          ? (this.dispatchStopEvent("move"),
            this.dispatchStopEvent("run"),
            this.onObject &&
              (this.dispatchStopEvent("jump"), this.dispatchStartEvent("idle")))
          : (this.dispatchStopEvent("idle"),
            this.onObject &&
              (this.dispatchStopEvent("jump"),
              this.movementState.run
                ? (this.dispatchStopEvent("move"),
                  this.dispatchStartEvent("run"))
                : (this.dispatchStopEvent("run"),
                  this.dispatchStartEvent("move"))));
      let n = kJ.copy(this.velocity);
      if (this.orientMode !== "none" && this.isFirstPerson === !1) {
        let o = Fs.copy(n);
        (o.y = 0), n.set(0, n.y, -o.length());
      }
      if (
        this.directionXZ.manhattanLength() > 0 &&
        this.orientMode !== "none" &&
        this.isFirstPerson === !1
      )
        if (this.orientWith === "camera" && this.path.length <= 1) {
          let o = As;
          this.camera.getWorldDirection(o);
          let l = Go.copy(ma).multiplyScalar(o.dot(ma));
          o.sub(l);
          let h = Fs.copy(this.directionXZ);
          (h.x *= -1),
            (this.rot.y =
              o.angleTo(h) * (o.cross(h).y > 0 ? -1 : 1) +
              this.rotationAccumWhenOrientWithCamera);
        } else
          this.rot.y =
            (this.path.length > 1 ? 0 : this.euler.y) +
            Math.atan2(-this.directionXZ.z, this.directionXZ.x) -
            Math.PI / 2;
      if (
        (pn.setFromVector3(this.rot),
        this.moveMode === "walk" && (pn.x = 0),
        n.applyEuler(pn),
        a &&
          ($n.setFromUnitVectors(ma, this.groundNormal), n.applyQuaternion($n)),
        i)
      ) {
        let o = pn.set(0, this.vrEulerYOffset * bE, 0);
        i.applyEuler(o),
          (n.x += i.x),
          (n.z += i.z),
          (this.nonColliderPosOffset.elements[13] += i.y * r);
      }
      if (this.usePhysics === !0) {
        let o = Fs;
        this.pushedVelocity.set(0, 0, 0);
        for (let l of this.sharedGameControlGlobals.entitiesWithTransformAnim) {
          let h = Go.setFromMatrixPosition(l.matrixWorld)
              .sub(l.prevT)
              .divideScalar(r)
              .divideScalar(this.pixelsPerMeter),
            u = l.rigidBody
              .collider(0)
              .castCollider(
                h,
                this.object.rigidBody.collider(0),
                As.copy(n).divideScalar(this.pixelsPerMeter),
                r,
                !1
              );
          h.multiplyScalar(this.pixelsPerMeter);
          let c = si.is(l) ? l : l.object;
          if (u !== null && this.lastHitObj !== c) {
            let d;
            l instanceof fs && (d = l);
            let p =
              this.sharedGameControlGlobals.entityToCollisionEvents[c.uuid];
            if (p)
              for (let f of p)
                f.data.target === "character" &&
                  (f.dispatch(d), c.dispatchEvent(dx));
            this.lastHitObj = c;
          }
          if (u !== null) {
            this.pushedVelocity.copy(h),
              o.copy(u.normal1).applyQuaternion(l.quaternion);
            break;
          }
        }
        if (this.pushedVelocity.manhattanLength() !== 0) {
          let l = o.dot(n);
          l < 0 && n.addScaledVector(o, -l), n.add(this.pushedVelocity);
        } else n.add(this.groundVelocity);
      }
      if (
        ((this.rotDirection.y =
          Number(this.movementState.rotPosY) -
          Number(this.movementState.rotNegY)),
        (this.rotDirection.x =
          Number(this.movementState.rotPosX) -
          Number(this.movementState.rotNegX)),
        this.rotDirection.normalize(),
        (this.rotationMode === "normal" &&
          (this.movementState.rotPosX || this.movementState.rotNegX)) ||
        (this.rotationMode === "steer" &&
          (this.movementState.rotPosX || this.movementState.rotNegX) &&
          (this.movementState.movePosZ ||
            this.movementState.moveNegZ ||
            this.moveMode === "walk"))
          ? (this.rotVelocityStick.x =
              -this.rotDirection.x * this.speedOrbit * this.rotForce)
          : (this.rotVelocityStick.x = 0),
        (this.rotationMode === "normal" &&
          (this.movementState.rotPosY || this.movementState.rotNegY)) ||
        (this.rotationMode === "steer" &&
          (this.movementState.rotPosY || this.movementState.rotNegY) &&
          (this.movementState.movePosZ || this.movementState.moveNegZ))
          ? (this.rotVelocityStick.y =
              -this.rotDirection.y * this.speedOrbit * this.rotForce)
          : (this.rotVelocityStick.y = 0),
        this.rotVelocityTarget.subVectors(
          this.eulerDelta.divideScalar(r),
          this.rotVelocityStick
        ),
        this.rotVelocityTarget.manhattanLength() === 0
          ? this.rotVelocity.lerp(
              this.rotVelocityTarget,
              1 - (1 - this.lerpFactorRotEnd) ** s
            )
          : this.rotVelocity.lerp(
              this.rotVelocityTarget,
              1 - (1 - this.lerpFactorRotStart) ** s
            ),
        (this.euler.x += this.rotVelocity.x * r),
        (this.euler.y += this.rotVelocity.y * r + this.groundYRotation),
        this.rotVelocityTarget.y === 0 &&
        this.directionXZ.manhattanLength() === 0
          ? (this.rotationAccumWhenOrientWithCamera = 0)
          : (this.cameraFollow === !1 || this.cameraYAxis === "Locked") &&
            (this.rotationAccumWhenOrientWithCamera += this.rotVelocity.y * r),
        this.isFirstPerson === !1 &&
          this.orientMode !== "none" &&
          this.directionXZ.manhattanLength() > 0)
      ) {
        if (this.orientMode === "radial") {
          this.objectToCamXZ
            .copy(this.objectToCamXZ0)
            .applyAxisAngle(ma, this.euler.y - this.euler0.y);
          let o = Fs.copy(this.objectToCamXZ).normalize(),
            l = Go.copy(n).multiplyScalar(r);
          l.y = 0;
          let h = l.sub(As.copy(o).multiplyScalar(l.dot(o))).cross(o).y;
          this.euler.y -= Math.atan2(h, this.objectToCamXZ.length());
        }
      } else
        (this.rot.y += this.rotVelocity.y * r + this.groundYRotation),
          this.rotVelocityTarget.y !== 0 &&
            (this.cameraFollow === !1 || this.cameraYAxis === "Locked") &&
            (this.euler.y = this.rot.y);
      if (
        (this.cameraFollow === !0 &&
          (this.moveMode === "walk"
            ? this.cameraXAxis === "Limit"
              ? (this.euler.x = dt.clamp(
                  this.euler.x,
                  -this.maxPolarAngle + this.cameraPolarOffset + 1e-6,
                  -this.minPolarAngle + this.cameraPolarOffset - 1e-6
                ))
              : (this.euler.x = dt.clamp(
                  this.euler.x,
                  -this.PI_2 + this.cameraPolarOffset,
                  this.PI_2 + this.cameraPolarOffset
                ))
            : this.cameraXAxis === "Limit" &&
              (this.euler.x = dt.clamp(this.euler.x, -this.PI_2, this.PI_2))),
        this.moveMode === "fly"
          ? (this.rot.x = this.euler.x)
          : this.isFirstPerson &&
            (t ? (pn.copy(t), (pn.y = 0)) : (pn.copy(this.euler), (pn.y = 0)),
            this.nonColliderRotOffset.makeRotationFromEuler(pn)),
        t &&
          (this.moveMode === "walk"
            ? ((this.rot.y = t.y), (this.rot.x = 0), (this.rot.z = 0))
            : this.rot.setFromEuler(t),
          (this.rot.y += this.vrEulerYOffset * bE)),
        fa.setFromAxisAngle(UJ, this.rot.x),
        $n.setFromAxisAngle(ma, this.rot.y),
        $n.multiply(fa),
        fa.setFromAxisAngle(VJ, this.rot.z),
        $n.multiply(fa),
        this.quaternion.copy($n),
        this.objectRealQuat.multiplyQuaternions(
          this.quaternion,
          this.objXZQuat
        ),
        this.colliderWorldQuat
          .copy(this.objectRealQuat)
          .multiply(this.collider.rotation),
        this.collisionEnabled)
      )
        if (this.usePhysics) {
          let o = Fs.copy(n).multiplyScalar(r / this.pixelsPerMeter),
            l = null;
          this.didHit = !1;
          let h = new I();
          for (let u = 0; u < 5; u++) {
            let c = o.length(),
              d = Go.copy(o).normalize();
            if (
              ((l = this.sharedGameControlGlobals.rapierWorld.castShape(
                this.colliderWorldPosition
                  .divideScalar(this.pixelsPerMeter)
                  .add(h),
                this.colliderWorldQuat,
                d,
                this.object.rigidBody?.collider(0).shape,
                c,
                !1,
                24,
                void 0,
                void 0,
                this.object.rigidBody
              )),
              l !== null)
            ) {
              this.didHit = !0;
              let p = this.sharedGameControlGlobals.colliderToEntity.get(
                l.collider.handle
              );
              if (p !== this.lastHitObj && u === 0) {
                this.lastHitObj = p;
                let y =
                  this.sharedGameControlGlobals.entityToCollisionEvents[
                    p?.uuid
                  ];
                if (y) {
                  for (let x of y)
                    if (x.data.target === "character") {
                      let b =
                          (this.sharedGameControlGlobals.rapierWorld?.getCollider(
                            l.collider.handle
                          ))._parent,
                        _;
                      if (p.cloner) {
                        for (let S of p.cloner.children)
                          if (S.rigidBody === b) {
                            _ = S;
                            break;
                          }
                      }
                      x.dispatch(_), p.dispatchEvent(dx);
                    }
                }
              }
              let f = mE
                  .set(l.normal2.x, l.normal2.y, l.normal2.z)
                  .applyQuaternion(this.colliderWorldQuat),
                m = gE.copy(d).multiplyScalar(l.toi).dot(f),
                g = l.toi;
              if (
                (g === 0 &&
                  (this.position.y += this.offset * this.pixelsPerMeter),
                m > this.offset &&
                  ((g = (l.toi * (m - this.offset)) / m),
                  h.addScaledVector(d, g)),
                o.copy(d).multiplyScalar(c - g),
                Math.acos(-f.y) > this.slopeThresh)
              ) {
                let y = this.colliderWorldPosition
                    .divideScalar(this.pixelsPerMeter)
                    .add(h),
                  x = Go.copy(l.witness2).applyQuaternion(
                    this.colliderWorldQuat
                  );
                x.y = 0;
                let b = y.add(x);
                b.y += this.stepThresh;
                let _ = this.sharedGameControlGlobals.rapierWorld.castShape(
                  b,
                  this.colliderWorldQuat,
                  o,
                  this.object.rigidBody?.collider(0).shape,
                  1,
                  !1,
                  24,
                  void 0,
                  void 0,
                  this.object.rigidBody
                );
                _ !== null && _.toi === 0 && ((f.y = 0), f.normalize());
              }
              o.addScaledVector(f, -o.dot(f));
            } else {
              u === 0 &&
                this.directionXZ.manhattanLength() !== 0 &&
                (this.lastHitObj = null),
                h.add(o);
              break;
            }
          }
          this.position.addScaledVector(h, this.pixelsPerMeter),
            this.object.rigidBody?.setTranslation(
              As.copy(this.position).divideScalar(this.pixelsPerMeter),
              !0
            ),
            this.object.rigidBody?.setRotation(
              fa
                .copy(this.quaternion)
                .premultiply(this.groundTilt)
                .multiply(this.objXZQuat),
              !0
            );
        } else {
          let o = this.onObject ? 1 : 5,
            l = n.multiplyScalar(r / o);
          for (let h = 0; h < o; h++)
            this.position.add(l), this.collisionAdjustment(r / o);
        }
      else this.position.addScaledVector(n, r);
      if (
        (this.moveMode === "walk" &&
          this.onObject &&
          ((this.velocityTarget.y = 0), (this.velocity.y = 0)),
        this.quaternion.premultiply(this.groundTilt).multiply(this.objXZQuat),
        this.forwardDir === "+z" &&
          this.quaternion.premultiply(fa.setFromAxisAngle(ma, Math.PI)),
        this.object.matrix.compose(this.position, this.quaternion, this.scale),
        (this.object.matrixWorldNeedsUpdate = !0),
        this.object.matrix
          .multiply(this.nonColliderPosOffset)
          .multiply(this.nonColliderRotOffset),
        this.quaternion
          .premultiply(this.groundTiltInv)
          .multiply(this.objXZQuatInv),
        this.cameraFollow === !0)
      ) {
        this.updateFollowArms();
        let o = this.objectToTarget.add(this.position),
          l = this.targetToCamera.add(o);
        Z0.lookAt(l, o, ma).setPosition(l),
          Z0.decompose(this.targetPos, this.targetQuat, As),
          this.camera.quaternion.slerp(
            this.targetQuat,
            1 - (1 - this.lerpFactorRotCamera) ** s
          ),
          this.camera.position.lerp(
            this.targetPos,
            1 - (1 - this.lerpFactorPosCamera) ** s
          ),
          this.camera.updateMatrix(),
          this.camera.updateMatrixWorld(),
          this.cameraYAxis === "Limit" &&
            this.orientMode === "cartesian" &&
            (this.euler.y = dt.clamp(
              this.euler.y,
              this.minAzimuthAngleRel,
              this.maxAzimuthAngleRel
            )),
          (this.euler.x = dt.clamp(
            this.euler.x,
            -this.PI_2 +
              (this.cameraPolarOffset < 0 ? this.cameraPolarOffset : 0),
            this.PI_2 +
              (this.cameraPolarOffset > 0 ? this.cameraPolarOffset : 0)
          ));
      }
      return (
        this.eulerDelta.set(0, 0, 0),
        this.object.dispatchEvent(YJ),
        this.path.length < 2 &&
        this.lastPosition.distanceToSquared(this.position) <
          this.threshEndTranslate &&
        Math.abs(this.rotVelocity.x) < this.threshEndRotVel &&
        Math.abs(this.rotVelocity.y) < this.threshEndRotVel &&
        (this.camera === void 0 ||
          this.isFirstPerson ||
          (this.lastCameraPosition.distanceToSquared(this.camera.position) <
            this.threshEndTranslate &&
            8 * (1 - this.lastCameraQuaternion.dot(this.camera.quaternion)) <
              this.threshEndRotate)) &&
        (this.moveMode === "fly" ||
          this.onObject === !0 ||
          this.collisionEnabled === !1) &&
        (this.navMeshPathDest === null ||
          this.navMeshPathDest.material.opacity <
            -0.04 * this.navMeshPathDest?.material?.userData.opacity0)
          ? !1
          : (this.camera &&
              (this.lastCameraPosition.copy(this.camera.position),
              this.lastCameraQuaternion.copy(this.camera.quaternion)),
            this.lastPosition.copy(this.position),
            this.object.dispatchEvent(qJ),
            !0)
      );
    }
    updateFollowArms() {
      this.objectToTarget.copy(this.objectToTarget0),
        this.targetToCamera.copy(this.targetToCamera0);
      let e = fa.setFromAxisAngle(
        ma,
        this.cameraYAxis === "Limit" && this.orientMode !== "radial"
          ? dt.clamp(
              this.euler.y - this.euler0.y,
              this.minAzimuthAngleRel,
              this.maxAzimuthAngleRel
            )
          : this.euler.y - this.euler0.y
      );
      (this.cameraYAxis !== "Locked" || this.orientMode === "radial") &&
        this.objectToTarget.applyQuaternion(e);
      let t;
      this.cameraXAxis === "Limit"
        ? (t = dt.clamp(
            this.euler.x,
            -this.maxPolarAngle + this.cameraPolarOffset + 1e-6,
            -this.minPolarAngle + this.cameraPolarOffset - 1e-6
          ))
        : (t = dt.clamp(
            this.euler.x,
            -this.PI_2 + this.cameraPolarOffset + 1e-6,
            this.PI_2 + this.cameraPolarOffset - 1e-6
          ));
      let i = As.copy(this.cameraPolarAxis0);
      (this.cameraYAxis !== "Locked" || this.orientMode === "radial") &&
        i.applyQuaternion(e);
      let r = $n.setFromAxisAngle(i, t);
      this.cameraYAxis !== "Locked" && this.targetToCamera.applyQuaternion(e),
        this.cameraXAxis !== "Locked" && this.targetToCamera.applyQuaternion(r);
    }
    groundTiltAdjustment(e) {
      (ma.angleTo(e) * 180) / Math.PI < 15 ||
      (ma.angleTo(e) * 180) / Math.PI > 85
        ? fa.identity()
        : fa.setFromUnitVectors(ma, e),
        this.groundTilt.slerp(fa, 0.06),
        this.groundTiltInv.copy(this.groundTilt).invert();
    }
    collisionAdjustment(e) {
      let t = gE.set(0, 0, 0);
      this.object.matrix.compose(this.position, this.quaternion, this.scale);
      let i = Z0.multiplyMatrices(this.object.matrix, this.objXZRotMat)
        .multiply(this.collider.matrix)
        .decompose(As, fa, Fs)
        .compose(As, fa, yE);
      this.sharedGameControlGlobals.entitiesWithTransformAnim.forEach((s) => {
        if (s === this.object || s.isDescendantOf(this.object)) return;
        ga.makeEmpty(), s.updateMatrixWorldSVD();
        let a = s.matrixWorldRigid,
          n = vE.copy(a).invert(),
          o = NJ.copy(vE).multiply(i);
        Ur.copy(this.collider.segment),
          Ur.start.applyMatrix4(o),
          Ur.end.applyMatrix4(o);
        let l = mE.copy(this.position).applyMatrix4(n);
        ga.expandByPoint(Ur.start),
          ga.expandByPoint(Ur.end),
          ga.min.addScalar(-this.collider.radius),
          ga.max.addScalar(this.collider.radius),
          s.bvhGeometry.boundsTree.shapecast({
            traverseBoundsOrder(h) {
              return h.distanceToPoint(Ur.end);
            },
            intersectsBounds: (h) => h.intersectsBox(ga),
            intersectsTriangle: (h) => {
              let u = As,
                c = Fs,
                d = h.closestPointToSegment(Ur, u, c);
              if (d < this.collider.radius) {
                let p = this.collider.radius - d,
                  f = c.sub(u).normalize(),
                  m = Go.copy(l);
                m.addScaledVector(f, p);
                let g = m.applyMatrix4(a).sub(this.position);
                t.add(g),
                  Ur.start.addScaledVector(f, p),
                  Ur.end.addScaledVector(f, p);
              }
            },
          });
      }),
        ga.makeEmpty(),
        Ur.copy(this.collider.segment),
        Ur.start.applyMatrix4(i),
        Ur.end.applyMatrix4(i),
        ga.expandByPoint(Ur.start),
        ga.expandByPoint(Ur.end),
        ga.min.addScalar(-this.collider.radius),
        ga.max.addScalar(this.collider.radius),
        this.sharedGameControlGlobals.staticMeshBVH?.shapecast({
          traverseBoundsOrder(s) {
            return s.distanceToPoint(Ur.end);
          },
          intersectsBounds: (s) => s.intersectsBox(ga),
          intersectsTriangle: (s) => {
            let a = As,
              n = Fs,
              o = s.closestPointToSegment(Ur, a, n);
            if (o < this.collider.radius) {
              let l = this.collider.radius - o,
                h = n.sub(a).normalize();
              this.alignToGround && this.groundTiltAdjustment(h),
                t.addScaledVector(h, l),
                Ur.start.addScaledVector(h, l),
                Ur.end.addScaledVector(h, l);
            }
          },
        }),
        (this.onObject = Math.abs(t.y) > Math.abs(e * this.velocity.y * 0.25)),
        this.onObject && this.dispatchStopEvent("jump");
      let r = Math.max(0, t.length() - 1e-5);
      t.normalize().multiplyScalar(r), this.position.add(t);
    }
  },
  SD = cx;
SD.isLocked = !1;
var XJ = Sr(FE());
function co(e, t) {
  let i = new yt();
  if (!e.getAttribute("position"))
    return i.setAttribute("position", new ot([], 3)), i.setIndex([]), i;
  let { positions: r, triIndices: s } = kg(
    e.getAttribute("position"),
    e.getIndex()
  );
  return (
    i.setAttribute("position", new ot(r, 3)),
    i.setIndex(s),
    t && i.applyMatrix4(t),
    i
  );
}
var QJ = new je(),
  ZJ = new je(),
  fn = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
  ];
function AD(e) {
  let t = e.elements;
  (fn[0][0] = t[0]),
    (fn[0][1] = t[4]),
    (fn[0][2] = t[8]),
    (fn[1][0] = t[1]),
    (fn[1][1] = t[5]),
    (fn[1][2] = t[9]),
    (fn[2][0] = t[2]),
    (fn[2][1] = t[6]),
    (fn[2][2] = t[10]);
  let { u: i, v: r } = (0, XJ.SVD)(fn),
    s = QJ.set(
      i[0][0],
      i[0][1],
      i[0][2],
      0,
      i[1][0],
      i[1][1],
      i[1][2],
      0,
      i[2][0],
      i[2][1],
      i[2][2],
      0,
      0,
      0,
      0,
      1
    ),
    a = ZJ.set(
      r[0][0],
      r[0][1],
      r[0][2],
      0,
      r[1][0],
      r[1][1],
      r[1][2],
      0,
      r[2][0],
      r[2][1],
      r[2][2],
      0,
      0,
      0,
      0,
      1
    );
  return s.multiply(a.transpose());
}
var KJ = class extends PC {
    constructor() {
      super(), this.layers.enable(3), this.layers.enable(8);
    }
    setFromCamera(e, t) {
      t.isOrthographicCamera
        ? (this.ray.origin.set(e.x, e.y, -1).unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : t.isPerspectiveCamera
        ? (this.ray.origin.set(e.x, e.y, -1).unproject(t),
          this.ray.direction
            .set(e.x, e.y, 0.5)
            .unproject(t)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = t))
        : console.error("Raycaster: Unsupported camera type.");
    }
    intersectVisibleObjects(e, t = !0, i = []) {
      return (
        e.forEach((r) => {
          r.visible && this.intersectObject(r, t, i);
        }),
        i
      );
    }
    createRaycastLineHelper() {
      let e = new gl({ color: 65280, linewidth: 10 }),
        t = new I(this.ray.origin.x, this.ray.origin.y, this.ray.origin.z),
        i = new I(
          this.ray.direction.x,
          this.ray.direction.y,
          this.ray.direction.z
        ),
        r = this.camera.far - this.camera.near,
        s = new I().addVectors(t, i.multiplyScalar(r)),
        a = new yt();
      return a.setFromPoints([t, s]), new _m(a, e);
    }
  },
  MD = (e) => e instanceof kc || e instanceof Nc;
function JJ(e, t) {
  return e.distance - t.distance;
}
function ED(e, t, i) {
  if (!(!ho(t) || !t.visible)) {
    ja(t) && t.raycast(e, i);
    for (let r of t.children) ED(e, r, i);
  }
}
function mm(e, t, i, r = !1) {
  if (!r && !i.some((a) => vg(e, a) !== void 0)) return [];
  let s = [];
  return t.children.forEach((a) => ED(e, a, s)), s.sort(JJ), s;
}
function ux(e) {
  let t = [];
  if (e.length) {
    let i = e[0].object;
    ho(i) && t.push(i);
    let r = i.parent;
    for (; r; ) MD(r) && t.push(r), (r = r.parent);
  }
  return t;
}
function uo(e, t, i, r) {
  let s = e.frame;
  if (s) {
    let a = t[0] * s.width,
      n = (1 - t[1]) * s.height;
    for (let o of i) {
      let l = o === s.uuid ? s : s.find(o);
      if (l?.intersects(a, n)) return r(l), !0;
    }
  }
  return !1;
}
function vg(e, t) {
  if (ja(t)) {
    if (t.visible) {
      let i = [];
      return t.raycast(e, i), i.length ? i[0] : void 0;
    }
  } else if (MD(t)) return CD(e, t);
}
function CD(e, t) {
  if (!(!ho(t) || !t.visible)) {
    if (ja(t)) {
      let i = [];
      if ((t.raycast(e, i), i.length)) return i[0];
    }
    for (let i of t.children) {
      let r = CD(e, i);
      if (r) return r;
    }
  }
}
function $J(e, t, i) {
  return {
    x: ((e - (i.left + window.scrollX)) / i.width) * 2 - 1,
    y: -((t - (i.top + window.scrollY)) / i.height) * 2 + 1,
  };
}
function e$(e, t, i) {
  return {
    x: (e - (i.left + window.scrollX)) / i.width,
    y: 1 - (t - (i.top + window.scrollY)) / i.height,
  };
}
var t$ = class {
    constructor(e, t, i, r, s, a, n, o) {
      (this.renderer = e),
        (this.publish = t),
        (this.scene = i),
        (this.getCamera = r),
        (this.sharedAssets = s),
        (this.requestRender = a),
        (this.isExport = n),
        (this.frame = o),
        (this.raycaster = new KJ()),
        (this._useWindowEvents = !1),
        (this.pointerWorld = { x: 0, y: 0 }),
        (this.pointerScreen = { x: 0, y: 0 }),
        (this._useWindowEvents = t.mouseEventTarget === "window"),
        (this.domElement = e.domElement),
        (this.eventElement = this._useWindowEvents ? window : e.domElement),
        (this._domRect = this.domElement.getBoundingClientRect());
    }
    get stopRaycast() {
      return this.publish.stopRaycast;
    }
    get page() {
      return this.scene.activePage;
    }
    set useWindowEvents(e) {
      (this._useWindowEvents = e),
        (this.eventElement = e ? window : this.renderer.domElement);
    }
    get useWindowEvents() {
      return this._useWindowEvents;
    }
    set domRect(e) {
      this._domRect = e;
    }
    get domRect() {
      return this._domRect;
    }
    updateRaycaster(e) {
      let { pageX: t, pageY: i } = e.touches?.length > 0 ? e.touches[0] : e;
      (this.pointerWorld = $J(t, i, this._domRect)),
        (this.pointerScreen = e$(t, i, this._domRect)),
        this.raycaster.setFromCamera(this.pointerWorld, this.getCamera());
    }
  },
  en = class {
    constructor(e) {
      (this.eventContext = e),
        (this.domEventsNeeded = new Set()),
        (this.hasVideoAction = !1);
    }
    connect() {}
    disconnect() {}
  },
  Xb = [
    ["start", "Start"],
    ["keyDown", "KeyDown"],
    ["keyUp", "KeyUp"],
    ["mouseDown", "MouseDown"],
    ["mouseUp", "MouseUp"],
    ["mouseHover", "MouseHover"],
    ["collision", "Collision"],
    ["lookAt", "LookAt"],
    ["follow", "Follow"],
    ["scroll", "Scroll"],
  ],
  TD = (e) => Xb.find(([t, i]) => i === e)?.[0],
  gp = (e) => Xb.find(([t]) => t === e)?.[1],
  i$ = (e, t) => {
    let i = TD(e);
    if (i) {
      let r = new CustomEvent(i, { bubbles: !0 });
      return Object.defineProperty(r, "target", { writable: !1, value: t }), r;
    }
  },
  r$ = class extends en {
    constructor(e) {
      super(e),
        (this.objectsPerEvents = new Map()),
        (this.splineEvents = {}),
        (this.onBeginEvent = (i) => {
          if (!i.eventName || !i.target || i.eventName === "Scroll") return;
          let r = this.splineEvents[TD(i.eventName)]?.[i.target.uuid];
          if (!r) return;
          i.eventName === "Scroll" &&
            i.deltaY !== void 0 &&
            Object.assign(r, { deltaY: i.deltaY });
          let { domElement: s } = this.eventContext;
          s.dispatchEvent(r);
        });
      let { page: t } = this.eventContext;
      t.traverseEntity((i) => {
        if (i.data?.events.length) {
          for (let [r, s] of Xb)
            if (
              i.data.events.some((a) => a.data.type === s && !a.data.disabled)
            ) {
              this.objectsPerEvents.has(r)
                ? this.objectsPerEvents.get(r)?.push(i)
                : this.objectsPerEvents.set(r, [i]);
              let a = { id: i.uuid, name: i.name },
                n = i$(s, a),
                o = this.splineEvents[r];
              o ? (o[i.uuid] = n) : (this.splineEvents[r] = { [i.uuid]: n });
            }
        }
      });
    }
    connect() {
      this.objectsPerEvents.forEach((e) => {
        e.forEach((t) => {
          t.addEventListener("beginEvent", this.onBeginEvent);
        });
      });
    }
    disconnect() {
      this.objectsPerEvents.forEach((e) => {
        e.forEach((t) => {
          t.removeEventListener("beginEvent", this.onBeginEvent);
        });
      });
    }
  },
  s$ = class {
    constructor(e, t, i, r, s, a) {
      if (
        ((this.id = e),
        (this.data = t),
        (this.object = i),
        (this.entered = !1),
        (this.alreadyPlayedNonTogglingActions = new Set()),
        (this.useToggle = t.runMode === "Toggle"),
        (t.type === "KeyDown" || t.type === "KeyUp" || t.type === "KeyPress") &&
          !t.key)
      )
        throw new Error("Missing property");
      this.actions = Rs(t, t.actions, r, s, a, i);
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatchHeld(e) {
      this.actions.Create.forEach((t) => {
        e && t.dispatchThrottled.cancel(), t.dispatchThrottled();
      });
    }
    dispatch(e = !1) {
      this.actions.Transition.forEach((t) => {
        t.object.currentTransitionEvent !== this
          ? ((t.object.currentTransitionEvent = this), t.init())
          : this.data.runMode === "Once" &&
            this.alreadyPlayedNonTogglingActions.add(t);
      }),
        this.useToggle
          ? (this.actions.Transition.forEach((t) => {
              t.toggle();
            }),
            this.actions.Animation.forEach((t) => {
              t.toggle();
            }),
            this.actions.SwitchCamera.forEach((t) => {
              t.toggle();
            }))
          : this.data.type === "MousePress" || this.data.type === "KeyPress"
          ? this.entered ||
            ((this.entered = !0),
            this.actions.Transition.forEach((t) => t.playFromCurrent()),
            this.actions.Animation.forEach((t) => t.playFromCurrent()),
            this.actions.SwitchCamera.forEach((t) => t.playFromCurrent()),
            this.actions.Create.forEach((t) => t.dispatchStart()))
          : (this.actions.Transition.some((t) => t.playing) ||
              this.actions.Transition.forEach((t) => {
                this.alreadyPlayedNonTogglingActions.has(t) === !1 && t.play();
              }),
            this.actions.SwitchCamera.some((t) => t.playing) ||
              this.actions.SwitchCamera.forEach((t) => {
                t.play();
              }),
            this.actions.Animation.forEach((t) => {
              t.play();
            })),
        this.actions.Link.forEach((t) => {
          t.dispatch();
        }),
        this.actions.SceneTransition.forEach((t) => {
          t.dispatch();
        }),
        e === !1 &&
          this.actions.Create.forEach((t) => {
            t.dispatch();
          }),
        this.actions.Destroy.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Reset.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Audio.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.Video.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.Particles.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch());
    }
    dispatchRelease() {
      this.entered &&
        ((this.entered = !1),
        this.actions.Transition.forEach((e) => e.reverseFromCurrent()),
        this.actions.Particles.forEach((e) => e.reverseFromCurrent()),
        this.actions.Animation.forEach((e) => e.reverseFromCurrent()),
        this.actions.SwitchCamera.forEach((e) => e.reverseFromCurrent()),
        this.actions.Create.forEach((e) => e.dispatchStop()));
    }
    dispatchUserEvent(e) {
      this.actions.Transition.forEach((t) => {
        t.object.currentTransitionEvent !== this &&
          ((t.object.currentTransitionEvent = this), t.init());
      }),
        e
          ? (this.actions.Transition.forEach((t) => t.reverseFromCurrent()),
            this.actions.Animation.forEach((t) => t.reverseFromCurrent()),
            this.actions.SwitchCamera.forEach((t) => t.reverseFromCurrent()))
          : (this.actions.Transition.forEach((t) => t.playFromCurrent()),
            this.actions.Animation.forEach((t) => t.playFromCurrent()),
            this.actions.SwitchCamera.forEach((t) => t.playFromCurrent())),
        this.actions.Link.forEach((t) => {
          t.dispatch();
        }),
        this.actions.SceneTransition.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Create.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Destroy.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Reset.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Audio.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.Video.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.Particles.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch());
    }
  },
  a$ = class extends en {
    constructor(e, t, i) {
      super(e),
        (this.useForRaycastProperty = i),
        (this.objectsPerTypes = {
          MouseDown: [],
          MouseUp: [],
          MousePress: [],
          KeyDown: [],
          KeyUp: [],
          KeyPress: [],
        }),
        (this.canvasMouseEvents = []),
        (this.eventsPerObjects = {
          MouseDown: {},
          MouseUp: {},
          MousePress: {},
          KeyDown: {},
          KeyUp: {},
          KeyPress: {},
        }),
        (this.heldKeys = {}),
        (this.heldKeysPress = {}),
        (this._prevObjects = []),
        (this.sceneInterects = null),
        (this.onCanvasRaycast = (n) => {
          if (
            this.useForRaycastProperty === !0 &&
            this.sceneInterects === null
          ) {
            this.eventContext.updateRaycaster(n);
            let { raycaster: o, page: l } = this.eventContext,
              h = mm(o, l, [], !0);
            (this.sceneInterects = h),
              h.length &&
                (this.eventContext.sharedAssets.raycastProperty = {
                  x: h[0].point.x,
                  y: h[0].point.y,
                  z: h[0].point.z,
                  objX: h[0].object.matrixWorld.elements[12],
                  objY: h[0].object.matrixWorld.elements[13],
                  objZ: h[0].object.matrixWorld.elements[14],
                });
          }
        }),
        (this.onCanvasMouseDown = (n) => {
          (n.target === this.eventContext.domElement ||
            n.target.tagName === "SPLINE-VIEWER") &&
            this.canvasMouseEvents.forEach((o) => {
              (o.data.type === "MouseDown" || o.data.type === "MousePress") &&
                (this.onCanvasRaycast(n), o.dispatch());
            });
        }),
        (this.onCanvasMouseUp = (n) => {
          (n.target === this.eventContext.domElement ||
            n.target.tagName === "SPLINE-VIEWER") &&
            this.canvasMouseEvents.forEach((o) => {
              o.data.type === "MouseUp"
                ? (this.onCanvasRaycast(n), o.dispatch())
                : o.data.type === "MousePress" && o.dispatchRelease();
            });
        }),
        (this.onMouseDown = (n) => {
          Pt.length > 1 ||
            (this.eventContext.updateRaycaster(n),
            this.handleMouseEvent("MouseDown"));
        }),
        (this.onMouseUp = (n) => {
          Pt.length > 1 ||
            (this.eventContext.updateRaycaster(n),
            this.handleMouseEvent("MouseUp"));
        }),
        (this.onMousePressDown = (n) => {
          Pt.length > 1 ||
            (this.eventContext.updateRaycaster(n),
            this.handleMousePressEvent());
        }),
        (this.onMousePressRelease = (n) => {
          Pt.length > 1 ||
            (this.eventContext.updateRaycaster(n),
            this.handleMousePressEvent(!0));
        }),
        (this.onKeyDown = (n) => {
          this.heldKeys[n.key] ||
            (this.handleKeyEvent(n, "KeyDown"),
            this.handleKeyEventHeld(n, "KeyDown", !0)),
            (this.heldKeys[n.key] = !0);
        }),
        (this.onKeyUp = (n) => {
          this.handleKeyEvent(n, "KeyUp"),
            this.handleKeyEventHeld(n, "KeyUp", !0);
        }),
        (this.onKeyPressDown = (n) => {
          this.heldKeysPress[n.key]
            ? this.handleKeyEventHeld(n, "KeyPress")
            : (this.handleKeyEvent(n, "KeyPress"),
              this.handleKeyEventHeld(n, "KeyPress", !0)),
            (this.heldKeysPress[n.key] = !0);
        }),
        (this.onKeyPressUp = (n) => {
          this.handleKeyEvent(n, "KeyPress", !0);
        }),
        (this.releaseHeldKey = (n) => {
          delete this.heldKeys[n.key];
        }),
        (this.releaseHeldKeyPress = (n) => {
          delete this.heldKeysPress[n.key];
        }),
        (this._onUserEvent = ({ eventName: n, target: o, reverse: l }) => {
          if (!n || !o) return;
          let h = gp(n);
          h &&
            (h === "MouseDown" || h === "MouseUp" || h === "MousePress"
              ? (o.dispatchEvent({ type: "beginEvent", eventName: h }),
                this.eventsPerObjects[h]?.[o.uuid]?.forEach((u) => {
                  u.dispatchUserEvent(l);
                }))
              : (h === "KeyDown" || h === "KeyUp" || h === "KeyPress") &&
                (o.dispatchEvent({ type: "beginEvent", eventName: h }),
                this.eventsPerObjects[h]?.[o.uuid]?.forEach((u) => {
                  u.dispatchUserEvent();
                })));
        });
      let { page: r, sharedAssets: s } = this.eventContext,
        a = (n, o) => {
          if (!n.data?.events.length) return;
          let l = [
            "MouseDown",
            "MouseUp",
            "MousePress",
            "KeyDown",
            "KeyUp",
            "KeyPress",
          ];
          for (let h of l) {
            let u = this.eventsPerObjects[h];
            n.data.events
              .filter(({ data: c }) => c.type === h && c.disabled !== !0)
              .forEach(({ id: c, data: d }) => {
                try {
                  let p = new s$(c, d, n, r, s, t);
                  p.actions.Video.length && (this.hasVideoAction = !0),
                    (d.type === "MouseDown" ||
                      d.type === "MouseUp" ||
                      d.type === "MousePress") &&
                    (d.mode === "Canvas" || d.mode === "Window")
                      ? this.canvasMouseEvents.push(p)
                      : u[n.uuid]
                      ? u[n.uuid].some((f) => f.id === p.id) ||
                        u[n.uuid].push(p)
                      : (u[n.uuid] = [p]);
                } catch {}
              }),
              u[n.uuid]?.length &&
                this.objectsPerTypes[h].push(
                  n instanceof Rr &&
                    (h === "MouseDown" || h === "MouseUp" || h === "MousePress")
                    ? o
                    : n
                );
          }
        };
      r.traverseEntity((n) => {
        (n instanceof ps || n instanceof Hr) &&
          n.frame?.traverse((o) => {
            a(o, n);
          }),
          a(n);
      });
    }
    connect() {
      let { domElement: e } = this.eventContext;
      (this.heldKeys = {}),
        (this.heldKeysPress = {}),
        this.domEventsNeeded.clear(),
        e.addEventListener("pointerdown", this.onCanvasMouseDown),
        e.addEventListener("pointerup", this.onCanvasMouseUp),
        (this.objectsPerTypes.MouseDown?.length ||
          this.useForRaycastProperty) &&
          (this.domEventsNeeded.add("pointerdown"),
          e.addEventListener("pointerdown", this.onMouseDown)),
        this.objectsPerTypes.MouseUp?.length &&
          (this.domEventsNeeded.add("pointerup"),
          e.addEventListener("pointerup", this.onMouseUp)),
        this.objectsPerTypes.MousePress?.length &&
          (this.domEventsNeeded.add("pointerdown"),
          e.addEventListener("pointerdown", this.onMousePressDown),
          this.domEventsNeeded.add("pointerup"),
          e.addEventListener("pointerup", this.onMousePressRelease)),
        this.objectsPerTypes.KeyDown?.length &&
          (this.domEventsNeeded.add("keydown"),
          document.addEventListener("keydown", this.onKeyDown),
          document.addEventListener("keyup", this.releaseHeldKey)),
        this.objectsPerTypes.KeyUp?.length &&
          (this.domEventsNeeded.add("keyup"),
          document.addEventListener("keyup", this.onKeyUp)),
        this.objectsPerTypes.KeyPress?.length &&
          (this.domEventsNeeded.add("keydown"),
          document.addEventListener("keydown", this.onKeyPressDown),
          document.addEventListener("keyup", this.releaseHeldKeyPress),
          this.domEventsNeeded.add("keyup"),
          document.addEventListener("keyup", this.onKeyPressUp)),
        Object.entries(this.objectsPerTypes).forEach(([t, i]) => {
          i.forEach((r) => {
            r.addEventListener("userEvent", this._onUserEvent);
          });
        });
    }
    disconnect() {
      let { domElement: e } = this.eventContext;
      this.domEventsNeeded.clear(),
        (this.heldKeys = {}),
        (this.heldKeysPress = {}),
        e.removeEventListener("pointerdown", this.onCanvasMouseDown),
        e.removeEventListener("pointerup", this.onCanvasMouseUp),
        e.removeEventListener("pointerdown", this.onMouseDown),
        e.removeEventListener("pointerdown", this.onMousePressDown),
        e.removeEventListener("pointerup", this.onMouseUp),
        e.removeEventListener("pointerup", this.onMousePressRelease),
        document.removeEventListener("keydown", this.onKeyDown),
        document.removeEventListener("keyup", this.onKeyUp),
        document.removeEventListener("keydown", this.onKeyPressDown),
        document.removeEventListener("keyup", this.onKeyPressUp),
        document.removeEventListener("keyup", this.releaseHeldKey),
        Object.values(this.eventsPerObjects).forEach((t) => {
          Object.values(t).forEach((i) => {
            i.forEach((r) => {
              r.disconnect();
            });
          });
        }),
        this.canvasMouseEvents.forEach((t) => {
          t.disconnect();
        }),
        Object.entries(this.objectsPerTypes).forEach(([t, i]) => {
          i.forEach((r) => {
            r.removeEventListener("userEvent", this._onUserEvent);
          });
        });
    }
    handleMouseEvent(e) {
      let {
          stopRaycast: t,
          raycaster: i,
          page: r,
          pointerScreen: s,
        } = this.eventContext,
        a = this.objectsPerTypes[e],
        n = a.filter((o) => !(o instanceof Rr));
      if (
        !(!a.length && !this.useForRaycastProperty) &&
        !(
          r.uiCanvas &&
          uo(r, [s.x, s.y], Object.keys(this.eventsPerObjects[e]), (o) => {
            this.handleObjectMouseEventDispatch(o, e);
          })
        )
      ) {
        if (t || this.useForRaycastProperty) {
          let o;
          if (
            (this.sceneInterects === null
              ? (o = mm(i, r, n, this.useForRaycastProperty))
              : ((o = this.sceneInterects), (this.sceneInterects = null)),
            this.useForRaycastProperty &&
              o.length &&
              (this.eventContext.sharedAssets.raycastProperty = {
                x: o[0].point.x,
                y: o[0].point.y,
                z: o[0].point.z,
                objX: o[0].object.matrixWorld.elements[12],
                objY: o[0].object.matrixWorld.elements[13],
                objZ: o[0].object.matrixWorld.elements[14],
              }),
            t)
          ) {
            let l = [o[0]?.uv?.x ?? 0, o[0]?.uv?.y ?? 0];
            ux(o).forEach((h) => {
              h instanceof ps &&
                uo(h, l, Object.keys(this.eventsPerObjects[e]), (u) => {
                  this.handleObjectMouseEventDispatch(u, e);
                }),
                this.eventsPerObjects[e][h.uuid] &&
                  this.handleObjectMouseEventDispatch(h, e);
            });
          }
        }
        t ||
          n.forEach((o) => {
            let l = vg(i, o);
            l &&
              (this.handleObjectMouseEventDispatch(o, e),
              o instanceof ps &&
                uo(
                  o,
                  [l?.uv?.x ?? 0, l?.uv?.y ?? 0],
                  Object.keys(this.eventsPerObjects[e]),
                  (h) => {
                    this.handleObjectMouseEventDispatch(h, e);
                  }
                ));
          });
      }
    }
    handleMousePressEvent(e = !1) {
      let t = "MousePress",
        i = this.objectsPerTypes[t],
        r = i.filter((a) => !(a instanceof Rr)),
        s = [];
      if (i.length) {
        if (!e) {
          let {
              stopRaycast: a,
              raycaster: n,
              page: o,
              pointerScreen: l,
            } = this.eventContext,
            h = !1;
          if (
            (o.uiCanvas &&
              (h = uo(
                o,
                [l.x, l.y],
                Object.keys(this.eventsPerObjects[t]),
                (u) => {
                  s.push(u);
                }
              )),
            a && !h)
          ) {
            let u = mm(n, o, r);
            (s = ux(u)),
              u.forEach((c) => {
                c.object instanceof ps &&
                  uo(
                    c.object,
                    [c?.uv?.x ?? 0, c?.uv?.y ?? 0],
                    Object.keys(this.eventsPerObjects[t]),
                    (d) => {
                      s.push(d);
                    }
                  );
              });
          } else
            r.forEach((u) => {
              let c = vg(n, u);
              c &&
                (s.push(u),
                u instanceof ps &&
                  uo(
                    u,
                    [c?.uv?.x ?? 0, c?.uv?.y ?? 0],
                    Object.keys(this.eventsPerObjects[t]),
                    (d) => {
                      s.push(d);
                    }
                  ));
            });
        }
        this._prevObjects.length &&
          this._prevObjects.forEach((a) => {
            s.includes(a) || this.handleObjectMouseEventDispatchRelease(a, t);
          }),
          s.length &&
            s.forEach((a) => {
              this.handleObjectMouseEventDispatch(a, t);
            }),
          (this._prevObjects = s);
      }
    }
    handleObjectMouseEventDispatch(e, t) {
      e.dispatchEvent({ type: "beginEvent", eventName: t }),
        this.eventsPerObjects[t]?.[e.uuid]?.forEach((i) => {
          i.dispatch();
        });
    }
    handleObjectMouseEventDispatchRelease(e, t) {
      e.dispatchEvent({ type: "beginEvent", eventName: t }),
        this.eventsPerObjects[t]?.[e.uuid]?.forEach((i) => {
          i.dispatchRelease();
        });
    }
    handleKeyEvent(e, t, i = !1) {
      this.objectsPerTypes[t].forEach((r) => {
        let s = this.eventsPerObjects[t][r.uuid];
        s.some(({ data: a }) => "key" in a && a.key === e.key) &&
          r.dispatchEvent({ type: "beginEvent", eventName: t }),
          s.forEach((a) => {
            "key" in a.data &&
              a.data.key === e.key &&
              (i ? a.dispatchRelease() : a.dispatch(!0));
          });
      });
    }
    handleKeyEventHeld(e, t, i = !1) {
      this.objectsPerTypes[t].forEach((r) => {
        this.eventsPerObjects[t][r.uuid].forEach((s) => {
          "key" in s.data && s.data.key === e.key && s.dispatchHeld(i);
        });
      });
    }
  },
  n$ = new I(),
  o$ = new I(),
  PD = class {
    constructor(e, t, i, r, s) {
      (this.actionsIn = Rs(e, e.inActions, i, r, s, t)),
        (this.actionsOut = Rs(e, e.outActions, i, r, s, t));
    }
    disconnect() {
      Xr(this.actionsIn), Xr(this.actionsOut);
    }
  },
  l$ = class extends PD {
    constructor(e, t, i, r, s, a) {
      super(t, i, r, s, a),
        (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.stage = "out"),
        (this.objects = []),
        (this.onUpdateMatrixWorld = () => {
          for (let d of this.objects) if (!d.visible) return;
          let h = n$.setFromMatrixPosition(this.objects[0].matrixWorld),
            u = o$.setFromMatrixPosition(this.objects[1].matrixWorld),
            c = h.distanceTo(u) <= this.distance ? "in" : "out";
          if (this.stage !== c) {
            this.stage = c;
            let d = c === "in" ? this.actionsIn : this.actionsOut;
            d.Audio.forEach((p) => p.dispatchConditional()),
              d.Particles.forEach((p) => p.dispatchConditional()),
              d.Video.forEach((p) => p.dispatchConditional()),
              d.Link.forEach((p) => p.dispatch()),
              d.Create.forEach((p) => p.dispatch()),
              d.Destroy.forEach((p) => p.dispatch()),
              d.Reset.forEach((p) => p.dispatch()),
              d.Transition.forEach((p) => {
                p.object.currentTransitionEvent !== this &&
                  (p.object.currentTransitionEvent = this),
                  p.init();
              }),
              d.Transition.forEach((p) => p.play()),
              d.Animation.forEach((p) => p.play()),
              d.SwitchCamera.forEach((p) => p.play()),
              d.SceneTransition.forEach((p) => p.dispatch()),
              d.SetVariable.forEach((p) => p.checkConditions()),
              d.SetVariable.forEach((p) => p.dispatch()),
              d.DynamicVariablePlay.forEach((p) => p.dispatch());
          }
        });
      let { distance: n, fromObject: o, toObject: l } = t.condition;
      this.distance = n;
      for (let h of [o, l]) {
        if (!h) throw new Error("Missing property");
        let u = r.find(h);
        if (!u) throw new Error("Missing property");
        this.objects.push(u);
      }
    }
    connect() {
      window.setTimeout(() => {
        this.objects.forEach((e) => {
          e.addEventListener("updateMatrixWorld", this.onUpdateMatrixWorld);
        }),
          this.onUpdateMatrixWorld();
      }, 0);
    }
    disconnect() {
      super.disconnect(),
        (this.stage = "out"),
        this.objects.forEach((e) => {
          e.removeEventListener("updateMatrixWorld", this.onUpdateMatrixWorld);
        });
    }
  },
  h$ = class extends PD {
    constructor(e, t, i, r, s, a) {
      super(t, i, r, s, a),
        (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.onBegin = ({ target: l, state: h }) => {
          this.toState !== h &&
            (this.actionsOut.Audio.forEach((u) => u.dispatchConditional()),
            this.actionsOut.Particles.forEach((u) => u.dispatchConditional()),
            this.actionsOut.Video.forEach((u) => u.dispatchConditional()),
            this.actionsOut.Link.forEach((u) => u.dispatch()),
            this.actionsOut.Create.forEach((u) => u.dispatch()),
            this.actionsOut.Destroy.forEach((u) => u.dispatch()),
            this.actionsOut.Reset.forEach((u) => u.dispatch()),
            this.actionsIn.Transition.forEach((u) => u.pause()),
            (this.object.currentTransitionEvent = this),
            this.actionsOut.Transition.forEach((u) => u.play()),
            this.actionsOut.Animation.forEach((u) => u.play()),
            this.actionsIn.SwitchCamera.forEach((u) => u.pause()),
            this.actionsOut.SwitchCamera.forEach((u) => u.play()),
            this.actionsOut.SceneTransition.forEach((u) => u.dispatch()),
            this.actionsOut.SetVariable.forEach((u) => u.checkConditions()),
            this.actionsOut.SetVariable.forEach((u) => u.dispatch()),
            this.actionsOut.DynamicVariablePlay.forEach((u) => u.dispatch()));
        }),
        (this.onComplete = ({ target: l, state: h }) => {
          this.toState === h &&
            (this.actionsIn.Audio.forEach((u) => u.dispatchConditional()),
            this.actionsIn.Particles.forEach((u) => u.dispatchConditional()),
            this.actionsIn.Video.forEach((u) => u.dispatchConditional()),
            this.actionsIn.Link.forEach((u) => u.dispatch()),
            this.actionsIn.Create.forEach((u) => u.dispatch()),
            this.actionsIn.Destroy.forEach((u) => u.dispatch()),
            this.actionsIn.Reset.forEach((u) => u.dispatch()),
            this.actionsOut.Transition.forEach((u) => u.pause()),
            this.actionsOut.Transition.forEach((u) => u.pause()),
            (this.object.currentTransitionEvent = this),
            this.actionsIn.Transition.forEach((u) => u.play()),
            this.actionsIn.Animation.forEach((u) => u.play()),
            this.actionsOut.SwitchCamera.forEach((u) => u.pause()),
            this.actionsIn.SwitchCamera.forEach((u) => u.play()),
            this.actionsIn.SceneTransition.forEach((u) => u.dispatch()),
            this.actionsIn.SetVariable.forEach((u) => u.checkConditions()),
            this.actionsIn.SetVariable.forEach((u) => u.dispatch()),
            this.actionsIn.DynamicVariablePlay.forEach((u) => u.dispatch()));
        });
      let { condition: n } = t;
      if (!n.object) throw new Error("Missing property");
      let o = r.find(n.object) ?? r.scene.find2D(n.object);
      if (!o) throw new Error("Missing property");
      if (((this.toObject = o), n.state && !this.toObject.states?.[n.state]))
        throw new Error("Missing property");
      this.toState = n.state;
    }
    connect() {
      Gl(this.actionsOut).forEach((e) => {
        this.actionsOut[e]?.length &&
          this.toObject.addEventListener("beginState", this.onBegin);
      }),
        Gl(this.actionsIn).forEach((e) => {
          this.actionsIn[e]?.length &&
            this.toObject.addEventListener("completeState", this.onComplete);
        });
    }
    disconnect() {
      super.disconnect(),
        Gl(this.actionsOut).forEach((e) => {
          this.actionsIn[e]?.length &&
            this.toObject.removeEventListener("beginState", this.onBegin);
        }),
        Gl(this.actionsIn).forEach((e) => {
          this.actionsIn[e]?.length &&
            this.toObject.removeEventListener("completeState", this.onComplete);
        });
    }
  },
  c$ = class extends en {
    constructor(e, t) {
      super(e),
        (this.eventsPerConditions = {
          Comparison: [],
          Distance: [],
          State: [],
        }),
        (this.hasVideoAction = !1);
      let { page: i, sharedAssets: r } = this.eventContext;
      i.traverseEntity((s) => {
        if (s.data?.events.length) {
          for (let { id: a, data: n } of s.data.events)
            if (!n.disabled && n.type === "Conditional")
              try {
                let o;
                n.condition.type === "Comparison" ||
                  (n.condition.type === "Distance"
                    ? (o = new l$(a, n, s, i, r, t))
                    : n.condition.type === "State" &&
                      (o = new h$(a, n, s, i, r, t))),
                  o &&
                    (this.eventsPerConditions[n.condition.type].push(o),
                    (o.actionsIn.Video.length || o.actionsOut.Video.length) &&
                      (this.hasVideoAction = !0));
              } catch {}
        }
      });
    }
    connect() {
      super.connect(),
        Object.values(this.eventsPerConditions).forEach((e) =>
          e.forEach((t) => t.connect())
        );
    }
    disconnect() {
      super.disconnect(),
        Object.values(this.eventsPerConditions).forEach((e) =>
          e.forEach((t) => t.disconnect())
        );
    }
  },
  sd = new I(),
  Wo = new I(),
  Ol = new I(),
  wE = new Ks(),
  u$ = 0.01,
  fi = new I(),
  Or = new I(),
  _E = new I(),
  Kl = new Rt(),
  K0 = new Ir(),
  d$ = new je(),
  J0 = new lr(),
  nc = new I(),
  mn = new I(),
  oc = 0.2;
function $0(e, t) {
  !t ||
    (t[0] < t[1] && (e.x = Math.min(Math.max(e.x, t[0]), t[1])),
    t[2] < t[3] && (e.y = Math.min(Math.max(e.y, t[2]), t[3])),
    t[4] < t[5] && (e.z = Math.min(Math.max(e.z, t[4]), t[5])));
}
var p$ = (function () {
    let e = new je();
    return (t, i, r) => {
      let s = t.obj;
      e.copy(s.hiddenMatrix),
        s.parent !== null && e.premultiply(s.parent.matrixWorld),
        e.invert(),
        s.position.copy(i),
        t.reference === "global" && $0(s.position, t.limits),
        s.position.applyMatrix4(e),
        t.reference === "parent"
          ? $0(s.position, t.limits)
          : t.reference === "local" &&
            (Kl.copy(t.quat0).invert(),
            s.position.sub(t.position0),
            s.position.applyQuaternion(Kl),
            $0(s.position, t.limits),
            Kl.invert(),
            s.position.applyQuaternion(Kl),
            s.position.add(t.position0)),
        e.multiply(r ?? s.matrixWorld).decompose(fi, s.quaternion, Or),
        s.updateMatrix(),
        s.hasNonUniformScale &&
          (s.updateMatrixWorld(), s.updateMatrixWorldSVD()),
        s instanceof Is &&
          yo(s.parent) &&
          s.invalidateDownstreamBooleanData(!0);
    };
  })(),
  f$ = class {
    constructor(e, t, i, r, s, a) {
      (this.object = e),
        (this.data = t),
        (this.dropDestIds = []),
        (this.activeIdx = null),
        (this.wasDragEventTriggered = !1),
        (this.resetDampingFactor =
          this.data.resetSpeed === 0 ? 1 : 8 / this.data.resetSpeed + 1),
        (this.snapDampingFactor =
          this.data.snapSpeed === 0 ? 1 : 8 / this.data.snapSpeed + 1),
        (this.actionsDrag = Rs(
          t,
          t.dragDropActions.drag,
          i,
          r,
          s,
          this.object
        )),
        (this.actionsDrop = Rs(
          t,
          t.dragDropActions.drop,
          i,
          r,
          s,
          this.object
        ));
      let n = [];
      this.data.objects.forEach((o) => {
        let l = i.find(o);
        !l ||
          (l.data.visible !== !1 &&
            (n.push(l),
            a[l.uuid] &&
              a[l.uuid].forEach((h) => {
                let u = i.find(h);
                !u || (u.data.visible !== !1 && n.push(u));
              })));
      }),
        this.data.dropDestinations.forEach((o) => {
          let l = i.find(o);
          !l ||
            (l.data.visible !== !1 &&
              (this.dropDestIds.push(l.uuid),
              a[l.uuid] &&
                a[l.uuid].forEach((h) => {
                  let u = i.find(h);
                  !u ||
                    (u.data.visible !== !1 && this.dropDestIds.push(u.uuid));
                })));
        }),
        (this.dragItems = n.map(
          (o) => (
            this.data.planeMode === "locked" && (o.userData.lockedPlane = !0),
            (o.userData.worldPosition0 = new I().setFromMatrixPosition(
              o.matrixWorld
            )),
            {
              obj: o,
              fromPosition: new I().setFromMatrixPosition(o.matrixWorld),
              pointStart: new I(),
              pointEnd: new I(),
              paused: !0,
              currentDampingFactor: this.data.dampingFactor,
              reset: !1,
              position0: new I().copy(o.position),
              quat0: new Rt().copy(o.quaternion),
              snapped: !1,
              orientationMatrix: new je(),
              limits: this.data.limits,
              reference: this.data.referenceFrame,
            }
          )
        ));
    }
    get activeDragItem() {
      return this.activeIdx !== null ? this.dragItems[this.activeIdx] : null;
    }
    dispose() {
      Xr(this.actionsDrag),
        Xr(this.actionsDrop),
        this.dragItems.forEach((e) => {
          e.fromPosition.copy(e.obj.userData.worldPosition0),
            e.pointStart.copy(e.fromPosition),
            e.pointEnd.copy(e.pointStart),
            (e.obj.recursiveBBoxNeedsUpdate = !0),
            (e.obj.userData.lockedPlane = void 0),
            e.obj.position.copy(e.position0),
            e.obj.quaternion.copy(e.quat0),
            e.obj.updateMatrix();
        });
    }
  },
  m$ = class extends en {
    constructor(e, t) {
      super(e),
        (this.eventManager = t),
        (this.events = []),
        (this.lastDropDestination = null),
        (this.dragTimeout = null),
        (this.onPointerDown = (r) => {
          if (Pt.length > 1) return;
          this.eventContext.updateRaycaster(r);
          let { raycaster: s, page: a } = this.eventContext,
            n = a.raycastWithClones(s);
          if (((this.lastDropDestination = null), n.length === 0)) {
            this.activeEvent = null;
            return;
          }
          for (let o of this.events) {
            let l = 0;
            for (let { obj: h, pointEnd: u, pointStart: c } of o.dragItems) {
              if (
                h === n[0].object ||
                h === n[0].object.object ||
                (si.is(h) && h.isAncestorOf(n[0].object.uuid))
              ) {
                if (
                  ((o.activeIdx = l),
                  (o.activeDragItem.reset = !1),
                  (o.activeDragItem.currentDampingFactor =
                    o.data.dampingFactor),
                  (o.activeDragItem.snapped = !1),
                  o.data.cursor === "hand" && this.setCursor("grabbing"),
                  this.eventManager.controlsManager.usePhysics)
                ) {
                  o.activeDragItem.obj.rigidBody &&
                    o.activeDragItem.obj.rigidBody.setBodyType(2, !0);
                  let d = o.activeDragItem.obj;
                  h.hasNonUniformScale && h.updateMatrixWorldSVD(),
                    (d.hasNonUniformScale
                      ? d.matrixWorldRigid
                      : d.matrixWorld
                    ).decompose(fi, Kl, Or),
                    K0.setFromQuaternion(Kl),
                    d.prevR === void 0
                      ? ((d.prevR = K0.clone()), (d.prevT = fi.clone()))
                      : (d.prevR.copy(K0), d.prevT.copy(fi)),
                    this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.push(
                      o.activeDragItem.obj
                    );
                }
                this.calcPlaneIntersectPos(
                  h,
                  c,
                  o.data.plane,
                  o.data.referenceFrame
                ),
                  u.copy(c),
                  ((this.eventManager.controlsManager.usePhysics &&
                    h.data.physics?.rigidBody === "dynamic") ||
                    o.data.drop === !1 ||
                    o.data.resetOnSnapFail === !1) &&
                    o.activeDragItem.fromPosition.setFromMatrixPosition(
                      o.activeDragItem.obj.matrixWorld
                    ),
                  (this.activeEvent = o),
                  this.eventManager.controlsManager.orbitControls &&
                    (this.eventManager.controlsManager.orbitControls.enabled =
                      !1);
                return;
              }
              l++;
            }
          }
          this.activeEvent = null;
        }),
        (this.onPointerMove = (r) => {
          if (Pt.length > 1) return;
          this.eventContext.updateRaycaster(r);
          let { raycaster: s, page: a } = this.eventContext,
            n = a.raycastWithClones(s);
          if (Pt.length === 0) {
            let o = !1;
            for (let l of this.events) {
              for (let { obj: h } of l.dragItems)
                if (
                  h === n[0]?.object ||
                  h === n[0]?.object?.object ||
                  (si.is(h) && h.isAncestorOf(n[0]?.object.uuid))
                ) {
                  switch (((o = !0), l.data.cursor)) {
                    case "hand":
                      this.setCursor("grab");
                      break;
                    case "move":
                      this.setCursor("move");
                      break;
                    default:
                      break;
                  }
                  break;
                }
              if (o) break;
            }
            o || this.setCursor("default");
            return;
          }
          if (this.activeEvent && this.activeEvent.activeDragItem) {
            let o = this.activeEvent.activeDragItem;
            o.snapped = !1;
            let l;
            if (
              (this.activeEvent.data.drop &&
                (l = n.filter(
                  (h) =>
                    o.obj !== h.object &&
                    !o.obj.isAncestorOf(h.object.uuid) &&
                    !(h.object instanceof kc) &&
                    (this.activeEvent.data.dropOn === "all" ||
                      this.activeEvent.dropDestIds.some(
                        (u) =>
                          u === h.object.uuid ||
                          a.scene.find(u).isAncestorOf(h.object.uuid)
                      ))
                )[0]),
              l)
            ) {
              let h = _E
                .copy(l.face.normal)
                .applyMatrix3(J0.getNormalMatrix(l.object.matrixWorld));
              if (this.activeEvent.data.snapTo === "center")
                o.fromPosition.setFromMatrixPosition(l.object.matrixWorld);
              else if (this.activeEvent.data.snapTo === "surface") {
                if (
                  (o.fromPosition.copy(l.point),
                  this.activeEvent.data.snapSurfaceMode === "bbox")
                ) {
                  fi.copy(h).applyMatrix3(
                    J0.setFromMatrix4(o.obj.matrixWorld).transpose()
                  );
                  let u = o.obj;
                  fi.x > oc
                    ? (Or.x = -u.recursiveBBox.min.x)
                    : fi.x < -oc && (Or.x = -u.recursiveBBox.max.x),
                    fi.y > oc
                      ? (Or.y = -u.recursiveBBox.min.y)
                      : fi.y < -oc && (Or.y = -u.recursiveBBox.max.y),
                    fi.z > oc
                      ? (Or.z = -u.recursiveBBox.min.z)
                      : fi.z < -oc && (Or.z = -u.recursiveBBox.max.z),
                    Or.applyMatrix3(J0.invert());
                } else
                  Or.copy(h).multiplyScalar(
                    this.activeEvent.data.snapSurfaceOffset
                  );
                o.fromPosition.add(Or);
              }
              this.activeEvent.data.autoOrient &&
                (fi.set(0, 1, 0).cross(h),
                fi.length() < 1e-4 && fi.set(-1, 0, 0).cross(h),
                Or.crossVectors(_E, fi),
                o.orientationMatrix.makeBasis(fi, Or, h)),
                o.pointStart.copy(o.fromPosition),
                o.pointEnd.copy(o.pointStart),
                (o.currentDampingFactor = this.activeEvent.snapDampingFactor),
                (o.snapped = !0),
                this.lastDropDestination !== l.object &&
                  ((this.lastDropDestination = l.object),
                  this.activeEvent.actionsDrop.Transition.forEach((u) => {
                    u.play();
                  }),
                  this.activeEvent.actionsDrop.Animation.forEach((u) => {
                    u.play();
                  }),
                  this.activeEvent.actionsDrop.Audio.forEach((u) => {
                    u.dispatchGameControl("start");
                  }),
                  this.activeEvent.actionsDrop.Particles.forEach((u) => {
                    u.dispatchGameControl("start");
                  }),
                  this.activeEvent.actionsDrop.Create.forEach((u) => {
                    u.dispatchThrottled();
                  }));
            } else
              o.orientationMatrix.makeRotationFromQuaternion(o.quat0),
                (this.lastDropDestination = null),
                (o.currentDampingFactor = this.activeEvent.data.dampingFactor),
                this.calcPlaneIntersectPos(
                  o.obj,
                  o.pointEnd,
                  this.activeEvent.data.plane,
                  this.activeEvent.data.referenceFrame
                ),
                this.activeEvent.actionsDrop.Transition.forEach((h) => {
                  h.stop(),
                    h.object.currentState !== null &&
                      h.object.changeSelectedState(null, {
                        scene: this.eventContext.page.scene,
                        shared: this.eventContext.sharedAssets,
                      });
                }),
                this.activeEvent.actionsDrop.Animation.forEach((h) => {
                  h.stop();
                }),
                this.activeEvent.actionsDrop.Audio.forEach((h) => {
                  h.dispatchGameControl("stop");
                }),
                this.activeEvent.actionsDrop.Particles.forEach((h) => {
                  h.dispatchGameControl("stop");
                });
            this.activeEvent.actionsDrag.Create.forEach((h) => {
              h.dispatchThrottled();
            }),
              this.activeEvent.actionsDrag.SetVariable.forEach((h) =>
                h.checkConditions()
              ),
              this.activeEvent.actionsDrag.SetVariable.forEach((h) =>
                h.dispatch()
              ),
              this.activeEvent.actionsDrag.DynamicVariablePlay.forEach((h) =>
                h.dispatch()
              ),
              this.activeEvent.wasDragEventTriggered === !1 &&
                ((this.activeEvent.wasDragEventTriggered = !0),
                this.activeEvent.actionsDrag.Transition.forEach((h) => {
                  h.play();
                }),
                this.activeEvent.actionsDrag.Animation.forEach((h) => {
                  h.play();
                }),
                this.activeEvent.actionsDrag.Audio.forEach((h) => {
                  h.dispatchGameControl("start");
                }),
                this.activeEvent.actionsDrag.Particles.forEach((h) => {
                  h.dispatchGameControl("start");
                })),
              this.dragTimeout && window.clearTimeout(this.dragTimeout),
              (this.dragTimeout = window.setTimeout(() => {
                !this.activeEvent ||
                  ((this.activeEvent.wasDragEventTriggered = !1),
                  this.activeEvent.actionsDrag.Audio.forEach((h) => {
                    h.dispatchGameControl("stop");
                  }),
                  this.activeEvent.actionsDrag.Particles.forEach((h) => {
                    h.dispatchGameControl("stop");
                  }),
                  this.activeEvent.actionsDrag.Transition.forEach((h) => {
                    h.stop(),
                      h.object.currentState !== null &&
                        h.object.changeSelectedState(null, {
                          scene: this.eventContext.page.scene,
                          shared: this.eventContext.sharedAssets,
                        });
                  }),
                  this.activeEvent.actionsDrag.Animation.forEach((h) => {
                    h.stop();
                  }));
              }, 500)),
              this.updateDragItem(o),
              o.obj.dispatchEvent({ type: "requestRender" });
          }
        }),
        (this.onPointerUp = (r) => {
          if (this.activeEvent && this.activeEvent.activeDragItem) {
            this.activeEvent.data.cursor === "hand" && this.setCursor("grab");
            let s =
              this.activeEvent.activeDragItem.obj.data.physics?.rigidBody ===
              "dynamic";
            this.activeEvent.activeDragItem.snapped === !1 &&
              this.activeEvent.data.drop &&
              this.activeEvent.data.resetOnSnapFail &&
              (this.eventManager.controlsManager.usePhysics === !1 || !s) &&
              ((this.activeEvent.activeDragItem.reset =
                this.activeEvent.data.resetOnSnapFail),
              (this.activeEvent.activeDragItem.paused = !1),
              (this.activeEvent.activeDragItem.currentDampingFactor =
                this.activeEvent.resetDampingFactor)),
              this.eventManager.controlsManager.usePhysics &&
                s &&
                (this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.pop(),
                this.activeEvent.activeDragItem.obj.rigidBody.setBodyType(
                  0,
                  !0
                ),
                (this.activeEvent.activeDragItem.paused = !0)),
              this.activeEvent.wasDragEventTriggered === !0 &&
                ((this.activeEvent.wasDragEventTriggered = !1),
                this.activeEvent.actionsDrag.Transition.forEach((a) => {
                  a.stop(),
                    a.object.currentState !== null &&
                      a.object.changeSelectedState(null, {
                        scene: this.eventContext.page.scene,
                        shared: this.eventContext.sharedAssets,
                      });
                }),
                this.activeEvent.actionsDrag.Animation.forEach((a) => {
                  a.stop();
                }),
                this.activeEvent.actionsDrag.Audio.forEach((a) => {
                  a.dispatchGameControl("stop");
                }),
                this.activeEvent.actionsDrag.Particles.forEach((a) => {
                  a.dispatchGameControl("stop");
                }),
                this.activeEvent.actionsDrop.SetVariable.forEach((a) =>
                  a.checkConditions()
                ),
                this.activeEvent.actionsDrop.SetVariable.forEach((a) =>
                  a.dispatch()
                ),
                this.activeEvent.actionsDrop.DynamicVariablePlay.forEach((a) =>
                  a.dispatch()
                )),
              this.eventManager.controlsManager.orbitControls &&
                (this.eventManager.controlsManager.orbitControls.enabled = !0);
          }
        });
      let i = {};
      e.page.traverseEntity((r) => {
        r.component &&
          (i[r.component.uuid]
            ? i[r.component.uuid].push(r.uuid)
            : (i[r.component.uuid] = [r.uuid]));
      }),
        e.page.traverseEntity((r) => {
          r.data?.events
            .filter((s) => s.data.type === "DragDrop" && !s.data.disabled)
            .forEach((s) => {
              this.events.push(new f$(r, s.data, e.page, e.sharedAssets, t, i));
            });
        });
    }
    connect() {
      if (!this.events.length) return;
      this.domEventsNeeded.clear(), this.domEventsNeeded.add("pointerdown");
      let e = this.eventContext.domElement;
      e.addEventListener("pointerdown", this.onPointerDown),
        e.addEventListener("pointermove", this.onPointerMove),
        e.addEventListener("pointerup", this.onPointerUp),
        this.domEventsNeeded.add("pointermove");
    }
    disconnect() {
      if (!this.events.length) return;
      this.domEventsNeeded.clear();
      let e = this.eventContext.domElement;
      e.removeEventListener("pointerdown", this.onPointerDown),
        e.removeEventListener("pointermove", this.onPointerMove),
        e.removeEventListener("pointerup", this.onPointerUp),
        this.events.forEach((t) => t.dispose());
    }
    setCursor(e) {
      this.eventContext.domElement.style.cursor = e;
    }
    onAnimationFrameDamping() {
      for (let e of this.events)
        for (let t of e.dragItems) t.paused || this.updateDragItem(t, !0);
    }
    calcPlaneIntersectPos(e, t, i, r) {
      let { getCamera: s, raycaster: a } = this.eventContext;
      s().getWorldDirection(Wo), Wo.negate();
      let n = Kl.identity();
      switch (
        (r === "parent"
          ? d$
              .multiplyMatrices(e.parent.matrixWorld, e.hiddenMatrix)
              .decompose(fi, n, Or)
          : r === "local" && e.matrixWorld.decompose(fi, n, Or),
        i)
      ) {
        case "x":
          fi.set(1, 0, 0).applyQuaternion(n),
            nc.copy(Wo).cross(fi),
            mn.copy(fi).cross(nc);
          break;
        case "y":
          fi.set(0, 1, 0).applyQuaternion(n),
            nc.copy(Wo).cross(fi),
            mn.copy(fi).cross(nc);
          break;
        case "z":
          fi.set(0, 0, 1).applyQuaternion(n),
            nc.copy(Wo).cross(fi),
            mn.copy(fi).cross(nc);
          break;
        case "xy":
          mn.set(0, 0, 1).applyQuaternion(n);
          break;
        case "yz":
          mn.set(1, 0, 0).applyQuaternion(n);
          break;
        case "xz":
          mn.set(0, 1, 0).applyQuaternion(n);
          break;
        case "adaptive":
          Wo.angleTo(Or.set(0, 1, 0)) > Math.PI / 6
            ? (fi.crossVectors(Or.set(0, 1, 0), Wo), mn.crossVectors(fi, Or))
            : mn.set(0, 1, 0);
          break;
        default:
          mn.copy(Wo);
          break;
      }
      Ol.setFromMatrixPosition(e.matrixWorld);
      let o = e.userData.lockedPlane ? e.userData.worldPosition0 : Ol;
      if (
        (wE.setFromNormalAndCoplanarPoint(mn, o),
        !!a.ray.intersectPlane(wE, t) && (i === "x" || i === "y" || i === "z"))
      ) {
        let l = Or.subVectors(t, o).dot(fi);
        t.copy(o).addScaledVector(fi, l);
      }
    }
    updateDragItem(e, t = !1) {
      Ol.setFromMatrixPosition(e.obj.matrixWorld),
        e.reset === "current"
          ? sd
              .subVectors(e.fromPosition, Ol)
              .divideScalar(e.currentDampingFactor)
          : e.reset === "original"
          ? (sd
              .subVectors(e.obj.userData.worldPosition0, Ol)
              .divideScalar(e.currentDampingFactor),
            e.fromPosition.copy(e.obj.userData.worldPosition0),
            e.pointStart.copy(e.fromPosition),
            e.pointEnd.copy(e.pointStart))
          : sd
              .subVectors(e.pointEnd, e.pointStart)
              .add(e.fromPosition)
              .sub(Ol)
              .divideScalar(e.currentDampingFactor),
        (e.paused = e.currentDampingFactor > 1 ? sd.length() < u$ : !0),
        ((this.activeEvent && this.activeEvent.data.dampingFactor === 1) ||
          t) &&
          p$(
            e,
            sd.add(Ol),
            this.activeEvent?.data.drop && this.activeEvent?.data.autoOrient
              ? e.orientationMatrix
              : null
          ),
        e.obj.dispatchEvent({ type: "beginEvent", eventName: "DragDrop" }),
        this.eventManager.requestRender();
    }
  },
  lc = new I(),
  ey = new I(),
  eo = new I(),
  to = new I(),
  SE = new Ks(),
  g$ = 0.01,
  v$ = { type: "requestRender" },
  y$ = (function () {
    let e = new I(),
      t = new I();
    return (i, r, s) =>
      s > 0
        ? (e.subVectors(i, r),
          e.length() <= s ? i : t.copy(r).add(e.normalize().multiplyScalar(s)))
        : r;
  })(),
  AE = (function () {
    let e = new je();
    return (t, i) => {
      t.position.copy(i),
        t.parent !== null &&
          (e.copy(t.parent.matrixWorld).invert(), t.position.applyMatrix4(e)),
        e.copy(t.hiddenMatrix).invert(),
        t.position.applyMatrix4(e),
        t.updateMatrix(),
        t.hasNonUniformScale &&
          (t.updateMatrixWorld(), t.updateMatrixWorldSVD()),
        t instanceof Is &&
          yo(t.parent) &&
          t.invalidateDownstreamBooleanData(!0);
    };
  })(),
  x$ = class {
    constructor(e, t, i, r, s) {
      (this.data = e),
        (this.object = t),
        (this.paused = !1),
        (this.currentDampingFactor = 1),
        (this.snapComplete = !1),
        (this.isReset = !1),
        (this.worldPosition0 = new I()),
        (this.timeoutId = null),
        (this.delayFinished = !0),
        (this.wasOutside = !1),
        (this.data = {
          ...Vy.defaultData,
          ...e,
          ...(e.resetOnPointerLeave === void 0 && { resetOnPointerLeave: !1 }),
        }),
        e.target === void 0 ||
          e.target === "cursor" ||
          (this.target = i.find(e.target)),
        this.data.dampingFactor &&
          (this.currentDampingFactor = this.data.dampingFactor),
        (this.resetDampingFactor = 80 / this.data.resetSpeed + 1),
        this.object.getWorldPosition(this.worldPosition0),
        (this.actions = Rs(e, e.actions, i, r, s, t));
    }
  },
  b$ = class extends en {
    constructor(e, t) {
      super(e),
        (this.events = []),
        (this.pairOfEventListeners = []),
        (this.onMouseMove = (r) => {
          if (!(Pt.length > 1)) {
            this.eventContext.updateRaycaster(r);
            for (let s of this.events)
              s.target === void 0 && this.updateSingleEvent(s);
          }
        }),
        (this.onMouseEnter = (r) => {
          for (let s of this.events)
            s.target === void 0 &&
              ((s.isReset = !1),
              (s.currentDampingFactor = s.data.dampingFactor));
        }),
        (this.onMouseLeave = (r) => {
          for (let s of this.events)
            s.target === void 0 &&
              (s.data.resetOnPointerLeave &&
                ((s.isReset = !0),
                (s.currentDampingFactor = s.resetDampingFactor)),
              this.updateSingleEvent(s));
        }),
        (this.onTargetChange = (r) => () => {
          this.updateSingleEvent(r);
        });
      let { page: i } = this.eventContext;
      i.traverseEntity((r) => {
        let s = r.data?.events.find(
          (a) => a.data.type === "Follow" && !a.data.disabled
        );
        s &&
          (!i.data.globalPhysics.usePhysics ||
            r.dataPatched.physics?.rigidBody !== "dynamic") &&
          this.events.push(new x$(s.data, r, i, e.sharedAssets, t));
      });
    }
    connect() {
      if (!this.events.length) return;
      let { domElement: e, eventElement: t } = this.eventContext;
      this.domEventsNeeded.clear(),
        Js &&
          (this.domEventsNeeded.add("pointerdown"),
          e.addEventListener("pointerdown", this.onMouseMove)),
        this.domEventsNeeded.add("pointermove"),
        t.addEventListener("pointermove", this.onMouseMove),
        this.eventContext.useWindowEvents ||
          (e.addEventListener("pointerenter", this.onMouseEnter),
          e.addEventListener("pointerleave", this.onMouseLeave));
      for (let i of this.events)
        if (i.target !== void 0) {
          let r = i.target,
            s = this.onTargetChange(i);
          this.pairOfEventListeners.push([r, s]),
            r.addEventListener("requestRender", s);
        }
    }
    disconnect() {
      if (!this.events.length) return;
      let { domElement: e, eventElement: t } = this.eventContext;
      this.domEventsNeeded.clear(),
        Js && e.removeEventListener("pointerdown", this.onMouseMove),
        t.removeEventListener("pointermove", this.onMouseMove),
        e.removeEventListener("pointerenter", this.onMouseEnter),
        e.removeEventListener("pointerleave", this.onMouseLeave);
      for (let [i, r] of this.pairOfEventListeners)
        i.removeEventListener("requestRender", r);
      for (let i of this.events)
        (i.paused = !0), (i.isReset = !1), Xr(i.actions);
    }
    onAnimationFrameDamping() {
      for (let e of this.events) e.paused || this.updateSingleEvent(e, !0);
    }
    updateSingleEvent(e, t = !1) {
      this.events.forEach((n) => {
        n.actions.Create.forEach((o) => {
          o.dispatchThrottled();
        });
      });
      let { plane: i, limitDistance: r, limitDistanceEnabled: s } = e.data;
      if ((e.object.getWorldPosition(eo), e.isReset)) to.copy(e.worldPosition0);
      else if (e.target) e.target.getWorldPosition(to);
      else {
        let { getCamera: n, raycaster: o } = this.eventContext;
        if (
          (i === "custom"
            ? (n().getWorldDirection(ey), ey.negate(), lc.copy(ey))
            : i === "xy"
            ? lc.set(0, 0, 1)
            : i === "xz"
            ? lc.set(0, 1, 0)
            : i === "yz" && lc.set(1, 0, 0),
          SE.setFromNormalAndCoplanarPoint(lc, eo),
          !o.ray.intersectPlane(SE, to))
        )
          return;
      }
      if (!e.isReset) {
        if (to.distanceTo(e.worldPosition0) > r && s && e.target)
          if (
            ((e.snapComplete = !1),
            e.data.snapDelay &&
              ((e.delayFinished = !1),
              typeof window < "u" &&
                e.timeoutId !== null &&
                (window.clearTimeout(e.timeoutId), (e.timeoutId = null))),
            (e.wasOutside = !0),
            e.data.resetAfterDistanceLimit)
          )
            to.copy(e.worldPosition0),
              (e.currentDampingFactor = e.resetDampingFactor);
          else return;
        else if (
          (e.wasOutside &&
            (e.data.snapDelay &&
              typeof window < "u" &&
              (e.timeoutId = window.setTimeout(() => {
                (e.delayFinished = !0),
                  (e.paused = !1),
                  this.updateSingleEvent(e);
              }, e.data.snapDelay * 1e3)),
            (e.currentDampingFactor = e.data.dampingFactor),
            (e.wasOutside = !1)),
          e.delayFinished === !1)
        )
          return;
      }
      e.data.enabledTranslation[0] === !1 && (to.x = eo.x),
        e.data.enabledTranslation[1] === !1 && (to.y = eo.y),
        e.data.enabledTranslation[2] === !1 && (to.z = eo.z);
      let a = y$(eo, to, e.wasOutside ? 0 : e.data.maxDelta);
      if (e.currentDampingFactor > 1) {
        let n = lc.subVectors(a, eo).divideScalar(e.currentDampingFactor);
        eo.add(n), t && AE(e.object, eo), (e.paused = n.length() < g$);
      } else AE(e.object, a), (e.paused = !0);
      e.object?.dispatchEvent({ type: "beginEvent", eventName: "Follow" }),
        e.object.dispatchEvent(v$);
    }
  },
  ad = new I(),
  $f = new I(),
  nd = new je(),
  hc = new Rt(),
  qo = new Rt(),
  od = new I(),
  ld = new I(),
  Il = new I(),
  io = new I(),
  ty = new Ks(),
  w$ = 1e-6,
  _$ = { type: "requestRender" },
  S$ = { type: "changeRotation" },
  ME = (function () {
    let e = new je();
    return function (t, i) {
      t.parent !== null
        ? e.multiplyMatrices(t.parent.matrixWorld, t.hiddenMatrix)
        : e.copy(t.hiddenMatrix),
        i.premultiply(AD(e).invert()),
        t.rotation.setFromRotationMatrix(i),
        t.updateMatrix(),
        t instanceof Is &&
          yo(t.parent) &&
          t.invalidateDownstreamBooleanData(!0);
    };
  })(),
  A$ = class {
    constructor(e, t, i) {
      (this.object = t),
        (this.paused = !1),
        (this.currentDampingFactor = 1),
        (this.isReset = !1),
        (this.worldQuaternion0 = new Rt()),
        (this.timeoutId = null),
        (this.delayFinished = !0),
        (this.wasOutside = !1),
        (this.data = {
          ...jy.defaultData,
          ...e,
          ...(e.resetOnPointerLeave === void 0 && { resetOnPointerLeave: !1 }),
        }),
        e.target === void 0 ||
          e.target === "cursor" ||
          (this.target = i.find(e.target)),
        this.data.dampingFactor &&
          (this.currentDampingFactor = this.data.dampingFactor),
        this.object.getWorldQuaternion(this.worldQuaternion0),
        (this.resetDampingFactor = 80 / this.data.resetSpeed + 1);
    }
  },
  M$ = class extends en {
    constructor(e) {
      super(e),
        (this.events = []),
        (this.pairOfEventListeners = []),
        (this.pairOfUserEventListeners = []),
        (this.onMouseMove = (i) => {
          if (!(Pt.length > 1)) {
            (this._lastMouseEvent = i), this.eventContext.updateRaycaster(i);
            for (let r of this.events)
              r.target === void 0 && this.updateSingleEvent(r);
          }
        }),
        (this.onMouseEnter = (i) => {
          for (let r of this.events)
            r.target === void 0 &&
              ((r.isReset = !1),
              (r.currentDampingFactor = r.data.dampingFactor));
        }),
        (this.onMouseLeave = (i) => {
          for (let r of this.events)
            r.target === void 0 &&
              (r.data.resetOnPointerLeave &&
                ((r.isReset = !0),
                (r.currentDampingFactor = r.resetDampingFactor)),
              this.updateSingleEvent(r));
        }),
        (this.onScroll = (i) => {
          if (this._lastMouseEvent) {
            let r = new PointerEvent("pointermove", {
              clientX: this._lastMouseEvent.clientX,
              clientY: this._lastMouseEvent.clientY,
              bubbles: !0,
              cancelable: !0,
              view: window,
            });
            this.eventContext.eventElement.dispatchEvent(r);
          }
        }),
        (this.onTargetChange = (i) => () => {
          this.updateSingleEvent(i);
        }),
        (this.createUserEventListener =
          (i) =>
          ({ eventName: r, target: s }) => {
            if (!r || !s) return;
            let a = gp(r);
            a && a === "LookAt" && this.updateSingleEvent(i);
          });
      let { page: t } = this.eventContext;
      t.traverseEntity((i) => {
        let r = i.data?.events.find(
          (s) => s.data.type === "LookAt" && !s.data.disabled
        );
        r &&
          (!t.data.globalPhysics.usePhysics ||
            i.dataPatched.physics?.rigidBody !== "dynamic") &&
          this.events.push(new A$(r.data, i, t));
      });
    }
    connect() {
      if (!this.events.length) return;
      let { domElement: e, eventElement: t } = this.eventContext;
      this.domEventsNeeded.clear(),
        Js &&
          (this.domEventsNeeded.add("pointerdown"),
          e.addEventListener("pointerdown", this.onMouseMove)),
        this.domEventsNeeded.add("pointermove"),
        t.addEventListener("pointermove", this.onMouseMove),
        this.eventContext.useWindowEvents
          ? t.addEventListener("scroll", this.onScroll)
          : (e.addEventListener("pointerenter", this.onMouseEnter),
            e.addEventListener("pointerleave", this.onMouseLeave));
      for (let i of this.events) {
        if (i.target !== void 0) {
          let a = this.onTargetChange(i),
            n = i.target;
          this.pairOfEventListeners.push([n, a]),
            n.addEventListener("requestRender", a);
        }
        let r = this.createUserEventListener(i),
          s = i.object;
        this.pairOfUserEventListeners.push([s, r]),
          s.addEventListener("userEvent", r);
      }
    }
    disconnect() {
      if (!this.events.length) return;
      let { domElement: e, eventElement: t } = this.eventContext;
      this.domEventsNeeded.clear(),
        Js && e.removeEventListener("pointerdown", this.onMouseMove),
        t.removeEventListener("pointermove", this.onMouseMove),
        e.removeEventListener("pointerenter", this.onMouseEnter),
        e.removeEventListener("pointerleave", this.onMouseLeave),
        t.removeEventListener("scroll", this.onScroll);
      for (let [i, r] of this.pairOfEventListeners)
        i.removeEventListener("requestRender", r);
      for (let [i, r] of this.pairOfUserEventListeners)
        i.removeEventListener("userEvent", r);
      for (let i of this.events) (i.paused = !0), (i.isReset = !1);
    }
    onAnimationFrameDamping() {
      for (let e of this.events) e.paused || this.updateSingleEvent(e);
    }
    updateSingleEvent(e) {
      let {
          tilt: t,
          axis: i,
          distance: r,
          plane: s,
          limitDistance: a,
          enabledRotation: n,
          limitDistanceEnabled: o,
        } = e.data,
        { getCamera: l, raycaster: h } = this.eventContext,
        { object: u, target: c } = e;
      if ((u.getWorldPosition(od), !e.isReset))
        if (e.target) e.target.getWorldPosition(ld);
        else {
          if (
            (s === "custom"
              ? (l().getWorldDirection($f),
                $f.negate(),
                ty.setFromNormalAndCoplanarPoint($f, od))
              : (s === "xy"
                  ? ad.set(0, 0, 1)
                  : s === "xz"
                  ? ad.set(0, 1, 0)
                  : s === "yz" && ad.set(1, 0, 0),
                ty.setFromNormalAndCoplanarPoint(ad, od)),
            !h.ray.intersectPlane(ty, ld))
          )
            return;
          r > 0 &&
            (s === "custom" || s === void 0) &&
            ld.addScaledVector($f, r);
        }
      if (
        (e.isReset ||
          (c
            ? t === "target"
              ? Il.copy(c.up)
                  .applyMatrix4(nd.extractRotation(c.matrixWorld))
                  .normalize()
              : n.some((d) => d === !1)
              ? (i === "x"
                  ? (io.set(0, 0, 1), n[2] === !1 && io.set(0, 1, 0))
                  : i === "y"
                  ? (io.set(1, 0, 0), n[0] === !1 && io.set(0, 0, 1))
                  : (io.set(0, 1, 0), n[1] === !1 && io.set(1, 0, 0)),
                Il.copy(io).applyQuaternion(e.worldQuaternion0).normalize())
              : Il.set(0, 1, 0)
            : s === "custom"
            ? Il.set(0, 1, 0)
            : Il.copy(ad)),
        e.isReset)
      )
        qo.copy(e.worldQuaternion0);
      else if (od.distanceTo(ld) > a && o && c)
        if (
          (e.data.snapDelay &&
            ((e.delayFinished = !1),
            typeof window < "u" &&
              e.timeoutId !== null &&
              (window.clearTimeout(e.timeoutId), (e.timeoutId = null))),
          (e.wasOutside = !0),
          e.data.resetAfterDistanceLimit)
        )
          qo.copy(e.worldQuaternion0),
            (e.currentDampingFactor = e.resetDampingFactor);
        else return;
      else {
        if (
          (e.wasOutside &&
            (e.data.snapDelay &&
              typeof window < "u" &&
              (e.timeoutId = window.setTimeout(() => {
                (e.delayFinished = !0),
                  (e.paused = !1),
                  this.updateSingleEvent(e);
              }, e.data.snapDelay * 1e3)),
            (e.currentDampingFactor = e.data.dampingFactor),
            (e.wasOutside = !1)),
          e.delayFinished === !1)
        )
          return;
        E$(nd, ld, od, Il, i, io),
          qo.setFromRotationMatrix(nd),
          hc.setFromUnitVectors(io.applyQuaternion(qo), Il),
          n.some((d) => d === !1) &&
            t !== "target" &&
            qo.premultiply(hc).normalize();
      }
      e.currentDampingFactor > 1
        ? (u.updateWorldMatrix(!0, !1),
          hc.setFromRotationMatrix(AD(u.matrixWorld)),
          hc.slerp(qo, 1 / e.currentDampingFactor),
          ME(u, nd.makeRotationFromQuaternion(hc)),
          (e.paused = 8 * (1 - hc.dot(qo)) < w$))
        : (ME(u, nd.makeRotationFromQuaternion(qo)), (e.paused = !0)),
        e.object?.dispatchEvent({ type: "beginEvent", eventName: "LookAt" }),
        u.dispatchEvent(_$),
        u.dispatchEvent(S$);
    }
  },
  va = new I(),
  Dr = new I(),
  nr = new I();
function E$(e, t, i, r, s, a) {
  let n = e.elements;
  nr.subVectors(t, i),
    nr.lengthSq() === 0 && (nr.z = 1),
    nr.normalize(),
    Dr.crossVectors(r, nr),
    Dr.lengthSq() === 0 &&
      (Math.abs(r.z) === 1 ? (nr.x += 1e-4) : (nr.z += 1e-4),
      nr.normalize(),
      Dr.crossVectors(r, nr)),
    Dr.normalize(),
    va.crossVectors(nr, Dr),
    s === "x"
      ? a.z === 1
        ? ([Dr, va, nr] = [nr, Dr, va])
        : (Dr.negate(), ([Dr, nr] = [nr, Dr]))
      : s === "y"
      ? a.x === 1
        ? ([Dr, va, nr] = [va, nr, Dr])
        : (Dr.negate(), ([va, nr] = [nr, va]))
      : a.x === 1 && (Dr.negate(), ([Dr, va] = [va, Dr])),
    (n[0] = Dr.x),
    (n[4] = va.x),
    (n[8] = nr.x),
    (n[1] = Dr.y),
    (n[5] = va.y),
    (n[9] = nr.y),
    (n[2] = Dr.z),
    (n[6] = va.z),
    (n[10] = nr.z);
}
var C$ = class {
    constructor(e, t, i, r, s, a) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.entered = !1),
        (this.actions = Rs(t, t.actions, r, s, a, i));
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatchEnter() {
      this.actions.Transition.forEach((e) => {
        e.object.currentTransitionEvent !== this &&
          ((e.object.currentTransitionEvent = this), e.init());
      }),
        this.entered ||
          ((this.entered = !0),
          this.actions.Transition.forEach((e) => e.playFromCurrent()),
          this.actions.Animation.forEach((e) => e.play()),
          this.actions.Create.forEach((e) => e.dispatch()),
          this.actions.Particles.forEach((e) => e.dispatchBasic()),
          this.actions.Destroy.forEach((e) => e.dispatch()),
          this.actions.SwitchCamera.forEach((e) => e.playFromCurrent()),
          this.actions.SceneTransition.forEach((e) => e.dispatch()),
          this.actions.SetVariable.forEach((e) => e.checkConditions()),
          this.actions.SetVariable.forEach((e) => e.dispatch()),
          this.actions.DynamicVariablePlay.forEach((e) => e.dispatch()));
    }
    dispatchLeave() {
      this.actions.Transition.forEach((e) => {
        e.object.currentTransitionEvent !== this &&
          ((e.object.currentTransitionEvent = this), e.init());
      }),
        this.entered &&
          ((this.entered = !1),
          this.actions.Transition.forEach((e) => e.reverseFromCurrent()),
          this.actions.Particles.forEach((e) => e.reverseFromCurrent()),
          this.actions.SwitchCamera.forEach((e) => e.reverseFromCurrent()));
    }
    dispatchUserEvent(e) {
      this.actions.Transition.forEach((t) => {
        t.object.currentTransitionEvent !== this &&
          ((t.object.currentTransitionEvent = this), t.init());
      }),
        e
          ? (this.actions.Transition.forEach((t) => t.reverseFromCurrent()),
            this.actions.Particles.forEach((t) => t.reverseFromCurrent()),
            this.actions.Animation.forEach((t) => t.reverseFromCurrent()),
            this.actions.SwitchCamera.forEach((t) => t.reverseFromCurrent()))
          : (this.actions.Transition.forEach((t) => t.playFromCurrent()),
            this.actions.Animation.forEach((t) => t.playFromCurrent()),
            this.actions.Create.forEach((t) => t.dispatch()),
            this.actions.Particles.forEach((t) => t.dispatchBasic()),
            this.actions.Destroy.forEach((t) => t.dispatch()),
            this.actions.SwitchCamera.forEach((t) => t.playFromCurrent())),
        this.actions.SceneTransition.forEach((t) => t.dispatch()),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch());
    }
  },
  T$ = class extends en {
    constructor(e, t) {
      super(e),
        (this.eventsPerObjects = {}),
        (this.objects = []),
        (this.objects2D = []),
        (this._prevObjects = []),
        (this.onMouseDown = (a) => {
          Pt.length > 1 ||
            (this.eventContext.updateRaycaster(a),
            this.handleMouseHoverEvent());
        }),
        (this.onMouseUp = (a) => {
          Pt.length > 1 || this.handleMouseHoverEvent(!0);
        }),
        (this.onMouseMove = (a) => {
          Pt.length > 1 ||
            (this.eventContext.updateRaycaster(a),
            this.handleMouseHoverEvent());
        }),
        (this.onUserEvent = ({ eventName: a, target: n, reverse: o }) => {
          if (!a || !n) return;
          let l = gp(a);
          l &&
            l === "MouseHover" &&
            (n.dispatchEvent({ type: "beginEvent", eventName: "MouseHover" }),
            this.eventsPerObjects[n.uuid]?.forEach((h) =>
              h.dispatchUserEvent(o)
            ));
        });
      let { page: i, sharedAssets: r } = this.eventContext,
        s = (a, n) => {
          if (!(!a.visible || !a.data?.events.length)) {
            for (let { id: o, data: l } of a.data.events)
              if (!l.disabled && l.type === "MouseHover")
                try {
                  let h = new C$(o, l, a, i, r, t);
                  this.eventsPerObjects[a.uuid]
                    ? this.eventsPerObjects[a.uuid].push(h)
                    : (this.eventsPerObjects[a.uuid] = [h]);
                } catch {}
            this.eventsPerObjects[a.uuid]?.length &&
              this.objects.push(a instanceof Rr ? n : a);
          }
        };
      i.traverseEntity((a) => {
        (a instanceof ps || a instanceof Hr) &&
          a.frame?.traverse((n) => {
            s(n, a);
          }),
          s(a);
      });
    }
    connect() {
      if (!this.objects.length) return;
      let { domElement: e } = this.eventContext;
      this.domEventsNeeded.clear(),
        Js &&
          (this.domEventsNeeded.add("pointerdown"),
          e.addEventListener("pointerdown", this.onMouseDown),
          this.domEventsNeeded.add("pointerup"),
          e.addEventListener("pointerup", this.onMouseUp)),
        this.domEventsNeeded.add("pointermove"),
        e.addEventListener("pointermove", this.onMouseMove),
        this.objects.forEach((t) => {
          t.addEventListener("userEvent", this.onUserEvent);
        });
    }
    disconnect() {
      if (!this.objects.length) return;
      let { domElement: e } = this.eventContext;
      this.domEventsNeeded.clear(),
        Js &&
          (e.removeEventListener("pointerdown", this.onMouseDown),
          e.removeEventListener("pointerup", this.onMouseUp)),
        e.removeEventListener("pointermove", this.onMouseMove),
        Object.values(this.eventsPerObjects).forEach((t) => {
          t.forEach((i) => {
            i.disconnect();
          });
        }),
        this.objects.forEach((t) => {
          t.removeEventListener("userEvent", this.onUserEvent);
        });
    }
    handleMouseHoverEvent(e = !1) {
      let t = [];
      if (!e) {
        let {
            stopRaycast: i,
            raycaster: r,
            page: s,
            pointerScreen: a,
          } = this.eventContext,
          n = !1;
        if (
          (s.uiCanvas &&
            (n = uo(s, [a.x, a.y], Object.keys(this.eventsPerObjects), (o) => {
              t.push(o);
            })),
          i && !n)
        ) {
          let o = mm(r, s, this.objects);
          (t = ux(o)),
            o.forEach((l) => {
              l.object instanceof ps &&
                uo(
                  l.object,
                  [l?.uv?.x ?? 0, l?.uv?.y ?? 0],
                  Object.keys(this.eventsPerObjects),
                  (h) => {
                    t.push(h);
                  }
                );
            });
        } else
          this.objects.forEach((o) => {
            let l = vg(r, o);
            l &&
              (t.push(o),
              o instanceof ps &&
                uo(
                  o,
                  [l?.uv?.x ?? 0, l?.uv?.y ?? 0],
                  Object.keys(this.eventsPerObjects),
                  (h) => {
                    t.push(h);
                  }
                ));
          });
      }
      this._prevObjects.length &&
        this._prevObjects.forEach((i) => {
          t.includes(i) ||
            (i.dispatchEvent({ type: "beginEvent", eventName: "MouseHover" }),
            this.eventsPerObjects[i.uuid]?.forEach((r) => r.dispatchLeave()));
        }),
        t.length &&
          t.forEach((i) => {
            i.dispatchEvent({ type: "beginEvent", eventName: "MouseHover" }),
              this.eventsPerObjects[i.uuid]?.forEach((r) => r.dispatchEnter());
          }),
        (this._prevObjects = t);
    }
  },
  P$ = class {
    constructor(e, t, i, r, s, a) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.scrollCounter = 0),
        (this.actions = Rs(t, t.actions, r, s, a, i));
    }
    connect() {
      this.scrollCounter = 0;
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatch(e) {
      this.actions.Transition.forEach((r) => {
        r.object.currentTransitionEvent !== this &&
          ((r.object.currentTransitionEvent = this), r.init());
      });
      let t = e > 0 ? 1 : -1;
      (this.scrollCounter += t),
        (this.scrollCounter = Math.min(
          Math.max(this.scrollCounter, 0),
          this.data.steps
        ));
      let i = this.scrollCounter / this.data.steps;
      this.actions.Transition.forEach((r) => r.seek(i)),
        this.actions.Animation.forEach((r) => r.seek(t)),
        this.actions.Create.forEach((r) => r.dispatchThrottled()),
        this.actions.SetVariable.forEach((r) => r.checkConditions()),
        this.actions.SetVariable.forEach((r) => r.dispatch()),
        this.actions.DynamicVariablePlay.forEach((r) => r.dispatch());
    }
    dispatchUserEvent(e) {
      this.actions.Transition.forEach((t) => {
        t.object.currentTransitionEvent !== this &&
          ((t.object.currentTransitionEvent = this), t.init());
      }),
        e
          ? (this.actions.Transition.forEach((t) => t.reverseFromCurrent()),
            this.actions.Animation.forEach((t) => t.reverseFromCurrent()))
          : (this.actions.Transition.forEach((t) => {
              t.playFromCurrent();
            }),
            this.actions.Animation.forEach((t) => {
              t.playFromCurrent();
            })),
        this.actions.Create.forEach((t) => t.dispatchThrottled()),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch());
    }
  },
  D$ = class {
    constructor(e, t, i, r, s, a, n) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.domElement = a),
        (this.eventManager = n),
        (this.scrollStart = 0),
        (this.scrollEnd = 0),
        (this.actions = Rs(t, t.actions, r, s, n, i));
    }
    computeScrollBounds() {
      let e = this.domElement.getBoundingClientRect(),
        t = document.body,
        i = document.documentElement,
        r = window.pageYOffset || i.scrollTop || t.scrollTop,
        s = i.clientTop || t.clientTop || 0,
        a = Math.round(e.top + r - s);
      if (this.data.startFrom === "enter") {
        let n = window.innerHeight,
          o = e.height,
          l = this.data.enterAnchor,
          h = l === "top" ? n : l === "bottom" ? n - o : n - o * 0.5;
        this.scrollStart = a - h;
      } else this.scrollStart = 0;
      (this.scrollStart += this.data.startOffset ?? 0),
        (this.scrollEnd = this.scrollStart + (this.data.endAfter ?? 400)),
        (this.box = e),
        this.computeScroll({ x: window.scrollX, y: window.scrollY });
    }
    connect() {
      this.computeScrollBounds();
    }
    disconnect() {
      Xr(this.actions);
    }
    handleResize() {
      this.computeScrollBounds();
    }
    get isInvalidBox() {
      return (
        this.box === void 0 ||
        (this.box.width === 0 &&
          this.box.height === 0 &&
          this.box.top === 0 &&
          this.box.bottom === 0)
      );
    }
    computeScroll({ x: e, y: t }) {
      this.actions.Transition.forEach((s) => {
        s.object.currentTransitionEvent !== this &&
          ((s.object.currentTransitionEvent = this), s.init());
      });
      let i = this.scrollEnd - this.scrollStart,
        r = Math.min(1, Math.max(0, (t - this.scrollStart) / i));
      this.actions.Transition.forEach((s) => s.seek(r)),
        this.actions.Animation.forEach((s) => s.seek(r)),
        this.actions.Create.forEach((s) => s.dispatchThrottled()),
        this.actions.SetVariable.forEach((s) => s.checkConditions()),
        this.actions.SetVariable.forEach((s) => s.dispatch()),
        this.actions.DynamicVariablePlay.forEach((s) => s.dispatch());
    }
    dispatch(e) {
      this.isInvalidBox && this.computeScrollBounds(), this.computeScroll(e);
    }
    dispatchUserEvent(e) {
      this.actions.Transition.forEach((t) => {
        t.object.currentTransitionEvent !== this &&
          ((t.object.currentTransitionEvent = this), t.init());
      }),
        e
          ? (this.actions.Transition.forEach((t) => t.reverseFromCurrent()),
            this.actions.Animation.forEach((t) => t.reverseFromCurrent()))
          : (this.actions.Transition.forEach((t) => {
              t.playFromCurrent();
            }),
            this.actions.Animation.forEach((t) => {
              t.playFromCurrent();
            })),
        this.actions.Create.forEach((t) => t.dispatchThrottled()),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch());
    }
  },
  O$ = class extends en {
    constructor(e, t) {
      super(e),
        (this.wheelEventsPerObject = new Map()),
        (this.scrollEventsPerObject = new Map()),
        (this.isInview = !0),
        (this.handleResize = () => {
          [...this.scrollEventsPerObject.entries()].forEach(([o, l]) => {
            l.forEach((h) => h.handleResize());
          });
        }),
        (this.onScroll = (o) => {
          if (!this.isInview) return;
          let l = { y: window.scrollY, x: window.scrollX };
          [...this.scrollEventsPerObject.entries()].forEach(([h, u]) => {
            h.dispatchEvent({
              type: "beginEvent",
              eventName: "Scroll",
              scroll: l,
            }),
              u.forEach((c) => c.dispatch(l));
          });
        }),
        (this.onWheel = (o) => {
          !this.isInview ||
            o.ctrlKey ||
            [...this.wheelEventsPerObject.entries()].forEach(([l, h]) => {
              l.dispatchEvent({
                type: "beginEvent",
                eventName: "Scroll",
                deltaY: o.deltaY,
              }),
                h.forEach((u) => u.dispatch(o.deltaY));
            });
        }),
        (this.onUserEvent = ({ eventName: o, target: l, reverse: h }) => {
          if (!o || !l) return;
          let u = gp(o);
          u &&
            u === "Scroll" &&
            (l.dispatchEvent({ type: "beginEvent", eventName: "Scroll" }),
            this.wheelEventsPerObject.get(l)?.forEach((c) => {
              c.dispatchUserEvent(h);
            }));
        });
      let {
          page: i,
          sharedAssets: r,
          domElement: s,
          isExport: a,
        } = this.eventContext,
        n = (o) => {
          if (o.data?.events.length) {
            for (let { id: l, data: h } of o.data.events)
              if (!h.disabled && h.type === "Scroll")
                if (h.trigger === "load" || !a) {
                  let u = new P$(l, h, o, i, r, t);
                  this.wheelEventsPerObject.has(o)
                    ? this.wheelEventsPerObject.get(o)?.push(u)
                    : this.wheelEventsPerObject.set(o, [u]);
                } else {
                  let u = new D$(l, h, o, i, r, s, t);
                  this.scrollEventsPerObject.has(o)
                    ? this.scrollEventsPerObject.get(o)?.push(u)
                    : this.scrollEventsPerObject.set(o, [u]);
                }
          }
        };
      i.traverseEntity((o) => {
        (o instanceof ps || o instanceof Hr) &&
          o.frame?.traverse((l) => {
            n(l);
          }),
          n(o);
      }),
        (this.intersectionObserver = new IntersectionObserver(
          (o) => {
            let l = o[0];
            l && (this.isInview = l.isIntersecting);
          },
          { root: null }
        ));
    }
    connect() {
      this.intersectionObserver.observe(this.eventContext.domElement),
        [...this.wheelEventsPerObject.entries()].forEach(([e, t]) => {
          t.forEach((i) => i.connect()),
            e.addEventListener("userEvent", this.onUserEvent);
        }),
        [...this.scrollEventsPerObject.entries()].forEach(([e, t]) => {
          t.forEach((i) => i.connect()),
            e.addEventListener("userEvent", this.onUserEvent);
        }),
        [...this.wheelEventsPerObject.values()].some((e) => e.length) &&
          (this.domEventsNeeded.add("wheel"),
          window.addEventListener("wheel", this.onWheel)),
        [...this.scrollEventsPerObject.values()].some((e) => e.length) &&
          (this.domEventsNeeded.add("scroll"),
          window.addEventListener("scroll", this.onScroll),
          window.addEventListener("resize", this.handleResize));
    }
    disconnect() {
      window.removeEventListener("wheel", this.onWheel),
        window.removeEventListener("scroll", this.onScroll),
        window.removeEventListener("resize", this.handleResize),
        this.intersectionObserver.unobserve(this.eventContext.domElement),
        this.domEventsNeeded.clear(),
        [...this.wheelEventsPerObject.entries()].forEach(([e, t]) => {
          t.forEach((i) => i.disconnect()),
            e.removeEventListener("userEvent", this.onUserEvent);
        }),
        [...this.scrollEventsPerObject.entries()].forEach(([e, t]) => {
          t.forEach((i) => i.disconnect()),
            e.removeEventListener("userEvent", this.onUserEvent);
        });
    }
  },
  I$ = class {
    constructor(e, t, i, r, s, a) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.actions = Rs(t, t.actions, r, s, a, i));
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatch() {
      this.actions.Transition.forEach((e) => {
        e.play();
      }),
        this.actions.Animation.forEach((e) => {
          e.play();
        }),
        this.actions.SwitchCamera.forEach((e) => {
          e.play();
        }),
        this.actions.SceneTransition.forEach((e) => {
          e.dispatch();
        }),
        this.actions.Reset.forEach((e) => e.dispatch()),
        this.actions.SetVariable.forEach((e) => e.checkConditions()),
        this.actions.SetVariable.forEach((e) => e.dispatch()),
        this.actions.DynamicVariablePlay.forEach((e) => e.dispatch()),
        this.actions.Create.forEach((e) => {
          e.dispatchFromStart();
        }),
        this.actions.Destroy.forEach((e) => {
          e.dispatchFromStart();
        });
    }
    dispatchAfter(e) {
      this.actions.Audio.forEach((t) => {
        (t.interaction.data.triggerAfter ?? "any") === e &&
          (t.interaction instanceof Zl
            ? t.interaction.audioPlayer.play()
            : t.interaction instanceof sx && t.interaction.dispatch());
      }),
        this.actions.Video.forEach((t) => {
          let i = t.interaction.data.triggerAfter ?? "autoplay";
          i === e &&
            (t.interaction instanceof Vc
              ? t.interaction.play(i === "autoplay")
              : t.interaction instanceof hx && t.interaction.dispatch());
        }),
        this.actions.Particles.forEach((t) => {
          (t.data.triggerAfter ?? "any") === e && t.dispatchBasic();
        });
    }
    dispatchUserEvent(e) {
      this.actions.Transition.forEach((t) => {
        t.object.currentTransitionEvent !== this &&
          ((t.object.currentTransitionEvent = this), t.init());
      }),
        e
          ? (this.actions.Transition.forEach((t) => t.reverseFromCurrent()),
            this.actions.Animation.forEach((t) => t.reverseFromCurrent()),
            this.actions.SwitchCamera.forEach((t) => t.reverseFromCurrent()))
          : (this.actions.Transition.forEach((t) => t.playFromCurrent()),
            this.actions.Animation.forEach((t) => t.playFromCurrent()),
            this.actions.SwitchCamera.forEach((t) => t.playFromCurrent())),
        this.actions.SceneTransition.forEach((t) => t.dispatch()),
        this.actions.Reset.forEach((t) => t.dispatch()),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch()),
        this.actions.Create.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Destroy.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Audio.forEach((t) => {
          t.interaction instanceof Zl
            ? t.interaction.audioPlayer.play()
            : t.interaction instanceof sx && t.interaction.dispatch();
        }),
        this.actions.Video.forEach((t) => {
          t.interaction instanceof Vc
            ? t.interaction.play()
            : t.interaction instanceof hx && t.interaction.dispatch();
        }),
        this.actions.Particles.forEach((t) => {
          t.dispatchBasic();
        });
    }
  },
  R$ = class extends en {
    constructor(e, t) {
      super(e),
        (this.eventManager = t),
        (this.eventsPerObject = new Map()),
        (this.eventsAfterPerObject = new Map()),
        (this.onMouseDown = () => {
          [...this.eventsAfterPerObject.entries()].forEach(([i, r]) => {
            i.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
              r.forEach((s) => {
                s.dispatchAfter("mouseDown");
              });
          });
        }),
        (this.onKeyDown = () => {
          [...this.eventsAfterPerObject.entries()].forEach(([i, r]) => {
            i.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
              r.forEach((s) => {
                s.dispatchAfter("keyDown");
              });
          });
        }),
        (this.onAny = () => {
          let { domElement: i, isExport: r } = this.eventContext;
          (r ? document : i).removeEventListener("pointerdown", this.onAny),
            document.removeEventListener("keydown", this.onAny),
            [...this.eventsAfterPerObject.entries()].forEach(([s, a]) => {
              s.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
                a.forEach((n) => {
                  n.dispatchAfter("any");
                });
            });
        }),
        (this.onSceneTransitionAudioVideoPlay = () => {
          [...this.eventsAfterPerObject.entries()].forEach(([i, r]) => {
            i.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
              r.forEach((s) => {
                s.actions.Audio.forEach((a) => {
                  a.interaction instanceof Zl &&
                    a.interaction.audioPlayer.play();
                }),
                  s.actions.Video.forEach((a) => {
                    let n = a.interaction.data.triggerAfter ?? "autoplay";
                    a.interaction instanceof Vc &&
                      a.interaction.play(n === "autoplay");
                  }),
                  s.actions.Particles.forEach((a) => {
                    a.dispatchBasic();
                  });
              });
          });
        }),
        (this.onPlay = () => {
          [...this.eventsAfterPerObject.entries()].forEach(([i, r]) => {
            i.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
              r.forEach((s) => {
                s.dispatchAfter("autoplay");
              });
          });
        }),
        (this.onUserEvent = ({ eventName: i, target: r, reverse: s }) => {
          if (!i || !r) return;
          let a = gp(i);
          a &&
            a === "Start" &&
            (r instanceof Rr ||
              r.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
            this.eventsPerObject.get(r)?.forEach((n) => {
              n.dispatchUserEvent(s);
            }),
            this.eventsAfterPerObject.get(r)?.forEach((n) => {
              n.dispatchUserEvent(s);
            }));
        });
    }
    connect() {
      let { sharedAssets: e, page: t } = this.eventContext,
        i = (r) => {
          if (r.data?.events.length)
            for (let { id: s, data: a } of r.data.events) {
              if (a.disabled || a.type !== "Start") continue;
              let n = new I$(s, a, r, t, e, this.eventManager);
              (n.actions.Transition.length ||
                n.actions.Animation.length ||
                n.actions.SwitchCamera.length ||
                n.actions.Create.length ||
                n.actions.Destroy.length ||
                n.actions.SceneTransition.length ||
                n.actions.Reset.length ||
                n.actions.SetVariable.length ||
                n.actions.DynamicVariablePlay.length) &&
                (this.eventsPerObject.has(r)
                  ? this.eventsPerObject.get(r)?.push(n)
                  : this.eventsPerObject.set(r, [n])),
                n.actions.Audio.length &&
                  (this.eventsAfterPerObject.has(r)
                    ? this.eventsAfterPerObject.get(r)?.push(n)
                    : this.eventsAfterPerObject.set(r, [n])),
                n.actions.Video.length &&
                  ((this.hasVideoAction = !0),
                  this.eventsAfterPerObject.has(r)
                    ? this.eventsAfterPerObject.get(r)?.push(n)
                    : this.eventsAfterPerObject.set(r, [n])),
                n.actions.Particles.length &&
                  (this.eventsAfterPerObject.has(r)
                    ? this.eventsAfterPerObject.get(r)?.push(n)
                    : this.eventsAfterPerObject.set(r, [n]));
            }
        };
      if (
        (t.traverseEntity((r) => {
          (r instanceof ps || r instanceof Hr) &&
            r.frame?.traverse((s) => {
              i(s);
            }),
            i(r);
        }),
        [...this.eventsAfterPerObject.values()].some((r) => r.length))
      ) {
        if (this.eventManager.activateCount === 0) {
          let { domElement: r, isExport: s } = this.eventContext,
            a = s ? document : r;
          a.addEventListener("pointerdown", this.onMouseDown, { once: !0 }),
            a.addEventListener("mousedown", this.onMouseDown, { once: !0 }),
            document.addEventListener("keydown", this.onKeyDown, { once: !0 }),
            a.addEventListener("pointerdown", this.onAny),
            a.addEventListener("mousedown", this.onAny),
            document.addEventListener("keydown", this.onAny),
            [...this.eventsAfterPerObject.entries()].forEach(([n, o]) => {
              n.addEventListener("userEvent", this.onUserEvent);
            });
        } else this.onSceneTransitionAudioVideoPlay();
        this.onPlay();
      }
      [...this.eventsPerObject.entries()].forEach(([r, s]) => {
        r.dispatchEvent({ type: "beginEvent", eventName: "Start" }),
          s.forEach((a) => a.dispatch()),
          r.addEventListener("userEvent", this.onUserEvent);
      });
    }
    disconnect() {
      if ([...this.eventsAfterPerObject.values()].some((e) => e.length)) {
        let { domElement: e, isExport: t } = this.eventContext,
          i = t ? document : e;
        i.removeEventListener("pointerdown", this.onMouseDown),
          i.removeEventListener("mousedown", this.onMouseDown),
          document.removeEventListener("keydown", this.onKeyDown),
          i.removeEventListener("pointerdown", this.onAny),
          i.removeEventListener("mousedown", this.onAny),
          document.removeEventListener("keydown", this.onAny),
          [...this.eventsAfterPerObject.entries()].forEach(([r, s]) => {
            r.removeEventListener("userEvent", this.onUserEvent),
              s.forEach((a) => a.disconnect());
          });
      }
      [...this.eventsPerObject.entries()].forEach(([e, t]) => {
        e.removeEventListener("userEvent", this.onUserEvent),
          t.forEach((i) => i.disconnect());
      }),
        this.eventsPerObject.clear(),
        this.eventsAfterPerObject.clear();
    }
  },
  L$ = class {
    constructor(e, t, i, r, s, a) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.disabled = !1),
        (this.alreadyPlayedNonTogglingActions = new Set()),
        (this.actions = Rs(t, t.actions, r, s, a, i)),
        (this.target = t.target),
        (this.useToggle = t.runMode === "Toggle");
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatch(e) {
      this.disabled ||
        (this.actions.Transition.forEach((t) => {
          t.object.currentTransitionEvent !== this
            ? ((t.object.currentTransitionEvent = this), t.init())
            : this.data.runMode === "Once" &&
              this.alreadyPlayedNonTogglingActions.add(t);
        }),
        this.object.dispatchEvent({
          type: "beginEvent",
          eventName: "Collision",
        }),
        this.useToggle
          ? (this.actions.Transition.forEach((t) => {
              t.toggle();
            }),
            this.actions.Animation.forEach((t) => {
              t.toggle();
            }))
          : (this.actions.Transition.forEach((t) => {
              this.alreadyPlayedNonTogglingActions.has(t) === !1 && t.play();
            }),
            this.actions.Animation.forEach((t) => {
              t.play();
            })),
        this.actions.Reset.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Link.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Reset.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Create.forEach((t) => {
          t.dispatch();
        }),
        this.actions.Destroy.forEach((t) => {
          t.dispatch(e ?? !1);
        }),
        this.actions.SetVariable.forEach((t) => t.checkConditions()),
        this.actions.SetVariable.forEach((t) => t.dispatch()),
        this.actions.DynamicVariablePlay.forEach((t) => t.dispatch()),
        this.actions.Audio.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.Particles.forEach((t) => {
          t.dispatchBasic();
        }),
        this.actions.Video.forEach((t) => {
          t.dispatchBasic();
        }));
    }
  },
  B$ = class extends en {
    constructor(e, t, i, r, s) {
      super(e),
        (this.sharedVariables = t),
        (this.eventManager = i),
        (this.needsMouse = r),
        (this.needsRaycast = s),
        (this.dynamicVars = []),
        (this.variablesToWatch = []),
        (this.prevMouseProperty = null),
        (this.prevRaycastProperty = null),
        (this.pauseTime = 0),
        (this.events = []),
        (this.onFrame = (a) => {
          this.rafId = window.requestAnimationFrame(this.onFrame);
          let n = new Date(),
            o = [],
            l = [];
          for (let c = 0; c < this.propertiesToWatch.length; c++) {
            let {
                objectId: d,
                property: p,
                prevValue: f,
              } = this.propertiesToWatch[c],
              m = this.eventContext.scene.find(d),
              g = Gy.propertyPaths[p];
            if (g[0] === "width" || g[0] === "height" || g[0] === "depth")
              m = m.geometry.userData.parameters[g[0]];
            else for (let y = 0; y < g.length; y++) m = m[g[y]];
            f === null
              ? (this.propertiesToWatch[c].prevValue =
                  m instanceof I ? m.clone() : m)
              : (m instanceof I ? !m.equals(f) : f !== m) &&
                (l.push({ objId: d, property: p }),
                m instanceof I
                  ? this.propertiesToWatch[c].prevValue.copy(m)
                  : (this.propertiesToWatch[c].prevValue = m));
          }
          for (let c = 0; c < this.variablesToWatch.length; c++) {
            let { id: d, prevValue: p } = this.variablesToWatch[c],
              f = this.shared.getVariable(d);
            f !== p && (o.push(d), (this.variablesToWatch[c].prevValue = f));
          }
          for (let c = 0; c < this.dynamicVars.length; c++) {
            let {
                id: d,
                expectedTime: p,
                last: f,
                data: m,
                timerSeconds: g,
                startValue: y,
              } = this.dynamicVars[c],
              x = 1e3;
            if (
              ((m.dynamicVariableType === "timer" ||
                m.dynamicVariableType === "stopwatch") &&
              m.format === "number3decimal"
                ? (x = 1)
                : m.dynamicVariableType === "counter"
                ? (x = m.updateInterval)
                : m.dynamicVariableType === "random" &&
                  (x = m.isStatic ? 1 / 0 : m.updateInterval),
              p === -1)
            ) {
              (this.dynamicVars[c].last = a),
                (this.dynamicVars[c].expectedTime = a + x);
              continue;
            }
            if (
              !(
                (this.shared.getDynamicVariablePlayState(d) === "Stopped" ||
                  this.shared.getDynamicVariablePlayState(d) === "Restarted") &&
                ((this.dynamicVars[c].last = a),
                (this.dynamicVars[c].expectedTime = a + x),
                m.dynamicVariableType === "counter" &&
                  this.shared.getVariable(d) !== y &&
                  (this.shared.updateVariable(d, y),
                  this.eventManager.requestRender()),
                (m.dynamicVariableType === "timer" ||
                  m.dynamicVariableType === "stopwatch") &&
                  this.dynamicVars[c].timerSeconds !== y &&
                  ((this.dynamicVars[c].timerSeconds = y),
                  this.shared.updateVariable(d, wa.getFormattedTimerTime(y, m)),
                  this.eventManager.requestRender()),
                this.shared.getDynamicVariablePlayState(d) === "Restarted" &&
                  this.shared.setDynamicVariablePlayState(d, "Playing"),
                this.shared.getDynamicVariablePlayState(d) === "Stopped")
              )
            ) {
              if (this.shared.getDynamicVariablePlayState(d) === "Paused") {
                this.dynamicVars[c].deltaToExpectedTime === void 0 &&
                  (this.dynamicVars[c].deltaToExpectedTime = Math.max(
                    this.dynamicVars[c].expectedTime - a,
                    0
                  )),
                  (this.dynamicVars[c].last =
                    a - (x - this.dynamicVars[c].deltaToExpectedTime)),
                  (this.dynamicVars[c].expectedTime =
                    a + this.dynamicVars[c].deltaToExpectedTime);
                continue;
              } else this.dynamicVars[c].deltaToExpectedTime = void 0;
              if (a >= p)
                if (
                  ((this.dynamicVars[c].last = a),
                  (this.dynamicVars[c].expectedTime += x),
                  m.dynamicVariableType === "random")
                ) {
                  let b = m.min + Math.random() * (m.max - m.min),
                    _ = m.decimals;
                  (b = Math.round(b * Math.pow(10, _)) / Math.pow(10, _)),
                    this.shared.updateVariable(d, b),
                    o.push(d),
                    this.eventManager.requestRender();
                } else if (m.dynamicVariableType === "counter") {
                  if (m.increment === 0) continue;
                  let b = this.shared.getVariable(d),
                    _ = this.shared.getDynamicVariableToggleIsForward(d) ?? !0,
                    S = this.shared.getVariable(d) + m.increment * (_ ? 1 : -1);
                  m.hasEnd &&
                    ((S =
                      m.increment > 0
                        ? dt.clamp(S, y, m.endValue)
                        : dt.clamp(S, m.endValue, y)),
                    S === y &&
                      this.shared.setDynamicVariableToggleIsForward(d, void 0),
                    m.repeat
                      ? S === m.endValue && (S = y)
                      : (S === y || S === m.endValue) &&
                        this.shared.setDynamicVariablePlayState(d, "Paused")),
                    S !== b &&
                      (o.push(d),
                      this.shared.updateVariable(d, S),
                      this.eventManager.requestRender());
                } else if (m.dynamicVariableType === "time")
                  this.shared.updateVariable(d, jA(n, m)),
                    o.push(d),
                    this.eventManager.requestRender();
                else {
                  let b = $s.isTextValue(m.endValue)
                      ? EE(m.endValue.textValue)
                      : m.endValue,
                    _ = this.shared.getDynamicVariableToggleIsForward(d) ?? !0,
                    S =
                      g +
                      ((a - f) / 1e3) *
                        (m.dynamicVariableType === "timer" ? -1 : 1) *
                        (_ ? 1 : -1);
                  (S = Math.max(S, 0)),
                    m.hasEnd &&
                      ((S =
                        m.dynamicVariableType === "stopwatch"
                          ? dt.clamp(S, y, b)
                          : dt.clamp(S, b, y)),
                      S === y &&
                        this.shared.setDynamicVariableToggleIsForward(
                          d,
                          void 0
                        ),
                      m.repeat
                        ? Math.abs(S - b) <
                            (m.format === "number3decimal" ? 1e-4 : 0.1) &&
                          (S = y)
                        : (Math.abs(S - y) <
                            (m.format === "number3decimal" ? 1e-4 : 0.1) ||
                            Math.abs(S - b) <
                              (m.format === "number3decimal" ? 1e-4 : 0.1)) &&
                          this.shared.setDynamicVariablePlayState(d, "Paused")),
                    S !== g &&
                      (o.push(d),
                      (this.dynamicVars[c].timerSeconds = S),
                      this.shared.updateVariable(
                        d,
                        wa.getFormattedTimerTime(S, m)
                      ),
                      this.eventManager.requestRender());
                }
            }
          }
          this.needsMouse &&
            this.shared.mouseProperty !== this.prevMouseProperty &&
            ((this.prevMouseProperty = this.shared.mouseProperty),
            this.events.forEach((c) => {
              c.data.variableId === "mouseProperty" &&
                (c.dispatch(), this.eventManager.requestRender());
            }));
          let h = !1;
          this.shared.mouseProperty !== this.prevMouseProperty &&
            ((this.prevMouseProperty = this.shared.mouseProperty), (h = !0));
          let u = !1;
          this.shared.raycastProperty !== this.prevRaycastProperty &&
            ((this.prevRaycastProperty = this.shared.raycastProperty),
            (u = !0)),
            this.events.forEach((c) => {
              (o.includes(c.data.variableId) ||
                l.find(
                  (d) =>
                    d.objId === c.data.objectId &&
                    d.property === c.data.property
                ) ||
                (c.data.variableId === "mouseProperty" && h) ||
                (c.data.variableId === "raycastProperty" && u)) &&
                (c.dispatch(), this.eventManager.requestRender());
            });
        }),
        (this.onBlur = () => {
          this.pause();
        }),
        (this.onFocus = () => {
          this.resume();
        }),
        e.page.traverseEntity((a) => {
          a.data?.events
            .filter((n) => n.data.type === "VariableChange" && !n.data.disabled)
            .forEach((n) => {
              this.events.push(
                new z$(a.uuid, n.data, a, e.page, e.sharedAssets, i)
              );
            });
        }),
        (this.propertiesToWatch = this.events
          .filter(
            (a) =>
              a.data.variableId === "objectProperty" && a.data.objectId !== null
          )
          .map((a) => ({
            objectId: a.data.objectId,
            property: a.data.property,
            prevValue: null,
          }))),
        (this.shared = e.sharedAssets),
        this.sharedVariables.forEach(({ id: a, data: n }) => {
          if (!("dynamicVariableType" in n)) {
            this.events.find((l) => l.data.variableId === a) &&
              this.variablesToWatch.push({
                id: a,
                prevValue: this.shared.getVariable(a),
              });
            return;
          }
          let o;
          if (
            n.dynamicVariableType === "timer" ||
            n.dynamicVariableType === "stopwatch"
          ) {
            let l;
            if ($s.isTextValue(n.value) && Array.isArray(n.value.textValue)) {
              let h = n.value.textValue;
              h.length === 3
                ? (l = h[2] + h[1] * 60 + h[0] * 3600)
                : (l = h[1] + h[0] * 60);
            } else l = n.value;
            (o = l),
              this.dynamicVars.push({
                id: a,
                last: -1,
                expectedTime: -1,
                data: n,
                timerSeconds: l,
                startValue: o,
              });
          } else
            n.dynamicVariableType === "time" &&
              this.shared.updateVariable(a, jA(new Date(), n)),
              n.dynamicVariableType === "counter" &&
                (o = $s.isTextValue(n.value) ? EE(n.value.textValue) : n.value),
              this.dynamicVars.push({
                id: a,
                last: -1,
                expectedTime: -1,
                data: n,
                startValue: o,
              });
        });
    }
    pause() {
      this.pauseTime = Date.now();
    }
    resume() {
      let e = Date.now() - this.pauseTime;
      for (let t = 0; t < this.dynamicVars.length; t++)
        (this.dynamicVars[t].last += e),
          (this.dynamicVars[t].expectedTime += e);
    }
    connect() {
      (this.rafId = window.requestAnimationFrame(this.onFrame)),
        window.addEventListener("blur", this.onBlur),
        window.addEventListener("focus", this.onFocus);
    }
    disconnect() {
      window.removeEventListener("blur", this.onBlur),
        window.removeEventListener("focus", this.onFocus),
        this.rafId &&
          (window.cancelAnimationFrame(this.rafId), (this.rafId = void 0)),
        this.events.forEach((e) => e.dispose());
    }
  },
  z$ = class {
    constructor(e, t, i, r, s, a) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.actions = Rs(t, t.actions, r, s, a, i));
    }
    dispatch() {
      let e = this.actions;
      e.Audio.forEach((t) => t.dispatchConditional()),
        e.Particles.forEach((t) => t.dispatchConditional()),
        e.Video.forEach((t) => t.dispatchConditional()),
        e.Create.forEach((t) => t.dispatch()),
        e.Destroy.forEach((t) => t.dispatch()),
        e.Reset.forEach((t) => t.dispatch()),
        e.Transition.forEach((t) => {
          t.object.currentTransitionEvent !== this &&
            (t.object.currentTransitionEvent = this),
            t.init();
        }),
        e.Transition.forEach((t) => t.play()),
        e.Animation.forEach((t) => t.play()),
        e.SwitchCamera.forEach((t) => t.play()),
        e.SceneTransition.forEach((t) => t.dispatch()),
        e.SetVariable.forEach((t) => t.checkConditions()),
        e.SetVariable.forEach((t) => t.dispatch()),
        e.DynamicVariablePlay.forEach((t) => t.dispatch());
    }
    dispose() {
      Xr(this.actions);
    }
  };
function EE(e) {
  return e.length === 3 ? e[2] + e[1] * 60 + e[0] * 3600 : e[1] + e[0] * 60;
}
var F$ = "https://unpkg.com/@splinetool/runtime@1.0.31/build/",
  k$ = "https://unpkg.com/@splinetool/navmesh-wasm@1.0.31/build/",
  N$ = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import('${F$}' + 'navmesh.js'),
		fetch('${k$}' + 'navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`,
  U$ = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import(self.location.origin + '/_libraries/navmesh.js'),
		fetch(self.location.origin + '/_libraries/navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`,
  V$ = `

onmessage = function(messageEvent) {
	const meshData = messageEvent.data;
	const positions = meshData[0];
	const offset = meshData[1];
	const indices = meshData[2];
	const indicesLength = meshData[3];
	const parameters = meshData[4];

	const module = self.module;
	const rc = new module.rcConfig();
	rc.cs = parameters.cs;
	rc.ch = parameters.ch;
	rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;
	rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;
	rc.walkableSlopeAngle = parameters.walkableSlopeAngle;
	rc.walkableHeight = parameters.walkableHeight;
	rc.walkableClimb = parameters.walkableClimb;
	rc.walkableRadius = parameters.walkableRadius;
	rc.maxEdgeLen = parameters.maxEdgeLen;
	rc.maxSimplificationError = parameters.maxSimplificationError;
	rc.minRegionArea = parameters.minRegionArea;
	rc.mergeRegionArea = parameters.mergeRegionArea;
	rc.maxVertsPerPoly = parameters.maxVertsPerPoly;
	rc.detailSampleDist = parameters.detailSampleDist;
	rc.detailSampleMaxError = parameters.detailSampleMaxError;

	if (!self.navMesh) {
		self.navMesh = new module.NavMesh();
	}
	self.navMesh.build(positions, offset, indices, indicesLength, rc);

	const navmeshData = navMesh.getNavmeshData();
	const arrView = new Uint8Array(module.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);
	const ret = new Uint8Array(navmeshData.size);
	ret.set(arrView);
	navMesh.freeNavmeshData(navmeshData);

	postMessage(ret);
}
`,
  CE = 0.001,
  j$ = {
    cs: 6,
    ch: 2,
    walkableSlopeAngle: 90,
    walkableHeight: 20,
    walkableClimb: 5,
    walkableRadius: 0,
    maxEdgeLen: 12,
    maxSimplificationError: 1.3,
    minRegionArea: 8,
    mergeRegionArea: 20,
    maxVertsPerPoly: 6,
    detailSampleDist: 6,
    detailSampleMaxError: 1,
  },
  DD,
  ri,
  es;
GH.then((e) => {
  (DD = e), (ri = new e.Vec3()), (es = new e.Vec3());
});
var H$ = new I(),
  G$ = class {
    constructor(e = !1, t = !1) {
      (this.usePhysics = e),
        (this.isExport = t),
        (this.onPointerDown = (i) => {
          if (Pt.length !== 1) return;
          let { raycaster: r, page: s } = this.eventContext;
          this.eventContext.updateRaycaster(i);
          let a = s.raycastWithClones(r);
          if (a.length !== 0) {
            if (this.gameControl) {
              let n = H$.copy(this.gameControl.colliderWorldPosition);
              (n.y -= this.gameControl.colliderHeight / 2),
                (this.gameControl.path = this.computePath(n, a[0].point));
            }
            this.eventContext.requestRender();
          }
        }),
        (this.traverseWithPhysics = (i, r) => (s) => {
          let a;
          if (s instanceof Wa)
            if (s.objectForSample) {
              if (s.objectForSample.dataPatched.physics.fusedBody) return;
              a = s.object;
            } else
              return s.object.dataPatched.physics.fusedBody === !0 &&
                s.object.dataPatched.physics.rigidBody === "dynamic"
                ? !0
                : void 0;
          else if (s instanceof fs) a = s.object;
          else if (
            ((a = s),
            a.dataPatched.cloner?.disabled === !1 &&
              a.dataPatched.cloner?.hideBase &&
              a.dataPatched.physics?.fusedBody !== !0)
          )
            return !0;
          if (r && !a.userData.navmesh) return;
          let n = a.dataPatched;
          if (!n.visible && n.physics?.enabled !== !0) return !0;
          s.updateMatrixWorldSVD();
          let o = yg(n),
            l = a.userData.hasDestroy,
            h = a.userData.hasDrag,
            u = !1,
            c = !1;
          for (let d of n.events)
            d.data.disabled !== !0 &&
              (d.data.type === "GameControl"
                ? (u = !0)
                : d.data.type === "Follow" && (c = !0));
          if (u || o || c || l || h) return !0;
          if (this.usePhysics && n.physics?.rigidBody === "dynamic") {
            if (this.usePhysics && n.physics?.fusedBody) return !0;
          } else if (
            ("geometry" in s &&
              s.geometry &&
              i.push(co(s.geometry, s.matrixWorld)),
            this.usePhysics && n.physics?.fusedBody)
          )
            return (
              s.traverseObject((d, p) => {
                if (p === 0) return;
                let f;
                if (d instanceof Wa)
                  if (d.objectForSample) {
                    if (d.objectForSample.dataPatched.physics.fusedBody) return;
                    f = d.object;
                  } else
                    return d.object.dataPatched.physics.fusedBody === !0 &&
                      d.object.dataPatched.physics.rigidBody === "dynamic"
                      ? !0
                      : void 0;
                else if (d instanceof fs) f = d.object;
                else if (((f = d), d.dataPatched.cloner?.hideBase)) return !0;
                let m = f.dataPatched;
                if (!m.visible && m.physics?.enabled !== !0) return !0;
                "geometry" in d &&
                  d.geometry &&
                  i.push(co(d.geometry, d.matrixWorld));
              }),
              !0
            );
        }),
        (this.traverseNoPhysics = (i, r) => (s) => {
          let a;
          if (s instanceof Wa) return;
          s instanceof fs ? (a = s.object) : (a = s);
          let n = a.dataPatched;
          if (
            n.physics.enabled === "visibility" ? !n.visible : !n.physics.enabled
          )
            return !0;
          if (r && !a.userData.navmesh) return;
          let o = s.geometry,
            l = a.userData.hasDestroy === !0,
            h = a.userData.hasDrag === !0;
          if (
            yg(n) ||
            l ||
            h ||
            a.dataPatched.events.some(
              (u) => u.data.disabled !== !0 && u.data.type === "GameControl"
            )
          )
            return !0;
          o && i.push(co(o, s.matrixWorld));
        }),
        (this.navmeshWasm = DD),
        (this.navMesh = new this.navmeshWasm.NavMesh()),
        (this._workerURL = URL.createObjectURL(new Blob([(t ? N$ : U$) + V$]))),
        (this._worker = new Worker(this._workerURL));
    }
    init(e, t, i) {
      (this.gameControl = t),
        (this.eventContext = i),
        (this.resolution = e.ch),
        this.setDefaultQueryExtent(
          new I().setScalar(e.ch * e.walkableRadius * 1.2)
        ),
        (this._worker.onmessage = () => {
          this.createNavMesh(i.page, e, (r) => {
            this.buildFromNavmeshData(r.data);
          });
        }),
        this.eventContext.renderer.domElement.addEventListener(
          "pointerdown",
          this.onPointerDown
        );
    }
    createNavMesh(e, t, i) {
      t.objects.forEach((l) => {
        let h = e.scene.find(l);
        h.traverseEntity((u) => {
          u.userData.navmesh = !0;
        }),
          h.cloner?.traverseObject((u) => {
            u.userData.navmesh = !0;
          });
      });
      let r = [],
        s = (
          this.usePhysics ? this.traverseWithPhysics : this.traverseNoPhysics
        )(r, t.zones === "custom");
      if (
        (e.traverseChildren(s),
        t.objects.forEach((l) => {
          let h = e.scene.find(l);
          h.traverseEntity((u) => {
            u.userData.navmesh = void 0;
          }),
            h.cloner?.traverseObject((u) => {
              u.userData.navmesh = void 0;
            });
        }),
        r.length === 0)
      )
        return !1;
      let a = Ql(r),
        { positions: n, triIndices: o } = kg(
          a.getAttribute("position"),
          a.getIndex()
        );
      return (
        this._worker.postMessage([
          n,
          n.length / 3,
          o,
          o.length,
          { ...j$, ...t },
        ]),
        (this._worker.onmessage = i),
        !0
      );
    }
    createDebugNavGeometry() {
      let e,
        t,
        i = this.navMesh.getDebugNavMesh(),
        r = i.getTriangleCount(),
        s = new Uint32Array(r * 3),
        a = new Float32Array(r * 3 * 3);
      for (e = 0; e < r * 3; e++) s[e] = e;
      for (e = 0; e < r; e++)
        for (t = 0; t < 3; t++) {
          let o = i.getTriangle(e).getPoint(t);
          (a[e * 9 + t * 3 + 0] = o.x),
            (a[e * 9 + t * 3 + 1] = o.y),
            (a[e * 9 + t * 3 + 2] = o.z);
        }
      let n = new yt();
      return (
        n.setIndex(new It(s, 1)), n.setAttribute("position", new It(a, 3)), n
      );
    }
    getClosestPoint(e) {
      return (
        (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        this.navMesh.getClosestPoint(ri)
      );
    }
    getClosestPointToRef(e, t) {
      (ri.x = e.x), (ri.y = e.y), (ri.z = e.z);
      let i = this.navMesh.getClosestPoint(ri);
      t.set(i.x, i.y, i.z);
    }
    getRandomPointAround(e, t) {
      return (
        (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        this.navMesh.getRandomPointAround(ri, t)
      );
    }
    getRandomPointAroundToRef(e, t, i) {
      (ri.x = e.x), (ri.y = e.y), (ri.z = e.z);
      let r = this.navMesh.getRandomPointAround(ri, t);
      i.set(r.x, r.y, r.z);
    }
    moveAlong(e, t) {
      return (
        (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        (es.x = t.x),
        (es.y = t.y),
        (es.z = t.z),
        this.navMesh.moveAlong(ri, es)
      );
    }
    moveAlongToRef(e, t, i) {
      return (
        (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        (es.x = t.x),
        (es.y = t.y),
        (es.z = t.z),
        this.navMesh.moveAlong(ri, es)
      );
    }
    computePath(e, t) {
      let i = this.getClosestPoint(t);
      (es.x = i.x), (es.y = i.y), (es.z = i.z), this.getClosestPoint(e);
      let r = this.navMesh.computePath(ri, es),
        s = r.getPointCount(),
        a = [];
      for (let n = 0; n < s; n++) {
        let o = r.getPoint(n);
        a.push(new I(o.x, o.y, o.z));
      }
      return a;
    }
    createCrowd(e, t) {
      return new W$(this, e, t);
    }
    setDefaultQueryExtent(e) {
      (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        this.navMesh.setDefaultQueryExtent(ri);
    }
    getDefaultQueryExtent() {
      return this.navMesh.getDefaultQueryExtent();
    }
    buildFromNavmeshData(e) {
      let t = e.length * e.BYTES_PER_ELEMENT,
        i = this.navmeshWasm._malloc(t),
        r = new Uint8Array(this.navmeshWasm.HEAPU8.buffer, i, t);
      r.set(e);
      let s = new this.navmeshWasm.NavmeshData();
      (s.dataPointer = r.byteOffset),
        (s.size = e.length),
        this.navMesh.buildFromNavmeshData(s),
        this.navmeshWasm._free(r.byteOffset);
    }
    getNavmeshData() {
      let e = this.navMesh.getNavmeshData(),
        t = new Uint8Array(
          this.navmeshWasm.HEAPU8.buffer,
          e.dataPointer,
          e.size
        ),
        i = new Uint8Array(e.size);
      return i.set(t), this.navMesh.freeNavmeshData(e), i;
    }
    getDefaultQueryExtentToRef(e) {
      let t = this.navMesh.getDefaultQueryExtent();
      e.set(t.x, t.y, t.z);
    }
    dispose() {
      this.navMesh.destroy(),
        this._worker.terminate(),
        URL.revokeObjectURL(this._workerURL),
        this.eventContext?.renderer.domElement.removeEventListener(
          "pointerdown",
          this.onPointerDown
        );
    }
    addCylinderObstacle(e, t, i) {
      return (
        (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        this.navMesh.addCylinderObstacle(ri, t, i)
      );
    }
    addBoxObstacle(e, t, i) {
      return (
        (ri.x = e.x),
        (ri.y = e.y),
        (ri.z = e.z),
        (es.x = t.x),
        (es.y = t.y),
        (es.z = t.z),
        this.navMesh.addBoxObstacle(ri, es, i)
      );
    }
    removeObstacle(e) {
      this.navMesh.removeObstacle(e);
    }
    isSupported() {
      return this.navmeshWasm !== void 0;
    }
  },
  W$ = class {
    constructor(e, t, i) {
      (this.navmeshWasmWrapper = e),
        (this.transforms = []),
        (this.agents = new Array()),
        (this.reachRadii = new Array()),
        (this._agentDestinationArmed = new Array()),
        (this._agentDestination = new Array()),
        (this.crowd = new this.navmeshWasmWrapper.navmeshWasm.Crowd(
          t,
          i,
          this.navmeshWasmWrapper.navMesh.getNavMesh()
        ));
    }
    onReachTarget(e, t) {}
    addAgent(e, t, i) {
      let r = new this.navmeshWasmWrapper.navmeshWasm.dtCrowdAgentParams();
      (r.radius = t.radius),
        (r.height = t.height),
        (r.maxAcceleration = t.maxAcceleration),
        (r.maxSpeed = t.maxSpeed),
        (r.collisionQueryRange = t.collisionQueryRange),
        (r.pathOptimizationRange = t.pathOptimizationRange),
        (r.separationWeight = t.separationWeight),
        (r.updateFlags = 7),
        (r.obstacleAvoidanceType = 0),
        (r.queryFilterType = 0),
        (r.userData = 0);
      let s = this.crowd.addAgent(
        new this.navmeshWasmWrapper.navmeshWasm.Vec3(e.x, e.y, e.z),
        r
      );
      return (
        this.transforms.push(i),
        this.agents.push(s),
        this.reachRadii.push(t.reachRadius ? t.reachRadius : t.radius),
        this._agentDestinationArmed.push(!1),
        this._agentDestination.push(new I(0, 0, 0)),
        s
      );
    }
    getAgentPosition(e) {
      return this.crowd.getAgentPosition(e);
    }
    getAgentPositionToRef(e, t) {
      let i = this.crowd.getAgentPosition(e);
      t.set(i.x, i.y, i.z);
    }
    getAgentVelocity(e) {
      return this.crowd.getAgentVelocity(e);
    }
    getAgentVelocityToRef(e, t) {
      let i = this.crowd.getAgentVelocity(e);
      t.set(i.x, i.y, i.z);
    }
    getAgentNextTargetPath(e) {
      return this.crowd.getAgentNextTargetPath(e);
    }
    getAgentNextTargetPathToRef(e, t) {
      let i = this.crowd.getAgentNextTargetPath(e);
      t.set(i.x, i.y, i.z);
    }
    getAgentState(e) {
      return this.crowd.getAgentState(e);
    }
    overOffmeshConnection(e) {
      return this.crowd.overOffmeshConnection(e);
    }
    agentGoto(e, t) {
      this.crowd.agentGoto(
        e,
        new this.navmeshWasmWrapper.navmeshWasm.Vec3(t.x, t.y, t.z)
      );
      let i = this.agents.indexOf(e);
      i > -1 &&
        ((this._agentDestinationArmed[i] = !0),
        this._agentDestination[i].set(t.x, t.y, t.z));
    }
    agentTeleport(e, t) {
      this.crowd.agentTeleport(
        e,
        new this.navmeshWasmWrapper.navmeshWasm.Vec3(t.x, t.y, t.z)
      );
    }
    updateAgentParameters(e, t) {
      let i = this.crowd.getAgentParameters(e);
      t.radius !== void 0 && (i.radius = t.radius),
        t.height !== void 0 && (i.height = t.height),
        t.maxAcceleration !== void 0 && (i.maxAcceleration = t.maxAcceleration),
        t.maxSpeed !== void 0 && (i.maxSpeed = t.maxSpeed),
        t.collisionQueryRange !== void 0 &&
          (i.collisionQueryRange = t.collisionQueryRange),
        t.pathOptimizationRange !== void 0 &&
          (i.pathOptimizationRange = t.pathOptimizationRange),
        t.separationWeight !== void 0 &&
          (i.separationWeight = t.separationWeight),
        this.crowd.setAgentParameters(e, i);
    }
    removeAgent(e) {
      this.crowd.removeAgent(e);
      let t = this.agents.indexOf(e);
      t > -1 &&
        (this.agents.splice(t, 1),
        this.transforms.splice(t, 1),
        this.reachRadii.splice(t, 1),
        this._agentDestinationArmed.splice(t, 1),
        this._agentDestination.splice(t, 1));
    }
    getAgents() {
      return this.agents;
    }
    update(e) {
      if ((this.navmeshWasmWrapper.navMesh.update(), e <= CE)) return;
      let t = 1 / 60,
        i = 10;
      if (t <= CE) this.crowd.update(e);
      else {
        let r = Math.floor(e / t);
        i && r > i && (r = i), r < 1 && (r = 1);
        let s = e / r;
        for (let a = 0; a < r; a++) this.crowd.update(s);
      }
      for (let r = 0; r < this.agents.length; r++) {
        let s = this.agents[r],
          a = this.getAgentPosition(s);
        if ((this.transforms[r].copy(a), this._agentDestinationArmed[r])) {
          let n = a.x - this._agentDestination[r].x,
            o = a.z - this._agentDestination[r].z,
            l = this.reachRadii[r],
            h = this._agentDestination[r].y - this.reachRadii[r],
            u = this._agentDestination[r].y + this.reachRadii[r],
            c = n * n + o * o;
          a.y > h &&
            a.y < u &&
            c < l * l &&
            (this.onReachTarget(s, this._agentDestination[r]),
            (this._agentDestinationArmed[r] = !1));
        }
      }
    }
    setDefaultQueryExtent(e) {
      let t = new this.navmeshWasmWrapper.navmeshWasm.Vec3(e.x, e.y, e.z);
      this.crowd.setDefaultQueryExtent(t);
    }
    getDefaultQueryExtent() {
      return this.crowd.getDefaultQueryExtent();
    }
    getDefaultQueryExtentToRef(e) {
      let t = this.crowd.getDefaultQueryExtent();
      e.set(t.x, t.y, t.z);
    }
    getCorners(e) {
      let t,
        i = this.crowd.getCorners(e),
        r = i.getPointCount(),
        s = [];
      for (t = 0; t < r; t++) {
        let a = i.getPoint(t);
        s.push(new I(a.x, a.y, a.z));
      }
      return s;
    }
    dispose() {
      this.crowd.destroy();
    }
  };
function q$(e) {
  let t = !1;
  return (
    e.scene.objects.forEach((i) => {
      i.data.type === "Page" &&
        !t &&
        i.data.publish.gameControlObject &&
        Wd.traverseModuleInstances(e, i.id, (r, s, a) => {
          for (let n of a)
            n.data.type === "GameControl" && n.data.navmesh.enabled && (t = !0);
        });
    }),
    t
  );
}
var Y$ = { type: "change" },
  TE = { type: "changeZoom" },
  X$ = { type: "changePan" },
  cc = { type: "start" },
  uc = { type: "end", changed: !0 },
  Q$ = { type: "end", changed: !1 },
  iy = new Rt(),
  PE = new re(),
  Z$ = 2 * Math.PI,
  K$ = 1e-8,
  J$ = 0.01,
  ry = new I(),
  em = new re(),
  sy = new I(),
  tm = new Rt(),
  DE = new je(),
  $$ = { type: "requestRender" },
  OD = class extends ls {
    constructor(e, t, i = { isPlayMode: !1, isExport: !1 }) {
      super(),
        (this.object = e),
        (this.domElement = t),
        (this.options = i),
        (this.enabled = !0),
        (this.useKeyEvents = !0),
        (this.enableDamping = !1),
        (this.enableZoom = !0),
        (this.enableRotate = !0),
        (this.enablePan = !0),
        (this.autoRotate = !1),
        (this.rotationLimitsMode = 0),
        (this.panLimitsMode = 0),
        (this.rotationSoftLimit = 2),
        (this.panSoftLimit = 2),
        (this.hoverRotatePanMode = 0),
        (this.zoomLimitsEnabled = !1),
        (this.mouseButtons = [0, 5]),
        (this.mouseButtonsPlay = [3, 4, 5]),
        (this.touches = [null, ha.DOLLY_ROTATE, ha.PAN]),
        (this.offset = new I()),
        (this.eye = new I()),
        (this.lastPosition = new I()),
        (this.lastQuaternion = new Rt()),
        (this.current = new re()),
        (this.overShoot = new re()),
        (this.overRatio = new re()),
        (this.spherical = new dS()),
        (this.sphericalDelta = new dS()),
        (this.panOffset = new I()),
        (this.panLeftV = new I()),
        (this.panUpV = new I()),
        (this.panV = new I()),
        (this.rotateStart = new re()),
        (this.rotateEnd = new re()),
        (this.rotateDelta = new re()),
        (this.panStart = new re()),
        (this.panEnd = new re()),
        (this.panDelta = new re()),
        (this.dollyStart = new re()),
        (this.dollyEnd = new re()),
        (this.dollyDelta = new re()),
        (this.rotationRangeFactor = new re()),
        (this.panRangeFactor = new re()),
        (this.state = -1),
        (this.zoomChanged = !1),
        (this.isPointerDown = !1),
        (this.isThetaFlipped = !1),
        (this.prevScale = 0),
        (this.scale = 1),
        (this.gesture = !1),
        (this.timer = -1),
        (this.timerHover = -1),
        (this.minDistance = 0),
        (this.maxDistance = 1 / 0),
        (this.minZoom = 0),
        (this.maxZoom = 1 / 0),
        (this.minPhi = 0),
        (this.maxPhi = Math.PI),
        (this.minTheta = -1 / 0),
        (this.maxTheta = 1 / 0),
        (this.minH = 0),
        (this.maxH = Math.PI),
        (this.minV = -1 / 0),
        (this.maxV = 1 / 0),
        (this.autoRotateClockwise = !0),
        (this.isPanOverShoot = !1),
        (this.isRotateOverShoot = !1),
        (this.resetHoverEffectOnPointerLeave = !1),
        (this.hasChange = !1),
        (this.useWindowEvents = !1),
        (this.isTouchZoom = !0),
        (this.autoRotateSpeed = 2),
        (this.dampingFactor = 0.125),
        (this.zoomSpeed = 2),
        (this.rotateSpeed = 1),
        (this.panSpeed = 1),
        (this.hoverRotatePanStrength = 0.1),
        (this.hoverRotateDamping = this.dampingFactor),
        (this.thetaIsFree = !1),
        (this.phiIsFree = !1),
        (this.needsUpdate = !0),
        (this.onCameraChange = (r) => {
          this.object.removeEventListener("beginState", this.onBeginState),
            this.object.removeEventListener(
              "completeState",
              this.onCompleteState
            ),
            this.object.removeEventListener(
              "cameraChange",
              this.onCameraChange
            ),
            (this.object = r.camera),
            this.object.addEventListener("beginState", this.onBeginState),
            this.object.addEventListener("completeState", this.onCompleteState),
            this.object.addEventListener("cameraChange", this.onCameraChange);
        }),
        (this.update = () => {
          this.object.updateWorldMatrix(!0, !1),
            this.object.matrixWorld.decompose(sy, tm, ry),
            this.offset.copy(sy).sub(this.target),
            this.spherical.setFromVector3(this.offset),
            this.object.isUpVectorFlipped &&
              ((this.spherical.phi *= -1), (this.spherical.theta -= Math.PI)),
            this.autoRotate &&
              this.state === -1 &&
              this.rotateLeft(
                (this.autoRotateClockwise === !0 ? 1 : -1) *
                  this.getAutoRotationAngle()
              ),
            this.rotationLimitsMode !== 0 &&
              this.applyLimits(
                this.sphericalDelta,
                this.rotationLimitsMode,
                this.rotationSoftLimit,
                this.maxTheta,
                this.minTheta,
                this.maxPhi,
                this.minPhi,
                this.rotationRangeFactor
              ),
            this.rotationLimitsMode !== 2 &&
              (this.spherical.phi += this.sphericalDelta.phi),
            (this.rotationLimitsMode !== 1 || this.autoRotate === !0) &&
              (this.spherical.theta += this.sphericalDelta.theta),
            (this.spherical.radius *= this.scale),
            this.zoomLimitsEnabled &&
              (this.spherical.radius = Math.max(
                this.minDistance,
                Math.min(this.maxDistance, this.spherical.radius)
              )),
            this.panLimitsMode !== 0 &&
              (this.target.applyQuaternion(iy.copy(tm).invert()),
              this.panOffset.applyQuaternion(iy),
              this.applyLimits(
                this.panOffset,
                this.panLimitsMode,
                this.panSoftLimit,
                this.maxH,
                this.minH,
                this.maxV,
                this.minV,
                this.panRangeFactor
              ),
              this.target.applyQuaternion(tm),
              this.panOffset.applyQuaternion(tm)),
            this.panLimitsMode === 2 && (this.panOffset.y = 0),
            this.panLimitsMode === 1 && (this.panOffset.x = 0),
            this.state === -1 && !this.gesture
              ? (this.panOffset.multiplyScalar(1 - this.dampingFactor),
                this.target.add(this.panOffset))
              : (this.target.add(this.panOffset), this.panOffset.set(0, 0, 0)),
            this.offset.setFromSpherical(this.spherical),
            sy.copy(this.target).add(this.offset),
            this.object.position.copy(this.target).add(this.offset),
            this.object.parent &&
              (DE.copy(this.object.parent.matrixWorld).invert(),
              this.object.position.applyMatrix4(DE));
          let r = this.spherical.phi % Z$;
          if (
            (this.eye.copy(this.offset).normalize(),
            this.object.up
              .copy(_i.DEFAULT_UP)
              .applyAxisAngle(this.eye, this.object.angleOffsetFromUp),
            (r > 0 && r > Math.PI) || (r < 0 && r > -Math.PI)
              ? (this.object.up.negate(),
                this.object.lookAt(this.target),
                (this.object.isUpVectorFlipped = !0))
              : (this.object.lookAt(this.target),
                (this.object.isUpVectorFlipped = !1)),
            this.state === -1 || this.enableDamping === !0)
          ) {
            let s =
              this.hoverRotatePanMode === 1
                ? this.hoverRotateDamping
                : this.dampingFactor;
            (this.sphericalDelta.theta *= 1 - s),
              (this.sphericalDelta.phi *= 1 - s);
          } else this.sphericalDelta.set(0, 0, 0);
          return (
            (this.scale = 1),
            this.zoomChanged ||
            this.lastPosition.distanceToSquared(this.object.position) > J$ ||
            8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > K$
              ? (this.dispatchEvent(Y$),
                this.object.dispatchEvent($$),
                this.lastPosition.copy(this.object.position),
                this.lastQuaternion.copy(this.object.quaternion),
                (this.zoomChanged = !1),
                !0)
              : ((this.isPanOverShoot = !1),
                (this.isRotateOverShoot = !1),
                (this.object.wasMovedBySwitchCameraAction = !1),
                this.sphericalDelta.set(0, 0, 0),
                this.panOffset.set(0, 0, 0),
                !1)
          );
        }),
        (this.onPointerDown = (r) => {
          this.enabled !== !1 &&
            (r.pointerType === "touch" || (r.pointerType === "pen" && Js)
              ? this.onPointerDownTouch(r)
              : this.onPointerDownMouse(r),
            this.state !== -1 &&
              ((this.isPointerDown = !0),
              this.dispatchEvent(cc),
              this.domElement.addEventListener(
                "pointermove",
                this.onPointerMove
              ),
              this.domElement.addEventListener("pointerup", this.onPointerUp),
              r.stopPropagation(),
              r.pointerType === "touch" ||
                (r.pointerType === "pen" && Js) ||
                this.domElement.setPointerCapture(r.pointerId)));
        }),
        (this.onPointerLeave = (r) => {
          this.resetHoverEffectOnPointerLeave && !this.useWindowEvents
            ? (this.hoverRotatePanMode === 1
                ? ((this.sphericalDelta.theta = -this.spherical.theta),
                  (this.sphericalDelta.phi = -this.spherical.phi),
                  ry.subVectors(this.position0, this.target0),
                  this.spherical.setFromVector3(ry),
                  (this.sphericalDelta.theta += this.spherical.theta),
                  (this.sphericalDelta.phi += this.spherical.phi),
                  (this.sphericalDelta.theta /= 8),
                  (this.sphericalDelta.phi /= 8))
                : this.hoverRotatePanMode === 2 &&
                  this.panOffset
                    .subVectors(this.target0, this.target)
                    .divideScalar(8),
              this.update())
            : (this.pointerLeaveEvent = r);
        }),
        (this.onPointerEnter = (r) => {
          this.resetHoverEffectOnPointerLeave ||
          this.pointerLeaveEvent === void 0
            ? em.set(
                r.clientX - this.domElement.clientWidth / 2,
                r.clientY - this.domElement.clientHeight / 2
              )
            : em.set(
                r.clientX - this.pointerLeaveEvent.clientX,
                r.clientY - this.pointerLeaveEvent.clientY
              ),
            this.hoverRotatePanMode === 1
              ? (this.rotateDelta
                  .copy(em)
                  .multiplyScalar(
                    this.rotateSpeed * this.hoverRotatePanStrength
                  )
                  .rotateAround(PE, -this.object.angleOffsetFromUp),
                this.rotateLeft(
                  (2 * Math.PI * this.rotateDelta.x) /
                    this.domElement.clientHeight
                ),
                this.rotateUp(
                  (2 * Math.PI * this.rotateDelta.y) /
                    this.domElement.clientHeight
                ),
                this.rotateStart.set(r.clientX, r.clientY))
              : this.hoverRotatePanMode === 2 &&
                (this.panDelta
                  .copy(em)
                  .multiplyScalar(this.panSpeed * this.hoverRotatePanStrength),
                this.pan(this.panDelta.x, this.panDelta.y),
                this.panStart.set(r.clientX, r.clientY)),
            this.update();
        }),
        (this.onPointerMove = (r) => {
          this.enabled !== !1 &&
            (this.checkRaycastLock() ||
              (r.pointerType === "touch" || (r.pointerType === "pen" && Js)
                ? this.onPointerMoveTouch(r)
                : this.onPointerMoveMouse(r),
              r.stopPropagation()));
        }),
        (this.onPointerUp = (r) => {
          (this.isPointerDown = !1),
            Pt.length === 0 &&
              (this.domElement.removeEventListener(
                "pointermove",
                this.onPointerMove
              ),
              this.domElement.removeEventListener(
                "pointerup",
                this.onPointerUp
              )),
            Pt.length > 1 && r.preventDefault(),
            this.hasChange ? this.dispatchEvent(uc) : this.dispatchEvent(Q$),
            (this.state = -1),
            r &&
              (r.stopPropagation(),
              r.pointerType === "touch" ||
                (r.pointerType === "pen" && Js) ||
                this.domElement.releasePointerCapture(r.pointerId));
        }),
        (this.onPointerDownMouse = (r) => {
          let s;
          switch (
            (this.useKeyEvents
              ? (s = this.mouseButtons[r.button])
              : (s = this.mouseButtonsPlay[r.button]),
            s)
          ) {
            case 0:
              if (r.altKey === !0 && !r.shiftKey && !df(r)) {
                if (this.enableRotate === !1) return;
                this.handleMouseDownRotate(r), (this.state = 0);
              } else if (this.key === " ") {
                if (this.enablePan === !1) return;
                this.handleMouseDownPan(r), (this.state = 2);
              }
              break;
            case 4:
              if (this.enablePan === !1) return;
              this.handleMouseDownPan(r), (this.state = 2);
              break;
            case 3:
              if (df(r) || r.shiftKey) {
                if (this.enablePan === !1) return;
                this.handleMouseDownPan(r), (this.state = 2);
              } else {
                if (this.enableRotate === !1) return;
                this.handleMouseDownRotate(r), (this.state = 0);
              }
              break;
            case 5:
              if (df(r) || r.shiftKey) {
                if (this.enableRotate === !1) return;
                this.handleMouseDownRotate(r), (this.state = 0);
              } else {
                if (this.enablePan === !1) return;
                this.handleMouseDownPan(r), (this.state = 2);
              }
              break;
            default:
              this.state = -1;
          }
        }),
        (this.onPointerMoveMouse = (r) => {
          switch (this.state) {
            case 0:
              if (this.enableRotate === !1) return;
              this.handleMouseMoveRotate(r);
              break;
            case 1:
              if (this.enableZoom === !1) return;
              this.handleMouseMoveDolly(r);
              break;
            case 2:
              if (this.enablePan === !1) return;
              this.handleMouseMovePan(r);
              break;
          }
          this.object.wasMovedByUser = !0;
        }),
        (this.onPointerDownTouch = (r) => {
          switch (
            (Pt.length > 1 && r.preventDefault(), this.touches[Pt.length - 1])
          ) {
            case ha.ROTATE:
              if (this.enableRotate === !1) {
                this.state = -1;
                return;
              }
              this.handleTouchStartRotate(), (this.state = 3);
              break;
            case ha.PAN:
              if (this.enablePan === !1) {
                this.state = -1;
                return;
              }
              this.handleTouchStartPan(), (this.state = 4);
              break;
            case ha.DOLLY_PAN:
              if (this.enableZoom === !1 && this.enablePan === !1) return;
              this.handleTouchStartDollyPan(), (this.state = 5);
              break;
            case ha.DOLLY_ROTATE:
              if (this.enableZoom === !1 && this.enableRotate === !1) return;
              this.handleTouchStartDollyRotate(), (this.state = 6);
              break;
            default:
              this.state = -1;
          }
        }),
        (this.onPointerMoveTouch = (r) => {
          switch ((Pt.length > 1 && r.preventDefault(), this.state)) {
            case 3:
              if (this.enableRotate === !1) return;
              this.handleTouchMoveRotate(r), this.update();
              break;
            case 4:
              if (this.enablePan === !1) return;
              this.handleTouchMovePan(r), this.update();
              break;
            case 5:
              if (this.enableZoom === !1 && this.enablePan === !1) return;
              this.handleTouchMoveDollyPan(r), this.update();
              break;
            case 6:
              if (this.enableZoom === !1 && this.enableRotate === !1) return;
              this.handleTouchMoveDollyRotate(r), this.update();
              break;
            default:
              this.state = -1;
          }
          this.object.wasMovedByUser = !0;
        }),
        (this.dispatchEndDebounced = Yx(() => this.dispatchEvent(uc), 33)),
        (this.onMouseWheel = (r) => {
          this.enabled === !1 ||
            (this.enableZoom === !1 && this.enablePan === !1) ||
            this.checkRaycastLock() ||
            (!this.options.isExport &&
              this.domElement.clientHeight === document.body.clientHeight &&
              this.domElement.clientWidth === document.body.clientWidth &&
              r.preventDefault(),
            this.dispatchEvent(cc),
            this.handleMouseWheel(r),
            this.dispatchEndDebounced(),
            (this.object.wasMovedByUser = !0));
        }),
        (this.onGesture = (r) => {
          if (
            (r.preventDefault(),
            this.enabled !== !1 && !this.checkRaycastLock() && !Xx)
          )
            if (r.type === "gesturechange") {
              if (this.enableZoom === !1 || this.isTouchZoom === !1) return;
              this.dispatchEvent(cc),
                r.scale > this.prevScale
                  ? this.dollyIn(this.getZoomScale())
                  : r.scale < this.prevScale &&
                    this.dollyOut(this.getZoomScale()),
                (this.prevScale = r.scale),
                this.update(),
                (this.object.wasMovedByUser = !0);
            } else this.dispatchEvent(uc);
        }),
        (this.onContextMenu = (r) => {
          r.preventDefault();
        }),
        (this.onTouchEnd = (r) => {
          r.preventDefault();
        }),
        (this.onKeyDown = (r) => {
          this.enabled !== !1 &&
            ((this.key = r.key), r.key === " " && this.dispatchEvent(cc));
        }),
        (this.onKeyUp = (r) => {
          this.enabled !== !1 &&
            ((this.key = void 0),
            this.state !== -1 && r.key === "Alt" && this.onPointerUp(Pt[0]),
            r.key === " " && this.dispatchEvent(uc));
        }),
        (this.onPointerHover = (r) => {
          r.pointerType !== "mouse" ||
            this.enabled === !1 ||
            this.state !== -1 ||
            (this.hoverRotatePanMode === 2 && this.isPanOverShoot) ||
            (this.hoverRotatePanMode === 1 && this.isRotateOverShoot) ||
            ((this.isPointerDown = !0),
            this.hoverRotatePanMode === 2
              ? this.handleMouseMovePan(r, this.hoverRotatePanStrength)
              : this.hoverRotatePanMode === 1 &&
                this.handleMouseMoveRotate(r, this.hoverRotatePanStrength));
        }),
        (this.onBeginState = () => {
          (this.enabled = !1), (this.needsUpdate = !1);
        }),
        (this.onCompleteState = (r) => {
          (r.isfromEntity && this.options.isPlayMode) ||
            ((this.enabled = !0),
            (this.needsUpdate = !0),
            this.object.updateUp(),
            this.object.getTarget(this.target));
        }),
        (this.target = this.object.getTarget()),
        (this.target0 = this.target.clone()),
        (this.position0 = this.object.position.clone()),
        (this.zoom0 = this.object.zoom),
        (this.quat0 = this.object.quaternion.clone()),
        (this.isUpVectorFlipped0 = this.object.isUpVectorFlipped),
        this.offset.copy(this.object.position).sub(this.target),
        this.spherical.setFromVector3(this.offset),
        this.object.isUpVectorFlipped &&
          ((this.spherical.phi *= -1), (this.spherical.theta -= Math.PI)),
        this.addEventListenersToCamera();
    }
    dispatchEvent(e) {
      e.type === "start" ? (this.hasChange = !1) : (this.hasChange = !0),
        super.dispatchEvent(e);
    }
    addEventListenersToCamera() {
      this.object.addEventListener("beginState", this.onBeginState),
        this.object.addEventListener("completeState", this.onCompleteState),
        this.object.addEventListener("cameraChange", this.onCameraChange);
    }
    removeEventListenersFromCamera() {
      this.object.removeEventListener("beginState", this.onBeginState),
        this.object.removeEventListener("completeState", this.onCompleteState),
        this.object.removeEventListener("cameraChange", this.onCameraChange);
    }
    updateUseWindowEvents(e) {
      if (
        (window.removeEventListener("pointermove", this.onPointerHover),
        this.domElement.removeEventListener("pointermove", this.onPointerHover),
        (this.useWindowEvents = e),
        this.hoverRotatePanMode !== 0 &&
          (this.useWindowEvents
            ? window.addEventListener("pointermove", this.onPointerHover)
            : this.domElement.addEventListener(
                "pointermove",
                this.onPointerHover
              )),
        this.domElement.removeEventListener(
          "pointerleave",
          this.onPointerLeave
        ),
        this.domElement.removeEventListener(
          "pointerenter",
          this.onPointerEnter
        ),
        window.removeEventListener("pointerleave", this.onPointerLeave),
        window.removeEventListener("pointerenter", this.onPointerEnter),
        this.hoverRotatePanMode !== 0 && !this.useWindowEvents)
      ) {
        let t = this.useWindowEvents ? window : this.domElement;
        t.addEventListener("pointerleave", this.onPointerLeave),
          t.addEventListener("pointerenter", this.onPointerEnter);
      }
    }
    fromJSON(e, t) {
      this.setEnableDampingSpeed(e.enableDamping),
        (this.enablePan = e.enablePan),
        (this.enableZoom = e.enableZoom),
        (this.enableRotate = e.enableRotate),
        (this.rotationLimitsMode = e.rotationLimitsMode),
        (this.thetaIsFree =
          e.rotationHorizontalOffset.min === e.rotationHorizontalOffset.max &&
          e.rotationHorizontalOffset.min === Math.PI),
        (this.phiIsFree =
          e.rotationVerticalOffset.min === e.rotationVerticalOffset.max &&
          e.rotationVerticalOffset.min === Math.PI),
        (this.panLimitsMode = e.panLimitsMode),
        (this.panSoftLimit = e.panSoftLimit),
        (this.rotationSoftLimit = e.rotationSoftLimit),
        (this.hoverRotatePanMode = e.hoverRotatePanMode),
        (this.hoverRotateDamping = e.hoverRotateDamping ?? this.dampingFactor),
        (this.useWindowEvents = t === "window"),
        this.hoverRotatePanMode !== 0 &&
          (this.useWindowEvents
            ? window.addEventListener("pointermove", this.onPointerHover)
            : this.domElement.addEventListener(
                "pointermove",
                this.onPointerHover
              ));
      let i = e.hoverRotatePanStrength / 100;
      (this.hoverRotatePanStrength = i ** 2),
        (this.zoomLimitsEnabled = e.zoomLimitsEnabled),
        (this.minZoom = e.zoomLimits.min),
        (this.maxZoom = Math.max(e.zoomLimits.min, e.zoomLimits.max)),
        (this.minDistance = 1e3 / e.zoomLimits.max),
        (this.maxDistance = Math.max(this.minDistance, 1e3 / e.zoomLimits.min)),
        (this.autoRotate = e.autoRotate),
        (this.autoRotateSpeed = e.autoRotateSpeed),
        (this.autoRotateClockwise = e.autoRotateClockwise);
      let r = this.object
        .getTarget()
        .applyQuaternion(iy.copy(this.object.quaternion).invert());
      (this.minV = -e.panVerticalOffset.min + r.y),
        (this.maxV = e.panVerticalOffset.max + r.y),
        (this.minH = -e.panHorizontalOffset.min + r.x),
        (this.maxH = e.panHorizontalOffset.max + r.x),
        this.panRangeFactor
          .set(this.maxH - this.minH, this.maxV - this.minV)
          .divideScalar(2),
        this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4),
        (this.minPhi = gn(this.spherical.phi - e.rotationVerticalOffset.min)),
        (this.maxPhi = gn(this.spherical.phi + e.rotationVerticalOffset.max)),
        (this.minTheta = gn(
          gn(this.spherical.theta) - e.rotationHorizontalOffset.min
        )),
        (this.maxTheta = gn(
          gn(this.spherical.theta) + e.rotationHorizontalOffset.max
        )),
        (this.isThetaFlipped = this.minTheta > this.maxTheta),
        e.orbitTouches === 1 && (this.touches[0] = ha.ROTATE),
        e.panTouches === 1 && (this.touches[0] = ha.PAN),
        e.orbitTouches === 2 && (this.touches[1] = ha.DOLLY_ROTATE),
        e.panTouches === 2 && (this.touches[1] = ha.DOLLY_PAN),
        e.orbitTouches === 3 && (this.touches[2] = ha.ROTATE),
        e.panTouches === 3 && (this.touches[2] = ha.PAN),
        (this.isTouchZoom = e.isTouchZoom),
        (this.resetHoverEffectOnPointerLeave =
          e.resetHoverEffectOnPointerLeave ?? !1);
    }
    connect() {
      if (
        (this.domElement.addEventListener("contextmenu", this.onContextMenu),
        this.domElement.addEventListener("pointerdown", this.onPointerDown),
        this.domElement.addEventListener("wheel", this.onMouseWheel),
        window.addEventListener("keydown", this.onKeyDown, !1),
        window.addEventListener("keyup", this.onKeyUp, !1),
        this.domElement.addEventListener("gesturestart", this.onGesture),
        this.domElement.addEventListener("gesturechange", this.onGesture),
        this.domElement.addEventListener("gestureend", this.onGesture),
        this.domElement.addEventListener("touchend", this.onTouchEnd),
        this.hoverRotatePanMode !== 0 && !this.useWindowEvents)
      ) {
        let e = this.useWindowEvents ? window : this.domElement;
        e.addEventListener("pointerleave", this.onPointerLeave),
          e.addEventListener("pointerenter", this.onPointerEnter);
      }
      this.pointerLeaveEvent = void 0;
    }
    dispose() {
      this.removeEventListenersFromCamera(),
        this.domElement.removeEventListener("contextmenu", this.onContextMenu),
        this.domElement.removeEventListener("pointerdown", this.onPointerDown),
        this.domElement.removeEventListener("wheel", this.onMouseWheel),
        window.removeEventListener("keydown", this.onKeyDown, !1),
        window.removeEventListener("keyup", this.onKeyUp, !1),
        this.domElement.removeEventListener("pointermove", this.onPointerHover),
        window.removeEventListener("pointermove", this.onPointerHover),
        this.domElement.removeEventListener("gesturestart", this.onGesture),
        this.domElement.removeEventListener("gesturechange", this.onGesture),
        this.domElement.removeEventListener("gestureend", this.onGesture),
        this.domElement.removeEventListener("touchend", this.onTouchEnd),
        this.domElement.removeEventListener(
          "pointerleave",
          this.onPointerLeave
        ),
        this.domElement.removeEventListener(
          "pointerenter",
          this.onPointerEnter
        ),
        window.removeEventListener("pointerleave", this.onPointerLeave),
        window.removeEventListener("pointerenter", this.onPointerEnter),
        this.domElement.removeEventListener("pointermove", this.onPointerMove),
        this.domElement.removeEventListener("pointerup", this.onPointerUp);
    }
    applyLimits(e, t, i, r, s, a, n, o) {
      this.overShoot.set(0, 0);
      let l, h, u;
      e instanceof I
        ? ((l = e.x),
          (h = e.y),
          this.current.set(this.target.x, this.target.y),
          (u = !0))
        : ((l = e.theta),
          (h = e.phi),
          this.current.set(gn(this.spherical.theta), gn(this.spherical.phi)),
          (u = !1)),
        i === 0 && ((this.current.x += l), (this.current.y += h)),
        (t === 3 || t === 2) &&
          (!u && this.isThetaFlipped
            ? this.current.x > r && this.current.x < 0
              ? (this.overShoot.x = r - this.current.x)
              : this.current.x < s &&
                this.current.x > 0 &&
                (this.overShoot.x = s - this.current.x)
            : this.current.x > r
            ? (this.overShoot.x = r - this.current.x)
            : this.current.x < s && (this.overShoot.x = s - this.current.x)),
        (t === 3 || t === 1) &&
          (this.current.y > a
            ? (this.overShoot.y = a - this.current.y)
            : this.current.y < n && (this.overShoot.y = n - this.current.y)),
        u ||
          ((this.overShoot.x = gn(this.overShoot.x)),
          (this.overShoot.y = gn(this.overShoot.y))),
        i !== 0
          ? (this.overRatio.copy(this.overShoot).divide(o),
            (this.overRatio.x = Math.min(Math.abs(this.overRatio.x), 1)),
            (this.overRatio.y = Math.min(Math.abs(this.overRatio.y), 1)),
            i === 1 &&
              ((this.overRatio.x = OE(Math.abs(this.overRatio.x))),
              (this.overRatio.y = OE(Math.abs(this.overRatio.y)))),
            this.isPointerDown || i === 1
              ? i === 2 &&
                ((this.overRatio.x > 0.9 && !this.thetaIsFree) ||
                  (this.overRatio.y > 0.9 && !this.phiIsFree))
                ? (this.isPointerDown = !1)
                : (l * this.overShoot.x < 0 &&
                    !this.thetaIsFree &&
                    (l *= 1 - this.overRatio.x),
                  h * this.overShoot.y < 0 &&
                    !this.phiIsFree &&
                    (h *= 1 - this.overRatio.y))
              : i === 2 &&
                ((!u &&
                  ((this.overRatio.x > 0.002 && !this.thetaIsFree) ||
                    (this.overRatio.y > 0.002 && !this.phiIsFree))) ||
                (u &&
                  (Math.abs(this.overShoot.x) > 2 ||
                    Math.abs(this.overShoot.y) > 2))
                  ? (this.thetaIsFree || (l = this.overShoot.x * 0.05),
                    this.phiIsFree || (h = this.overShoot.y * 0.05),
                    u
                      ? (this.isPanOverShoot = !0)
                      : (this.isRotateOverShoot = !0))
                  : u
                  ? (this.isPanOverShoot = !1)
                  : (this.isRotateOverShoot = !1)))
          : ((l += this.overShoot.x), (h += this.overShoot.y)),
        e instanceof I
          ? ((e.x = l), (e.y = h))
          : (this.thetaIsFree || (e.theta = l), this.phiIsFree || (e.phi = h));
    }
    setEnableDampingSpeed(e) {
      (this.enableDamping = e), (this.rotateSpeed = e === !0 ? 0.2 : 1);
    }
    stopDamping() {
      (this.sphericalDelta.theta = 0), (this.sphericalDelta.phi = 0);
    }
    getAutoRotationAngle() {
      return ((2 * Math.PI) / 60 / 60) * this.autoRotateSpeed;
    }
    getZoomScale() {
      return Math.pow(0.95, this.zoomSpeed);
    }
    rotateLeft(e) {
      this.sphericalDelta.theta -= e;
    }
    rotateUp(e) {
      this.sphericalDelta.phi -= e;
    }
    panLeft(e, t) {
      this.panLeftV.setFromMatrixColumn(t, 0),
        this.panLeftV.multiplyScalar(-e),
        this.panOffset.add(this.panLeftV);
    }
    panUp(e, t) {
      this.panUpV.setFromMatrixColumn(t, 1),
        this.panUpV.multiplyScalar(e),
        this.panOffset.add(this.panUpV);
    }
    pan(e, t) {
      let i = this.domElement;
      if (i && this.object.isPerspectiveCamera) {
        let r = this.object.position;
        this.panV.copy(r).sub(this.target);
        let s = this.panV.length();
        (s *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
          this.panLeft((2 * e * s) / i.clientHeight, this.object.matrixWorld),
          this.panUp((2 * t * s) / i.clientHeight, this.object.matrixWorld);
      } else
        i &&
          this.object.isOrthographicCamera &&
          (this.panLeft(
            (e * (this.object.right - this.object.left)) /
              this.object.zoom /
              i.clientWidth,
            this.object.matrixWorld
          ),
          this.panUp(
            (t * (this.object.top - this.object.bottom)) /
              this.object.zoom /
              i.clientHeight,
            this.object.matrixWorld
          ));
      this.dispatchEvent(X$);
    }
    dollyOut(e) {
      this.object.isPerspectiveCamera
        ? (this.scale /= e)
        : this.object.isOrthographicCamera &&
          ((this.object.zoom *= e),
          this.zoomLimitsEnabled &&
            (this.object.zoom = Math.max(
              this.minZoom,
              Math.min(this.maxZoom, this.object.zoom)
            )),
          this.object.updateProjectionMatrix(),
          (this.zoomChanged = !0)),
        this.dispatchEvent(TE);
    }
    dollyIn(e) {
      this.object.isPerspectiveCamera
        ? (this.scale *= e)
        : this.object.isOrthographicCamera &&
          ((this.object.zoom /= e),
          this.zoomLimitsEnabled &&
            (this.object.zoom = Math.max(
              this.minZoom,
              Math.min(this.maxZoom, this.object.zoom)
            )),
          this.object.updateProjectionMatrix(),
          (this.zoomChanged = !0)),
        this.dispatchEvent(TE);
    }
    zoomOut(e = this.getZoomScale()) {
      this.dispatchEvent(cc), this.dollyOut(e), this.dispatchEvent(uc);
    }
    zoomIn(e = this.getZoomScale()) {
      this.dispatchEvent(cc), this.dollyIn(e), this.dispatchEvent(uc);
    }
    handleMouseDownRotate(e) {
      this.rotateStart.set(e.clientX, e.clientY);
    }
    handleMouseDownDolly(e) {
      this.dollyStart.set(e.clientX, e.clientY);
    }
    handleMouseDownPan(e) {
      this.panStart.set(e.clientX, e.clientY);
    }
    handleMouseMoveRotate(e, t = 1) {
      e.movementX !== void 0
        ? this.rotateDelta.set(e.movementX, e.movementY)
        : (this.rotateEnd.set(e.clientX, e.clientY),
          this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart),
          this.rotateStart.copy(this.rotateEnd)),
        this.rotateDelta
          .multiplyScalar(this.rotateSpeed * t)
          .rotateAround(PE, -this.object.angleOffsetFromUp);
      let i = this.domElement,
        r = this.useWindowEvents ? window.innerHeight : i.clientHeight,
        s = (2 * Math.PI * this.rotateDelta.x) / r,
        a = (2 * Math.PI * this.rotateDelta.y) / r;
      this.rotateLeft(s), this.rotateUp(a), this.update();
    }
    handleMouseMoveDolly(e) {
      this.dollyEnd.set(e.clientX, e.clientY),
        this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart),
        this.dollyDelta.y > 0
          ? this.dollyOut(this.getZoomScale())
          : this.dollyDelta.y < 0 && this.dollyIn(this.getZoomScale()),
        this.dollyStart.copy(this.dollyEnd),
        this.update();
    }
    handleMouseMovePan(e, t = 1) {
      e.movementX !== void 0
        ? this.panDelta.set(e.movementX, e.movementY)
        : (this.panEnd.set(e.clientX, e.clientY),
          this.panDelta.subVectors(this.panEnd, this.panStart),
          this.panStart.copy(this.panEnd)),
        this.panDelta.multiplyScalar(this.panSpeed * t),
        this.pan(this.panDelta.x, this.panDelta.y),
        this.update();
    }
    handleMouseWheel(e) {
      if (NH === !1 && df(e) === !1 && UH(e) === !0) {
        if (this.enablePan === !1) return;
        this.gesture
          ? (this.panDelta
              .set(-e.deltaX, -e.deltaY)
              .multiplyScalar(this.panSpeed),
            (this.panDelta.x =
              Math.min(Math.abs(this.panDelta.x), 100) *
              (this.panDelta.x < 0 ? -1 : 1)),
            (this.panDelta.y =
              Math.min(Math.abs(this.panDelta.y), 100) *
              (this.panDelta.y < 0 ? -1 : 1)),
            e.altKey
              ? this.pan(0, this.panDelta.y)
              : e.shiftKey
              ? this.pan(this.panDelta.x, 0)
              : this.pan(this.panDelta.x, this.panDelta.y),
            this.update())
          : ((this.gesture = !0), (this.isPointerDown = !0)),
          window.clearTimeout(this.timer),
          (this.timer = window.setTimeout(() => {
            (this.gesture = !1), (this.isPointerDown = !1);
          }, 30));
      } else {
        if (this.enableZoom === !1) return;
        e.deltaY === 0
          ? e.deltaX < 0
            ? this.dollyIn(this.getZoomScale())
            : e.deltaX > 0 && this.dollyOut(this.getZoomScale())
          : e.deltaY < 0
          ? this.dollyIn(this.getZoomScale())
          : e.deltaY > 0 && this.dollyOut(this.getZoomScale()),
          this.update(),
          (this.gesture = !1),
          (this.isPointerDown = !1);
      }
    }
    handleTouchStartRotate() {
      if (Pt.length === 2) {
        let e = 0.5 * (Pt[0].pageX + Pt[1].pageX),
          t = 0.5 * (Pt[0].pageY + Pt[1].pageY);
        this.rotateStart.set(e, t);
      } else this.rotateStart.set(Pt[0].pageX, Pt[0].pageY);
    }
    handleTouchStartPan() {
      if (Pt.length === 2) {
        let e = 0.5 * (Pt[0].pageX + Pt[1].pageX),
          t = 0.5 * (Pt[0].pageY + Pt[1].pageY);
        this.panStart.set(e, t);
      } else this.panStart.set(Pt[0].pageX, Pt[0].pageY);
    }
    handleTouchStartDolly() {
      let e = Pt[0].pageX - Pt[1].pageX,
        t = Pt[0].pageY - Pt[1].pageY,
        i = Math.sqrt(e * e + t * t);
      this.dollyStart.set(0, i);
    }
    handleTouchStartDollyPan() {
      this.enableZoom &&
        this.isTouchZoom === !0 &&
        this.handleTouchStartDolly(),
        this.enablePan && this.handleTouchStartPan();
    }
    handleTouchStartDollyRotate() {
      this.enableZoom &&
        this.isTouchZoom === !0 &&
        this.handleTouchStartDolly(),
        this.enableRotate && this.handleTouchStartRotate();
    }
    handleTouchMoveRotate(e) {
      if (Pt.length === 2) {
        let i = Yv(e),
          r = 0.5 * (e.pageX + i.x),
          s = 0.5 * (e.pageY + i.y);
        this.rotateEnd.set(r, s);
      } else {
        if (e.pointerId !== Pt[0].pointerId) return;
        this.rotateEnd.set(e.pageX, e.pageY);
      }
      this.rotateDelta
        .subVectors(this.rotateEnd, this.rotateStart)
        .multiplyScalar(this.rotateSpeed);
      let t = this.domElement;
      t &&
        (this.rotateLeft((2 * Math.PI * this.rotateDelta.x) / t.clientHeight),
        this.rotateUp((2 * Math.PI * this.rotateDelta.y) / t.clientHeight)),
        this.rotateStart.copy(this.rotateEnd);
    }
    handleTouchMovePan(e) {
      if (Pt.length === 2) {
        let t = Yv(e),
          i = 0.5 * (e.pageX + t.x),
          r = 0.5 * (e.pageY + t.y);
        this.panEnd.set(i, r);
      } else {
        if (e.pointerId !== Pt[0].pointerId) return;
        this.panEnd.set(e.pageX, e.pageY);
      }
      this.panDelta
        .subVectors(this.panEnd, this.panStart)
        .multiplyScalar(this.panSpeed),
        this.pan(this.panDelta.x, this.panDelta.y),
        this.panStart.copy(this.panEnd);
    }
    handleTouchMoveDolly(e) {
      let t = Yv(e),
        i = e.pageX - t.x,
        r = e.pageY - t.y,
        s = Math.sqrt(i * i + r * r);
      this.dollyEnd.set(0, s),
        this.dollyDelta.set(
          0,
          Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed)
        ),
        this.dollyOut(this.dollyDelta.y),
        this.dollyStart.copy(this.dollyEnd);
    }
    handleTouchMoveDollyPan(e) {
      this.enableZoom &&
        this.isTouchZoom === !0 &&
        this.handleTouchMoveDolly(e),
        this.enablePan && this.handleTouchMovePan(e);
    }
    handleTouchMoveDollyRotate(e) {
      this.enableZoom &&
        this.isTouchZoom === !0 &&
        this.handleTouchMoveDolly(e),
        this.enableRotate && this.handleTouchMoveRotate(e);
    }
    checkRaycastLock() {
      if (this.object.data.raycastLock) {
        if (this.options.isPlayMode) return !1;
        {
          let e = this.options?.showCameraLock;
          return e && e(), !0;
        }
      } else return !1;
    }
  };
function gn(e) {
  let t = Math.PI * 2;
  for (; e <= -Math.PI; ) e += t;
  for (; e > Math.PI; ) e -= t;
  return e;
}
function OE(e) {
  return 1 - Math.pow(1 - e, 4);
}
var IE = class {
    constructor(e, t, i, r, s, a) {
      (this.id = e),
        (this.data = t),
        (this.object = i),
        (this.page = r),
        (this.currentIntersectedObjects = []),
        (this.disabled = !1),
        (this.alreadyPlayedNonTogglingActions = new Set()),
        (this.actions = Rs(t, t.actions, r, s, a, i)),
        (this.target = t.target),
        (this.useToggle = t.runMode === "Toggle"),
        (this.triggeringObjects = t.triggeringObjects.map((n) =>
          r.scene.find(n)
        ));
    }
    isValidTriggeringObject(e) {
      return this.target === "all"
        ? !0
        : this.triggeringObjects.some(
            (t) => t === e || t.isAncestorOf(e.uuid) || e.isAncestorOf(t.uuid)
          );
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatch() {
      this.disabled ||
        this.object.destroyedInAction ||
        (this.actions.Transition.forEach((e) => {
          e.object.currentTransitionEvent !== this
            ? ((e.object.currentTransitionEvent = this), e.init())
            : this.data.runMode === "Once" &&
              this.alreadyPlayedNonTogglingActions.add(e);
        }),
        this.object.dispatchEvent({ type: "beginEvent", eventName: "Trigger" }),
        this.useToggle
          ? (this.actions.Transition.forEach((e) => {
              e.toggle();
            }),
            this.actions.SwitchCamera.forEach((e) => {
              e.toggle();
            }))
          : (this.actions.Transition.forEach((e) => {
              this.alreadyPlayedNonTogglingActions.has(e) === !1 && e.play();
            }),
            this.actions.SwitchCamera.forEach((e) => {
              e.play();
            })),
        this.actions.Link.forEach((e) => {
          e.dispatch();
        }),
        this.actions.Reset.forEach((e) => {
          e.dispatch();
        }),
        this.actions.Create.forEach((e) => {
          e.dispatch();
        }),
        this.actions.Destroy.forEach((e) => {
          e.dispatch(!1);
        }),
        this.actions.Audio.forEach((e) => {
          e.dispatchBasic();
        }),
        this.actions.Particles.forEach((e) => {
          e.dispatchBasic();
        }),
        this.actions.Video.forEach((e) => {
          e.dispatchBasic();
        }),
        this.actions.SceneTransition.forEach((e) => {
          e.dispatch();
        }),
        this.actions.SetVariable.forEach((e) => e.checkConditions()),
        this.actions.SetVariable.forEach((e) => e.dispatch()),
        this.actions.DynamicVariablePlay.forEach((e) => e.dispatch()));
    }
  },
  oi;
qH.then((e) => (oi = e));
var mr = new I(),
  Na = new Rt(),
  Yo = new I(),
  ay = new Ir(0, 0, 0, "YXZ"),
  RE = new Ir(0, 0, 0, "XYZ"),
  Ua = new I(),
  ny = new I(),
  oy = new I(1, 1, 1),
  dc = new Rt(),
  im = new je(),
  LE = new je(),
  eee = { type: "updateMatrix" },
  BE = new Rt(),
  ly = new Ws(),
  dx = { type: "beginEvent", eventName: "Collision" },
  tee = { type: "beginEvent", eventName: "Trigger" };
function iee(e) {
  if (Wd.physicsEnabled(e.scene.objects)) return !0;
  let t = !1;
  return (
    e.scene.objects.traverse((i, r) => {
      if (r.events) {
        if (Array.isArray(r.events)) {
          for (let s of r.events)
            if (
              s.data.disabled !== !0 &&
              s.data.type === "GameControl" &&
              s.data.collisionEnabled
            ) {
              t = !0;
              break;
            }
        } else
          for (let s of Object.values(r.events))
            if (
              s.disabled !== !0 &&
              s.type === "GameControl" &&
              s.collisionEnabled
            ) {
              t = !0;
              break;
            }
      }
    }),
    t
  );
}
var yg = (e) =>
    e.states.some(
      (t) =>
        t.data.position !== void 0 ||
        t.data.rotation !== void 0 ||
        t.data.hiddenMatrix !== void 0 ||
        t.data.cloner !== void 0 ||
        t.data.pathSnapping !== void 0
    ),
  ree = class {
    constructor(e) {
      (this.eventContext = e),
        (this.isEnabled = !1),
        (this.gameControl = null),
        (this.joysticks = []),
        (this.joystickToGameControls = []),
        (this.sharedGameControlGlobals = {
          entitiesWithTransformAnim: [],
          entityToCollisionEvents: {},
          colliderToEntity: new Map(),
          triggers: [],
          gamePads: [],
          createdObjects: [],
          nCreatedPerAction: {},
        }),
        (this.sensorToTriggerEvent = {}),
        (this.eventManager = void 0),
        (this.needsCollisionDetection = !1),
        (this.initializationCounter = -1),
        (this.rigidBodyToMesh = new Map()),
        (this.nActiveRigidBodies = 0),
        (this.collisionEvents = []),
        (this.isExport = !1),
        (this.processRigidBody = (t) => {
          if (t.bodyType() !== oi.RigidBodyType.Dynamic) return;
          t.isSleeping() || this.nActiveRigidBodies++;
          let [i, r, s] = this.rigidBodyToMesh.get(t.handle);
          if (
            (mr.copy(t.translation()).multiplyScalar(this.pixelsPerMeter),
            Na.copy(t.rotation()),
            i.matrixWorld.compose(mr, Na, r),
            i.hasNonUniformScale && i.matrixWorld.multiply(i.shearScale),
            i.dispatchEvent(eee),
            s)
          ) {
            let a = i.cloner;
            if (a && a.objectForSample === void 0) {
              a.matrixWorld.copy(i.matrixWorld);
              for (let n of a.children) n.updateMatrixWorld(!0);
            }
            for (let n of i.children) n.updateMatrixWorld(!0);
          }
        }),
        (this.accumulator = 0),
        (this.handleCollisionEvents = (t, i, r) => {
          if (r === !1) return;
          let s, a;
          if (
            (this.sensorToTriggerEvent[t]
              ? ((s = this.sensorToTriggerEvent[t]),
                (a = this.sharedGameControlGlobals.colliderToEntity.get(i)))
              : this.sensorToTriggerEvent[i] &&
                ((s = this.sensorToTriggerEvent[i]),
                (a = this.sharedGameControlGlobals.colliderToEntity.get(t))),
            s && a && s.isValidTriggeringObject(a))
          ) {
            s.dispatch();
            return;
          }
          for (
            let n = this.sharedGameControlGlobals.createdObjects.length - 1;
            n >= 0;
            n--
          ) {
            let o = this.sharedGameControlGlobals.createdObjects[n];
            if (
              o.userData.hasCollisionDestroy &&
              (o.rigidBody?.collider(0).handle === t ||
                o.rigidBody?.collider(0).handle === i)
            ) {
              this.sharedGameControlGlobals.createdObjects.splice(n, 1),
                o.removeFromParent(),
                requestAnimationFrame(() =>
                  this.sharedGameControlGlobals.rapierWorld?.removeRigidBody(
                    o.rigidBody
                  )
                );
              break;
            }
          }
          if (
            this.gameControl?.object ===
            this.sharedGameControlGlobals.colliderToEntity.get(t)
          ) {
            let n = this.sharedGameControlGlobals.colliderToEntity.get(i),
              o = this.sharedGameControlGlobals.entityToCollisionEvents[n.uuid];
            if (o === void 0) return;
            for (let l of o)
              l.data.target === "character" &&
                this.dispatchCollisionEvent(l, n, i);
          } else if (
            this.gameControl?.object ===
            this.sharedGameControlGlobals.colliderToEntity.get(i)
          ) {
            let n = this.sharedGameControlGlobals.colliderToEntity.get(t),
              o = this.sharedGameControlGlobals.entityToCollisionEvents[n.uuid];
            if (o === void 0) return;
            for (let l of o)
              l.data.target === "character" &&
                this.dispatchCollisionEvent(l, n, t);
          } else {
            let n = this.sharedGameControlGlobals.colliderToEntity.get(t),
              o = this.sharedGameControlGlobals.entityToCollisionEvents[n.uuid];
            if (o !== void 0)
              for (let u of o)
                u.data.target === "scene" &&
                  this.dispatchCollisionEvent(u, n, t);
            let l = this.sharedGameControlGlobals.colliderToEntity.get(i),
              h =
                this.sharedGameControlGlobals.entityToCollisionEvents[l?.uuid];
            if (h !== void 0)
              for (let u of h)
                u.data.target === "scene" &&
                  this.dispatchCollisionEvent(u, l, i);
          }
        }),
        (this.isExport = e.isExport),
        (this.sharedAssets = e.sharedAssets),
        (this.renderer = e.renderer),
        (this.requestRender = e.requestRender),
        (this.domElement = this.renderer.domElement),
        (this.pixelsPerMeter = _D),
        (this.gravity = this.page.data.globalPhysics.gravity);
    }
    get page() {
      return this.eventContext.page;
    }
    attachVRControllers(e) {
      e.forEach((t) => {
        t.addEventListener("connected", (i) => {
          "gamepad" in i.data &&
            "axes" in i.data.gamepad &&
            this.sharedGameControlGlobals.gamePads.push(i.data.gamepad);
        });
      });
    }
    markIsDestroyTarget() {
      this.page.traverseVisibleEntity((e) => {
        let t = e.dataPatched;
        for (let i of t.events) {
          if (i.data.disabled === !0) continue;
          let r = i.data.actions?.find((s) => s.data.type === "Destroy")?.data;
          if (r)
            for (let s of r.objects) {
              let a = this.page.scene.find(s);
              a && (a.userData.hasDestroy = !0);
            }
        }
      });
    }
    markIsDragObject() {
      this.page.traverseVisibleEntity((e) => {
        let t = e.dataPatched;
        for (let i of t.events)
          if (!(i.data.disabled === !0 || i.data.type !== "DragDrop"))
            for (let r of i.data.objects) {
              let s = this.page.scene.find(r);
              s && (s.userData.hasDrag = !0);
            }
      });
    }
    initBVH() {
      let e = [];
      if (
        (this.page.traverseChildren((t) => {
          let i,
            r = t instanceof N1,
            s = t instanceof Z1;
          if (t instanceof Wa || r || s) return;
          t instanceof fs ? (i = t.object) : (i = t);
          let a = i.dataPatched;
          if (
            a.physics?.enabled === "visibility"
              ? !a.visible
              : !a.physics?.enabled
          )
            return !0;
          let n = t.geometry,
            o = i.userData.hasDestroy === !0,
            l = i.userData.hasDrag === !0;
          if (
            yg(a) ||
            o ||
            l ||
            i.dataPatched.events.some(
              (h) => h.data.disabled !== !0 && h.data.type === "GameControl"
            )
          )
            return t.updateMatrixWorldSVD(), this.addBoundsTree(t), !0;
          n && e.push(co(n, t.matrixWorld));
        }),
        e.length > 0)
      ) {
        let t = Ql(e, !1);
        this.sharedGameControlGlobals.staticMeshBVH = new Ed(t);
      }
    }
    addRigidBody(e, t, i) {
      let r = [],
        s = "geometry" in e ? e.geometry : void 0,
        a = t.dataPatched;
      if (
        (s?.getAttribute("position") !== void 0 && r.push(co(s, e.shearScale)),
        a.physics.fusedBody)
      ) {
        let n = this.gatherChildrenGeom(e, r);
        e.traverseObject(n), e.children.forEach((l) => l.updateMatrixWorld(!0));
        let o = e.cloner;
        o &&
          o.objectForSample === void 0 &&
          a.physics.rigidBody === "dynamic" &&
          (o.traverseObject(n),
          o.children.forEach((l) => l.updateMatrixWorld(!0)));
      }
      if (r.length > 0) {
        let n,
          o =
            (!i.fromCreate && a.physics.rigidBody === "dynamic") ||
            (i.fromCreate && i.dynamic);
        o
          ? ((n = oi.RigidBodyDesc.dynamic()),
            n
              .setLinearDamping(a.physics.damping)
              .setAngularDamping(a.physics.damping)
              .setAdditionalMass(1e-9)
              .setGravityScale(a.physics.gravityScale)
              .enabledRotations(...a.physics.enabledRotation)
              .enabledTranslations(...a.physics.enabledTranslation))
          : (i.hasTransformAnim || i.hasFollow || i.hasDrag) && !i.fromCreate
          ? ((n = oi.RigidBodyDesc.kinematicPositionBased()),
            this.sharedGameControlGlobals.entitiesWithTransformAnim.push(e))
          : (n = oi.RigidBodyDesc.fixed());
        let l = Ql(r);
        (e.hasNonUniformScale ? e.matrixWorldRigid : e.matrixWorld).decompose(
          mr,
          Na,
          Yo
        ),
          (e.position0 = mr.clone().divideScalar(this.pixelsPerMeter)),
          (e.rotation0 = Na.clone()),
          mr.divideScalar(this.pixelsPerMeter),
          n.setTranslation(mr.x, mr.y, mr.z).setRotation(Na),
          s
            ? l?.scale(
                1 / this.pixelsPerMeter,
                1 / this.pixelsPerMeter,
                1 / this.pixelsPerMeter
              )
            : l?.scale(
                Yo.x / this.pixelsPerMeter,
                Yo.y / this.pixelsPerMeter,
                Yo.z / this.pixelsPerMeter
              );
        let h = this.sharedGameControlGlobals.rapierWorld.createRigidBody(n);
        o &&
          this.rigidBodyToMesh.set(h.handle, [
            e,
            Yo.clone(),
            a.physics.fusedBody,
          ]);
        let u = !(
          a.geometry === void 0 ||
          a.geometry.type === "SubdivGeometry" ||
          a.geometry.type === "NonParametricGeometry" ||
          a.geometry.type === "BooleanGeometry" ||
          a.geometry.type === "VectorGeometry" ||
          a.geometry.type === "StarGeometry" ||
          a.geometry.type === "RectangleGeometry" ||
          a.geometry.type === "EllipseGeometry" ||
          a.geometry.type === "TriangleGeometry" ||
          a.geometry.type === "TorusGeometry" ||
          a.geometry.type === "HelixGeometry"
        );
        try {
          this.addCollider(h, a.physics, l, t, u);
        } catch {
          try {
            this.addCollider(h, a.physics, l, t, !1);
          } catch (c) {
            console.error(c);
          }
        }
        e.rigidBody = h;
      }
    }
    addBoundsTree(e) {
      let t = [];
      if (
        (e.geometry?.getAttribute("position") !== void 0 &&
          e.geometry?.getAttribute("position").count > 0 &&
          t.push(co(e.geometry, e.shearScale)),
        e.traverseObject(this.gatherChildrenGeom(e, t)),
        e.children.forEach((i) => i.updateMatrixWorld(!0)),
        t.length > 0)
      ) {
        let i = Ql(t, !1);
        (e.bvhGeometry = i),
          (e.bvhGeometry.boundsTree = new Ed(i)),
          this.sharedGameControlGlobals.entitiesWithTransformAnim.push(e);
      }
    }
    addCollider(e, t, i, r, s = !0) {
      if (i?.getAttribute("position").count === 0 || i?.getIndex()?.count === 0)
        return;
      let a;
      i &&
        (t.colliderType === "trimesh"
          ? (a = oi.ColliderDesc.trimesh(
              i.getAttribute("position").array,
              i.getIndex().array
            ))
          : (a = oi.ColliderDesc.convexMesh(
              i.getAttribute("position").array,
              s ? i.getIndex().array : void 0
            ))),
        a
          .setFrictionCombineRule(oi.CoefficientCombineRule.Average)
          .setRestitutionCombineRule(oi.CoefficientCombineRule.Average)
          .setDensity(t.density)
          .setFriction(t.friction)
          .setRestitution(t.restitution);
      let n = this.sharedGameControlGlobals.rapierWorld.createCollider(a, e);
      this.sharedGameControlGlobals.colliderToEntity.set(n.handle, r),
        this.sharedGameControlGlobals.entityToCollisionEvents[r.uuid]?.some(
          (o) => o.target === "scene"
        ) && n.setActiveEvents(oi.ActiveEvents.COLLISION_EVENTS);
    }
    gatherChildrenGeom(e, t) {
      return (i, r) => {
        if (r === 0) return;
        let s;
        if (i instanceof Wa)
          if (i.objectForSample) {
            if (i.objectForSample.dataPatched.physics.fusedBody) return;
            s = i.object;
          } else
            return i.object.dataPatched.physics.fusedBody === !0 &&
              i.object.dataPatched.physics.rigidBody === "dynamic"
              ? !0
              : void 0;
        else if (i instanceof fs) s = i.object;
        else if (((s = i), s.dataPatched.cloner?.hideBase)) return !0;
        let a = s.dataPatched;
        if (
          a.physics.enabled === "visibility" ? !a.visible : !a.physics.enabled
        )
          return !0;
        r === 1
          ? e.hasNonUniformScale
            ? i.matrixWorld.multiplyMatrices(e.shearScale, i.hiddenMatrix)
            : i.matrixWorld.copy(i.hiddenMatrix)
          : i.matrixWorld.multiplyMatrices(
              i.parent.matrixWorld,
              i.hiddenMatrix
            ),
          i.matrixWorld.multiply(i.matrix);
        let n = i.geometry;
        n?.getAttribute("position") !== void 0 && t.push(co(n, i.matrixWorld));
      };
    }
    activate(e) {
      if (this.isEnabled) return;
      (this.isEnabled = !0),
        (this.eventManager = e),
        (this.usePhysics = this.page.data.globalPhysics.usePhysics);
      let t = this.page.playCamera,
        i = !1,
        r = 5,
        s = 8,
        a = 9,
        n = "drag",
        o = this.page.data.publish.gameControlObject,
        l = o !== null ? this.page.find(o) : null,
        h = null;
      if (l)
        for (let d of l.data.events) {
          if (d.data.disabled || d.data.type !== "GameControl") break;
          let p = l;
          for (
            ;
            this.usePhysics &&
            (p = p.parent)?.parent !== null &&
            !p.data.physics?.fusedBody;

          );
          d.data.collisionEnabled && (this.needsCollisionDetection = !0),
            h === null && (h = d.data);
        }
      if (
        (this.page.traverseEntity((d) => {
          for (let p of d.dataPatched.events)
            if (p.data.disabled === !1 && p.data.type === "Trigger")
              return (this.needsCollisionDetection = !0), !0;
        }),
        l && h)
      ) {
        i = i || h.camera === t.uuid || l.uuid === t.uuid;
        let d = new SD(
          l,
          this.renderer.domElement,
          h,
          this.eventContext.page.data.globalPhysics,
          this,
          l.uuid !== t.uuid && h.camera === t.uuid,
          t,
          this.page,
          this.sharedAssets
        );
        (this.gameControl = d),
          (r = h.joystickPosLoc),
          (s = h.joystickRotLoc),
          (a = h.jumpTouchButtonLoc),
          (n = h.rotByTouch),
          Js &&
            h.touchControl &&
            ((this.joystickToGameControls[r] = "pos"),
            h.moveMode === "walk" && (this.joystickToGameControls[a] = "jmp"),
            n === "joystick" && (this.joystickToGameControls[s] = "rot"));
      }
      if (this.gameControl && this.gameControl.data.navmesh.enabled) {
        let d = this.gameControl.data;
        if (!this.navigationMeshWrapper) {
          this.navigationMeshWrapper = new G$(this.usePhysics, this.isExport);
          let p;
          d.collider.type === "sphere"
            ? (p = d.collider.radius * 2)
            : (p = d.collider.height),
            (p = Math.floor(p / d.navmesh.ch - 1)),
            this.navigationMeshWrapper.init(
              { ...d.navmesh, walkableHeight: p },
              this.gameControl,
              this.eventContext
            );
        }
      }
      if (i === !1) {
        let {
          enableRotate: d,
          enablePan: p,
          enableZoom: f,
          autoRotate: m,
          hoverRotatePanMode: g,
        } = this.eventManager.publish.orbitControls;
        (d || p || f || m || g !== 0) &&
          ((this.orbitControls = new OD(t, this.renderer.domElement, {
            isExport: this.isExport,
            isPlayMode: !0,
          })),
          this.orbitControls.addEventListener("change", this.requestRender),
          this.orbitControls.addEventListener("end", this.requestRender),
          this.orbitControls.addEventListener("start", this.requestRender),
          this.orbitControls.fromJSON(
            this.eventManager.publish.orbitControls,
            this.eventManager.publish.mouseEventTarget
          ),
          (this.orbitControls.useKeyEvents = !1),
          this.orbitControls.addEventListenersToCamera(),
          this.orbitControls.connect(),
          this.orbitControls.update());
      }
      let u = this.renderer.domElement.width / this.renderer.getPixelRatio(),
        c = this.renderer.domElement.height / this.renderer.getPixelRatio();
      this.joystickToGameControls.forEach((d, p) => {
        let f = document.body.appendChild(document.createElement("div")),
          [m, g, y] =
            this.eventManager.eventContext.publish.joystickSizeAndXYOffset[p],
          x = (u - 5 * m) / 4 + m,
          b = {},
          _ = d === "jmp",
          S = _ ? 0 : m;
        p < 10
          ? (p < 5 ? (b.top = S / 2) : (b.bottom = S / 2),
            (b.left = S / 2 + (p % 5) * x))
          : p === 10
          ? ((b.left = S / 2), (b.top = c / 2))
          : ((b.right = S / 2), (b.top = c / 2)),
          b.top ? (b.top -= g[1]) : (b.bottom += g[1]),
          b.left ? (b.left += g[0]) : (b.right -= g[0]);
        for (let A in b) b[A] += "px";
        if (_) {
          let A = f.appendChild(document.createElement("div"));
          Object.assign(A.style, b, {
            position: "absolute",
            width: m + "px",
            height: m + "px",
            backgroundColor: `rgba(255,255,255,${y === "show" ? 0.4 : 0})`,
            zIndex: "9999",
            borderRadius: m + "px",
            border: y === "show" ? "solid 2px rgba(0, 0, 0, .1)" : "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            touchAction: "none",
          });
          let T = (m / 16) * 16 * 0.4;
          y === "show" &&
            (A.innerHTML = `
						<svg width="${T}" height="${
              m * 0.4
            }" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M2 10L8 4L14 10" stroke="black" stroke-opacity="40%" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					`),
            A.addEventListener("pointerdown", () => {
              (this.gameControl.movementState.jump = 1), this.requestRender();
            }),
            A.addEventListener("touchend", (P) => P.preventDefault()),
            (this.joysticks[p] = [void 0, f]);
          return;
        }
        let M = { zone: f, mode: "static", position: b, size: m };
        y === "hide" && (M.restOpacity = 0);
        let C = gK.create(M);
        C.on("move", (A, T) => {
          let P = this.gameControl;
          d === "pos"
            ? T.force < 0.2
              ? (P.moveForce = 0)
              : ((P.movementState.movePosZ = Math.sin(-T.angle.radian)),
                (P.movementState.movePosX = Math.cos(-T.angle.radian)),
                T.force > 1.2
                  ? (P.movementState.run = 1)
                  : (P.movementState.run = 0),
                T.force < 0.3
                  ? (P.moveForce = (T.force - 0.2) / 0.1)
                  : (P.moveForce = 1))
            : d === "rot" &&
              (T.force < 0.2
                ? (P.rotForce = 0)
                : ((P.movementState.rotPosX = T.vector.y),
                  (P.movementState.rotPosY = -T.vector.x),
                  T.force < 0.3
                    ? (P.rotForce = (T.force - 0.2) / 0.1)
                    : (P.rotForce = 1))),
            this.requestRender();
        }),
          C.on("end", (A, T) => {
            let P = this.gameControl;
            d === "pos"
              ? ((P.movementState.movePosZ = 0),
                (P.movementState.movePosX = 0),
                (P.moveForce = 1))
              : d === "rot" &&
                ((P.movementState.rotPosX = 0),
                (P.movementState.rotPosY = 0),
                (P.rotForce = 1));
          }),
          (this.joysticks[p] = [C, f]);
      }),
        this.markIsDestroyTarget(),
        this.markIsDragObject(),
        this.rebuildBVH(),
        this.initializationCounter++,
        window.setTimeout(() => {
          this.collisionEvents.forEach((d) => (d.disabled = !1));
        }, 80);
    }
    initPhysics() {
      this.sharedGameControlGlobals.rapierWorld?.free(),
        (this.sharedGameControlGlobals.rapierWorld = new oi.World(
          new oi.Vector3(0, this.gravity, 0)
        )),
        (this.events = new oi.EventQueue(!0));
      let e = [],
        t = [];
      if (
        (this.page.traverseChildren((n) => {
          let o;
          if (n instanceof Wa)
            if (n.objectForSample) {
              if (n.objectForSample.dataPatched.physics.fusedBody) return;
              o = n.object;
            } else
              return n.object.dataPatched.physics.fusedBody === !0 &&
                n.object.dataPatched.physics.rigidBody === "dynamic"
                ? !0
                : void 0;
          else if (n instanceof fs) o = n.object;
          else {
            if (n instanceof Z1 || n instanceof N1) return;
            if (
              ((o = n),
              o.dataPatched.cloner?.disabled === !1 &&
                o.dataPatched.cloner?.hideBase &&
                o.dataPatched.physics?.fusedBody !== !0)
            )
              return !0;
          }
          let l = o.dataPatched,
            h;
          for (let g of l.events)
            g.data.disabled !== !0 &&
              g.data.type === "GameControl" &&
              (h = g.data);
          if (
            !l.physics ||
            (l.physics.enabled === "visibility"
              ? !l.visible
              : !l.physics.enabled)
          )
            return !0;
          n.updateMatrixWorldSVD();
          let u = yg(l),
            c = !1,
            d = o.userData.hasDestroy,
            p = o.userData.hasDrag,
            f = !1;
          for (let g of l.events)
            if (g.data.disabled !== !0) {
              if (g.data.type === "Collision") {
                c = !0;
                let y = new L$(
                  g.id,
                  g.data,
                  o,
                  this.page,
                  this.sharedAssets,
                  this.eventManager
                );
                (y.disabled = !0),
                  this.collisionEvents.push(y),
                  this.sharedGameControlGlobals.entityToCollisionEvents[
                    o.uuid
                  ] &&
                  this.sharedGameControlGlobals.entityToCollisionEvents[
                    o.uuid
                  ].every((x) => x.id !== g.id)
                    ? this.sharedGameControlGlobals.entityToCollisionEvents[
                        o.uuid
                      ].push(y)
                    : (this.sharedGameControlGlobals.entityToCollisionEvents[
                        o.uuid
                      ] = [y]);
              } else if (g.data.type === "Follow") {
                f = !0;
                let y = g.data.target;
                n.traverseVisible((x) => {
                  x.userData.isFollowingObj = y;
                });
              }
            }
          l.physics.rigidBody === "dynamic" &&
            l.physics.fusedBody === !1 &&
            (n.matrixWorldFusedFalse = n.matrixWorld.clone());
          let m = n.geometry;
          if (h !== void 0) {
            let g = oi.RigidBodyDesc.kinematicPositionBased();
            (n.hasNonUniformScale
              ? n.matrixWorldRigid
              : n.matrixWorld
            ).decompose(mr, Na, Yo),
              (n.position0 = mr.clone().divideScalar(this.pixelsPerMeter)),
              (n.rotation0 = Na.clone()),
              mr.divideScalar(this.pixelsPerMeter),
              g.setTranslation(mr.x, mr.y, mr.z).setRotation(Na);
            let y =
              this.sharedGameControlGlobals.rapierWorld.createRigidBody(g);
            n.rigidBody = y;
            let x;
            h.collider.type === "sphere"
              ? (x = oi.ColliderDesc.ball(
                  h.collider.radius / this.pixelsPerMeter
                ))
              : h.collider.type === "capsule"
              ? (x = oi.ColliderDesc.capsule(
                  (h.collider.height / 2 - h.collider.radius) /
                    this.pixelsPerMeter,
                  h.collider.radius / this.pixelsPerMeter
                ))
              : (x = oi.ColliderDesc.cuboid(
                  h.collider.width / this.pixelsPerMeter / 2,
                  h.collider.height / this.pixelsPerMeter / 2,
                  h.collider.depth / this.pixelsPerMeter / 2
                )),
              x
                .setFrictionCombineRule(oi.CoefficientCombineRule.Average)
                .setRestitutionCombineRule(oi.CoefficientCombineRule.Average)
                .setDensity(l.physics.density)
                .setFriction(l.physics.friction)
                .setRestitution(l.physics.restitution);
            let b = this.sharedGameControlGlobals.rapierWorld.createCollider(
              x,
              y
            );
            this.sharedGameControlGlobals.colliderToEntity.set(b.handle, o),
              mr
                .fromArray(h.collider.position)
                .multiply(Yo.setFromMatrixScale(o.matrixWorld))
                .divideScalar(this.pixelsPerMeter),
              b.setTranslationWrtParent(mr);
            let _ = new Rt().setFromEuler(
              new Ir().setFromVector3(new I().fromArray(h.collider.rotation))
            );
            b.setRotationWrtParent(_),
              b.setActiveEvents(oi.ActiveEvents.COLLISION_EVENTS),
              this.generateSensorColliderDescs(o, !0);
          } else
            l.physics.rigidBody === "dynamic" || u || f || d || p || c
              ? (this.addRigidBody(n, o, {
                  hasFollow: f,
                  hasTransformAnim: u,
                  hasDrag: p,
                }),
                this.generateSensorColliderDescs(o, l.physics.fusedBody))
              : (m && e.push(co(m, n.matrixWorld)),
                l.physics.fusedBody &&
                  n.traverseObject((g, y) => {
                    if (y === 0) return;
                    let x;
                    if (g instanceof Wa)
                      if (g.objectForSample) {
                        if (g.objectForSample.dataPatched.physics.fusedBody)
                          return;
                        x = g.object;
                      } else
                        return g.object.dataPatched.physics.fusedBody === !0 &&
                          g.object.dataPatched.physics.rigidBody === "dynamic"
                          ? !0
                          : void 0;
                    else if (g instanceof fs) x = g.object;
                    else if (((x = g), x.dataPatched.cloner?.hideBase))
                      return !0;
                    let b = x.dataPatched;
                    if (
                      b.physics.enabled === "visibility"
                        ? !b.visible
                        : !b.physics.enabled
                    )
                      return !0;
                    let _ = g.geometry;
                    _?.getAttribute("position") !== void 0 &&
                      e.push(co(_, g.matrixWorld));
                  }),
                this.generateSensorColliderDescs(o, l.physics.fusedBody, t));
          if (l.physics?.fusedBody === !0 || h) return !0;
        }),
        e.length === 0)
      )
        return;
      let i = Ql(e);
      i.scale(
        1 / this.pixelsPerMeter,
        1 / this.pixelsPerMeter,
        1 / this.pixelsPerMeter
      );
      let r = oi.RigidBodyDesc.fixed(),
        s = this.sharedGameControlGlobals.rapierWorld.createRigidBody(r),
        a = oi.ColliderDesc.trimesh(
          i.getAttribute("position").array,
          i.getIndex().array
        )
          .setFrictionCombineRule(oi.CoefficientCombineRule.Multiply)
          .setRestitutionCombineRule(oi.CoefficientCombineRule.Multiply)
          .setFriction(1)
          .setRestitution(1);
      this.sharedGameControlGlobals.rapierWorld.createCollider(a, s);
      for (let [n, o] of t) {
        let l = this.sharedGameControlGlobals.rapierWorld.createCollider(n, s);
        this.sensorToTriggerEvent[l.handle] = o;
      }
    }
    updatePositions() {
      return (
        (this.nActiveRigidBodies = 0),
        this.sharedGameControlGlobals.rapierWorld.forEachRigidBody(
          this.processRigidBody
        ),
        this.nActiveRigidBodies > 0
      );
    }
    rebuildBVH() {
      this.usePhysics
        ? this.initPhysics()
        : (this.page.traverseEntity((e) => {
            for (let t of e.dataPatched.events)
              if (t.data.type === "Trigger" && t.data.disabled !== !0) {
                let i = new IE(
                    t.id,
                    t.data,
                    e,
                    this.page,
                    this.sharedAssets,
                    this.eventManager
                  ),
                  r = new je().compose(
                    Ua.fromArray(t.data.position),
                    dc.setFromEuler(RE.fromArray(t.data.rotation)),
                    oy
                  );
                if (t.data.triggerZone === "box") {
                  let s = new ur();
                  s.min.fromArray(t.data.size).multiplyScalar(-0.5),
                    s.max.fromArray(t.data.size).multiplyScalar(0.5),
                    this.sharedGameControlGlobals.triggers.push([s, r, e, i]);
                } else
                  this.sharedGameControlGlobals.triggers.push([
                    t.data.radius,
                    r,
                    e,
                    i,
                  ]);
              }
          }),
          this.needsCollisionDetection && this.initBVH());
    }
    disconnectEvents() {
      this.collisionEvents.forEach((e) => e.disconnect()),
        this.sharedGameControlGlobals.triggers.forEach((e) =>
          e[3].disconnect()
        ),
        (this.sharedGameControlGlobals.triggers.length = 0);
    }
    deactivate() {
      if (this.isEnabled) {
        (this.isEnabled = !1),
          this.page.traverse((e) => {
            let t = e;
            t.matrixWorldFusedFalse && (t.matrixWorldFusedFalse = void 0),
              t.rigidBody && (t.rigidBody = void 0),
              t.position0 && (t.position0 = void 0),
              t.rotation0 && (t.rotation0 = void 0);
          }),
          this.sharedGameControlGlobals.rapierWorld?.free(),
          (this.sharedGameControlGlobals.rapierWorld = void 0),
          (this.sharedGameControlGlobals.staticMeshBVH = void 0),
          (this.accumulator = 0),
          (this.sharedGameControlGlobals.entitiesWithTransformAnim = []),
          this.disconnectEvents(),
          this.gameControl?.reset(),
          this.gameControl?.dispose(),
          (this.gameControl = null),
          (this.initializationCounter = -1),
          this.joysticks.forEach(([e, t]) => {
            e?.destroy(), t.remove();
          }),
          (this.joystickToGameControls = []),
          (this.joysticks = []),
          this.orbitControls &&
            (this.orbitControls.dispose(), (this.orbitControls = void 0)),
          this.navigationMeshWrapper?.dispose(),
          (this.navigationMeshWrapper = void 0);
        for (let e of Object.values(
          this.sharedGameControlGlobals.entityToCollisionEvents
        ))
          e.forEach((t) => t.disconnect());
        (this.sharedGameControlGlobals.entityToCollisionEvents = {}),
          this.page.updateMatrixWorld(!0);
      }
    }
    update(e, t, i) {
      if (!this.isEnabled) return !0;
      let r = !0;
      if (
        (this.orbitControls !== void 0 &&
          this.orbitControls.needsUpdate &&
          (r = !this.orbitControls.update()),
        this.initializationCounter >= 0 && this.initializationCounter < 2
          ? (this.initializationCounter++, (r = !1))
          : this.initializationCounter === 2 &&
            this.gameControl &&
            (r = !this.gameControl.update(e, t, i) && r),
        this.usePhysics === !1 && this.checkTrigger(),
        this.usePhysics)
      ) {
        let s = 0.016666666666666666;
        if (e === 0) r = this.stepPhysics() && r;
        else {
          let a = e / 1e3;
          a < s && a > s * 0.55 && (a = s), (this.accumulator += a);
          let n = performance.now(),
            o = 0,
            l = 6;
          for (
            ;
            this.accumulator >= s &&
            o < l &&
            ((r = this.stepPhysics() && r),
            (this.accumulator -= s),
            o++,
            !(performance.now() - n > s * 1e3));

          );
          this.accumulator = this.accumulator % s;
        }
      }
      return r;
    }
    stepPhysics() {
      for (let e of this.sharedGameControlGlobals.entitiesWithTransformAnim) {
        (e.hasNonUniformScale ? e.matrixWorldRigid : e.matrixWorld).decompose(
          mr,
          Na,
          Yo
        ),
          ay.setFromQuaternion(Na);
        let t = e;
        t.prevR === void 0
          ? ((t.prevR = ay.clone()), (t.prevT = mr.clone()))
          : (t.prevR.copy(ay), t.prevT.copy(mr)),
          e.rigidBody &&
            (e.rigidBody.setNextKinematicTranslation(
              mr.divideScalar(this.pixelsPerMeter)
            ),
            e.rigidBody.setNextKinematicRotation(Na));
      }
      return (
        this.sharedGameControlGlobals.rapierWorld.step(this.events),
        this.events?.drainCollisionEvents(this.handleCollisionEvents),
        !this.updatePositions()
      );
    }
    dispatchCollisionEvent(e, t, i) {
      let r =
          (this.sharedGameControlGlobals.rapierWorld?.getCollider(i))._parent,
        s;
      if (t.cloner) {
        for (let a of t.cloner.children)
          if (a.rigidBody === r) {
            s = a;
            break;
          }
      }
      e.dispatch(s), t.dispatchEvent(dx);
    }
    updateUseWindowEvents(e) {
      this.orbitControls?.updateUseWindowEvents(e);
    }
    generateSensorColliderDescs(e, t, i) {
      let r = LE.copy(e.matrixWorld).invert();
      e.traverseEntity((s, a) => {
        if (t === !1 && a === 1) return !0;
        for (let n of s.dataPatched.events)
          if (n.data.type === "Trigger" && n.data.disabled !== !0) {
            let o = new IE(
                n.id,
                n.data,
                s,
                this.page,
                this.sharedAssets,
                this.eventManager
              ),
              l;
            if (
              (n.data.triggerZone === "box"
                ? (l = oi.ColliderDesc.cuboid(
                    ...n.data.size.map((h) => h / (2 * this.pixelsPerMeter))
                  ))
                : (l = oi.ColliderDesc.ball(
                    n.data.radius / this.pixelsPerMeter
                  )),
              l
                .setDensity(0)
                .setSensor(!0)
                .setActiveEvents(oi.ActiveEvents.COLLISION_EVENTS),
              Ua.fromArray(n.data.position),
              dc.setFromEuler(RE.fromArray(n.data.rotation)),
              im.compose(Ua, dc, oy).premultiply(s.matrixWorld),
              i
                ? (im.decompose(Ua, dc, ny),
                  l.setActiveCollisionTypes(
                    oi.ActiveCollisionTypes.KINEMATIC_FIXED |
                      oi.ActiveCollisionTypes.DYNAMIC_FIXED
                  ))
                : (im.premultiply(r).decompose(Ua, dc, ny),
                  e.rigidBody.bodyType() === oi.RigidBodyType.Dynamic ||
                    (e.rigidBody.bodyType() === oi.RigidBodyType.Fixed
                      ? l.setActiveCollisionTypes(
                          oi.ActiveCollisionTypes.KINEMATIC_FIXED |
                            oi.ActiveCollisionTypes.DYNAMIC_FIXED
                        )
                      : l.setActiveCollisionTypes(
                          oi.ActiveCollisionTypes.KINEMATIC_KINEMATIC |
                            oi.ActiveCollisionTypes.DYNAMIC_KINEMATIC
                        ))),
              Ua.divideScalar(this.pixelsPerMeter),
              l.setTranslation(Ua.x, Ua.y, Ua.z),
              l.setRotation(dc),
              i)
            )
              i.push([l, o]);
            else {
              let h = this.sharedGameControlGlobals.rapierWorld.createCollider(
                l,
                e.rigidBody
              );
              this.sensorToTriggerEvent[h.handle] = o;
            }
          }
      });
    }
    checkTrigger() {
      let e;
      for (let t = 0; t < this.sharedGameControlGlobals.triggers.length; t++) {
        let [i, r, s, a] = this.sharedGameControlGlobals.triggers[t];
        for (
          let n = 0;
          n < this.sharedGameControlGlobals.entitiesWithTransformAnim.length;
          n++
        ) {
          let o = this.sharedGameControlGlobals.entitiesWithTransformAnim[n];
          if (
            s === o ||
            a.isValidTriggeringObject(si.is(o) ? o : o.object) === !1
          )
            continue;
          let l = LE.copy(s.matrixWorld)
              .decompose(Ua, BE, ny)
              .compose(Ua, BE, oy)
              .multiply(r),
            h = im.copy(o.matrixWorld).invert().multiply(l);
          i instanceof ur
            ? (e = o.bvhGeometry.boundsTree.intersectsBox(i, h))
            : ((ly.radius = i),
              ly.center.setFromMatrixPosition(h),
              (e = o.bvhGeometry.boundsTree.intersectsSphere(ly))),
            e
              ? a.currentIntersectedObjects.indexOf(o) === -1 &&
                (a.currentIntersectedObjects.push(o),
                a.dispatch(),
                s.dispatchEvent(tee))
              : (a.currentIntersectedObjects =
                  a.currentIntersectedObjects.filter((u) => u !== o));
        }
      }
    }
  };
function see(e) {
  let t = this._clip.duration,
    i = this._clip.start ?? 0,
    r = this.loop,
    s = this.time + e,
    a = this._loopCount,
    n = r === fx;
  if (e === 0) return a === -1 ? s : n && (a & 1) === 1 ? t - (s - i) : s;
  if (r === WE) {
    a === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
    e: {
      if (s >= t) s = t;
      else if (s < 0) s = 0;
      else {
        this.time = s;
        break e;
      }
      this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
        (this.time = s),
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1,
        });
    }
  } else {
    if (
      (a === -1 &&
        (e >= 0
          ? ((a = 0), this._setEndings(!0, this.repetitions === 0, n))
          : this._setEndings(this.repetitions === 0, !0, n)),
      s >= t || s < i)
    ) {
      let o = Math.floor((s - i) / (t - i));
      (s -= (t - i) * o), (a += Math.abs(o));
      let l = this.repetitions - a;
      if (l <= 0)
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          n || ((s = e > 0 ? t : i), this.repetitions === 1 && (s = t)),
          (this.time = s),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1,
          });
      else {
        if (l === 1) {
          let h = e < 0;
          this._setEndings(h, !h, n);
        } else this._setEndings(!1, !1, n);
        (this._loopCount = a),
          (this.time = s),
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: o,
          });
      }
    } else this.time = s;
    if (n && (a & 1) === 1) return t - (s - i);
  }
  return s;
}
var zE = !1,
  aee = class {
    constructor(e, t, i, r) {
      (this.scene = e),
        (this.requestRender = t),
        (this.updateDisplayProgress = i),
        (this.animationInspectorState = r),
        (this.clipIdToAction = {}),
        (this.activeClip = null),
        (this.needsUpdate = !1),
        (this.addClip = (s) => {
          s.data.type === "Empty" &&
            s.data.animations &&
            s.data.animations.forEach((a, n) => {
              let o = a[0] + "/";
              if (
                (Array.isArray(s.identity)
                  ? (o += s.identity[0])
                  : (o += s.uuid),
                this.clipIdToAction[o])
              )
                return;
              let l = wy.parse(JSON.parse(a[2]));
              s.animations[n] = l;
              let h = this.mixer.clipAction(l, s);
              zE === !1 &&
                ((Object.getPrototypeOf(h)._updateTime = see), (zE = !0)),
                (h.clampWhenFinished = !0),
                (this.clipIdToAction[o] = h);
            });
        }),
        (this.mixer = new lk(e)),
        this.scene.traverseEntity(this.addClip);
    }
    deleteClip(e, t) {
      let i = this.scene.find(t);
      if (!i) return;
      let r = i.animations.find((a) => a.uuid === e);
      if (!r) return;
      let s = this.clipIdToAction[e];
      !s ||
        (s.stop(),
        this.mixer.uncacheClip(r),
        delete this.clipIdToAction[e],
        (i.animations = i.animations.filter((a) => a.uuid !== e)));
    }
    get isPlaying() {
      return Object.values(this.clipIdToAction).some((e) => e.isRunning());
    }
    playFromInspector(e) {
      this.mixer.stopAllAction();
      let t = this.clipIdToAction[e];
      !t || (t.play(), (this.activeClip = t.getClip()), this.requestRender());
    }
    onExitPlayMode() {
      Object.values(this.clipIdToAction).forEach((e) => {
        (e.repetitions = 1 / 0), (e.loop = qE);
      }),
        this.mixer.stopAllAction(),
        this.requestRender();
    }
    play(e) {
      let t = e.clipId + "/" + e.object,
        i = this.clipIdToAction[t];
      if (i)
        return (
          e &&
            (e.repeat >= 0 && (i.repetitions = e.repeat + 1),
            e.direction === "pingpong" && e.repeat !== 0 && (i.loop = fx)),
          i.play(),
          (i.paused = !1),
          this.requestRender(),
          i
        );
    }
    resumeFromInspector(e) {
      let t = this.clipIdToAction[e];
      !t || (t.play(), (t.paused = !1), this.requestRender());
    }
    pauseFromInspector(e) {
      let t = this.clipIdToAction[e];
      !t || (t.paused = !0);
    }
    stop() {
      this.mixer.stopAllAction(), this.requestRender();
    }
    update(e) {
      if (this.needsUpdate) this.needsUpdate = !1;
      else if (
        this.isPlaying === !1 ||
        this.animationInspectorState?.isScrubbing
      )
        return;
      this.mixer.update(e / 1e3),
        this.activeClip &&
          this.updateDisplayProgress(
            Math.round(
              ((this.mixer.time / this.activeClip.duration) * this.maxFrames) %
                this.maxFrames
            )
          ),
        this.requestRender();
    }
    get maxFrames() {
      return this.activeClip?.tracks[0]?.times.length ?? 0;
    }
    setProgressFromInspector(e, t) {
      if (!this.clipIdToAction[t]) return;
      this.activeClip !== this.clipIdToAction[t].getClip() &&
        this.playFromInspector(t);
      let i = this.clipIdToAction[t].paused;
      (this.clipIdToAction[t].paused = !1),
        this.mixer.setTime(
          Math.min(this.maxFrames ? e / this.maxFrames : 0, 0.9999) *
            this.activeClip.duration
        ),
        this.requestRender(),
        i && (this.clipIdToAction[t].paused = !0);
    }
  },
  hy = new WeakMap(),
  nee = class extends op {
    constructor(e) {
      super(e),
        (this.decoderPath = ""),
        (this.decoderConfig = {}),
        (this.decoderBinary = null),
        (this.decoderPending = null),
        (this.workerLimit = 4),
        (this.workerPool = []),
        (this.workerNextTaskID = 1),
        (this.workerSourceURL = ""),
        (this.defaultAttributeIDs = {
          position: "POSITION",
          normal: "NORMAL",
          color: "COLOR",
          uv: "TEX_COORD",
        }),
        (this.defaultAttributeTypes = {
          position: "Float32Array",
          normal: "Float32Array",
          color: "Float32Array",
          uv: "Float32Array",
        });
    }
    setDecoderPath(e) {
      return (this.decoderPath = e), this;
    }
    setDecoderConfig(e) {
      return (this.decoderConfig = e), this;
    }
    setWorkerLimit(e) {
      return (this.workerLimit = e), this;
    }
    load(e, t, i, r) {
      let s = new _y(this.manager);
      s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(
          e,
          (a) => {
            this.decodeDracoFile(a, t).catch(r);
          },
          i,
          r
        );
    }
    decodeDracoFile(e, t, i, r) {
      let s = {
        attributeIDs: i || this.defaultAttributeIDs,
        attributeTypes: r || this.defaultAttributeTypes,
        useUniqueIDs: !!i,
      };
      return this.decodeGeometry(e, s).then(t);
    }
    decodeGeometry(e, t) {
      let i = JSON.stringify(t);
      if (hy.has(e)) {
        let o = hy.get(e);
        if (o.key === i) return o.promise;
        if (e.byteLength === 0)
          throw new Error(
            "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
          );
      }
      let r,
        s = this.workerNextTaskID++,
        a = e.byteLength,
        n = this._getWorker(s, a)
          .then(
            (o) => (
              (r = o),
              new Promise((l, h) => {
                (r._callbacks[s] = { resolve: l, reject: h }),
                  r.postMessage(
                    { type: "decode", id: s, taskConfig: t, buffer: e },
                    [e]
                  );
              })
            )
          )
          .then((o) => this._createGeometry(o.geometry));
      return (
        n
          .catch(() => !0)
          .then(() => {
            r && s && this._releaseTask(r, s);
          }),
        hy.set(e, { key: i, promise: n }),
        n
      );
    }
    _createGeometry(e) {
      let t = new yt();
      e.index && t.setIndex(new It(e.index.array, 1));
      for (let i = 0; i < e.attributes.length; i++) {
        let r = e.attributes[i],
          s = r.name,
          a = r.array,
          n = r.itemSize;
        t.setAttribute(s, new It(a, n));
      }
      return t;
    }
    _loadLibrary(e, t) {
      let i = new _y(this.manager);
      return (
        i.setPath(this.decoderPath),
        i.setResponseType(t),
        i.setWithCredentials(this.withCredentials),
        new Promise((r, s) => {
          i.load(e, r, void 0, s);
        })
      );
    }
    preload() {
      return this._initDecoder(), this;
    }
    _initDecoder() {
      if (this.decoderPending) return this.decoderPending;
      let e =
          typeof WebAssembly != "object" || this.decoderConfig.type === "js",
        t = [];
      return (
        e
          ? t.push(this._loadLibrary("draco_decoder.js", "text"))
          : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
            t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        (this.decoderPending = Promise.all(t).then((i) => {
          let r = i[0];
          e || (this.decoderConfig.wasmBinary = i[1]);
          let s = oee.toString(),
            a = [
              "/* draco decoder */",
              r,
              "",
              "/* worker */",
              s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
            ].join(`
`);
          this.workerSourceURL = URL.createObjectURL(new Blob([a]));
        })),
        this.decoderPending
      );
    }
    _getWorker(e, t) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          let r = new Worker(this.workerSourceURL);
          (r._callbacks = {}),
            (r._taskCosts = {}),
            (r._taskLoad = 0),
            r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
            (r.onmessage = function (s) {
              let a = s.data;
              switch (a.type) {
                case "decode":
                  r._callbacks[a.id].resolve(a);
                  break;
                case "error":
                  r._callbacks[a.id].reject(a);
                  break;
                default:
                  console.error(
                    'THREE.DRACOLoader: Unexpected message, "' + a.type + '"'
                  );
              }
            }),
            this.workerPool.push(r);
        } else
          this.workerPool.sort(function (r, s) {
            return r._taskLoad > s._taskLoad ? -1 : 1;
          });
        let i = this.workerPool[this.workerPool.length - 1];
        return (i._taskCosts[e] = t), (i._taskLoad += t), i;
      });
    }
    _releaseTask(e, t) {
      (e._taskLoad -= e._taskCosts[t]),
        delete e._callbacks[t],
        delete e._taskCosts[t];
    }
    debug() {
      console.log(
        "Task load: ",
        this.workerPool.map((e) => e._taskLoad)
      );
    }
    dispose() {
      for (let e = 0; e < this.workerPool.length; ++e)
        this.workerPool[e].terminate();
      return (
        (this.workerPool.length = 0),
        this.workerSourceURL !== "" &&
          URL.revokeObjectURL(this.workerSourceURL),
        this
      );
    }
  };
function oee() {
  let e, t;
  onmessage = function (n) {
    let o = n.data;
    switch (o.type) {
      case "init":
        (e = o.decoderConfig),
          (t = new Promise(function (u) {
            (e.onModuleLoaded = function (c) {
              u({ draco: c });
            }),
              DracoDecoderModule(e);
          }));
        break;
      case "decode":
        let l = o.buffer,
          h = o.taskConfig;
        t.then((u) => {
          let c = u.draco,
            d = new c.Decoder(),
            p = new c.DecoderBuffer();
          p.Init(new Int8Array(l), l.byteLength);
          try {
            let f = i(c, d, p, h),
              m = f.attributes.map((g) => g.array.buffer);
            f.index && m.push(f.index.array.buffer),
              self.postMessage({ type: "decode", id: o.id, geometry: f }, m);
          } catch (f) {
            console.error(f),
              self.postMessage({ type: "error", id: o.id, error: f.message });
          } finally {
            c.destroy(p), c.destroy(d);
          }
        });
        break;
    }
  };
  function i(n, o, l, h) {
    let u = h.attributeIDs,
      c = h.attributeTypes,
      d,
      p,
      f = o.GetEncodedGeometryType(l);
    if (f === n.TRIANGULAR_MESH)
      (d = new n.Mesh()), (p = o.DecodeBufferToMesh(l, d));
    else if (f === n.POINT_CLOUD)
      (d = new n.PointCloud()), (p = o.DecodeBufferToPointCloud(l, d));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!p.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + p.error_msg());
    let m = { index: null, attributes: [] };
    for (let g in u) {
      let y = self[c[g]],
        x,
        b;
      if (h.useUniqueIDs) (b = u[g]), (x = o.GetAttributeByUniqueId(d, b));
      else {
        if (((b = o.GetAttributeId(d, n[u[g]])), b === -1)) continue;
        x = o.GetAttribute(d, b);
      }
      m.attributes.push(s(n, o, d, g, y, x));
    }
    return f === n.TRIANGULAR_MESH && (m.index = r(n, o, d)), n.destroy(d), m;
  }
  function r(n, o, l) {
    let h = l.num_faces() * 3,
      u = h * 4,
      c = n._malloc(u);
    o.GetTrianglesUInt32Array(l, u, c);
    let d = new Uint32Array(n.HEAPF32.buffer, c, h).slice();
    return n._free(c), { array: d, itemSize: 1 };
  }
  function s(n, o, l, h, u, c) {
    let d = c.num_components(),
      p = l.num_points() * d,
      f = p * u.BYTES_PER_ELEMENT,
      m = a(n, u),
      g = n._malloc(f);
    o.GetAttributeDataArrayForAllPoints(l, c, m, f, g);
    let y = new u(n.HEAPF32.buffer, g, p).slice();
    return n._free(g), { name: h, array: y, itemSize: d };
  }
  function a(n, o) {
    switch (o) {
      case Float32Array:
        return n.DT_FLOAT32;
      case Int8Array:
        return n.DT_INT8;
      case Int16Array:
        return n.DT_INT16;
      case Int32Array:
        return n.DT_INT32;
      case Uint8Array:
        return n.DT_UINT8;
      case Uint16Array:
        return n.DT_UINT16;
      case Uint32Array:
        return n.DT_UINT32;
    }
  }
}
var ll;
function lee() {
  return (
    ll ||
      ((ll = new nee()),
      ll
        .setDecoderPath(
          "https://www.gstatic.com/draco/versioned/decoders/1.5.2/"
        )
        .preload()),
    ll.decoderPending
  );
}
async function hee(e) {
  if (ll) {
    let t = {
        attributeIDs: ll.defaultAttributeIDs,
        attributeTypes: ll.defaultAttributeTypes,
        useUniqueIDs: !1,
      },
      i;
    try {
      i = await ll.decodeGeometry(new Int8Array(e).buffer, t);
    } catch (r) {
      console.error(r);
    }
    if (i)
      return {
        index: i.index ? { array: i.index.array } : void 0,
        attributes: Object.entries(i.attributes).map(([r, s]) => ({
          name: r,
          itemSize: s.itemSize,
          array: s.array,
        })),
      };
  }
  return null;
}
async function cee(e, t) {
  let [i, r] = TT(Ny.deserialize(new Uint8Array(e)));
  e3(i);
  let s = [];
  i.scene.objects.traverse((a, n) => {
    n.type === "Mesh" &&
      n.geometry.type === "NonParametricGeometry" &&
      n.geometry.data.draco !== void 0 &&
      s.push(n);
  }),
    s.length && (await lee());
  for (let a of s) {
    let n = await hee(hr(a.geometry.data.draco));
    if (n) {
      n.index &&
        (a.geometry.data.index = {
          array: n.index.array,
          itemSize: 1,
          normalized: !1,
          type: "Uint32Array",
        });
      let o = {};
      n.attributes.forEach(({ name: l, array: h, itemSize: u }) => {
        o[l] = { array: h, itemSize: u, type: "Float32Array", normalized: !1 };
      }),
        (a.geometry.data.attributes = o),
        (a.geometry.data.draco = void 0);
    }
  }
  return t && t(i), r.result().data;
}
var uee = class {
    constructor(e, t, i, r, s, a, n) {
      (this.id = e),
        (this.data = t),
        (this.dataEvent = i),
        (this.object = r),
        (this.stage = !1),
        (this.actions = Rs(i, t.actions, s, a, n, r));
    }
    disconnect() {
      Xr(this.actions);
    }
    dispatchIn() {
      this.actions.Audio.forEach((e) => e.dispatchBasic()),
        this.actions.Particles.forEach((e) => e.dispatchBasic()),
        this.actions.Video.forEach((e) => e.dispatchBasic()),
        this.actions.Create.forEach((e) => e.dispatch()),
        this.actions.Destroy.forEach((e) => e.dispatch()),
        this.actions.Reset.forEach((e) => e.dispatch()),
        this.actions.Link.forEach((e) => e.dispatch()),
        this.actions.Transition.forEach((e) => {
          e.object.currentTransitionEvent !== this &&
            ((e.object.currentTransitionEvent = this), e.init());
        }),
        this.actions.Transition.forEach((e) => e.toggle()),
        this.actions.Animation.forEach((e) => e.play()),
        this.actions.SwitchCamera.forEach((e) => e.play()),
        this.actions.SceneTransition.forEach((e) => e.dispatch()),
        this.actions.SetVariable.forEach((e) => e.checkConditions()),
        this.actions.SetVariable.forEach((e) => e.dispatch()),
        this.actions.DynamicVariablePlay.forEach((e) => e.dispatch());
    }
    dispatchOut() {
      this.actions.Transition.forEach((e) => {
        e.toggle();
      });
    }
  },
  dee = class extends en {
    constructor(e, t) {
      super(e),
        (this.eventManager = t),
        (this.breakpoints = []),
        (this.resize = (i, r) => {
          this.breakpoints.forEach((s) => {
            let a = Hy.deviceToSize(s.data.size),
              n = s.dataEvent.orientation === "horizontal" ? i : r,
              o;
            switch (s.data.operator) {
              case "<":
                o = n < a[0];
                break;
              case ">":
                o = n > a[0];
                break;
              case "<>":
                o = n > a[0] && n < a[1];
                break;
            }
            s.stage !== o &&
              ((s.stage = o), s.stage ? s.dispatchIn() : s.dispatchOut());
          });
        }),
        (this.onResizeObserver = new ResizeObserver((i) => {
          for (let r of i) {
            let { width: s, height: a } = r.contentRect;
            this.resize(s, a);
          }
        }));
    }
    connect() {
      let { page: e, sharedAssets: t, domElement: i } = this.eventContext;
      this.onResizeObserver.observe(i);
      let r = (s) => {
        if (!(!s.visible || !s.data?.events.length))
          for (let { data: a } of s.data.events)
            a.disabled ||
              (a.type === "Resize" &&
                a.breakpoints.forEach(({ data: n, id: o }) => {
                  try {
                    let l = new uee(o, n, a, s, e, t, this.eventManager);
                    this.breakpoints.push(l);
                  } catch {}
                }));
      };
      e.traverseEntity((s) => {
        (s instanceof ps || s instanceof Hr) &&
          s.frame?.traverse((a) => {
            r(a);
          }),
          r(s);
      });
    }
    disconnect() {
      this.onResizeObserver.disconnect(),
        this.breakpoints.forEach((e) => {
          e.disconnect();
        }),
        (this.breakpoints = []);
    }
  },
  pee = class {
    constructor(e, t, i, r, s) {
      (this.publish = e),
        (this.controlsManager = t),
        (this.animationControls = i),
        (this.eventContext = r),
        (this.sharedVariables = s),
        (this.isEnabled = !1),
        (this.activateCount = 0),
        (this.needsMouse = !1),
        (this.needsRaycast = !1),
        (this.onTouchMovePreventScroll = (a) => {
          (a.touches.length > 1 || this.preventTouchScroll) &&
            a.preventDefault();
        }),
        (this.onMouseWheelPreventScroll = (a) => {
          this.preventScroll && a.preventDefault();
        }),
        (this.onMouseMove = (a) => {
          this.eventContext.sharedAssets.mouseProperty = {
            ...this.getMousePosition(a),
            pressed: a.buttons > 0,
          };
        }),
        (this.onMouseDown = (a) => {
          this.eventContext.sharedAssets.mouseProperty = {
            ...this.getMousePosition(a),
            pressed: !0,
          };
        }),
        (this.onMouseUp = (a) => {
          this.eventContext.sharedAssets.mouseProperty = {
            ...this.getMousePosition(a),
            pressed: !1,
          };
        }),
        (this.getMousePosition = (a) => {
          let { domRect: n } = this.eventContext,
            { pageX: o, pageY: l } = a.touches?.length > 0 ? a.touches[0] : a;
          return {
            x: o - (n.left + window.scrollX),
            y: l - (n.top + window.scrollY),
          };
        }),
        (this.stopRaycast = e.stopRaycast),
        (this.preventScroll = e.preventScroll),
        (this.preventTouchScroll = e.preventTouchScroll),
        (this.hideCursor = e.hideCursor),
        (this.requestRender = r.requestRender);
    }
    activate() {
      if (this.isEnabled) return;
      (this.isEnabled = !0),
        this.initializeActionsDependentStates(),
        this.needsMouse &&
          (this.eventContext.domElement.addEventListener(
            "pointermove",
            this.onMouseMove
          ),
          this.eventContext.domElement.addEventListener(
            "pointerdown",
            this.onMouseDown
          )),
        (this.handlers = {
          Spline: new r$(this.eventContext),
          DynamicVariable: new B$(
            this.eventContext,
            this.sharedVariables,
            this,
            this.needsMouse,
            this.needsRaycast
          ),
          Conditional: new c$(this.eventContext, this),
          Start: new R$(this.eventContext, this),
          Basic: new a$(this.eventContext, this, this.needsRaycast),
          MouseHover: new T$(this.eventContext, this),
          Scroll: new O$(this.eventContext, this),
          Follow: new b$(this.eventContext, this),
          DragDrop: new m$(this.eventContext, this),
          LookAt: new M$(this.eventContext),
          Resize: new dee(this.eventContext, this),
        });
      let { page: e, domElement: t } = this.eventContext;
      this.hideCursor && (t.style.cursor = "none"),
        e.traverseEntity((i) => {
          i.addEventListener("requestRender", this.requestRender);
        }),
        Object.values(this.handlers).forEach((i) => i.connect()),
        t.addEventListener("wheel", this.onMouseWheelPreventScroll),
        t.addEventListener("touchmove", this.onTouchMovePreventScroll),
        this.activateCount++;
    }
    deactivate() {
      if (!this.isEnabled) return;
      (this.isEnabled = !1),
        this.eventContext.domElement.removeEventListener(
          "pointermove",
          this.onMouseMove
        ),
        this.eventContext.domElement.removeEventListener(
          "pointerdown",
          this.onMouseDown
        ),
        this.eventContext.domElement.removeEventListener(
          "pointerup",
          this.onMouseUp
        ),
        (this.eventContext.sharedAssets.mouseProperty = null),
        (this.eventContext.sharedAssets.raycastProperty = null);
      let { page: e, domElement: t } = this.eventContext;
      (t.style.cursor = ""),
        Object.values(this.handlers).forEach((i) => i.disconnect()),
        this.controlsManager.gameControl?.disposeActions(),
        this.controlsManager.disconnectEvents(),
        e.traverseEntity((i) => {
          i.removeEventListener("requestRender", this.requestRender),
            (i.destroyedInAction = !1);
        }),
        t.removeEventListener("touchmove", this.onTouchMovePreventScroll),
        t.removeEventListener("wheel", this.onMouseWheelPreventScroll),
        this.animationControls.onExitPlayMode();
    }
    get isPaused() {
      return this.isEnabled;
    }
    pause() {
      this.deactivate();
    }
    resume() {
      this.activate();
    }
    reset() {
      this.deactivate(),
        this.activate(),
        this.controlsManager.page.updateMatrixWorld(!0),
        this.controlsManager.rebuildBVH();
    }
    updateUseWindowEvents(e) {
      let t = this.isEnabled;
      t && this.deactivate(),
        (this.eventContext.useWindowEvents = e),
        t && this.activate();
    }
    initializeActionsDependentStates() {
      let e = this.eventContext.sharedAssets;
      e.resetDynamicVariablePlayState();
      let t = (i) => {
        if (
          (i.data.type === "Conditional" &&
            (i.data.ifActions.forEach(t), i.data.elseActions.forEach(t)),
          i.data.type === "Conditional" || i.data.type === "SetVariable")
        )
          for (let r of i.data.type === "Conditional"
            ? i.data.condition
            : i.data.expression)
            "id" in r &&
              Array.isArray(r.id) &&
              (r.id[0] === "mouse" && (this.needsMouse = !0),
              r.id[0] === "raycast" && (this.needsRaycast = !0));
        i.data.type === "DynamicVariablePlay" &&
          i.data.variableId !== "" &&
          (i.data.mode === "Play" ||
            i.data.mode === "PlayPause" ||
            i.data.mode === "Toggle") &&
          e.setDynamicVariablePlayState(i.data.variableId, "Stopped");
      };
      this.eventContext.page.traverseEntity((i) => {
        if (i.data?.events.length) {
          for (let r of i.data.events)
            if (!r.data.disabled)
              if (
                (r.data.type === "VariableChange" &&
                  (r.data.variableId === "mouseProperty" &&
                    (this.needsMouse = !0),
                  r.data.variableId === "raycastProperty" &&
                    (this.needsRaycast = !0)),
                r.data.type === "Conditional")
              )
                for (let s of ["inActions", "outActions"]) r.data[s].forEach(t);
              else if (r.data.type === "DragDrop")
                for (let s of ["drag", "drop"])
                  r.data.dragDropActions[s].forEach(t);
              else if (r.data.type === "GameControl")
                for (let s of ["idle", "move", "jump", "run"])
                  r.data.gameActions[s].forEach(t);
              else if (r.data.type === "Resize")
                for (let s of r.data.breakpoints) s.data.actions.forEach(t);
              else r.data.type === "LookAt" || r.data.actions.forEach(t);
        }
      });
    }
  },
  fee = class {
    constructor(e, t, i, r, s) {
      (this._aspect = 1),
        (this.enableResponsive = !1),
        (this._renderer = e),
        (this._camera = t),
        (this._frameSize = new re().copy(i)),
        (this._editorSize = new re().copy(r)),
        (this._aspect = t.aspect),
        (this._fov = s ?? t.fov);
    }
    set frameSize(e) {
      this._frameSize.copy(e);
    }
    updateRenderer() {
      !this._renderer ||
        this._renderer.setSize(this._frameSize.x, this._frameSize.y);
    }
    updateViewport() {
      if (
        !this._renderer ||
        !this._camera ||
        this._camera.cameraType !== "PerspectiveCamera"
      )
        return;
      let e = this._frameSize.x,
        t = this._frameSize.y,
        i = this._editorSize.y;
      (this._aspect = e / t),
        t <= i && (this._camera.zoom *= i / t),
        this._renderer.setViewport(0, 0, e, t);
    }
    updateCamera(e = !0) {
      if (this._camera)
        if (this._camera.cameraType === "PerspectiveCamera") {
          let t = this._frameSize.y,
            i = this._editorSize.y,
            r = this._fov;
          if (e && t > i) {
            let s = mee(t, 1080, 2160, 1, 15) / 100;
            (r *= t / i), (r *= 1 - s);
          }
          (this._camera.aspect = this._aspect),
            (this._camera.fov = r),
            this._camera.updateProjectionMatrix();
        } else
          this._camera.setViewplaneSize(
            this._frameSize.x,
            this._frameSize.y,
            this.enableResponsive
          );
    }
    setCamera(e) {
      (this._camera = e), (this._aspect = e.aspect), (this._fov = e.fov);
    }
    revert() {
      let e = window.innerWidth,
        t = window.innerHeight;
      this._renderer &&
        (this._renderer.setViewport(0, 0, e, t), this._renderer.setSize(e, t)),
        this._camera &&
          ((this._camera.aspect = e / t),
          (this._camera.fov = this._fov),
          this._camera.setViewplaneSize(e, t, this.enableResponsive),
          this._camera.updateProjectionMatrix());
    }
  };
function mee(e, t, i, r, s) {
  return ((e - t) / (i - t)) * (s - r) + r;
}
var gee = class {
    get sharedAssets() {
      return this.shared;
    }
    constructor(e, t = {}) {
      (this.shared = new _b(e.shared, t)),
        (this.scene = new Lb(e.scene, this.sharedAssets)),
        this.shared.setEntityOpContext({
          scene: this.scene,
          shared: this.shared,
        });
    }
    reset(e, t) {
      this.scene.clearScene(),
        this.sharedAssets.reset(e.shared),
        this.scene.resetAfterClear(e.scene, this.sharedAssets);
    }
    resetPersonalCameraFromDocumentData() {
      for (let e of this.scene.children)
        e instanceof Hr &&
          !e.uiScene &&
          e.personalCamera.updateState(e.data.camera, {
            scene: this.scene,
            shared: this.shared,
          });
    }
    dispose() {
      this.scene.dispose(), this.shared.dispose();
    }
    gc() {
      this.shared.geometryCache.startGc(),
        this.shared.geometryCache2.startGc(),
        this.scene.traverseEntity((e) => {
          e instanceof ms && e.markGeometryAsReachable(this.shared);
        }),
        this.shared.geometryCache.endGc(),
        this.shared.geometryCache2.endGc();
    }
  },
  vee = class {
    constructor({ x: e = 10, y: t = 10 }) {
      this._startTime = 0;
      let i = document.getElementById("spe-perfs");
      i
        ? (this.element = i)
        : ((this.element = document.createElement("div")),
          document.body.appendChild(this.element),
          (this.element.style.position = "absolute"),
          (this.element.style.zIndex = "10000"),
          (this.element.style.fontFamily = "monospace"),
          (this.element.style.background = "black"),
          (this.element.style.color = "white"),
          (this.element.style.padding = "10px"),
          (this.element.style.opacity = "0.5"),
          (this.element.style.fontSize = "11px"),
          this.element.setAttribute("id", "spe-perfs")),
        (this.element.style.left = `${e}px`),
        (this.element.style.top = `${t}px`);
    }
    dispose() {
      this.element.parentElement?.removeChild(this.element);
    }
    start() {
      this._startTime = performance.now();
    }
    end() {
      let e = performance.now() - this._startTime;
      this.element.innerHTML = e.toFixed(3) + " ms";
    }
  };
function yee(e) {
  let t;
  if (e.index)
    for (let i = 0; i < e.index.array.length; i += 3)
      (t = e.index.array[i]),
        (e.index.array[i] = e.index.array[i + 2]),
        (e.index.array[i + 2] = t);
}
function Od(e) {
  return e instanceof $d
    ? "SubdivObject"
    : e.geometry.type === "NonParametricGeometry"
    ? "NonParametric"
    : "Mesh";
}
function xee(e, t) {
  let i = {};
  return (
    e.traverseEntity((r) => {
      if (
        !r.visible ||
        !(r instanceof Is) ||
        r.type !== "Mesh" ||
        Array.isArray(r.material) ||
        (r.states && Object.keys(r.states).length)
      )
        return;
      let s = r.parent;
      for (; s; ) {
        if (s instanceof Is && r.states && Object.keys(r.states).length) return;
        s = s.parent;
      }
      let a = r.material.uuid,
        n = t.shared.materials[a];
      if (n) {
        if (!gs.isMergable(n)) return;
      } else {
        let l = t.scene.objects.get(r.uuid)?.data;
        if (l && "material" in l && typeof l.material != "string") {
          if (!gs.isMergable(l.material)) return;
          a = gs.getHash(l.material);
        }
      }
      i[a] || (i[a] = {});
      let o = i[a][Od(r)];
      if (o) {
        if ((o.push(r), r.cloner)) for (let l of r.cloner.children) o.push(l);
      } else if (((i[a][Od(r)] = [r]), r.cloner))
        for (let l of r.cloner.children) i[a][Od(r)].push(l);
    }),
    i
  );
}
function bee(e) {
  let t = 0;
  return (
    Object.values(e).forEach((i) => {
      Object.values(i).forEach((r) => {
        let s = r.length;
        s > t && (t = s);
      });
    }),
    t
  );
}
function wee(e, t) {
  let i = xee(t, e),
    r = bee(i),
    s = new Array(r),
    a = 0,
    n = new Array(r),
    o = 0,
    l = new Array(r),
    h = 0,
    u = new Array(r),
    c = 0;
  for (let [d, p] of Object.entries(i))
    for (let f of Object.values(p)) {
      if (
        ((o = 0),
        (h = 0),
        f.forEach((g) => {
          g instanceof Is && ((n[o++] = g.geometry.clone()), (l[h++] = g));
        }),
        h < 2)
      )
        continue;
      for (let g = 0; g < h; g++)
        l[g].updateWorldMatrix(!0, !1),
          n[g].applyMatrix4(l[g].matrixWorld),
          l[g].matrixWorld.determinant() < 0 && yee(n[g]);
      let m = Ql(n.slice(0, o), !1);
      if (m) {
        let g;
        switch (d) {
          case "SubdivObject": {
            console.warn("Turning subdiv object into mesh"),
              (g = new br(m, l[0].material));
            break;
          }
          default: {
            g = new br(m, l[0].material);
            break;
          }
        }
        (g.castShadow = l[0].castShadow),
          (g.receiveShadow = l[0].receiveShadow),
          t.add(g);
        let y = (x) => {
          c = 0;
          for (let b of x)
            b.children && y(b.children),
              b instanceof Is &&
                (Array.isArray(b.material) ||
                  (i[b.material.uuid] &&
                    i[b.material.uuid][Od(b)] &&
                    i[b.material.uuid][Od(b)].length > 1) ||
                  (u[c++] = b));
          for (let b = 0; b < c; b++) t.attach(u[b]);
        };
        for (let x = 0; x < h; x++) {
          let b = l[x];
          y(b.children), (s[a++] = b);
        }
      }
    }
  for (let d = 0; d < a; d++) s[d].removeFromParent();
}
var _ee = Sr(qO(), 1),
  See = new re();
function Aee(e) {
  let t =
    "The Spline Runtime only accepts .splinecode files that are generated from Spline export panel.";
  e.endsWith(".spline")
    ? console.warn(
        t + " The .spline files are only meant to be used by the Editor."
      )
    : e.endsWith(".splinecode") || console.warn(t);
}
var Qb = class {
  constructor(e, { renderOnDemand: t, renderMode: i = "auto" } = {}) {
    (this._viewportMode = 1),
      (this._viewportWidth = window.innerWidth),
      (this._viewportHeight = window.innerHeight),
      (this._proxyObjectCache = new Map()),
      (this._variablesCache = new Map()),
      (this._isPaused = !1),
      (this._renderRequested = !1),
      (this._skipRender = !1),
      (this.time = performance.now()),
      (this.dt = 0),
      (this.currentTAAFrame = 0),
      (this.disposed = !1),
      (this._requestRenderAutoMode = () => {
        this._skipRender = !1;
      }),
      (this.requestRender = () => {
        this._renderRequested = !0;
      }),
      (this.render = (r) => {
        if (
          ((this.time = r),
          this._lastTime && (this.dt = this.time - this._lastTime),
          (this._lastTime = this.time),
          this._perfs?.start(),
          !this._renderer)
        ) {
          this._perfs?.end();
          return;
        }
        if (
          !this._isPaused &&
          ((this.renderMode === "manual" && !this._renderRequested) ||
            (this.renderMode === "auto" && this._skipRender))
        ) {
          this._perfs?.end();
          return;
        }
        if (
          ((this._renderRequested = !1),
          (this._skipRender = !0),
          this._controls && (this._skipRender = this._controls.update(this.dt)),
          this._eventManager &&
            (this._eventManager.handlers?.Start.hasVideoAction ||
              this._eventManager.handlers?.Basic.hasVideoAction ||
              this._eventManager.handlers?.Conditional.hasVideoAction) &&
            (this._skipRender = !1),
          this._animationControls?.update(this.dt),
          this._skipRender
            ? (this.currentTAAFrame++,
              this.currentTAAFrame < 32
                ? (this._skipRender = !1)
                : (this.currentTAAFrame = 0))
            : (this.currentTAAFrame = 0),
          this._scene?.traverseVisibleEntity((s) => {
            s.type === "ParticleSystem" &&
              (s.update(this.dt), (this._skipRender = !1));
          }),
          this._scene &&
            this._scene.activeCamera !== this._camera &&
            (this._camera = this._scene.activeCamera),
          this._eventManager?.isEnabled &&
            ((this._eventManager.handlers?.Follow).onAnimationFrameDamping(),
            (this._eventManager.handlers?.LookAt).onAnimationFrameDamping(),
            (this._eventManager.handlers?.DragDrop).onAnimationFrameDamping()),
          this._scene && this._camera)
        ) {
          if (
            (this._scene.pathConstraints.applyConstraints(this._scene),
            this._renderer.sceneTransitionTimeRemaining > 0)
          ) {
            this._renderer.sceneTransitionTimeRemaining -= this.dt;
            let s =
              1 -
              this._renderer.sceneTransitionTimeRemaining /
                this._renderer.sceneTransitionDuration;
            (this._renderer.pipeline.sceneTransitionPass.uniforms.mixRatio.value =
              s),
              (this._skipRender = !1);
          } else this._renderer.pipeline.sceneTransitionFromTexture = null;
          this._renderer.renderSplineScene(this._scene, this._camera);
        }
        this.canvas.dispatchEvent(this._renderedEvent), this._perfs?.end();
      }),
      (this._resize = () => {
        if (this._renderer) {
          if (
            (this._viewportMode === 1 &&
              this._frameView &&
              (this._frameView.frameSize = See.set(
                this._viewportWidth,
                this._viewportHeight
              )),
            this._renderer.setSize(
              this._viewportWidth,
              this._viewportHeight,
              !1
            ),
            (this._camera = this._scene?.activeCamera),
            this._scene?.updateViewPlaneSize(
              this._frameView?.frameSize?.x ?? this._viewportWidth,
              this._frameView?.frameSize?.y ?? this._viewportHeight,
              this._frameView?.enableResponsive ?? !1
            ),
            this._camera)
          ) {
            let r =
              Object.values(this._data?.frames ?? {})[0].preset ?? "fullscreen";
            this._frameView?.setCamera(this._camera),
              this._frameView?.updateCamera(r !== "fullscreen"),
              this._camera.cameraType === "PerspectiveCamera" &&
                (this._camera.aspect =
                  this._viewportWidth / this._viewportHeight),
              this._camera.updateProjectionMatrix();
          }
          this.eventManager &&
            (this.eventManager.eventContext.domRect =
              this.canvas.getBoundingClientRect()),
            this._requestRenderAutoMode();
        }
      }),
      (this._debouncedResize = Yx(this._resize, 10)),
      (this._onScroll = (r) => {
        this.eventManager &&
          (this.eventManager.eventContext.domRect =
            this.canvas.getBoundingClientRect());
      }),
      (this.canvas = e),
      (this.renderMode = t ? "auto" : i),
      (this._renderedEvent = new CustomEvent("rendered", { bubbles: !0 })),
      Object.defineProperty(this._renderedEvent, "target", {
        writable: !1,
        value: this,
      }),
      window.location.search.includes("perfs") &&
        (this._perfs = new vee({ x: 10, y: 10 })),
      jH(e);
  }
  async load(e, t, i) {
    Aee(e), (this.disposed = !1);
    let r = await (await fetch(e, i)).arrayBuffer();
    await this.start(r, { variables: t });
  }
  async start(e, { interactive: t = !0, variables: i } = {}) {
    if (this.disposed) return;
    let r = await cee(e);
    (this._data = r),
      r.version &&
        (0, _ee.default)(r.version, "1.0.31") > 0 &&
        console.warn(
          "Your .splinecode file is more recent than the library. Please upgrade @splinetool/runtime to the latest version."
        ),
      await Promise.all(
        [
          lM(r) && E7(),
          gY(r) && _7(),
          Wd.physicsEnabled(r.scene.objects) && YH(),
          iM(r) && rY(),
          MM(r) && iZ(),
          q$(r) && WH(),
        ].filter(Boolean)
      ),
      this._eventManager?.deactivate(),
      this._controls?.deactivate(),
      this._scene?.dispose();
    let s = new gee(r);
    if (
      (s.resetPersonalCameraFromDocumentData(),
      (this._scene = s.scene),
      (this._sharedAssetsManager = s.sharedAssets),
      (this._camera = this._scene.activeCamera),
      window.location.search.includes("merge-geometries"))
    ) {
      let o = performance.now();
      wee(r, s.scene);
      let l = performance.now();
      console.log("Merged geometries in ", l - o, " ms");
    }
    lM(r) &&
      this._scene.traverse((o) => {
        yo(o) && o.recomputeBoolean();
      }),
      this._sharedAssetsManager.setRequestRender(() => {
        this._requestRenderAutoMode(),
          this._scene?.traverse((o) => {
            o instanceof Wa && o.pendingMediaLoad && o.update();
          });
      }),
      this._scene?.traverse((o) => {
        o.type === "ParticleSystem" &&
          (o.wakeUp(), o.data.autoPlay ? o.start() : o.stop());
      });
    let a = Object.keys(r.shared.fonts).map(
      (o) => this._sharedAssetsManager.getFont(o).loadingPromise
    );
    if (
      (Promise.all(a).then(() => {
        s.scene.markNeedsUpdateRendererDirty(), this._requestRenderAutoMode();
      }),
      iM(r) && iee(r) && (await Promise.all(a)),
      MM(r))
    ) {
      let o = [];
      this._scene.traverseEntity((l) => {
        (l instanceof ps || l instanceof Hr) &&
          l.uiCanvas &&
          o.push(l.uiCanvas);
      }),
        await Promise.all(o.map((l) => l.promise));
    }
    this._scene.rewriteEventsBeforeGoToPlayMode(),
      Yb(this._scene.activePage, this._sharedAssetsManager),
      this._renderer ||
        ((this._renderer = new XQ({
          canvas: this.canvas,
          antialias: !1,
          alpha: !0,
          stencil: !1,
          depth: !1,
          powerPreference: "high-performance",
        })),
        (this._renderer.hdTransmission = r.scene.publish.hdTransmission === !0),
        this._renderer.setPixelRatio(window.devicePixelRatio),
        this._renderer.pipeline.enableUIOverlay(),
        this._renderer.pipeline.addEventListener(
          "smaaloaded",
          this._requestRenderAutoMode
        )),
      this._scene.initializeSplatViewer(this._renderer),
      r.scene.blueNoiseTextureData !== void 0 &&
        this._renderer.pipeline.updateBlueNoiseTexture(
          r.scene.blueNoiseTextureData
        );
    let n = Object.values(r.frames)[0];
    if (
      (this._frameView
        ? this._frameView.setCamera(this._camera)
        : (n.preset === "fullscreen"
            ? ((this._viewportMode = 1),
              (this.canvas.style.display = "block"),
              this.canvas.parentElement &&
                ((this._viewportWidth =
                  this.canvas.parentElement.clientWidth || 300),
                (this.canvas.style.width = "100%")),
              this.canvas.parentElement &&
                ((this._viewportHeight =
                  this.canvas.parentElement.clientHeight || 150),
                (this.canvas.style.height = "100%")))
            : ((this._viewportMode = 2),
              (this._viewportWidth = n.size[0]),
              (this._viewportHeight = n.size[1]),
              (this.canvas.style.width = `${this._viewportWidth}px`),
              (this.canvas.style.height = `${this._viewportHeight}px`)),
          this._renderer.setSize(this._viewportWidth, this._viewportHeight, !1),
          (this._frameView = new fee(
            this._renderer,
            this._camera,
            new re(this._viewportWidth, this._viewportHeight),
            new re(window.innerWidth, window.innerHeight)
          )),
          (this._frameView.enableResponsive =
            (n.allowResponsive ?? !1) && n.preset === "fullscreen")),
      t)
    ) {
      let o = new t$(
        this._renderer,
        this.data.scene.publish,
        this._scene,
        () => this._scene.activeCamera,
        this._sharedAssetsManager,
        this._requestRenderAutoMode,
        !0,
        n
      );
      this._scene.updateMatrixWorld(!0),
        (this._controls = new ree(o)),
        (this._animationControls = new aee(
          this._scene,
          this._requestRenderAutoMode
        )),
        (this._eventManager = new pee(
          r.scene.publish,
          this._controls,
          this._animationControls,
          o,
          r.shared.variables
        )),
        this._eventManager.activate(),
        this._controls.activate(this._eventManager);
    }
    this._resize(),
      i !== void 0 && this.setVariables(i),
      this.dt === 0 &&
        (this.render(performance.now()),
        setTimeout(() => {
          this._renderer?.setAnimationLoop(this.render);
        }, 0)),
      (this._resizeObserverTimeout = setTimeout(() => {
        !this._resizeObserver &&
          this.canvas.parentElement &&
          ((this._resizeObserver = new ResizeObserver(() => {
            (this._viewportWidth = this.canvas.clientWidth),
              (this._viewportHeight = this.canvas.clientHeight),
              this._debouncedResize();
          })),
          this._resizeObserver.observe(this.canvas.parentElement));
      }, 300)),
      document.addEventListener("scroll", this._onScroll);
  }
  setVariables(e) {
    if (this._data !== void 0) {
      let t = Object.entries(e);
      for (let [i, r] of t) this.setVariable(i, r);
    }
  }
  setVariable(e, t) {
    let i = this._getVariableByName(e);
    if (i && !("dynamicVariableType" in i.data)) {
      let r = t;
      typeof i.data.value == "number"
        ? (r =
            typeof t == "number"
              ? t
              : typeof t == "boolean"
              ? t === !0
                ? 1
                : 0
              : parseFloat(t))
        : typeof i.data.value == "boolean"
        ? (r =
            typeof t == "number"
              ? !!t
              : typeof t == "boolean"
              ? t
              : t.toLocaleLowerCase() === "false"
              ? !1
              : !!t)
        : typeof i.data.value != "string" &&
          i.data.value.textValue !== void 0 &&
          (r = t.toString());
      let s = typeof r == "string" ? { textValue: r } : r;
      this._sharedAssetsManager?.updateVariable(i.id, s),
        this.requestRender(),
        this._requestRenderAutoMode();
    } else
      i === void 0
        ? console.warn(
            `No variable named ${e} was found in your Spline file. Make sure to create it from Spline editor.`
          )
        : "dynamicVariableType" in i.data &&
          console.warn(
            `Dynamic variables like ${e} cannot be updated from code.`
          );
  }
  getVariables() {
    let e = {};
    return (
      this._data &&
        this._data.shared.variables.forEach((t) => {
          e[t.data.name] === void 0 &&
            (e[t.data.name] = this._getVariableValue(
              this._sharedAssetsManager.getVariable(t.id)
            ));
        }),
      e
    );
  }
  getVariable(e) {
    let t = this._getVariableByName(e);
    if (t) {
      let i = this._sharedAssetsManager.getVariable(t.id);
      return this._getVariableValue(i);
    }
  }
  _getVariableValue(e) {
    return typeof e != "string" && $s.isTextValue(e)
      ? $s.getDisplayedValue(e)
      : e;
  }
  _getVariableByName(e) {
    if (this._data) {
      if (this._variablesCache.has(e)) return this._variablesCache.get(e);
      let t = this._data.shared.variables.find((i) => i.data.name === e);
      return t && this._variablesCache.set(e, t), t;
    }
  }
  findObjectById(e) {
    let t = this._scene?.getObjectByProperty("uuid", e);
    return this._createProxyObject(t);
  }
  findObjectByName(e) {
    let t = this._scene?.getObjectByName(e);
    return this._createProxyObject(t);
  }
  getAllObjects() {
    let e = [];
    return (
      this._scene?.traverseEntity((t) => {
        if (
          t.uuid !== mu &&
          !this._scene.isInvisibleObjects(t) &&
          !(t instanceof Hr)
        ) {
          let i = this._createProxyObject(t);
          i && e.push(i);
        }
      }),
      e
    );
  }
  getSplineEvents() {
    return (this._eventManager?.handlers?.Spline).splineEvents;
  }
  emitEvent(e, t) {
    (this.findObjectById(t) || this.findObjectByName(t))?.emitEvent(e);
  }
  emitEventReverse(e, t) {
    (this.findObjectById(t) || this.findObjectByName(t))?.emitEventReverse(e);
  }
  addEventListener(e, t) {
    this.canvas.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.canvas.removeEventListener(e, t);
  }
  setZoom(e) {
    this._controls?.orbitControls instanceof OD &&
      this._controls?.orbitControls.zoomOut(e);
  }
  get eventManager() {
    return this._eventManager;
  }
  get controls() {
    return this._controls;
  }
  setSize(e, t) {
    (this._viewportWidth = e),
      (this._viewportHeight = t),
      (this._viewportMode = 2),
      this._resize();
  }
  setBackgroundColor(e) {
    let { r: t, g: i, b: r, a: s } = { r: 0, g: 0, b: 0, a: 1 },
      a = new os(t, i, r, s);
    try {
      a.setStyle(e);
    } catch {
      console.error("This is not a valid css color", e);
    }
    this._scene?.activePage.setBackgroundColor(a),
      this._requestRenderAutoMode();
  }
  dispose() {
    (this.disposed = !0),
      this._eventManager?.deactivate(),
      this._scene?.dispose(),
      this._sharedAssetsManager?.dispose(),
      this._proxyObjectCache.forEach((e) => {
        _S.unsubscribe(e);
      }),
      this._variablesCache.clear(),
      this._renderer?.setAnimationLoop(null),
      this._renderer?.dispose(),
      (this._renderer = void 0),
      this._sharedAssetsManager?.dispose(),
      this._resizeObserver &&
        (this._resizeObserver.disconnect(), (this._resizeObserver = void 0)),
      this._resizeObserverTimeout !== void 0 &&
        clearTimeout(this._resizeObserverTimeout),
      (this.canvas.style.width = ""),
      (this.canvas.style.height = ""),
      this.canvas.removeAttribute("width"),
      this.canvas.removeAttribute("height"),
      this._frameView && (this._frameView = void 0),
      this._controls?.deactivate(),
      HH(this.canvas),
      document.removeEventListener("scroll", this._onScroll);
  }
  get isStopped() {
    return this._isPaused;
  }
  stop() {
    this._isPaused ||
      (this._renderer?.setAnimationLoop(null),
      (this._isPaused = !0),
      this._eventManager?.pause(),
      this._controls?.orbitControls &&
        (this._controls.orbitControls.enabled = !1));
  }
  play() {
    !this._isPaused ||
      ((this._isPaused = !1),
      this._eventManager?.resume(),
      this._controls?.orbitControls &&
        (this._controls.orbitControls.enabled = !0),
      this._renderer?.setAnimationLoop(this.render));
  }
  setGlobalEvents(e) {
    this._eventManager?.updateUseWindowEvents(e);
  }
  get data() {
    return this._data;
  }
  _createProxyObject(e) {
    if (e == null) return;
    if (this._proxyObjectCache.has(e.uuid))
      return this._proxyObjectCache.get(e.uuid);
    let t;
    e.traverseAncestors((s) => {
      s instanceof Hr && (t = s.name);
    });
    let i = {
        name: e.name,
        uuid: e.uuid,
        visible: e.visible,
        intensity: e.intensity,
        position: e.position,
        rotation: e.rotation,
        scale: e.scale,
        type: e.data.type,
        page: t,
        parentUuid:
          e.parent instanceof Hr || e instanceof Lb ? void 0 : e.parent?.uuid,
        emitEvent(s) {
          e.dispatchEvent({ type: "userEvent", eventName: s });
        },
        emitEventReverse(s) {
          e.dispatchEvent({ type: "userEvent", eventName: s, reverse: !0 });
        },
      },
      r = _S(i, (s, a) => {
        typeof e[s] != "object" &&
          Object.getOwnPropertyDescriptor(e, s)?.writable &&
          (e[s] = a),
          this._requestRenderAutoMode(),
          e.updateMatrix();
      });
    return this._proxyObjectCache.set(e.uuid, r), r;
  }
  setUIWasmUrl(e) {
    nP.skiaWasmUrl = e;
  }
};
var Wg = window,
  qg =
    Wg.ShadowRoot &&
    (Wg.ShadyCSS === void 0 || Wg.ShadyCSS.nativeShadow) &&
    "adoptedStyleSheets" in Document.prototype &&
    "replace" in CSSStyleSheet.prototype,
  Zb = Symbol(),
  ID = new WeakMap(),
  vp = class {
    constructor(t, i, r) {
      if (((this._$cssResult$ = !0), r !== Zb))
        throw Error(
          "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
        );
      (this.cssText = t), (this.t = i);
    }
    get styleSheet() {
      let t = this.o,
        i = this.t;
      if (qg && t === void 0) {
        let r = i !== void 0 && i.length === 1;
        r && (t = ID.get(i)),
          t === void 0 &&
            ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText),
            r && ID.set(i, t));
      }
      return t;
    }
    toString() {
      return this.cssText;
    }
  },
  RD = (e) => new vp(typeof e == "string" ? e : e + "", void 0, Zb),
  Kb = (e, ...t) => {
    let i =
      e.length === 1
        ? e[0]
        : t.reduce(
            (r, s, a) =>
              r +
              ((n) => {
                if (n._$cssResult$ === !0) return n.cssText;
                if (typeof n == "number") return n;
                throw Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    n +
                    ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                );
              })(s) +
              e[a + 1],
            e[0]
          );
    return new vp(i, e, Zb);
  },
  Jb = (e, t) => {
    qg
      ? (e.adoptedStyleSheets = t.map((i) =>
          i instanceof CSSStyleSheet ? i : i.styleSheet
        ))
      : t.forEach((i) => {
          let r = document.createElement("style"),
            s = Wg.litNonce;
          s !== void 0 && r.setAttribute("nonce", s),
            (r.textContent = i.cssText),
            e.appendChild(r);
        });
  },
  Yg = qg
    ? (e) => e
    : (e) =>
        e instanceof CSSStyleSheet
          ? ((t) => {
              let i = "";
              for (let r of t.cssRules) i += r.cssText;
              return RD(i);
            })(e)
          : e;
var $b,
  Xg = window,
  LD = Xg.trustedTypes,
  Mee = LD ? LD.emptyScript : "",
  BD = Xg.reactiveElementPolyfillSupport,
  tw = {
    toAttribute(e, t) {
      switch (t) {
        case Boolean:
          e = e ? Mee : null;
          break;
        case Object:
        case Array:
          e = e == null ? e : JSON.stringify(e);
      }
      return e;
    },
    fromAttribute(e, t) {
      let i = e;
      switch (t) {
        case Boolean:
          i = e !== null;
          break;
        case Number:
          i = e === null ? null : Number(e);
          break;
        case Object:
        case Array:
          try {
            i = JSON.parse(e);
          } catch {
            i = null;
          }
      }
      return i;
    },
  },
  zD = (e, t) => t !== e && (t == t || e == e),
  ew = {
    attribute: !0,
    type: String,
    converter: tw,
    reflect: !1,
    hasChanged: zD,
  },
  To = class extends HTMLElement {
    constructor() {
      super(),
        (this._$Ei = new Map()),
        (this.isUpdatePending = !1),
        (this.hasUpdated = !1),
        (this._$El = null),
        this.u();
    }
    static addInitializer(t) {
      var i;
      this.finalize(),
        ((i = this.h) !== null && i !== void 0 ? i : (this.h = [])).push(t);
    }
    static get observedAttributes() {
      this.finalize();
      let t = [];
      return (
        this.elementProperties.forEach((i, r) => {
          let s = this._$Ep(r, i);
          s !== void 0 && (this._$Ev.set(s, r), t.push(s));
        }),
        t
      );
    }
    static createProperty(t, i = ew) {
      if (
        (i.state && (i.attribute = !1),
        this.finalize(),
        this.elementProperties.set(t, i),
        !i.noAccessor && !this.prototype.hasOwnProperty(t))
      ) {
        let r = typeof t == "symbol" ? Symbol() : "__" + t,
          s = this.getPropertyDescriptor(t, r, i);
        s !== void 0 && Object.defineProperty(this.prototype, t, s);
      }
    }
    static getPropertyDescriptor(t, i, r) {
      return {
        get() {
          return this[i];
        },
        set(s) {
          let a = this[t];
          (this[i] = s), this.requestUpdate(t, a, r);
        },
        configurable: !0,
        enumerable: !0,
      };
    }
    static getPropertyOptions(t) {
      return this.elementProperties.get(t) || ew;
    }
    static finalize() {
      if (this.hasOwnProperty("finalized")) return !1;
      this.finalized = !0;
      let t = Object.getPrototypeOf(this);
      if (
        (t.finalize(),
        t.h !== void 0 && (this.h = [...t.h]),
        (this.elementProperties = new Map(t.elementProperties)),
        (this._$Ev = new Map()),
        this.hasOwnProperty("properties"))
      ) {
        let i = this.properties,
          r = [
            ...Object.getOwnPropertyNames(i),
            ...Object.getOwnPropertySymbols(i),
          ];
        for (let s of r) this.createProperty(s, i[s]);
      }
      return (this.elementStyles = this.finalizeStyles(this.styles)), !0;
    }
    static finalizeStyles(t) {
      let i = [];
      if (Array.isArray(t)) {
        let r = new Set(t.flat(1 / 0).reverse());
        for (let s of r) i.unshift(Yg(s));
      } else t !== void 0 && i.push(Yg(t));
      return i;
    }
    static _$Ep(t, i) {
      let r = i.attribute;
      return r === !1
        ? void 0
        : typeof r == "string"
        ? r
        : typeof t == "string"
        ? t.toLowerCase()
        : void 0;
    }
    u() {
      var t;
      (this._$E_ = new Promise((i) => (this.enableUpdating = i))),
        (this._$AL = new Map()),
        this._$Eg(),
        this.requestUpdate(),
        (t = this.constructor.h) === null ||
          t === void 0 ||
          t.forEach((i) => i(this));
    }
    addController(t) {
      var i, r;
      ((i = this._$ES) !== null && i !== void 0 ? i : (this._$ES = [])).push(t),
        this.renderRoot !== void 0 &&
          this.isConnected &&
          ((r = t.hostConnected) === null || r === void 0 || r.call(t));
    }
    removeController(t) {
      var i;
      (i = this._$ES) === null ||
        i === void 0 ||
        i.splice(this._$ES.indexOf(t) >>> 0, 1);
    }
    _$Eg() {
      this.constructor.elementProperties.forEach((t, i) => {
        this.hasOwnProperty(i) && (this._$Ei.set(i, this[i]), delete this[i]);
      });
    }
    createRenderRoot() {
      var t;
      let i =
        (t = this.shadowRoot) !== null && t !== void 0
          ? t
          : this.attachShadow(this.constructor.shadowRootOptions);
      return Jb(i, this.constructor.elementStyles), i;
    }
    connectedCallback() {
      var t;
      this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()),
        this.enableUpdating(!0),
        (t = this._$ES) === null ||
          t === void 0 ||
          t.forEach((i) => {
            var r;
            return (r = i.hostConnected) === null || r === void 0
              ? void 0
              : r.call(i);
          });
    }
    enableUpdating(t) {}
    disconnectedCallback() {
      var t;
      (t = this._$ES) === null ||
        t === void 0 ||
        t.forEach((i) => {
          var r;
          return (r = i.hostDisconnected) === null || r === void 0
            ? void 0
            : r.call(i);
        });
    }
    attributeChangedCallback(t, i, r) {
      this._$AK(t, r);
    }
    _$EO(t, i, r = ew) {
      var s;
      let a = this.constructor._$Ep(t, r);
      if (a !== void 0 && r.reflect === !0) {
        let n = (
          ((s = r.converter) === null || s === void 0
            ? void 0
            : s.toAttribute) !== void 0
            ? r.converter
            : tw
        ).toAttribute(i, r.type);
        (this._$El = t),
          n == null ? this.removeAttribute(a) : this.setAttribute(a, n),
          (this._$El = null);
      }
    }
    _$AK(t, i) {
      var r;
      let s = this.constructor,
        a = s._$Ev.get(t);
      if (a !== void 0 && this._$El !== a) {
        let n = s.getPropertyOptions(a),
          o =
            typeof n.converter == "function"
              ? { fromAttribute: n.converter }
              : ((r = n.converter) === null || r === void 0
                  ? void 0
                  : r.fromAttribute) !== void 0
              ? n.converter
              : tw;
        (this._$El = a),
          (this[a] = o.fromAttribute(i, n.type)),
          (this._$El = null);
      }
    }
    requestUpdate(t, i, r) {
      let s = !0;
      t !== void 0 &&
        (((r = r || this.constructor.getPropertyOptions(t)).hasChanged || zD)(
          this[t],
          i
        )
          ? (this._$AL.has(t) || this._$AL.set(t, i),
            r.reflect === !0 &&
              this._$El !== t &&
              (this._$EC === void 0 && (this._$EC = new Map()),
              this._$EC.set(t, r)))
          : (s = !1)),
        !this.isUpdatePending && s && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
      this.isUpdatePending = !0;
      try {
        await this._$E_;
      } catch (i) {
        Promise.reject(i);
      }
      let t = this.scheduleUpdate();
      return t != null && (await t), !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var t;
      if (!this.isUpdatePending) return;
      this.hasUpdated,
        this._$Ei &&
          (this._$Ei.forEach((s, a) => (this[a] = s)), (this._$Ei = void 0));
      let i = !1,
        r = this._$AL;
      try {
        (i = this.shouldUpdate(r)),
          i
            ? (this.willUpdate(r),
              (t = this._$ES) === null ||
                t === void 0 ||
                t.forEach((s) => {
                  var a;
                  return (a = s.hostUpdate) === null || a === void 0
                    ? void 0
                    : a.call(s);
                }),
              this.update(r))
            : this._$Ek();
      } catch (s) {
        throw ((i = !1), this._$Ek(), s);
      }
      i && this._$AE(r);
    }
    willUpdate(t) {}
    _$AE(t) {
      var i;
      (i = this._$ES) === null ||
        i === void 0 ||
        i.forEach((r) => {
          var s;
          return (s = r.hostUpdated) === null || s === void 0
            ? void 0
            : s.call(r);
        }),
        this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(t)),
        this.updated(t);
    }
    _$Ek() {
      (this._$AL = new Map()), (this.isUpdatePending = !1);
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$E_;
    }
    shouldUpdate(t) {
      return !0;
    }
    update(t) {
      this._$EC !== void 0 &&
        (this._$EC.forEach((i, r) => this._$EO(r, this[r], i)),
        (this._$EC = void 0)),
        this._$Ek();
    }
    updated(t) {}
    firstUpdated(t) {}
  };
(To.finalized = !0),
  (To.elementProperties = new Map()),
  (To.elementStyles = []),
  (To.shadowRootOptions = { mode: "open" }),
  BD?.({ ReactiveElement: To }),
  (($b = Xg.reactiveElementVersions) !== null && $b !== void 0
    ? $b
    : (Xg.reactiveElementVersions = [])
  ).push("1.6.0");
var iw,
  Qg = window,
  wu = Qg.trustedTypes,
  FD = wu ? wu.createPolicy("lit-html", { createHTML: (e) => e }) : void 0,
  xl = `lit$${(Math.random() + "").slice(9)}$`,
  GD = "?" + xl,
  Eee = `<${GD}>`,
  _u = document,
  xp = (e = "") => _u.createComment(e),
  bp = (e) => e === null || (typeof e != "object" && typeof e != "function"),
  WD = Array.isArray,
  Cee = (e) => WD(e) || typeof e?.[Symbol.iterator] == "function",
  yp = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  kD = /-->/g,
  ND = />/g,
  Sh = RegExp(
    `>|[ 	
\f\r](?:([^\\s"'>=/]+)([ 	
\f\r]*=[ 	
\f\r]*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    "g"
  ),
  UD = /'/g,
  VD = /"/g,
  qD = /^(?:script|style|textarea|title)$/i,
  YD =
    (e) =>
    (t, ...i) => ({ _$litType$: e, strings: t, values: i }),
  XD = YD(1),
  zce = YD(2),
  Ah = Symbol.for("lit-noChange"),
  Kr = Symbol.for("lit-nothing"),
  jD = new WeakMap(),
  bu = _u.createTreeWalker(_u, 129, null, !1),
  Tee = (e, t) => {
    let i = e.length - 1,
      r = [],
      s,
      a = t === 2 ? "<svg>" : "",
      n = yp;
    for (let l = 0; l < i; l++) {
      let h = e[l],
        u,
        c,
        d = -1,
        p = 0;
      for (; p < h.length && ((n.lastIndex = p), (c = n.exec(h)), c !== null); )
        (p = n.lastIndex),
          n === yp
            ? c[1] === "!--"
              ? (n = kD)
              : c[1] !== void 0
              ? (n = ND)
              : c[2] !== void 0
              ? (qD.test(c[2]) && (s = RegExp("</" + c[2], "g")), (n = Sh))
              : c[3] !== void 0 && (n = Sh)
            : n === Sh
            ? c[0] === ">"
              ? ((n = s ?? yp), (d = -1))
              : c[1] === void 0
              ? (d = -2)
              : ((d = n.lastIndex - c[2].length),
                (u = c[1]),
                (n = c[3] === void 0 ? Sh : c[3] === '"' ? VD : UD))
            : n === VD || n === UD
            ? (n = Sh)
            : n === kD || n === ND
            ? (n = yp)
            : ((n = Sh), (s = void 0));
      let f = n === Sh && e[l + 1].startsWith("/>") ? " " : "";
      a +=
        n === yp
          ? h + Eee
          : d >= 0
          ? (r.push(u), h.slice(0, d) + "$lit$" + h.slice(d) + xl + f)
          : h + xl + (d === -2 ? (r.push(void 0), l) : f);
    }
    let o = a + (e[i] || "<?>") + (t === 2 ? "</svg>" : "");
    if (!Array.isArray(e) || !e.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return [FD !== void 0 ? FD.createHTML(o) : o, r];
  },
  Mh = class {
    constructor({ strings: t, _$litType$: i }, r) {
      let s;
      this.parts = [];
      let a = 0,
        n = 0,
        o = t.length - 1,
        l = this.parts,
        [h, u] = Tee(t, i);
      if (
        ((this.el = Mh.createElement(h, r)),
        (bu.currentNode = this.el.content),
        i === 2)
      ) {
        let c = this.el.content,
          d = c.firstChild;
        d.remove(), c.append(...d.childNodes);
      }
      for (; (s = bu.nextNode()) !== null && l.length < o; ) {
        if (s.nodeType === 1) {
          if (s.hasAttributes()) {
            let c = [];
            for (let d of s.getAttributeNames())
              if (d.endsWith("$lit$") || d.startsWith(xl)) {
                let p = u[n++];
                if ((c.push(d), p !== void 0)) {
                  let f = s.getAttribute(p.toLowerCase() + "$lit$").split(xl),
                    m = /([.?@])?(.*)/.exec(p);
                  l.push({
                    type: 1,
                    index: a,
                    name: m[2],
                    strings: f,
                    ctor:
                      m[1] === "."
                        ? sw
                        : m[1] === "?"
                        ? aw
                        : m[1] === "@"
                        ? nw
                        : Au,
                  });
                } else l.push({ type: 6, index: a });
              }
            for (let d of c) s.removeAttribute(d);
          }
          if (qD.test(s.tagName)) {
            let c = s.textContent.split(xl),
              d = c.length - 1;
            if (d > 0) {
              s.textContent = wu ? wu.emptyScript : "";
              for (let p = 0; p < d; p++)
                s.append(c[p], xp()),
                  bu.nextNode(),
                  l.push({ type: 2, index: ++a });
              s.append(c[d], xp());
            }
          }
        } else if (s.nodeType === 8)
          if (s.data === GD) l.push({ type: 2, index: a });
          else {
            let c = -1;
            for (; (c = s.data.indexOf(xl, c + 1)) !== -1; )
              l.push({ type: 7, index: a }), (c += xl.length - 1);
          }
        a++;
      }
    }
    static createElement(t, i) {
      let r = _u.createElement("template");
      return (r.innerHTML = t), r;
    }
  };
function Su(e, t, i = e, r) {
  var s, a, n, o;
  if (t === Ah) return t;
  let l =
      r !== void 0
        ? (s = i._$Co) === null || s === void 0
          ? void 0
          : s[r]
        : i._$Cl,
    h = bp(t) ? void 0 : t._$litDirective$;
  return (
    l?.constructor !== h &&
      ((a = l?._$AO) === null || a === void 0 || a.call(l, !1),
      h === void 0 ? (l = void 0) : ((l = new h(e)), l._$AT(e, i, r)),
      r !== void 0
        ? (((n = (o = i)._$Co) !== null && n !== void 0 ? n : (o._$Co = []))[
            r
          ] = l)
        : (i._$Cl = l)),
    l !== void 0 && (t = Su(e, l._$AS(e, t.values), l, r)),
    t
  );
}
var rw = class {
    constructor(t, i) {
      (this.u = []), (this._$AN = void 0), (this._$AD = t), (this._$AM = i);
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    v(t) {
      var i;
      let {
          el: { content: r },
          parts: s,
        } = this._$AD,
        a = (
          (i = t?.creationScope) !== null && i !== void 0 ? i : _u
        ).importNode(r, !0);
      bu.currentNode = a;
      let n = bu.nextNode(),
        o = 0,
        l = 0,
        h = s[0];
      for (; h !== void 0; ) {
        if (o === h.index) {
          let u;
          h.type === 2
            ? (u = new Eh(n, n.nextSibling, this, t))
            : h.type === 1
            ? (u = new h.ctor(n, h.name, h.strings, this, t))
            : h.type === 6 && (u = new ow(n, this, t)),
            this.u.push(u),
            (h = s[++l]);
        }
        o !== h?.index && ((n = bu.nextNode()), o++);
      }
      return a;
    }
    p(t) {
      let i = 0;
      for (let r of this.u)
        r !== void 0 &&
          (r.strings !== void 0
            ? (r._$AI(t, r, i), (i += r.strings.length - 2))
            : r._$AI(t[i])),
          i++;
    }
  },
  Eh = class {
    constructor(t, i, r, s) {
      var a;
      (this.type = 2),
        (this._$AH = Kr),
        (this._$AN = void 0),
        (this._$AA = t),
        (this._$AB = i),
        (this._$AM = r),
        (this.options = s),
        (this._$Cm = (a = s?.isConnected) === null || a === void 0 || a);
    }
    get _$AU() {
      var t, i;
      return (i =
        (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null &&
        i !== void 0
        ? i
        : this._$Cm;
    }
    get parentNode() {
      let t = this._$AA.parentNode,
        i = this._$AM;
      return i !== void 0 && t.nodeType === 11 && (t = i.parentNode), t;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t, i = this) {
      (t = Su(this, t, i)),
        bp(t)
          ? t === Kr || t == null || t === ""
            ? (this._$AH !== Kr && this._$AR(), (this._$AH = Kr))
            : t !== this._$AH && t !== Ah && this.g(t)
          : t._$litType$ !== void 0
          ? this.$(t)
          : t.nodeType !== void 0
          ? this.T(t)
          : Cee(t)
          ? this.k(t)
          : this.g(t);
    }
    O(t, i = this._$AB) {
      return this._$AA.parentNode.insertBefore(t, i);
    }
    T(t) {
      this._$AH !== t && (this._$AR(), (this._$AH = this.O(t)));
    }
    g(t) {
      this._$AH !== Kr && bp(this._$AH)
        ? (this._$AA.nextSibling.data = t)
        : this.T(_u.createTextNode(t)),
        (this._$AH = t);
    }
    $(t) {
      var i;
      let { values: r, _$litType$: s } = t,
        a =
          typeof s == "number"
            ? this._$AC(t)
            : (s.el === void 0 && (s.el = Mh.createElement(s.h, this.options)),
              s);
      if (((i = this._$AH) === null || i === void 0 ? void 0 : i._$AD) === a)
        this._$AH.p(r);
      else {
        let n = new rw(a, this),
          o = n.v(this.options);
        n.p(r), this.T(o), (this._$AH = n);
      }
    }
    _$AC(t) {
      let i = jD.get(t.strings);
      return i === void 0 && jD.set(t.strings, (i = new Mh(t))), i;
    }
    k(t) {
      WD(this._$AH) || ((this._$AH = []), this._$AR());
      let i = this._$AH,
        r,
        s = 0;
      for (let a of t)
        s === i.length
          ? i.push((r = new Eh(this.O(xp()), this.O(xp()), this, this.options)))
          : (r = i[s]),
          r._$AI(a),
          s++;
      s < i.length && (this._$AR(r && r._$AB.nextSibling, s), (i.length = s));
    }
    _$AR(t = this._$AA.nextSibling, i) {
      var r;
      for (
        (r = this._$AP) === null || r === void 0 || r.call(this, !1, !0, i);
        t && t !== this._$AB;

      ) {
        let s = t.nextSibling;
        t.remove(), (t = s);
      }
    }
    setConnected(t) {
      var i;
      this._$AM === void 0 &&
        ((this._$Cm = t),
        (i = this._$AP) === null || i === void 0 || i.call(this, t));
    }
  },
  Au = class {
    constructor(t, i, r, s, a) {
      (this.type = 1),
        (this._$AH = Kr),
        (this._$AN = void 0),
        (this.element = t),
        (this.name = i),
        (this._$AM = s),
        (this.options = a),
        r.length > 2 || r[0] !== "" || r[1] !== ""
          ? ((this._$AH = Array(r.length - 1).fill(new String())),
            (this.strings = r))
          : (this._$AH = Kr);
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t, i = this, r, s) {
      let a = this.strings,
        n = !1;
      if (a === void 0)
        (t = Su(this, t, i, 0)),
          (n = !bp(t) || (t !== this._$AH && t !== Ah)),
          n && (this._$AH = t);
      else {
        let o = t,
          l,
          h;
        for (t = a[0], l = 0; l < a.length - 1; l++)
          (h = Su(this, o[r + l], i, l)),
            h === Ah && (h = this._$AH[l]),
            n || (n = !bp(h) || h !== this._$AH[l]),
            h === Kr ? (t = Kr) : t !== Kr && (t += (h ?? "") + a[l + 1]),
            (this._$AH[l] = h);
      }
      n && !s && this.j(t);
    }
    j(t) {
      t === Kr
        ? this.element.removeAttribute(this.name)
        : this.element.setAttribute(this.name, t ?? "");
    }
  },
  sw = class extends Au {
    constructor() {
      super(...arguments), (this.type = 3);
    }
    j(t) {
      this.element[this.name] = t === Kr ? void 0 : t;
    }
  },
  Pee = wu ? wu.emptyScript : "",
  aw = class extends Au {
    constructor() {
      super(...arguments), (this.type = 4);
    }
    j(t) {
      t && t !== Kr
        ? this.element.setAttribute(this.name, Pee)
        : this.element.removeAttribute(this.name);
    }
  },
  nw = class extends Au {
    constructor(t, i, r, s, a) {
      super(t, i, r, s, a), (this.type = 5);
    }
    _$AI(t, i = this) {
      var r;
      if (
        (t = (r = Su(this, t, i, 0)) !== null && r !== void 0 ? r : Kr) === Ah
      )
        return;
      let s = this._$AH,
        a =
          (t === Kr && s !== Kr) ||
          t.capture !== s.capture ||
          t.once !== s.once ||
          t.passive !== s.passive,
        n = t !== Kr && (s === Kr || a);
      a && this.element.removeEventListener(this.name, this, s),
        n && this.element.addEventListener(this.name, this, t),
        (this._$AH = t);
    }
    handleEvent(t) {
      var i, r;
      typeof this._$AH == "function"
        ? this._$AH.call(
            (r =
              (i = this.options) === null || i === void 0 ? void 0 : i.host) !==
              null && r !== void 0
              ? r
              : this.element,
            t
          )
        : this._$AH.handleEvent(t);
    }
  },
  ow = class {
    constructor(t, i, r) {
      (this.element = t),
        (this.type = 6),
        (this._$AN = void 0),
        (this._$AM = i),
        (this.options = r);
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t) {
      Su(this, t);
    }
  };
var HD = Qg.litHtmlPolyfillSupport;
HD?.(Mh, Eh),
  ((iw = Qg.litHtmlVersions) !== null && iw !== void 0
    ? iw
    : (Qg.litHtmlVersions = [])
  ).push("2.6.0");
var wp = (e, t, i) => {
  var r, s;
  let a = (r = i?.renderBefore) !== null && r !== void 0 ? r : t,
    n = a._$litPart$;
  if (n === void 0) {
    let o = (s = i?.renderBefore) !== null && s !== void 0 ? s : null;
    a._$litPart$ = n = new Eh(t.insertBefore(xp(), o), o, void 0, i ?? {});
  }
  return n._$AI(e), n;
};
var lw, hw;
var bl = class extends To {
  constructor() {
    super(...arguments),
      (this.renderOptions = { host: this }),
      (this._$Do = void 0);
  }
  createRenderRoot() {
    var t, i;
    let r = super.createRenderRoot();
    return (
      ((t = (i = this.renderOptions).renderBefore) !== null && t !== void 0) ||
        (i.renderBefore = r.firstChild),
      r
    );
  }
  update(t) {
    let i = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(t),
      (this._$Do = wp(i, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    var t;
    super.connectedCallback(),
      (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(),
      (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return Ah;
  }
};
(bl.finalized = !0),
  (bl._$litElement$ = !0),
  (lw = globalThis.litElementHydrateSupport) === null ||
    lw === void 0 ||
    lw.call(globalThis, { LitElement: bl });
var QD = globalThis.litElementPolyfillSupport;
QD?.({ LitElement: bl });
((hw = globalThis.litElementVersions) !== null && hw !== void 0
  ? hw
  : (globalThis.litElementVersions = [])
).push("3.2.2");
var ZD = (e) => (t) =>
  typeof t == "function"
    ? ((i, r) => (customElements.define(i, r), r))(e, t)
    : ((i, r) => {
        let { kind: s, elements: a } = r;
        return {
          kind: s,
          elements: a,
          finisher(n) {
            customElements.define(i, n);
          },
        };
      })(e, t);
var Dee = (e, t) =>
  t.kind === "method" && t.descriptor && !("value" in t.descriptor)
    ? {
        ...t,
        finisher(i) {
          i.createProperty(t.key, e);
        },
      }
    : {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: t.key,
        initializer() {
          typeof t.initializer == "function" &&
            (this[t.key] = t.initializer.call(this));
        },
        finisher(i) {
          i.createProperty(t.key, e);
        },
      };
function Ta(e) {
  return (t, i) =>
    i !== void 0
      ? ((r, s, a) => {
          s.constructor.createProperty(a, r);
        })(e, t, i)
      : Dee(e, t);
}
var cw,
  hue =
    ((cw = window.HTMLSlotElement) === null || cw === void 0
      ? void 0
      : cw.prototype.assignedElements) != null
      ? (e, t) => e.assignedElements(t)
      : (e, t) =>
          e.assignedNodes(t).filter((i) => i.nodeType === Node.ELEMENT_NODE);
var Zg = window.IntersectionObserver != null;
var KD = (e = 32, t = 2) => {
    let i = e / 2;
    return XD` <style>
			:host {
				width: 100%;
			}</style
		><style>
			:host {
				height: 100%;
			}
		</style>
		<div id="container">
			<canvas id="spline"></canvas>
			<div id="hints">
				<svg
					id="hint-drag"
					width="34"
					height="49"
					viewBox="0 0 34 49"
					fill="none"
					xmlns="http://www.w3.org/2000/svg"
				>
					<g>
						<circle
							cx="11.5"
							cy="11.5"
							r="9"
							fill="white"
							fill-opacity="0.75"
							stroke="black"
						/>
						<g>
							<path
								d="M13.5808 28.5807C13.5808 29.1151 14.014 29.5484 14.5485 29.5484C15.083 29.5484 15.5163 29.1151 15.5163 28.5807V24.7097C15.5163 23.6407 16.3828 22.7742 17.4517 22.7742C18.5207 22.7742 19.3872 23.6407 19.3872 24.7097V28.5807C19.3872 29.1152 19.8205 29.5484 20.355 29.5484C20.8894 29.5484 21.3227 29.1152 21.3227 28.5807V26.6452C21.3227 25.5762 22.1893 24.7097 23.2582 24.7097C24.3271 24.7097 25.1937 25.5762 25.1937 26.6452V28.5807C25.1937 29.1152 25.6269 29.5484 26.1614 29.5485C26.6959 29.5485 27.1292 29.1151 27.1292 28.5806C27.1292 27.5117 27.9957 26.6452 29.0646 26.6452C30.1336 26.6452 31.0001 27.5117 31.0001 28.5806L31.0001 38.9677C31.0001 43.386 27.4184 46.9677 23.0001 46.9677L20.1974 46.9677C18.5785 47.1273 5.02742 48.0887 4.87243 35.5722C4.87155 35.5568 4.87109 35.5413 4.87109 35.5256L4.87109 32.4197C4.87109 30.8339 6.15663 29.5484 7.74242 29.5484C7.76004 29.5484 7.77432 29.5627 7.77432 29.5803L7.77432 34.871C7.77432 35.1117 7.94423 35.3548 8.18496 35.3548H8.87384C9.33553 35.3548 9.7098 34.9806 9.7098 34.5189L9.7098 17.9355C9.7098 16.8665 10.5764 16 11.6453 16C12.7142 16 13.5808 16.8665 13.5808 17.9355L13.5808 28.5807Z"
								fill="white"
							/>
							<path
								d="M15.0163 24.7097V28.5807C15.0163 28.839 14.8068 29.0484 14.5485 29.0484C14.2902 29.0484 14.0808 28.839 14.0808 28.5807L14.0808 17.9355C14.0808 16.5904 12.9904 15.5 11.6453 15.5C10.3002 15.5 9.2098 16.5904 9.2098 17.9355L9.2098 34.5189C9.2098 34.7044 9.05939 34.8548 8.87384 34.8548H8.27432L8.27432 29.5803C8.27432 29.2865 8.03616 29.0484 7.74242 29.0484C5.88049 29.0484 4.37109 30.5578 4.37109 32.4197L4.37109 35.5256C4.37109 35.5467 4.3716 35.5676 4.3726 35.5884C4.41428 38.8082 5.31931 41.2025 6.71237 42.9656C8.10271 44.7253 9.94976 45.8194 11.8161 46.4937C15.4974 47.824 19.3423 47.5525 20.2217 47.4677L23.0001 47.4677C27.6945 47.4677 31.5001 43.6621 31.5001 38.9677L31.5001 28.5806C31.5001 27.2356 30.4097 26.1452 29.0646 26.1452C27.7196 26.1452 26.6292 27.2356 26.6292 28.5806C26.6292 28.839 26.4197 29.0485 26.1614 29.0485C25.9031 29.0485 25.6937 28.839 25.6937 28.5807V26.6452C25.6937 25.3001 24.6033 24.2097 23.2582 24.2097C21.9131 24.2097 20.8227 25.3001 20.8227 26.6452V28.5807C20.8227 28.839 20.6133 29.0484 20.355 29.0484C20.0966 29.0484 19.8872 28.839 19.8872 28.5807V24.7097C19.8872 23.3646 18.7968 22.2742 17.4517 22.2742C16.1067 22.2742 15.0163 23.3646 15.0163 24.7097Z"
								stroke="black"
							/>
						</g>
					</g>
				</svg>
			</div>
			<div id="preloader">
				<svg
					width="${e}"
					height="${e}"
					viewBox="0 0 ${e} ${e}"
					fill="none"
					id="spinner"
				>
					<circle
						cx="${i}"
						cy="${i}"
						r="${i - t / 2}"
						stroke="url(#paint1_linear)"
						stroke-opacity="0.4"
						stroke-width="${t}"
					/>
					<defs>
						<linearGradient
							id="paint1_linear"
							x1="0"
							y1="${i}"
							x2="${i}"
							y2="${i}"
							gradientUnits="userSpaceOnUse"
						>
							<stop stop-color="currentColor" />
							<stop offset="1" stop-color="currentColor" stop-opacity="0" />
						</linearGradient>
					</defs>
				</svg>
			</div>
			<a
				id="logo"
				href="https://spline.design/?utm_source=spline-viewer&utm_campaign=spline-logo"
			>
				<span></span>
				<svg
					width="89"
					height="13"
					viewBox="0 0 89 13"
					fill="none"
					xmlns="http://www.w3.org/2000/svg"
				>
					<path
						d="M0.966 10V1.276H3.894C4.53 1.276 5.05 1.374 5.454 1.57C5.858 1.766 6.156 2.028 6.348 2.356C6.544 2.68 6.642 3.044 6.642 3.448C6.642 3.972 6.494 4.396 6.198 4.72C5.906 5.04 5.504 5.22 4.992 5.26C5.4 5.288 5.746 5.378 6.03 5.53C6.318 5.678 6.536 5.894 6.684 6.178C6.836 6.462 6.912 6.822 6.912 7.258C6.912 7.882 6.784 8.398 6.528 8.806C6.276 9.21 5.928 9.51 5.484 9.706C5.04 9.902 4.532 10 3.96 10H0.966ZM2.346 8.698H3.678C4.27 8.698 4.708 8.606 4.992 8.422C5.28 8.238 5.424 7.872 5.424 7.324C5.424 6.912 5.346 6.618 5.19 6.442C5.034 6.262 4.824 6.15 4.56 6.106C4.296 6.058 4.002 6.034 3.678 6.034H2.346V8.698ZM2.346 4.882H3.636C4.024 4.882 4.328 4.834 4.548 4.738C4.768 4.638 4.922 4.492 5.01 4.3C5.102 4.108 5.148 3.87 5.148 3.586C5.152 3.206 5.012 2.942 4.728 2.794C4.448 2.642 4.082 2.566 3.63 2.566H2.346V4.882ZM10.2126 10.132C9.64456 10.132 9.18856 9.934 8.84456 9.538C8.50056 9.142 8.32856 8.574 8.32856 7.834V3.448H9.74456V7.456C9.74456 7.776 9.78056 8.04 9.85256 8.248C9.92456 8.456 10.0386 8.608 10.1946 8.704C10.3506 8.8 10.5526 8.848 10.8006 8.848C11.1006 8.848 11.3706 8.762 11.6106 8.59C11.8546 8.414 12.0266 8.216 12.1266 7.996V3.448H13.5426V10H12.3366L12.1746 7.528L12.2826 8.026C12.2346 8.386 12.1386 8.726 11.9946 9.046C11.8546 9.366 11.6406 9.628 11.3526 9.832C11.0686 10.032 10.6886 10.132 10.2126 10.132ZM15.3263 10V3.448H16.7603L16.7423 10H15.3263ZM16.0523 2.482C15.7923 2.482 15.5723 2.392 15.3923 2.212C15.2123 2.028 15.1223 1.794 15.1223 1.51C15.1223 1.23 15.2123 1.002 15.3923 0.826C15.5723 0.65 15.7923 0.562 16.0523 0.562C16.3043 0.562 16.5203 0.65 16.7003 0.826C16.8843 1.002 16.9763 1.23 16.9763 1.51C16.9763 1.794 16.8843 2.028 16.7003 2.212C16.5203 2.392 16.3043 2.482 16.0523 2.482ZM18.549 10V0.663999H19.965V10H18.549ZM23.6579 10.096C23.1379 10.096 22.7319 9.964 22.4399 9.7C22.1519 9.432 22.0079 9.05 22.0079 8.554V5.242C22.0079 5.11 22.0359 4.992 22.0919 4.888C22.1479 4.78 22.2299 4.712 22.3379 4.684L22.0079 3.712V3.538L22.3259 1.576H23.4059V8.2C23.4059 8.432 23.4559 8.594 23.5559 8.686C23.6599 8.778 23.8519 8.824 24.1319 8.824C24.3119 8.824 24.4779 8.824 24.6299 8.824C24.7819 8.82 24.9199 8.816 25.0439 8.812V10.018C24.8359 10.054 24.6079 10.076 24.3599 10.084C24.1119 10.092 23.8779 10.096 23.6579 10.096ZM21.1499 4.684V3.448H25.0559V4.684H21.1499ZM29.7628 10L27.7768 3.454H29.3308L30.1468 6.706L30.5488 8.794L30.6208 8.8L30.9448 6.7L31.7308 3.454H33.5128L34.2868 6.712L34.6048 8.866L34.6948 8.86L35.1028 6.712L35.9188 3.454H37.4668L35.4868 10H33.8308L33.0448 6.88L32.6788 4.984H32.5768L32.1928 6.886L31.4128 10H29.7628ZM38.5295 10V3.448H39.9635L39.9455 10H38.5295ZM39.2555 2.482C38.9955 2.482 38.7755 2.392 38.5955 2.212C38.4155 2.028 38.3255 1.794 38.3255 1.51C38.3255 1.23 38.4155 1.002 38.5955 0.826C38.7755 0.65 38.9955 0.562 39.2555 0.562C39.5075 0.562 39.7235 0.65 39.9035 0.826C40.0875 1.002 40.1795 1.23 40.1795 1.51C40.1795 1.794 40.0875 2.028 39.9035 2.212C39.7235 2.392 39.5075 2.482 39.2555 2.482ZM43.6149 10.096C43.0949 10.096 42.6889 9.964 42.3969 9.7C42.1089 9.432 41.9649 9.05 41.9649 8.554V5.242C41.9649 5.11 41.9929 4.992 42.0489 4.888C42.1049 4.78 42.1869 4.712 42.2949 4.684L41.9649 3.712V3.538L42.2829 1.576H43.3629V8.2C43.3629 8.432 43.4129 8.594 43.5129 8.686C43.6169 8.778 43.8089 8.824 44.0889 8.824C44.2689 8.824 44.4349 8.824 44.5869 8.824C44.7389 8.82 44.8769 8.816 45.0009 8.812V10.018C44.7929 10.054 44.5649 10.076 44.3169 10.084C44.0689 10.092 43.8349 10.096 43.6149 10.096ZM41.1069 4.684V3.448H45.0129V4.684H41.1069ZM46.3339 10V0.663999H47.7379V3.454L47.6419 5.32L47.6959 5.848L47.6239 5.422C47.6719 5.062 47.7639 4.722 47.8999 4.402C48.0399 4.078 48.2499 3.816 48.5299 3.616C48.8139 3.416 49.1939 3.316 49.6699 3.316C50.2899 3.316 50.7679 3.51 51.1039 3.898C51.4439 4.282 51.6139 4.87 51.6139 5.662V10H50.1919V6.154C50.1919 5.598 50.1099 5.2 49.9459 4.96C49.7819 4.72 49.4879 4.6 49.0639 4.6C48.7719 4.6 48.5079 4.698 48.2719 4.894C48.0399 5.086 47.8639 5.3 47.7439 5.536V10H46.3339ZM58.1494 10.12C57.5094 10.12 56.9554 10.018 56.4874 9.814C56.0194 9.61 55.6554 9.304 55.3954 8.896C55.1354 8.484 54.9994 7.968 54.9874 7.348H56.3554C56.3714 7.684 56.4534 7.966 56.6014 8.194C56.7534 8.422 56.9654 8.592 57.2374 8.704C57.5134 8.816 57.8454 8.872 58.2334 8.872C58.6054 8.872 58.9094 8.828 59.1454 8.74C59.3814 8.652 59.5554 8.528 59.6674 8.368C59.7794 8.204 59.8354 8.012 59.8354 7.792C59.8354 7.552 59.7674 7.35 59.6314 7.186C59.4954 7.018 59.2794 6.862 58.9834 6.718C58.6914 6.57 58.3034 6.412 57.8194 6.244C57.3194 6.072 56.8814 5.862 56.5054 5.614C56.1334 5.366 55.8434 5.072 55.6354 4.732C55.4314 4.388 55.3294 3.986 55.3294 3.526C55.3294 2.75 55.5834 2.158 56.0914 1.75C56.5994 1.342 57.2954 1.138 58.1794 1.138C58.7914 1.138 59.2874 1.232 59.6674 1.42C60.0474 1.608 60.3334 1.886 60.5254 2.254C60.7214 2.618 60.8514 3.07 60.9154 3.61H59.5414C59.5054 3.334 59.4314 3.106 59.3194 2.926C59.2074 2.746 59.0534 2.612 58.8574 2.524C58.6654 2.432 58.4234 2.386 58.1314 2.386C57.6794 2.386 57.3314 2.478 57.0874 2.662C56.8434 2.842 56.7214 3.112 56.7214 3.472C56.7214 3.676 56.7594 3.862 56.8354 4.03C56.9154 4.198 57.0774 4.364 57.3214 4.528C57.5694 4.692 57.9414 4.872 58.4374 5.068C58.8214 5.22 59.1814 5.366 59.5174 5.506C59.8574 5.642 60.1554 5.8 60.4114 5.98C60.6714 6.16 60.8754 6.384 61.0234 6.652C61.1714 6.92 61.2474 7.26 61.2514 7.672C61.2594 8.464 60.9994 9.07 60.4714 9.49C59.9474 9.91 59.1734 10.12 58.1494 10.12ZM65.5797 10.072C65.1477 10.072 64.8037 10 64.5477 9.856C64.2917 9.712 64.1037 9.544 63.9837 9.352C63.8637 9.156 63.7877 8.984 63.7557 8.836L63.2757 8.86L63.8337 8.386C63.8617 8.486 63.9237 8.584 64.0197 8.68C64.1157 8.772 64.2557 8.848 64.4397 8.908C64.6237 8.964 64.8497 8.992 65.1177 8.992C65.5657 8.992 65.9337 8.818 66.2217 8.47C66.5137 8.122 66.6597 7.54 66.6597 6.724C66.6597 6.02 66.5237 5.48 66.2517 5.104C65.9797 4.724 65.6317 4.534 65.2077 4.534C64.9077 4.534 64.6597 4.576 64.4637 4.66C64.2717 4.744 64.1257 4.842 64.0257 4.954C63.9257 5.066 63.8617 5.166 63.8337 5.254V4.804C63.8417 4.672 63.8757 4.524 63.9357 4.36C63.9997 4.192 64.1017 4.03 64.2417 3.874C64.3857 3.714 64.5737 3.584 64.8057 3.484C65.0417 3.38 65.3337 3.328 65.6817 3.328C66.2097 3.328 66.6537 3.47 67.0137 3.754C67.3737 4.038 67.6457 4.428 67.8297 4.924C68.0177 5.416 68.1117 5.976 68.1117 6.604C68.1117 7.184 68.0397 7.692 67.8957 8.128C67.7557 8.56 67.5637 8.92 67.3197 9.208C67.0797 9.496 66.8097 9.712 66.5097 9.856C66.2097 10 65.8997 10.072 65.5797 10.072ZM62.4237 12.418V3.448H63.8157L63.8337 4.354V8.44L63.7557 8.836L63.8337 10.006V12.418H62.4237ZM69.4787 10V0.663999H70.8947V10H69.4787ZM72.6896 10V3.448H74.1236L74.1056 10H72.6896ZM73.4156 2.482C73.1556 2.482 72.9356 2.392 72.7556 2.212C72.5756 2.028 72.4856 1.794 72.4856 1.51C72.4856 1.23 72.5756 1.002 72.7556 0.826C72.9356 0.65 73.1556 0.562 73.4156 0.562C73.6676 0.562 73.8836 0.65 74.0636 0.826C74.2476 1.002 74.3396 1.23 74.3396 1.51C74.3396 1.794 74.2476 2.028 74.0636 2.212C73.8836 2.392 73.6676 2.482 73.4156 2.482ZM75.9003 10V3.448H77.1123L77.2683 5.92L77.1663 5.422C77.2143 5.062 77.3083 4.722 77.4483 4.402C77.5923 4.078 77.8063 3.816 78.0903 3.616C78.3743 3.416 78.7543 3.316 79.2303 3.316C79.8503 3.316 80.3303 3.51 80.6703 3.898C81.0103 4.282 81.1803 4.87 81.1803 5.662V10H79.7643V6.154C79.7643 5.778 79.7263 5.476 79.6503 5.248C79.5783 5.02 79.4603 4.856 79.2963 4.756C79.1323 4.652 78.9143 4.6 78.6423 4.6C78.3463 4.6 78.0763 4.688 77.8323 4.864C77.5923 5.036 77.4203 5.232 77.3163 5.452V10H75.9003ZM85.5704 10.09C84.9384 10.09 84.3904 9.962 83.9264 9.706C83.4664 9.446 83.1124 9.064 82.8644 8.56C82.6164 8.056 82.4924 7.438 82.4924 6.706C82.4924 5.994 82.6224 5.386 82.8824 4.882C83.1464 4.374 83.5084 3.988 83.9684 3.724C84.4284 3.456 84.9564 3.322 85.5524 3.322C86.1404 3.322 86.6424 3.438 87.0584 3.67C87.4784 3.902 87.7984 4.246 88.0184 4.702C88.2384 5.154 88.3484 5.71 88.3484 6.37C88.3484 6.498 88.3444 6.604 88.3364 6.688C88.3324 6.772 88.3264 6.872 88.3184 6.988H83.9024C83.9384 7.656 84.1024 8.148 84.3944 8.464C84.6864 8.776 85.0444 8.932 85.4684 8.932C85.8644 8.932 86.1664 8.848 86.3744 8.68C86.5864 8.508 86.7224 8.316 86.7824 8.104H88.1504C88.1144 8.524 87.9824 8.884 87.7544 9.184C87.5264 9.48 87.2244 9.706 86.8484 9.862C86.4764 10.014 86.0504 10.09 85.5704 10.09ZM84.5504 6.022H86.9384C86.9264 5.542 86.8104 5.172 86.5904 4.912C86.3704 4.648 86.0084 4.516 85.5044 4.516C84.9804 4.516 84.5904 4.692 84.3344 5.044C84.0784 5.392 83.9344 5.874 83.9024 6.49C83.9344 6.31 84.0024 6.188 84.1064 6.124C84.2104 6.056 84.3584 6.022 84.5504 6.022Z"
						fill="white"
					/>
				</svg>
			</a>
		</div>`;
  },
  Bs = class extends bl {
    constructor() {
      super();
      this.url = null;
      this.width = void 0;
      this.height = void 0;
      this.background = void 0;
      this.loading = "auto";
      this.unloadable = !1;
      this.eventsTarget = void 0;
      this.loadingAnim = !1;
      this.loadingAnimType = void 0;
      this._intersectionObserver = null;
      this._isElementInViewport = !1;
      this._loaded = !1;
      this._loadedUrl = null;
      this._wasContextLost = !1;
      this._handleContextLost = () => {
        (this._wasContextLost = !0),
          (this._loadedUrl = null),
          this._spline.dispose(),
          this._isElementInViewport && this.load(),
          this.dispatchEvent(new CustomEvent("context-loss", { detail: {} }));
      };
      this._handleContextRestored = () => {};
      this.onLoaded = () => {
        (this._loaded = !0),
          this.eventsTarget !== void 0 &&
            this._spline.eventManager.updateUseWindowEvents(
              this.eventsTarget === "global"
            ),
          this.background !== void 0 &&
            this._spline?.setBackgroundColor(this.background),
          this._spline?.data.scene.publish.settings.web.logo !== !1 &&
            (this._logo.style.display = "flex"),
          (this.loadingAnim || this.loadingAnimType !== void 0) &&
            (this._preloader.style.display = "none"),
          setTimeout(() => {
            this._canvas.style.visibility = "visible";
          }),
          this.dispatchEvent(
            new CustomEvent("load-complete", { detail: { url: this.url } })
          ),
          (this.hint ?? this._spline.data.scene.publish.settings.web.hint) &&
            (this._canvas.addEventListener("pointerdown", this.onInteract),
            this._canvas.addEventListener("pointerup", this.onInteract),
            (this._hintDrag.style.display = "block"));
      };
      this.onInteract = () => {
        this._canvas.removeEventListener("pointerdown", this.onInteract),
          this._canvas.removeEventListener("pointerup", this.onInteract),
          (this._hintDrag.style.display = "none");
      };
      this.attachShadow({ mode: "open" });
      let i = this.shadowRoot;
      wp(KD(), i),
        (this._container = i.querySelector("#container")),
        (this._canvas = i.querySelector("#spline")),
        (this._logo = i.querySelector("#logo")),
        (this._hintDrag = i.querySelector("#hint-drag")),
        (this._preloader = i.querySelector("#preloader")),
        (this._spinner = i.querySelector("#spinner")),
        this._canvas.addEventListener(
          "webglcontextlost",
          this._handleContextLost
        ),
        this._canvas.addEventListener(
          "webglcontextrestored",
          this._handleContextRestored
        ),
        (this._spline = new Qb(this._canvas)),
        Zg
          ? (this._intersectionObserver = new IntersectionObserver(
              (r) => {
                for (let s of r)
                  s.target === this &&
                    ((this._isElementInViewport = s.isIntersecting),
                    this._isElementInViewport &&
                    (!this._loaded || this._wasContextLost)
                      ? this.load()
                      : this.unloadable &&
                        !this._isElementInViewport &&
                        this._loaded &&
                        this.unload(),
                    this.dispatchEvent(
                      new CustomEvent("viewport-intersection", {
                        detail: { intersection: this._isElementInViewport },
                      })
                    ));
              },
              { root: null, rootMargin: "0px", threshold: 1e-5 }
            ))
          : (this._isElementInViewport = !0);
    }
    rerender() {
      let i =
          this.loadingAnimType === "spinner-big-dark" ||
          this.loadingAnimType === "spinner-big-light",
        r =
          this.loadingAnimType === "spinner-big-light" ||
          this.loadingAnimType === "spinner-small-light",
        s = i ? 64 : 32,
        a = i ? 4 : 2,
        n = this.shadowRoot;
      wp(KD(s, a), n),
        (this._container = n.querySelector("#container")),
        (this._canvas = n.querySelector("#spline")),
        (this._logo = n.querySelector("#logo")),
        (this._hintDrag = n.querySelector("#hint-drag")),
        (this._preloader = n.querySelector("#preloader")),
        (this._spinner = n.querySelector("#spinner")),
        (this._spinner.style.color = r
          ? "rgba(255,255,255,0.5)"
          : "rgba(0,0,0,0.5)");
    }
    unload() {
      !this._loaded ||
        ((this._loaded = !1),
        (this._loadedUrl = null),
        this._spline.dispose(),
        this.dispatchEvent(new CustomEvent("unload", { detail: {} })));
    }
    recreateCanvas() {
      let i = this._canvas;
      i.removeEventListener("pointerdown", this.onInteract),
        i.removeEventListener("pointerup", this.onInteract),
        i.removeEventListener("webglcontextlost", this._handleContextLost),
        i.removeEventListener(
          "webglcontextrestored",
          this._handleContextRestored
        );
      let r = document.createElement("canvas");
      this._container.insertBefore(r, this._canvas),
        this._container.removeChild(this._canvas),
        r.setAttribute("id", "spline"),
        (this._canvas = r),
        this._canvas.addEventListener(
          "webglcontextlost",
          this._handleContextLost
        ),
        this._canvas.addEventListener(
          "webglcontextrestored",
          this._handleContextRestored
        ),
        (this._spline = new Qb(this._canvas));
    }
    load() {
      (this._loaded && !this._wasContextLost) ||
        (!this._isElementInViewport && this.loading !== "eager") ||
        !this.url ||
        this.url === this._loadedUrl ||
        ((this.loadingAnim || this.loadingAnimType !== void 0) &&
          ((this._preloader.style.display = "flex"), this.rerender()),
        (this._canvas.style.visibility = "hidden"),
        this.dispatchEvent(
          new CustomEvent("load-start", { detail: { url: this.url } })
        ),
        this._wasContextLost && this.recreateCanvas(),
        this._canvas.removeEventListener("pointerdown", this.onInteract),
        this._canvas.removeEventListener("pointerup", this.onInteract),
        (this._hintDrag.style.display = "none"),
        (this._loadedUrl = this.url),
        this._spline.load(this.url).then(this.onLoaded));
    }
    updated(i) {
      super.updated(i),
        i.has("url") &&
          (this.url == null && this._loaded
            ? this.unload()
            : this.url !== this._loadedUrl && this.load());
      let r = this.shadowRoot?.querySelector("style:nth-child(1)"),
        s = this.shadowRoot?.querySelector("style:nth-child(2)");
      if (
        (i.has("width") &&
          this.width !== void 0 &&
          ((this._container.style.width = this.width + "px"), r?.remove()),
        i.has("height") &&
          this.height !== void 0 &&
          ((this._container.style.height = this.height + "px"), s?.remove()),
        i.has("background") &&
          this.background !== void 0 &&
          this._spline?.setBackgroundColor(this.background),
        i.has("eventsTarget") && this.eventsTarget !== void 0)
      ) {
        let a = this.eventsTarget === "global";
        this._spline?.eventManager?.updateUseWindowEvents(a),
          this._spline?.controls?.updateUseWindowEvents(a);
      }
    }
    connectedCallback() {
      super.connectedCallback(), Zg && this._intersectionObserver.observe(this);
    }
    disconnectedCallback() {
      Zg && this._intersectionObserver.unobserve(this),
        super.disconnectedCallback();
    }
  };
(Bs.styles = Kb`
		:host {
			display: block;
		}
		#container {
			width: 100%;
			height: 100%;
			position: relative;
		}
		#spline {
			display: block;
		}

		#logo {
			display: none;
			position: absolute;
			z-index: 2;
			bottom: 20px;
			right: 20px;
			width: 137px;
			height: 36px;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			gap: 6px;
			border-radius: 12px;
			background: linear-gradient(180deg, #16181c 0%, #121316 100%);
			box-shadow: inset 0px -2px 0px -1px #060709,
				inset 0px 1px 0px rgba(255, 255, 255, 0.04);
		}
		#logo span {
			display: block;
			width: 20px;
			height: 20px;
			background-image: url(https://app.spline.design/_assets/_icons/icon_favicon32x32.png);
			background-size: cover;
		}
		#logo svg {
			display: block;
			margin-right: 2px;
		}
		#logo:hover {
			background: linear-gradient(180deg, #1b1c21 0%, #17181c 100%);
		}

		#hints {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			pointer-events: none;
		}
		#hint-drag {
			animation-duration: 4s;
			animation-name: slidein;
			animation-iteration-count: infinite;
			animation-timing-function: ease-in-out;
			display: none;
		}

		@keyframes slidein {
			from {
				transform: translateX(0px);
				opacity: 0;
			}
			50% {
				opacity: 0;
				transform: translateX(0px);
			}
			60% {
				opacity: 1;
			}
			65% {
				transform: translateX(-30px);
			}
			85% {
				transform: translateX(30px);
			}
			90% {
				opacity: 1;
			}
			to {
				opacity: 0;
				transform: translateX(0px);
			}
		}
		#preloader {
			position: absolute;
			display: none;
			top: 0;
			left: 0;
			align-items: center;
			justify-content: center;
			width: 100%;
			height: 100%;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}
			100% {
				transform: rotate(360deg);
			}
		}

		#spinner {
			color: rgba(0, 0, 0, 0.5);
			animation: spin 1s infinite linear;
		}
	`),
  la([Ta({ type: String })], Bs.prototype, "url", 2),
  la([Ta({ type: Number })], Bs.prototype, "width", 2),
  la([Ta({ type: Number })], Bs.prototype, "height", 2),
  la([Ta({ type: String })], Bs.prototype, "background", 2),
  la([Ta({ type: String })], Bs.prototype, "loading", 2),
  la([Ta({ type: Boolean })], Bs.prototype, "unloadable", 2),
  la(
    [Ta({ type: String, attribute: "events-target" })],
    Bs.prototype,
    "eventsTarget",
    2
  ),
  la([Ta({ type: Boolean })], Bs.prototype, "hint", 2),
  la(
    [Ta({ type: Boolean, attribute: "loading-anim" })],
    Bs.prototype,
    "loadingAnim",
    2
  ),
  la(
    [Ta({ type: String, attribute: "loading-anim-type" })],
    Bs.prototype,
    "loadingAnimType",
    2
  ),
  (Bs = la([ZD("spline-viewer")], Bs));
export { Bs as SplineViewer };
